{
    "count": 20,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 129943727,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two statements that are true regarding the USING and ON clauses in table joins.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>The <code>USING</code> clause is designed for equijoins, where the columns being joined have the same name in both tables. It simplifies the syntax by allowing you to specify the column name once. However, it cannot be used for nonequijoins, which involve conditions other than equality.</p><p>The <code>ON</code> clause is more flexible and can be used for both equijoins and nonequijoins. This means you can join tables based on equality or other conditions, including inequalities. For example, you can use the <code>ON</code> clause to join tables where the columns have different names or to apply conditions like greater than or less than.</p>",
                    "<p>The <strong>ON</strong> clause can join multiple pairs of columns, not just one, as long as the conditions are specified correctly.</p>",
                    "<p>The <strong>ON</strong> clause allows joining tables on any condition, including columns with different names, as long as their data types are compatible.</p>",
                    "<p>The <strong>WHERE</strong> clause can be used in combination with <strong>ON</strong> or <strong>USING</strong> to filter results further after the join operation.</p>"
                ],
                "explanation": "<p>The two correct statements regarding the <strong>USING</strong> and <strong>ON</strong> clauses in table joins are:</p><ol><li><p><strong>\"The ON clause can be used to join tables on columns that have different names but compatible data types.\"</strong></p><ul><li><p><strong>True</strong>: The <strong>ON</strong> clause allows joining tables on any condition, including columns with different names, as long as their data types are compatible.</p></li></ul></li><li><p><strong>\"The WHERE clause can be used to apply additional conditions in SELECT statements containing the ON or the USING clause.\"</strong></p><ul><li><p><strong>True</strong>: The <strong>WHERE</strong> clause can be used in combination with <strong>ON</strong> or <strong>USING</strong> to filter results further after the join operation.</p></li></ul></li></ol><p>Explanation for the incorrect statements:</p><ul><li><p><strong>\"Both USING and ON can be used for equijoins and nonequijoins.\"</strong></p><ul><li><p><strong>Incorrect</strong>: The <strong>USING</strong> clause is specifically for <strong>equijoins</strong> (joins based on equality of columns with the same name). The <strong>ON</strong> clause, however, can handle both <strong>equijoins</strong> and <strong>nonequijoins</strong> (joins using inequalities or other conditions).</p></li></ul></li><li><p><strong>\"A maximum of one pair of columns can be joined between the two tables using the ON clause.\"</strong></p><ul><li><p><strong>Incorrect</strong>: The <strong>ON</strong> clause can join multiple pairs of columns, not just one, as long as the conditions are specified correctly.</p></li></ul></li></ul><p><strong>Creating Joins with the ON Clause</strong></p><p>• The join condition for the natural join is basically an equijoin of identical column names.</p><p> • The ON clause can be used to join columns that have different names.</p><p>• Use the ON clause to specify conditions or specify columns to join.</p><p>• The join condition is separated from other search conditions.</p><p>• This is the easiest and most widely used form of the join clauses.</p><p><a href=\"https://www.w3resource.com/oracle/joins/joins-with-on-clause.php\">https://www.w3resource.com/oracle/joins/joins-with-on-clause.php</a></p><p><br></p><p>If the sources have incompatible data types, they will need to be converted to make the join using TO_CHAR as shown here:</p><pre class=\"prettyprint linenums\">SELECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*\nFROM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table1\nJOIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVL ( LTRIM (table1.col1, '0')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , '0'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= TO_CHAR (table2.col1)\n;</pre><p><a href=\"https://community.oracle.com/thread/1118689\">https://community.oracle.com/thread/1118689</a></p><p>The <code>WHERE</code> clause specifies a search condition for rows returned by the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement.</p><p><br></p><p>The <code>USING</code> clause: This allows you to specify the join key by name.</p><p>The USING clause is used if several columns share the same name, but you don’t want to join using all of these common columns. The columns listed in the USING clause can’t have any qualifiers in the statement, including the WHERE clause:</p><p><br></p><p>The <code>ON</code> clause: This syntax allows you to specify the column names for join keys in <strong>both tables</strong>.</p><p>The ON clause is used to join tables where the column names don’t match in both tables. The join conditions are removed from the filter conditions in the WHERE clause:</p><pre class=\"prettyprint linenums\">select department_name, city\nfrom departments\nJOIN locations\nUSING (location_id); -- specify the same column name \n                     -- for both of the tables for the join\nselect department_name, city\nfrom departments dept\njoin locations loc\non (dept.location_id = loc.id); -- specify different column name \n                                -- for the tables for the join.</pre><p><a href=\"https://stackoverflow.com/questions/10432107/difference-between-on-clause-and-using-clause-in-sql\">https://stackoverflow.com/questions/10432107/difference-between-on-clause-and-using-clause-in-sql</a></p><p><br></p><p><strong>Oracle EQUIJOINS</strong></p><p>An equijoin is such a join that performs against a join condition containing an equality operator. It combines rows of one table associated with one or more rows in another table based on the equality of column values or expressions.</p><pre class=\"prettyprint linenums\">SELECT column_list \nFROM table1, table2\nWHERE table1.column_name =\ntable2.column_name; </pre><p><a href=\"https://www.w3resource.com/oracle/joins/oracle-equijoins.php\">https://www.w3resource.com/oracle/joins/oracle-equijoins.php</a></p><p><br></p><p><strong>Oracle NON-EQUIJOINS</strong></p><p>The nonequijoins is such a join that matches column values from different tables based on an inequality (instead of the equal sign, like <strong>&gt;, &lt;, &gt;=, &lt;= </strong>) expression. The value of the join column in each row in the source table is compared to the corresponding values in the target table. A match is found if the expression based on an inequality operator used in the join evaluates to true.</p><pre class=\"prettyprint linenums\">SELECT table1.column, table2.column\nFROM table1\n[JOIN table2 ON (table1.column_name &lt; table2.column_name)]|\n[JOIN table2 ON (table1.column_name &gt; table2.column_name)]|\n[JOIN table2 ON (table1.column_name &lt;= table2.column_name)]|\n[JOIN table2 ON (table1.column_name &gt;= table2.column_name)]|\n[JOIN table2 ON (table1.column BETWEEN table2.col1 AND table2.col2)]| </pre><p><a href=\"https://www.w3resource.com/oracle/joins/oracle-non-equijoins.php\">https://www.w3resource.com/oracle/joins/oracle-non-equijoins.php</a></p>",
                "answers": [
                    "<p>Both USING and ON can be used for equijoins and nonequijoins.</p>",
                    "<p>A maximum of one pair of columns can be joined between the two tables using the ON clause.</p>",
                    "<p>The ON clause can be used to join tables on columns that have different names but compatible data types.</p>",
                    "<p>The WHERE clause can be used to apply additional conditions in SELECT statements containing the ON or the USING clause.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two statements that are true regarding the USING and ON clauses in table joins.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943729,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the default behaviour of the ORDER&nbsp;BY clause.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p><strong>True</strong>: By default, character sorting is <strong>case-sensitive</strong> in most databases. This means that uppercase letters (e.g., \"A\") are sorted before lowercase letters (e.g., \"a\"). However, this behavior can vary depending on collation settings.</p>",
                    "<p><strong>Incorrect</strong>: NULL values <strong>are</strong> included in the sort operation. By default, in ascending order (<code>ASC</code>), NULLs appear <strong>first</strong>, and in descending order (<code>DESC</code>), NULLs appear <strong>last</strong>. This behavior can be modified using <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p>",
                    "<p><strong>Incorrect</strong>: The <strong>ORDER BY</strong> clause can reference columns that are <strong>not</strong> included in the <code>SELECT</code> list. This allows so</p>",
                    "<p><strong>Incorrect</strong>: The <strong>ORDER BY</strong> clause does <strong>not</strong> automatically sort numeric values in descending order just because they have decimal places. The sorting order is determined explicitly by <code>ASC</code> (default) or <code>DESC</code>, regardless of whether the numbers have decimal positions.</p>",
                    "<p><strong>Incorrect</strong>: Column <strong>aliases</strong> can be used in the <strong>ORDER BY</strong> clause. For example:</p><pre class=\"prettyprint linenums\">sql\nSELECT first_name AS name FROM employees ORDER BY name;</pre><p>This query sorts by the alias <code>name</code>, which is derived from <code>first_name</code>.</p>"
                ],
                "explanation": "<p>The <strong>true</strong> statement regarding the default behavior of the <strong>ORDER BY</strong> clause is:</p><p><strong>\"In a character sort, the values are case-sensitive.\"</strong></p><ul><li><p><strong>True</strong>: By default, character sorting is <strong>case-sensitive</strong> in most databases. This means that uppercase letters (e.g., \"A\") are sorted before lowercase letters (e.g., \"a\"). However, this behavior can vary depending on collation settings.</p></li></ul><p>Explanation for the incorrect statements:</p><ul><li><p><strong>\"NULLS are not included in the sort operation.\"</strong></p><ul><li><p><strong>Incorrect</strong>: NULL values <strong>are</strong> included in the sort operation. By default, in ascending order (<code>ASC</code>), NULLs appear <strong>first</strong>, and in descending order (<code>DESC</code>), NULLs appear <strong>last</strong>. This behavior can be modified using <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p></li></ul></li><li><p><strong>\"Only columns that are specified in the SELECT list can be used in the ORDER BY clause.\"</strong></p><ul><li><p><strong>Incorrect</strong>: The <strong>ORDER BY</strong> clause can reference columns that are <strong>not</strong> included in the <code>SELECT</code> list. This allows sorting based on columns that are part of the underlying table but not explicitly selected.</p></li></ul></li><li><p><strong>\"Numeric values are displayed in descending order if they have decimal positions.\"</strong></p><ul><li><p><strong>Incorrect</strong>: The <strong>ORDER BY</strong> clause does <strong>not</strong> automatically sort numeric values in descending order just because they have decimal places. The sorting order is determined explicitly by <code>ASC</code> (default) or <code>DESC</code>, regardless of whether the numbers have decimal positions.</p></li></ul></li><li><p><strong>\"Column aliases cannot be used in the ORDER BY clause.\"</strong></p><ul><li><p><strong>Incorrect</strong>: Column <strong>aliases</strong> can be used in the <strong>ORDER BY</strong> clause. For example:</p><pre class=\"prettyprint linenums\">sql\nSELECT first_name AS name FROM employees ORDER BY name;</pre><p>This query sorts by the alias <code>name</code>, which is derived from <code>first_name</code>.</p></li></ul></li></ul><p><br></p><p>The ORDER&nbsp;BY clause performs case-sensitive sorting with character values.</p><p>ENAME is ordered ascending by default and shows the uppercase names before the lowercase names.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-07_14-07-42-1b0512a056143aae71615ffce716840f.png\"></p><p>Column aliases can be used in the ORDER BY clause.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/q_and_a/2021-01-02_14-44-32-87cfa7761cc78c166f3f0d495c8d0e3e.PNG\"></p>",
                "answers": [
                    "<p>In a character sort, the values are case-sensitive.</p>",
                    "<p>NULLS are not included in the sort operation.</p>",
                    "<p>Only columns that are specified in the SELECT list can be used in the ORDER&nbsp;BY clause.</p>",
                    "<p>Numeric values are displayed in descending order if they have decimal positions.</p>",
                    "<p>Column aliases cannot be used in the ORDER BY clause.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the default behaviour of the ORDER&nbsp;BY clause.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943731,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the two minimal requirements for a self-join.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p><strong>Incorrect</strong>: A self-join can use <strong>both equijoins and non-equijoins</strong> (e.g., inequalities).</p>",
                    "<p><strong>Incorrect</strong>: Self-joins can use <strong>inner joins, left outer joins, and right outer joins</strong>, depending on the requirement.</p>",
                    "<p><strong>True</strong>: A self-join requires a <strong>join condition</strong> to relate rows within the same table. Without a condition, it would produce a Cartesian product.</p>",
                    "<p><strong>Incorrect</strong>: Additional conditions (such as filtering with <code>WHERE</code> or applying other constraints) <strong>can</strong> be included in the query.</p>",
                    "<p><strong>True</strong>: Since a self-join involves joining a table to itself, it must be referenced <strong>twice</strong> in the query with <strong>different aliases</strong> to differentiate between the two instances of the same table.</p>"
                ],
                "explanation": "<p>The two <strong>minimal requirements</strong> for a <strong>self-join</strong> are:</p><ol><li><p><strong>\"There must be a condition on which the self-join is performed.\"</strong></p><ul><li><p><strong>True</strong>: A self-join requires a <strong>join condition</strong> to relate rows within the same table. Without a condition, it would produce a Cartesian product.</p></li></ul></li><li><p><strong>\"The table used for the self-join must have two different alias names in the query.\"</strong></p><ul><li><p><strong>True</strong>: Since a self-join involves joining a table to itself, it must be referenced <strong>twice</strong> in the query with <strong>different aliases</strong> to differentiate between the two instances of the same table.</p></li></ul></li></ol><p>Explanation for the incorrect statements:</p><ul><li><p><strong>\"Only equijoin conditions may be used in the query.\"</strong></p><ul><li><p><strong>Incorrect</strong>: A self-join can use <strong>both equijoins and non-equijoins</strong> (e.g., inequalities).</p></li></ul></li><li><p><strong>\"Outer joins must not be used in the query.\"</strong></p><ul><li><p><strong>Incorrect</strong>: Self-joins can use <strong>inner joins, left outer joins, and right outer joins</strong>, depending on the requirement.</p></li></ul></li><li><p><strong>\"No other condition except the self-join may be specified.\"</strong></p><ul><li><p><strong>Incorrect</strong>: Additional conditions (such as filtering with <code>WHERE</code> or applying other constraints) <strong>can</strong> be included in the query.</p></li></ul></li></ul><p><br></p><p><br></p><p><br></p><p>The self-join statement is necessary when two sets of data, within the same table, are compared.</p><p>A self-join is a join in which a table is joined with itself (which is also called a Unary relationship), especially when the table has a FOREIGN KEY that references its own PRIMARY KEY. To join a table itself means that each row of the table is combined with itself and with every other row of the table.</p><p>The self-join can be viewed as a join of two copies of the same table. The table is not actually copied, but SQL performs the command as though it were.</p><p>The syntax of the command for joining a table to itself is almost the same as that for joining two different tables. To distinguish the column names from one another, aliases for the actual table name are used, since both tables have the same name. Table name aliases are defined in the FROM clause of the SELECT statement. See the syntax :</p><pre class=\"prettyprint linenums\">SELECT a.column_name, b.column_name... \nFROM table1 a, table1 b \nWHERE a.common_filed = b.common_field;</pre><p><a href=\"https://www.w3resource.com/sql/joins/perform-a-self-join.php\">https://www.w3resource.com/sql/joins/perform-a-self-join.php</a></p>",
                "answers": [
                    "<p>Only equijoin conditions may be used in the query.</p>",
                    "<p>Outer joins must not be used in the query.</p>",
                    "<p>There must be a condition on which the self-join is performed.</p>",
                    "<p>No other condition except the self-join may be specified.</p>",
                    "<p>The table used for the self-join must have two different alias names in the query.</p>"
                ]
            },
            "correct_response": [
                "c",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the two minimal requirements for a self-join.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943733,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the MEMBERS table and the exhibit.</p><p><strong>Table: MEMBERS</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nMEMBER_ID               NOT NULL          VARCHAR2(6)\nFIRST_NAME                                VARCHAR2(50)\nLAST_NAME                                 VARCHAR2(50)\nADDRESS                                   VARCHAR2(50)</pre><p><br></p><p>The following SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT member_id, ' ', first_name, ' ', last_name \"ID FIRSTNAME LASTNAME\"\nFROM members</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The alias name specified after the column names is not the reason for the query to fail. The alias naming convention is valid in SQL, and it does not impact the query execution negatively.",
                    "The space specified in the single quotation marks after the column names is a valid part of the SQL syntax and does not cause the query to fail. The space is considered as part of the column heading and does not affect the query's success.",
                    "<p>The query executes successfully and displays the column details in three separate columns. The alias specified in the query will only replace the last column heading with the specified alias, while the other columns will retain their original headings.</p>",
                    "The query executes successfully and displays the column details in three separate columns. The alias specified in the query will only replace the last column heading with the specified alias, while the other columns will retain their original headings."
                ],
                "explanation": "<p><strong>Correct Answer: </strong><em>It executes successfully and displays the column details in five separate columns and replaces only the last column heading with the alias.</em></p><p><strong>Key Points About NULL in Oracle:</strong></p><ul><li><p><strong>NULL means \"unknown\"</strong>, not just \"empty\".</p></li><li><p>In Oracle, <strong>empty strings are also treated as NULL</strong>.</p></li></ul><ol><li><p><strong>NULL Represents an Unknown Value</strong></p><ul><li><p>It does not mean zero (<code>0</code>), an empty string (<code>''</code>), or any default value.</p></li><li><p>It indicates that the value is <strong>absent</strong> or <strong>not known</strong>.</p></li></ul></li><li><p><strong>NULL and Empty Strings (</strong><code><strong>''</strong></code><strong>) Are the Same in Oracle</strong></p><ul><li><p>Unlike some other databases, <strong>Oracle treats an empty string (</strong><code><strong>''</strong></code><strong>) as NULL</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">sql\nINSERT INTO members (first_name) VALUES ('');</pre><ul><li><p>The above statement <strong>stores NULL</strong> in the <code>first_name</code> column, <strong>not an empty string</strong>.</p></li></ul></li></ul></li><li><p><strong>Operations with NULL Yield NULL</strong></p><ul><li><p>Any arithmetic operation with NULL results in <strong>NULL</strong>.</p><pre class=\"prettyprint linenums\">sql\nSELECT 10 + NULL FROM dual; -- Result is NULL</pre></li><li><p>String concatenation with NULL also results in <strong>NULL</strong>.</p><pre class=\"prettyprint linenums\">sql\nSELECT 'Hello' || NULL FROM dual; -- Result is NULL</pre></li></ul></li><li><p><strong>NULL in Comparisons</strong></p><ul><li><p><code>NULL = NULL</code> <strong>is not TRUE</strong>; instead, it results in <strong>UNKNOWN</strong>.</p></li><li><p>Use <code>IS NULL</code> to check for NULL values:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM members WHERE first_name IS NULL;</pre></li></ul></li></ol><p><br></p><p><strong>Understanding the Query Components</strong></p><ol><li><p><strong>Selected Columns and Values:</strong></p><ul><li><p><code>member_id</code>: A column from the <code>MEMBERS</code> table.</p></li><li><p><code>' '</code> (space in single quotes): A <strong>literal string value</strong>.</p></li><li><p><code>first_name</code>: A column from the <code>MEMBERS</code> table.</p></li><li><p><code>' '</code> (another space): Another <strong>literal string value</strong>.</p></li><li><p><code>last_name \"ID FIRSTNAME LASTNAME\"</code>: The <strong>column </strong><code><strong>last_name</strong></code><strong> with an alias</strong> <code>\"ID FIRSTNAME LASTNAME\"</code>.</p></li></ul></li><li><p><strong>Behavior of the Query:</strong></p><ul><li><p><strong>Literals </strong><code><strong>' '</strong></code><strong> are valid in SQL</strong> and will be treated as separate columns.</p></li><li><p><strong>Aliases in Oracle apply only to the last selected expression</strong>, so <code>\"ID FIRSTNAME LASTNAME\"</code> will rename only <code>last_name</code>, not the entire output.</p></li></ul></li></ol><p><strong>Expected Output</strong></p><ul><li><p>The query <strong>executes successfully</strong>.</p></li><li><p>It returns <strong>five separate columns</strong> in the output:</p><ul><li><p><code>member_id</code></p></li><li><p>A column with a space (<code>' '</code>)</p></li><li><p><code>first_name</code></p></li><li><p>A column with a space (<code>' '</code>)</p></li><li><p><code>last_name</code> (renamed as <code>\"ID FIRSTNAME LASTNAME\"</code>)</p></li></ul></li></ul>",
                "answers": [
                    "<p>It fails because the alias name specified after the column names is invalid.</p>",
                    "<p>It fails because the space specified in the single quotation marks after the two first columns names is invalid.</p>",
                    "<p>It executes successfully and displays the column details in a single column with only the alias column heading.</p>",
                    "<p>It executes successfully and displays the column details in five separate columns and replaces only the last column heading with the alias.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the MEMBERS table and the exhibit.Table: MEMBERSName                    Null??            Type\nMEMBER_ID               NOT NULL          VARCHAR2(6)\nFIRST_NAME                                VARCHAR2(50)\nLAST_NAME                                 VARCHAR2(50)\nADDRESS                                   VARCHAR2(50)The following SQL statement has been executed.Exhibit: 1SELECT member_id, ' ', first_name, ' ', last_name \"ID FIRSTNAME LASTNAME\"\nFROM membersIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943735,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the BOOKS_TRANSACTIONS table and the exhibit.</p><p><strong>Table: BOOKS_TRANSACTIONS</strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nTRANSACTION_ID       NOT NULL          VARCHAR2(6)\nBORROWED_DATE                          DATE\nDUE_DATE                               VARCHAR2(8)\nMEMBER_ID                              VARCHAR2(6)</pre><p><br></p><p>Examine this partial SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">UPDATE books_transactions\nSET book_id = 'INVALID'\nWHERE ________________</pre><p><br></p><p><strong>Required: </strong>Update this table such that BOOK_ID is set to 'INVALID' for all rows where no MEMBER_ID has been entered.</p><p><br></p><p>Identify the condition that must be used in the WHERE clause to perform the required update.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This condition checks if the member_id column is an empty string, which is not the same as NULL. Using an empty string will not accurately identify rows where no MEMBER_ID has been entered.",
                    "This condition checks if the member_id column is explicitly set to NULL. However, in SQL, comparing to NULL using the equal sign will not yield the expected results. To check for NULL values, the IS NULL operator should be used instead.",
                    "This condition correctly uses the IS NULL operator to check if the member_id column has a NULL value. This is the appropriate way to identify rows where no MEMBER_ID has been entered in the table.",
                    "<p>This condition checks if the member_id column is an empty string enclosed in double quotes. It is using an empty string will not accurately identify rows where no MEMBER_ID has been entered.</p>"
                ],
                "explanation": "<p>The correct condition to use in the <strong>WHERE</strong> clause is:&nbsp; <code><strong>member_id IS NULL;</strong></code></p><p>Explanation:</p><ul><li><p>In SQL, <code><strong>NULL</strong></code><strong> is not the same as an empty string (</strong><code><strong>''</strong></code><strong> or </strong><code><strong>\"\"</strong></code><strong>)</strong>.</p></li><li><p><code><strong>member_id = NULL</strong></code> is incorrect because <code>NULL</code> cannot be compared using <code>=</code>. Instead, the correct syntax to check for <code>NULL</code> values is <code><strong>IS NULL</strong></code>.</p></li><li><p><code><strong>member_id = ''</strong></code><strong> or </strong><code><strong>member_id = \"\"</strong></code> are incorrect because:</p><ul><li><p>In <strong>Oracle SQL</strong>, <code>VARCHAR2</code> columns store <code>NULL</code> when an empty string is inserted.</p></li><li><p>So, <code>member_id = ''</code> is <strong>treated as </strong><code><strong>IS NULL</strong></code>, but using <code>IS NULL</code> is the proper SQL syntax.</p></li></ul></li></ul><p>Correct SQL Query:</p><pre class=\"prettyprint linenums\">sql\nUPDATE books_transactions\nSET book_id = 'INVALID'\nWHERE member_id IS NULL;</pre>",
                "answers": [
                    "<p><code>member_id = '';</code> </p>",
                    "<p><code>member_id = NULL;</code> </p>",
                    "<p><code>member_id IS NULL;</code> </p>",
                    "<p><code>member_id = \"\";</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the BOOKS_TRANSACTIONS table and the exhibit.Table: BOOKS_TRANSACTIONSName                 Null??            Type\nTRANSACTION_ID       NOT NULL          VARCHAR2(6)\nBORROWED_DATE                          DATE\nDUE_DATE                               VARCHAR2(8)\nMEMBER_ID                              VARCHAR2(6)Examine this partial SQL statement.Exhibit: 1UPDATE books_transactions\nSET book_id = 'INVALID'\nWHERE ________________Required: Update this table such that BOOK_ID is set to 'INVALID' for all rows where no MEMBER_ID has been entered.Identify the condition that must be used in the WHERE clause to perform the required update.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943737,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the MEMBERS table.</p><p><strong>Table: MEMBERS </strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nMEMBER_ID            NOT NULL          VARCHAR2(6)\nFIRST_NAME                             VARCHAR2(50)\nLAST_NAME            NOT NULL          VARCHAR2(50)\nADDRESS                                VARCHAR2(50)\nCITY                                   VARCHAR2(25)\nSTATE                NOT NULL          VARCHAR2(3)</pre><p><br></p><p><strong>Required:</strong> Display the last names and city names only for members from the states of MO or MI</p><p><br></p><p>Identify the response that would best meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query uses the logical operator 'AND' between the conditions for states 'MO' and 'MI', which means that a member's state must be both 'MO' and 'MI' at the same time, which is not possible. This query will not return any results.",
                    "This query uses the 'LIKE' operator with a wildcard '%' for states starting with 'M'. It does not specifically filter for states 'MO' or 'MI', so it will return members from all states starting with 'M', not just 'MO' or 'MI'.",
                    "This query uses the 'IN' operator to filter for states 'MO' or 'MI'. It correctly retrieves the last names and city names for members from the states 'MO' or 'MI' as required.",
                    "This query uses the 'OR' operator between the conditions for states 'MO' and 'MI'. It will return the distinct last names and city names for members from either state 'MO' or state 'MI', which meets the requirement."
                ],
                "explanation": "<p>The correct SQL statement to meet the requirement is:</p><pre class=\"prettyprint linenums\">SELECT last_name, city \nFROM members \nWHERE state IN ('MO', 'MI');</pre><p>Explanation:</p><ul><li><p>The <code><strong>IN ('MO', 'MI')</strong></code> condition correctly filters rows where the <strong>state is either 'MO' or 'MI'</strong>.</p></li><li><p>This is functionally equivalent to using <code><strong>WHERE state = 'MO' OR state = 'MI'</strong></code>, but more concise.</p></li></ul><p>Explanation for incorrect responses:</p><ol><li><p><code><strong>SELECT last_name, city FROM members WHERE state='MO' AND state='MI';</strong></code></p><ul><li><p><strong>Incorrect</strong>: The <code>AND</code> condition <strong>requires the state to be both 'MO' and 'MI' at the same time</strong>, which is impossible.</p></li></ul></li><li><p><code><strong>SELECT last_name, city FROM members WHERE state LIKE 'M%';</strong></code></p><ul><li><p><strong>Incorrect</strong>:</p><ul><li><p><code>LIKE 'M%'</code> matches any state code <strong>starting with 'M'</strong>, including other states like <strong>'MA', 'MN', 'MS', etc.</strong>, which are not required.</p></li></ul></li></ul></li><li><p><code><strong>SELECT DISTINCT last_name, city FROM members WHERE state='MO' OR state='MI';</strong></code></p><ul><li><p><strong>Not necessarily wrong</strong>, but <code><strong>DISTINCT</strong></code><strong> is unnecessary</strong> unless duplicate <strong>(last_name, city)</strong> pairs need to be removed.</p></li><li><p>The <code><strong>IN</strong></code><strong> condition is more concise</strong> and performs the same filtering without adding unnecessary operations.</p></li></ul></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT last_name, city \nFROM members \nWHERE state='MO' AND&nbsp;state='MI';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT last_name, city \nFROM members \nWHERE state \nLIKE 'M%';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT last_name, city \nFROM members \nWHERE state \nIN('MO','MI');</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT last_name, city \nFROM members \nWHERE state='MO' \nOR state='MI';</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the MEMBERS table.Table: MEMBERS Name                 Null??            Type\nMEMBER_ID            NOT NULL          VARCHAR2(6)\nFIRST_NAME                             VARCHAR2(50)\nLAST_NAME            NOT NULL          VARCHAR2(50)\nADDRESS                                VARCHAR2(50)\nCITY                                   VARCHAR2(25)\nSTATE                NOT NULL          VARCHAR2(3)Required: Display the last names and city names only for members from the states of MO or MIIdentify the response that would best meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943739,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDERS table.</p><p><strong>Table: ORDERS </strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nORDER_ID            NOT NULL          NUMBER(4)\nORDER_DATE                            DATE\nCUSTOMER_ID                           NUMBER(3)\nORDER_TOTAL                           NUMBER(7,2)</pre><p><br></p><p><strong>Given:</strong> The ORDERS table contains data, and all orders have been assigned a customer ID. </p><p><br></p><p>Identify the statement that would add a NOT&nbsp;NULL constraint to the CUSTOMER_ID column.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The syntax provided is incorrect for adding a NOT NULL constraint to a column. The ALTER TABLE statement should be used to modify the column directly, not to create a new constraint.",
                    "The syntax provided is incorrect for adding a NOT NULL constraint to a column. The ADD CONSTRAINT clause is used to add a new constraint, not to modify an existing column.",
                    "This statement correctly uses the ALTER TABLE command to modify the CUSTOMER_ID column in the ORDERS table and add a NOT NULL constraint to it. This is the appropriate way to ensure that the CUSTOMER_ID column does not contain any NULL values.",
                    "The statement provided is incorrect as it attempts to add a new column with a NOT NULL constraint, rather than modifying an existing column to have a NOT NULL constraint."
                ],
                "explanation": "<p>The correct SQL statement to add a <strong>NOT NULL</strong> constraint to the <code>CUSTOMER_ID</code> column is:&nbsp; <code><strong>ALTER TABLE orders MODIFY customer_id NOT NULL;</strong></code></p><p>Explanation:</p><ul><li><p>The <strong>MODIFY</strong> clause is used to change the properties of an existing column in an Oracle table.</p></li><li><p>Adding <code><strong>NOT NULL</strong></code> to a column means it <strong>must always have a value</strong>.</p></li></ul><p>Explanation for Incorrect Statements:</p><ol><li><p><code><strong>ALTER TABLE orders MODIFY CONSTRAINT orders_cust_id_nn NOT NULL (customer_id);</strong></code></p><ul><li><p><strong>Incorrect Syntax</strong>:</p><ul><li><p>The <code>MODIFY</code> clause is used to alter <strong>column attributes</strong> (like <code>NOT NULL</code>), but <code><strong>CONSTRAINT</strong></code><strong> cannot be used in this way</strong>.</p></li><li><p><code>NOT NULL</code> is a <strong>column constraint</strong>, not a named constraint that can be altered separately.</p></li></ul></li></ul></li><li><p><code><strong>ALTER TABLE orders ADD CONSTRAINT orders_cust_id_nn NOT NULL (customer_id);</strong></code></p><ul><li><p><strong>Incorrect Syntax</strong>:</p><ul><li><p><code>NOT NULL</code> is <strong>not added as a separate constraint</strong> like <code>CHECK</code> or <code>FOREIGN KEY</code>.</p></li><li><p><code>NOT NULL</code> should be <strong>modified at the column level</strong>, not added via <code>ADD CONSTRAINT</code>.</p></li></ul></li></ul></li><li><p><code><strong>ALTER TABLE orders ADD customer_id NUMBER(6) CONSTRAINT orders_cust_id_nn NOT NULL;</strong></code></p><ul><li><p><strong>Incorrect</strong>:</p><ul><li><p>This statement <strong>tries to add a new column (</strong><code><strong>customer_id</strong></code><strong>)</strong>, but <code>CUSTOMER_ID</code> <strong>already exists</strong> in the table.</p></li><li><p>It does <strong>not modify</strong> an existing column.</p></li></ul></li></ul></li></ol>",
                "answers": [
                    "<p><code>ALTER&nbsp;TABLE orders MODIFY&nbsp;CONSTRAINT orders_cust_id_nn NOT&nbsp;NULL (customer_id);</code> </p>",
                    "<p><code>ALTER&nbsp;TABLE orders ADD&nbsp;CONSTRAINT orders_cust_id_nn NOT&nbsp;NULL (customer_id);</code> </p>",
                    "<p><code>ALTER TABLE orders MODIFY customer_id NOT NULL;</code> </p>",
                    "<p><code>ALTER&nbsp;TABLE orders ADD customer_id NUMBER(6) CONSTRAINT orders_cust_id_nn NOT&nbsp;NULL;</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the ORDERS table.Table: ORDERS Name                 Null??            Type\nORDER_ID            NOT NULL          NUMBER(4)\nORDER_DATE                            DATE\nCUSTOMER_ID                           NUMBER(3)\nORDER_TOTAL                           NUMBER(7,2)Given: The ORDERS table contains data, and all orders have been assigned a customer ID. Identify the statement that would add a NOT&nbsp;NULL constraint to the CUSTOMER_ID column.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943741,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the SALES and PRODUCTS tables and the exhibit.</p><p><strong>Table: SALES</strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nPROD_ID              NOT NULL          NUMBER(3)\nCUST_ID              NOT NULL          NUMBER(3)\nTIME_ID                                DATE\nQTY_SOLD                               NUMBER(10,2)</pre><p><br></p><p><strong>Table: PRODUCTS</strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nPROD_ID              NOT NULL          NUMBER(3)\nPROD_NAME                              VARCHAR2(30)\nPROD_LIST_PRICE                        NUMBER(8,2)</pre><p><br></p><p>Examine this query, which is missing a JOIN operator.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT p.prod_id, COUNT(s.prod_id)\nFROM products p _______________ sales s\nON p.prod_id = s.prod_id\nGROUP&nbsp;BY p.prod_id;</pre><p><br></p><p><strong>Given: </strong>In the SALES table, PROD_ID is the foreign key referencing PROD_ID in the PRODUCTS table. </p><p><strong>Required:</strong> </p><ol><li><p>List each Product_ID and the number of times it has been sold.</p></li><li><p>Include also Product_IDs that have not been sold.</p></li></ol><p><br></p><p>Identify two JOIN operations that can be used to obtain the required output? (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "A FULL OUTER JOIN combines the results of both the SALES and PRODUCTS tables, including all rows from both tables regardless of whether there is a match between the tables. This type of join will ensure that all product IDs and the number of times they have been sold are included in the output.",
                    "MATCH JOIN is not a valid JOIN operation in Oracle SQL. It does not exist as a standard JOIN type in SQL and cannot be used to obtain the required output in this scenario.",
                    "A LEFT OUTER JOIN will include all rows from the PRODUCTS table and only the matching rows from the SALES table. This type of join will ensure that each product ID and the number of times it has been sold are included in the output, even if there are no sales records for a particular product.",
                    "A RIGHT OUTER JOIN will include all rows from the SALES table and only the matching rows from the PRODUCTS table. This type of join may not be suitable for obtaining the required output as it will prioritize the sales records over the product IDs, potentially excluding products that have not been sold."
                ],
                "explanation": "<p>The two <strong>JOIN</strong> operations that can be used to obtain the required output are:</p><ol><li><p><code><strong>LEFT OUTER JOIN</strong></code></p></li><li><p><code><strong>FULL OUTER JOIN</strong></code></p></li></ol><p>Explanation:</p><p>The requirement is to <strong>list each </strong><code><strong>PROD_ID</strong></code><strong> from the </strong><code><strong>PRODUCTS</strong></code><strong> table and the number of times it has been sold</strong>, <strong>including products that have not been sold</strong> (i.e., products with no matching records in the <code>SALES</code> table).</p><p><strong>1. LEFT OUTER JOIN</strong></p><ul><li><p>This will <strong>return all </strong><code><strong>PROD_ID</strong></code><strong>s from the </strong><code><strong>PRODUCTS</strong></code><strong> table</strong> (left table) and the matching <code>PROD_ID</code>s from <code>SALES</code> (right table).</p></li><li><p>If a product has <strong>not been sold</strong>, the count will be <strong>0</strong> because of the <code>COUNT(s.prod_id)</code>.</p></li></ul><p><strong>Query using LEFT OUTER JOIN:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT p.prod_id, COUNT(s.prod_id)\nFROM products p LEFT OUTER JOIN sales s\nON p.prod_id = s.prod_id\nGROUP BY p.prod_id;</pre><p><strong>2. FULL OUTER JOIN</strong> </p><ul><li><p>This will return <strong>all </strong><code><strong>PROD_ID</strong></code><strong>s from both </strong><code><strong>PRODUCTS</strong></code><strong> and </strong><code><strong>SALES</strong></code>, ensuring that <strong>even products with no sales and sales records without a matching product are included</strong>.</p></li><li><p>Since <code><strong>PROD_ID</strong></code><strong> is a foreign key in </strong><code><strong>SALES</strong></code><strong> referencing </strong><code><strong>PRODUCTS</strong></code>, there shouldn't be sales without a matching product, but <strong>using a </strong><code><strong>FULL OUTER JOIN</strong></code><strong> still guarantees all records from both tables</strong>.</p></li></ul><p><strong>Query using FULL OUTER JOIN:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT p.prod_id, COUNT(s.prod_id)\nFROM products p FULL OUTER JOIN sales s\nON p.prod_id = s.prod_id\nGROUP BY p.prod_id;</pre><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>MATCH JOIN</strong></p><ul><li><p><strong>Incorrect</strong>: This is <strong>not a standard SQL join type</strong>. Likely a <strong>misleading or incorrect option</strong>.</p></li></ul><p><strong>RIGHT OUTER JOIN</strong></p><ul><li><p><strong>Incorrect</strong>: This would include <strong>all </strong><code><strong>PROD_ID</strong></code><strong>s from the </strong><code><strong>SALES</strong></code><strong> table</strong> and any matching products from <code>PRODUCTS</code>.</p></li><li><p><strong>It does NOT ensure all products are listed</strong>, which is required in the problem statement.</p></li></ul><p><br></p><p><strong>The Oracle COUNT() function</strong> is an <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate function</a> that returns the number of items in a group.</p><p>The syntax of the <code>COUNT()</code> function is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">COUNT( [ALL | DISTINCT | * ] expression)</pre><p><br></p><p>The <code>COUNT()</code> function accepts a clause which can be either <code>ALL</code>, <code>DISTINCT</code>, or <code>*</code>:</p><p><code>COUNT(*)</code> function returns the number of items in a group, including <code>NULL</code> and duplicate values.</p><p><code>COUNT(DISTINCT expression)</code> function returns the number of unique and non-null items in a group.</p><p><code>COUNT(ALL expression)</code> evaluates the expression and returns the number of non-null items in a group, including duplicate values.</p><p>If you don’t explicitly specify <code>DISTINCT</code> or <code>ALL</code>, the <code>COUNT()</code> function uses <code>ALL</code> by default.</p><p>Note that, unlike other <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>, the <code>COUNT(*)</code> function does not ignore <code>NULL</code> values.</p><p><a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/\">https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/</a></p><p><br></p><p><strong>LEFT JOIN and LEFT OUTER JOIN are the same thing.</strong> LEFT JOIN performs a join starting with the first (left-most) table and then any matching second (right-most) table records. In this case, we are looking at the available products and matching them to the items that have been sold. If an item has not been sold, it will not be matched in the products table.</p><p><strong>FULL OUTER JOIN and FULL JOIN are the same. </strong>The FULL OUTER JOIN keyword returns all records when there is a match in the left (table1) or right (table2) table records. In this case, we are comparing the two tables to see what the common records are. If there are products in the table that have not been sold, the sales table will set them to zero when they are counted.</p><p><strong>Note that all queries ran successfully, but also note the difference in the output. </strong>The LEFT and FULL OUT JOIN render the same output of 7 records; the RIGHT and JOIN render the same output of 5 records because they are not reporting the products with zero sales.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-11_00-04-30-ba6b09810caf46ce0f7ce81df0f60b86.png\"></p>",
                "answers": [
                    "<p><code>FULL OUTER JOIN</code> </p>",
                    "<p><code>MATCH JOIN</code> </p>",
                    "<p><code>LEFT OUTER JOIN</code> </p>",
                    "<p><code>RIGHT OUTER JOIN</code> </p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the SALES and PRODUCTS tables and the exhibit.Table: SALESName                 Null??            Type\nPROD_ID              NOT NULL          NUMBER(3)\nCUST_ID              NOT NULL          NUMBER(3)\nTIME_ID                                DATE\nQTY_SOLD                               NUMBER(10,2)Table: PRODUCTSName                 Null??            Type\nPROD_ID              NOT NULL          NUMBER(3)\nPROD_NAME                              VARCHAR2(30)\nPROD_LIST_PRICE                        NUMBER(8,2)Examine this query, which is missing a JOIN operator.Exhibit: 1SELECT p.prod_id, COUNT(s.prod_id)\nFROM products p _______________ sales s\nON p.prod_id = s.prod_id\nGROUP&nbsp;BY p.prod_id;Given: In the SALES table, PROD_ID is the foreign key referencing PROD_ID in the PRODUCTS table. Required: List each Product_ID and the number of times it has been sold.Include also Product_IDs that have not been sold.Identify two JOIN operations that can be used to obtain the required output? (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943743,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the description of the BOOKS_TRANSACTIONS table and exhibit.</p><p><strong>Table: BOOKS_TRANSACTIONS </strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nTRANSACTION_ID       NOT NULL          VARCHAR2(6)\nTRANSACTION_TYPE     NOT NULL          VARCHAR2(3)\nBORROWED_DATE                          DATE\nBOOK_ID                                VARCHAR2(6)\nMEMBER_ID                              VARCHAR2(6)</pre><p><br></p><p>Examine this partial SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM books_transactions</pre><p><br></p><p>Identify two WHERE conditions that render the same result. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This WHERE condition checks for rows where the borrowed date is the current date and the transaction type is 'RM', or the member ID is either 'A101' or 'A102'. This condition will return results where either of the two conditions is met.",
                    "This WHERE condition checks for rows where either the borrowed date is the current date and the transaction type is 'RM', or the member ID is either 'A101' or 'A102'. This condition will return results where either of the two conditions is met, making it equivalent to the first condition.",
                    "This WHERE condition checks for rows where the borrowed date is the current date, or the transaction type is 'RM' and the member ID is either 'A101' or 'A102'. This condition will return results where either the borrowed date is the current date, or both the transaction type is 'RM' and the member ID is either 'A101' or 'A102'.",
                    "This WHERE condition checks for rows where the borrowed date is the current date and the transaction type is 'RM', or the member ID is either 'A101' or 'A102'. This condition will return results where either of the two conditions is met, making it equivalent to the first condition.",
                    "This WHERE condition checks for rows where the borrowed date is the current date, the transaction type is 'RM', and the member ID is either 'A101' or 'A102'. This condition will only return results where all three conditions are met, making it different from the other conditions."
                ],
                "explanation": "<p>The two <strong>WHERE</strong> conditions that render the same result are:</p><p><strong>1.</strong></p><pre class=\"prettyprint linenums\">sql\nWHERE borrowed_date = SYSDATE \nAND (transaction_type = 'RM' \nOR member_id IN ('A101', 'A102'));\n</pre><p><strong>2.</strong></p><pre class=\"prettyprint linenums\">sql\nWHERE (borrowed_date = SYSDATE\nAND transaction_type = 'RM')\nOR member_id IN ('A101', 'A102');</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-07_19-43-07-3423e3ed4c21e7bce978d9d60f801fca.png\"></p><p><br></p><p>Both conditions logically evaluate the same set of records because:</p><ol><li><p><strong>First condition:</strong></p><ul><li><p><code>borrowed_date = SYSDATE</code></p></li><li><p><strong>AND</strong> (either <code>transaction_type = 'RM'</code> <strong>or</strong> <code>member_id IN ('A101', 'A102')</code>)</p></li><li><p>This means <strong>only records where </strong><code><strong>borrowed_date = SYSDATE</strong></code><strong> are considered</strong>, but within those, it allows either <code>transaction_type = 'RM'</code> <strong>or</strong> specific <code>member_id</code>s.</p></li></ul></li><li><p><strong>Second condition:</strong></p><ul><li><p><code>(borrowed_date = SYSDATE AND transaction_type = 'RM')</code></p></li><li><p><strong>OR</strong> <code>member_id IN ('A101', 'A102')</code></p></li><li><p>This means:</p><ul><li><p>Either (<code>borrowed_date = SYSDATE</code> <strong>and</strong> <code>transaction_type = 'RM'</code>) <strong>OR</strong></p></li><li><p>Any row where <code>member_id IN ('A101', 'A102')</code>, regardless of <code>borrowed_date</code>.</p></li></ul></li><li><p>This effectively produces the same result as the first condition.</p></li></ul></li></ol><p><br></p><p><strong>Why the Other Options Are Incorrect</strong>:</p><pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE \nAND (transaction_type = 'RM' \nOR&nbsp;member_id IN ('A101','A102'));</pre><ul><li><p>This condition allows <strong>all records where </strong><code><strong>borrowed_date = SYSDATE</strong></code>, <strong>even if they don’t match </strong><code><strong>transaction_type = 'RM'</strong></code><strong> or </strong><code><strong>member_id</strong></code><strong> conditions</strong>.</p></li><li><p>It’s too broad and includes extra rows.</p></li></ul><pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE\nOR (transaction_type = 'RM'\nAND (member_id = 'A101'\nOR member_id = 'A102'));</pre><ul><li><p>Due to <strong>operator precedence</strong>, this condition is evaluated as:</p><pre class=\"prettyprint linenums\">sql\n(borrowed_date = SYSDATE AND transaction_type = 'RM') OR member_id IN ('A101', 'A102')\n</pre><ul><li><p>Which is <strong>the same as the second correct condition</strong>.</p></li><li><p>However, because <strong>it lacks parentheses</strong>, its meaning is ambiguous and should be avoided in favor of clearer syntax.</p></li></ul></li></ul><pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE\nAND (transaction_type = 'RM' \nAND member_id = 'A101' \nOR member_id = 'A102');</pre><ul><li><p>This is interpreted as:</p><pre class=\"prettyprint linenums\">sql\n(borrowed_date = SYSDATE AND transaction_type = 'RM' AND member_id = 'A101') OR member_id = 'A102'\n</pre><ul><li><p>This allows <strong>all records where </strong><code><strong>member_id = 'A102'</strong></code>, regardless of <code>borrowed_date</code>, making it incorrect.</p></li></ul></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE \nAND (transaction_type = 'RM' \nOR&nbsp;member_id IN ('A101','A102'));</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE (borrowed_date = SYSDATE\nAND transaction_type = 'RM')\nOR member_id IN ('A101','A102');</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE\nOR (transaction_type = 'RM'\nAND (member_id = 'A101'\nOR member_id = 'A102'));</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE \nAND transaction_type = 'RM' \nOR&nbsp;member_id IN ('A101','A102');</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE borrowed_date = SYSDATE\nAND (transaction_type = 'RM' \nAND member_id = 'A101' \nOR member_id = 'A102');</pre>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the description of the BOOKS_TRANSACTIONS table and exhibit.Table: BOOKS_TRANSACTIONS Name                 Null??            Type\nTRANSACTION_ID       NOT NULL          VARCHAR2(6)\nTRANSACTION_TYPE     NOT NULL          VARCHAR2(3)\nBORROWED_DATE                          DATE\nBOOK_ID                                VARCHAR2(6)\nMEMBER_ID                              VARCHAR2(6)Examine this partial SQL statement.Exhibit: 1SELECT *\nFROM books_transactionsIdentify two WHERE conditions that render the same result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943745,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given: </strong>The first DROP operation is performed on the PRODUCTS table using this command.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE products PURGE;</pre><p><br></p><p>Then a FLASHBACK operation is performed using this command.</p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">FLASHBACK TABLE products TO BEFORE DROP;</pre><p><br></p><p>Identify the result of the <code>FLASHBACK</code> command.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The FLASHBACK command in Oracle Database is used to recover data to a previous state, not just the table structure. Therefore, it is incorrect to say that it only recovers the table structure.",
                    "The FLASHBACK command in Oracle Database is designed to recover the entire state of the table, including data, structure, and indexes. It is not limited to recovering only the table structure.",
                    "The FLASHBACK command in Oracle Database is capable of recovering both the table structure and data, as well as any related indexes. It does not exclude the recovery of indexes when reverting to a previous state.",
                    "<p>The <code>DROP TABLE products PURGE;</code> command permanently removes the table and its metadata from the database, bypassing the recycle bin. Since the table is purged, it is no longer retrievable, and the <code>FLASHBACK TABLE</code> command cannot restore it. The <code>FLASHBACK</code> operation relies on the existence of the table's information in the recycle bin, which is not the case after using the <code>PURGE</code> option.</p>"
                ],
                "explanation": "<p>In this scenario, the <code>DROP TABLE products PURGE;</code> command is executed first, followed by a <code>FLASHBACK TABLE products TO BEFORE DROP;</code> command.</p><p><strong>Understanding the Commands:</strong></p><ol><li><p><code><strong>DROP TABLE products PURGE;</strong></code></p><ul><li><p>The <code>PURGE</code> option permanently removes the table and all its dependent objects from the <strong>Recycle Bin</strong>.</p></li><li><p>This means the table <strong>cannot</strong> be recovered using the <code>FLASHBACK TABLE</code> command.</p></li></ul></li><li><p><code><strong>FLASHBACK TABLE products TO BEFORE DROP;</strong></code></p><ul><li><p>This command is used to restore a dropped table from the <strong>Recycle Bin</strong>.</p></li><li><p>However, since the table was dropped with the <code>PURGE</code> option, it is <strong>not</strong> stored in the Recycle Bin.</p></li></ul></li></ol><p><strong>Result of the FLASHBACK Command:</strong></p><ul><li><p>The <code>FLASHBACK TABLE products TO BEFORE DROP;</code> command <strong>fails</strong> with an error stating that the table cannot be recovered because it is not in the Recycle Bin.</p></li></ul><p><strong>Error Message (Expected Output):</strong></p><p><br></p><pre class=\"prettyprint linenums\">ORA-38305: object not in RECYCLE BIN</pre><p><br></p><p><strong>Conclusion:</strong></p><p>Since the <code>PURGE</code> option was used in the <code>DROP TABLE</code> statement, the table is permanently deleted, and a <code>FLASHBACK</code> operation cannot restore it.</p><p><br></p><p>Use the <code>PURGE</code> statement to remove a table or index from your recycle bin and release all of the space associated with the object, or to remove the entire recycle bin, or to remove part of a dropped tablespace from the recycle bin.</p><p>You cannot roll back a <code>PURGE</code> statement, nor can you recover an object after it is purged.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9018.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9018.htm</a></p><p><br></p><p>Use the <code>DROP</code> <code>TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9003.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9003.htm</a></p><p><br></p><p>Use the <code>FLASHBACK</code> <code>TABLE</code> statement to restore an earlier state of a table in the event of a human or application error. The time in the past to which the table can be flashed back is dependent on the amount of undo data in the system. Also, Oracle Database cannot restore a table to an earlier state across any DDL operations that change the structure of the table.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9012.htm#SQLRF01802\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9012.htm#SQLRF01802</a></p>",
                "answers": [
                    "<p>It recovers only the table structure.</p>",
                    "<p>It recovers the table structure, data and the indexes.</p>",
                    "<p>It recovers the table structure and data but not the related indexes.</p>",
                    "<p>It is not possible to recover the table structure, data or the related indexes.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following scenario.Given: The first DROP operation is performed on the PRODUCTS table using this command.Exhibit: 1DROP&nbsp;TABLE products PURGE;Then a FLASHBACK operation is performed using this command.Exhibit: 2FLASHBACK TABLE products TO BEFORE DROP;Identify the result of the FLASHBACK command.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943747,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the structure in the ORDERS and ORDER_ITEMS tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-01-19-7d69163d6ea97f2b547986b73574afbe.png\"></p><p><br></p><p><strong>Required:</strong> Create a view that displays the ORDER_ID, ORDER_DATE, and the total number of items in each order, indicated by appropriately named columns.</p><p><br></p><p>Identify the response that would meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice is incorrect because the COUNT function is missing an alias for the calculated column, and the GROUP BY clause only includes the order_date column instead of both order_id and order_date as required.",
                    "This choice is incorrect because the syntax for the GROUP BY clause is incorrect, and the JOIN clause is not properly structured. Additionally, the COUNT function is missing an alias for the calculated column.",
                    "This choice is correct because it selects the order_id, order_date, and uses the COUNT function with an alias \"NO OF ITEMS\" to display the total number of items in each order. The JOIN and GROUP BY clauses are correctly structured to achieve the desired result.",
                    "This choice is incorrect because the concatenation operator (||) is used incorrectly in the COUNT function, and the syntax for the GROUP BY clause is incorrect. Additionally, the WITH CHECK OPTION clause is not applicable in this context."
                ],
                "explanation": "<p><strong>Correct View Creation Statement:</strong></p><p><br></p><pre class=\"prettyprint linenums\">sql\nCREATE OR REPLACE VIEW ord_vu AS \n    SELECT o.order_id, \n           o.order_date, \n           COUNT(i.line_item_id) AS \"NO OF ITEMS\"\n    FROM orders o \n    JOIN order_items i \n    ON (o.order_id = i.order_id)\n    GROUP BY o.order_id, o.order_date;</pre><p><br></p><p><strong>Why is this correct?</strong></p><ul><li><p><code><strong>CREATE OR REPLACE VIEW ord_vu</strong></code> → Ensures that if the view already exists, it will be replaced.</p></li><li><p><code><strong>SELECT o.order_id, o.order_date, COUNT(i.line_item_id) \"NO OF ITEMS\"</strong></code>:</p><ul><li><p><code>COUNT(i.line_item_id)</code>: Counts the number of items in each order.</p></li><li><p><code>\"NO OF ITEMS\"</code>: Assigns a clear alias for the column name.</p></li></ul></li><li><p><code><strong>FROM orders o JOIN order_items i ON (o.order_id = i.order_id)</strong></code>:</p><ul><li><p>Ensures only matching records between <code>orders</code> and <code>order_items</code> are included.</p></li></ul></li><li><p><code><strong>GROUP BY o.order_id, o.order_date</strong></code>:</p><ul><li><p>Necessary because <code>COUNT()</code> is an aggregate function, requiring grouping by <code>order_id</code> and <code>order_date</code>.</p></li></ul></li></ul><p><strong>An Oracle VIEW</strong>, in essence, is a virtual table that does not physically exist. Rather, it is created by a query <a href=\"https://www.techonthenet.com/oracle/joins.php\">joining one or more tables</a>.</p><p>The <code>CREATE VIEW</code> statement defines a view, which is a logical table based on one or more tables or views. A view contains no data itself. The tables upon which a view is based are called base tables.</p><p>To create a view in your own schema, you must have the <code>CREATE VIEW</code> system privilege. To create a view in another user's schema, you must have the <code>CREATE ANY VIEW</code> system privilege.</p><p>To create a subview, you must have the<code> UNDER ANY VIEW</code> system privilege or the <code>UNDER</code> object privilege on the superview.</p><p>The owner of the schema containing the view must have the privileges necessary to either select, insert, update, or delete rows from all the tables or views on which the view is based. The owner must be granted these privileges directly, rather than through a role.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_8004.htm#SQLRF01504\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_8004.htm#SQLRF01504</a></p><p><br></p><p>The syntax for the<strong> CREATE VIEW Statement</strong> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE VIEW view_name AS\n  SELECT columns\n  FROM tables\n  [WHERE conditions];</pre><p><br></p><p>To call the <code>VIEW</code>, it is treated like a regular table, which can be selectively searched and filtered.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM view_name ;</pre><p>As with any table, they can be altered, modified, or dropped.</p><p><br></p><p>Here is an example of how to use the Oracle <code>CREATE VIEW</code>:</p><pre class=\"prettyprint linenums\">CREATE VIEW sup_orders AS\n  SELECT suppliers.supplier_id, orders.quantity, orders.price\n  FROM suppliers\n  INNER JOIN orders\n  ON suppliers.supplier_id = orders.supplier_id\n  WHERE suppliers.supplier_name = 'Microsoft';</pre><p><a href=\"https://www.techonthenet.com/oracle/views.php\">https://www.techonthenet.com/oracle/views.php</a></p><p><br></p><p><strong>The Oracle GROUP BY clause</strong> is used in a<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statement</a> to collect data across multiple records and group the results by one or more columns.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>GROUP BY</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause. </p><p>aggregate_function - It can be a function such as<a href=\"https://www.techonthenet.com/oracle/functions/sum.php\"> SUM</a>,<a href=\"https://www.techonthenet.com/oracle/functions/count.php\"> COUNT</a>,<a href=\"https://www.techonthenet.com/oracle/functions/min.php\"> MIN</a>,<a href=\"https://www.techonthenet.com/oracle/functions/max.php\"> MAX</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/avg.php\">AVG</a> functions. </p><p>aggregate_expression - This is the column or expression that the <em>aggregate_function</em> will be used on. Tables: The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions are Optional. - The conditions that must be met for the records to be selected.</p><p><a href=\"https://www.techonthenet.com/oracle/group_by.php\">https://www.techonthenet.com/oracle/group_by.php</a></p><p><br></p><p><strong>NOTE:</strong> All columns in the <code>SELECT</code> clause need to be entered into the <code>GROUP&nbsp;BY,</code> except the aggregate function called in the <code>SELECT</code>&nbsp;clause.</p><pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW ord_vu AS \n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date,\n&nbsp; &nbsp; &nbsp;COUNT(i.line_item_id) \"NO OF ITEMS\"\n&nbsp; &nbsp; &nbsp;FROM orders o \n&nbsp; &nbsp; &nbsp;JOIN order_items i \n&nbsp; &nbsp; &nbsp;ON (o.order_id = i.order_id)\n&nbsp; &nbsp; &nbsp;GROUP BY o.order_id,o.order_date;</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW ord_vu AS \n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date,\n&nbsp; &nbsp; &nbsp;COUNT(i.line_item_id)\n&nbsp; &nbsp; &nbsp;FROM orders o \n&nbsp; &nbsp; &nbsp;JOIN order_items i \n&nbsp; &nbsp; &nbsp;ON (o.order_id = i.order_id)\n&nbsp; &nbsp; &nbsp;GROUP BY order_date;</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW ord_vu (order_id, order_date) AS \n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date, \n&nbsp; &nbsp; &nbsp;COUNT(i.line_item_id) \"NO OF ITEMS\"\n&nbsp; &nbsp; &nbsp;FROM orders o \n&nbsp; &nbsp; &nbsp;GROUP order_items i ON (o.order_id = i.order_id)\n&nbsp; &nbsp; &nbsp;JOIN BY o.order_id, o.order_date;</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW ord_vu AS \n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date,\n&nbsp; &nbsp; &nbsp;COUNT(i.line_item_id) \"NO OF ITEMS\"\n&nbsp; &nbsp; &nbsp;FROM orders o \n&nbsp; &nbsp; &nbsp;JOIN order_items i \n&nbsp; &nbsp; &nbsp;ON (o.order_id = i.order_id)\n&nbsp; &nbsp; &nbsp;GROUP BY o.order_id,o.order_date;</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW ord_vu AS \n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date,\n&nbsp; &nbsp; &nbsp;COUNT(i.line_item_id)||'NO OF ITEMS'\n&nbsp; &nbsp; &nbsp;FROM orders o \n&nbsp; &nbsp; &nbsp;JOIN order_items i ON (o.order_id = i.order_id)\n&nbsp; &nbsp; &nbsp;GROUP BY o.order_id,o.order_date\n&nbsp; &nbsp; &nbsp;WITH CHECK OPTION;</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View the exhibit and examine the structure in the ORDERS and ORDER_ITEMS tables.Required: Create a view that displays the ORDER_ID, ORDER_DATE, and the total number of items in each order, indicated by appropriately named columns.Identify the response that would meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943749,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the CREATE TABLE command. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Statements That Cause an Implicit Commit](https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/implicit-commit.html)"
                ],
                "feedbacks": [
                    "The CREATE TABLE command is used to create a new table in a database. It does not include the CREATE..INDEX statement for creating an index to enforce the primary key constraint. Index creation is a separate operation that can be done after creating the table.",
                    "When the TEMPORARY keyword is used in a CREATE TABLE statement, it indicates that the table is a temporary table. Temporary tables do not commit a transaction, meaning that any changes made to the table are not permanently saved to the database.",
                    "To create a table in another user's schema, the user executing the CREATE TABLE command must have the CREATE ANY TABLE system privilege. This privilege allows the user to create tables in any schema within the database.",
                    "The CREATE TABLE command does not implicitly roll back any pending transactions. Transactions in a database must be explicitly committed or rolled back by the user to ensure data integrity and consistency.",
                    "The owner of the table does not necessarily need to have the UNLIMITED TABLESPACE system privilege to create a table. The UNLIMITED TABLESPACE privilege allows a user to allocate unlimited space in a tablespace, but it is not a requirement for creating a table."
                ],
                "explanation": "<p>The <strong>true statements</strong> about the <code>CREATE TABLE</code> command are:</p><ol><li><p><strong>\"To create a table in another user's schema, you must have the CREATE ANY TABLE system privilege.\"</strong> </p><ul><li><p>This is correct because creating a table in another user's schema requires the <code>CREATE ANY TABLE</code> system privilege in Oracle databases.</p></li></ul></li><li><p><strong>\"CREATE TABLE statements do not commit a transaction if the TEMPORARY keyword is used.\"</strong> </p><ul><li><p>This is true because <strong>temporary tables</strong> exist only for the duration of a session or transaction, and their creation does not implicitly commit a transaction.</p></li></ul></li></ol><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_7002.htm#SQLRF01402\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_7002.htm#SQLRF01402</a></p><p><br></p><p><strong>False Statements Explained:</strong></p><ul><li><p><strong>\"It can include the CREATE..INDEX statement for creating an index to enforce the primary key constraint.\"</strong></p><ul><li><p><code>CREATE TABLE</code> does <strong>not</strong> include <code>CREATE INDEX</code>. Instead, when a primary key is defined, an <strong>index is automatically created</strong>, but not explicitly within the same command.</p></li></ul></li><li><p><strong>\"It implicitly rolls back any pending transactions.\"</strong></p><ul><li><p><code>CREATE TABLE</code> is a <strong>DDL (Data Definition Language) statement</strong>, and DDL statements <strong>implicitly commit</strong> transactions rather than rolling them back.</p></li></ul></li><li><p><strong>\"The owner of the table must have the UNLIMITED TABLESPACE system privilege.\"</strong></p><ul><li><p>This is incorrect. The owner needs a <strong>quota</strong> on the tablespace where the table is being created, but <code>UNLIMITED TABLESPACE</code> is only required if unrestricted use of the tablespace is necessary.</p></li></ul></li></ul><p><br></p><p>Most of these statements also cause an implicit commit after executing. The intent is to handle each such statement in its own special transaction because it cannot be rolled back anyway. Transaction-control and locking statements are exceptions: If an implicit commit occurs before execution, another does not occur after.</p><ul><li><p><strong>Data definition language (DDL) statements that define or modify database objects.</strong> <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-database.html\" title=\"13.1.1&nbsp;ALTER DATABASE Statement\"><code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Statement\"><code>ALTER EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-procedure.html\" title=\"13.1.6&nbsp;ALTER PROCEDURE Statement\"><code>ALTER PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-server.html\" title=\"13.1.7&nbsp;ALTER SERVER Statement\"><code>ALTER SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-table.html\" title=\"13.1.8&nbsp;ALTER TABLE Statement\"><code>ALTER TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-view.html\" title=\"13.1.10&nbsp;ALTER VIEW Statement\"><code>ALTER VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-database.html\" title=\"13.1.11&nbsp;CREATE DATABASE Statement\"><code>CREATE DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-event.html\" title=\"13.1.12&nbsp;CREATE EVENT Statement\"><code>CREATE EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-index.html\" title=\"13.1.14&nbsp;CREATE INDEX Statement\"><code>CREATE INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-procedure.html\" title=\"13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Statements\"><code>CREATE PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-server.html\" title=\"13.1.17&nbsp;CREATE SERVER Statement\"><code>CREATE SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-trigger.html\" title=\"13.1.20&nbsp;CREATE TRIGGER Statement\"><code>CREATE TRIGGER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-view.html\" title=\"13.1.21&nbsp;CREATE VIEW Statement\"><code>CREATE VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-database.html\" title=\"13.1.22&nbsp;DROP DATABASE Statement\"><code>DROP DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-event.html\" title=\"13.1.23&nbsp;DROP EVENT Statement\"><code>DROP EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-index.html\" title=\"13.1.25&nbsp;DROP INDEX Statement\"><code>DROP INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-procedure.html\" title=\"13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Statements\"><code>DROP PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-server.html\" title=\"13.1.28&nbsp;DROP SERVER Statement\"><code>DROP SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-table.html\" title=\"13.1.29&nbsp;DROP TABLE Statement\"><code>DROP TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-trigger.html\" title=\"13.1.31&nbsp;DROP TRIGGER Statement\"><code>DROP TRIGGER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-view.html\" title=\"13.1.32&nbsp;DROP VIEW Statement\"><code>DROP VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/install-plugin.html\" title=\"13.7.3.3&nbsp;INSTALL PLUGIN Statement\"><code>INSTALL PLUGIN</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/rename-table.html\" title=\"13.1.33&nbsp;RENAME TABLE Statement\"><code>RENAME TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/truncate-table.html\" title=\"13.1.34&nbsp;TRUNCATE TABLE Statement\"><code>TRUNCATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/uninstall-plugin.html\" title=\"13.7.3.4&nbsp;UNINSTALL PLUGIN Statement\"><code>UNINSTALL PLUGIN</code></a>.</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-function.html\" title=\"13.1.3&nbsp;ALTER FUNCTION Statement\"><code>ALTER FUNCTION</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-function.html\" title=\"13.1.13&nbsp;CREATE FUNCTION Statement\"><code>CREATE FUNCTION</code></a> and <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-function.html\" title=\"13.1.24&nbsp;DROP FUNCTION Statement\"><code>DROP FUNCTION</code></a> also cause an implicit commit when used with stored functions, but not with user-defined functions. (<a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-function.html\" title=\"13.1.3&nbsp;ALTER FUNCTION Statement\"><code>ALTER FUNCTION</code></a> can only be used with stored functions.)</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE</code></a> and <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/drop-table.html\" title=\"13.1.29&nbsp;DROP TABLE Statement\"><code>DROP TABLE</code></a> statements do not commit a transaction if the <code>TEMPORARY</code> keyword is used. (This does not apply to other operations on temporary tables such as <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-table.html\" title=\"13.1.8&nbsp;ALTER TABLE Statement\"><code>ALTER TABLE</code></a> and <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-index.html\" title=\"13.1.14&nbsp;CREATE INDEX Statement\"><code>CREATE INDEX</code></a>, which do cause a commit.) However, although no implicit commit occurs, neither can the statement be rolled back, which means that the use of such statements causes transactional atomicity to be violated. For example, if you use <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TEMPORARY TABLE</code></a> and then roll back the transaction, the table remains in existence.</p><p>The <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE</code></a> statement in <code>InnoDB</code> is processed as a single transaction. This means that a <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/commit.html\" title=\"13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Statements\"><code>ROLLBACK</code></a> from the user does not undo <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE</code></a> statements the user made during that transaction.</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table.html\" title=\"13.1.18&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE ... SELECT</code></a> causes an implicit commit before and after the statement is executed when you are creating nontemporary tables. (No commit occurs for <code>CREATE TEMPORARY TABLE ... SELECT</code>.)</p></li></ul>",
                "answers": [
                    "<p>It can include the CREATE..INDEX statement for creating an index to enforce the primary key constraint</p>",
                    "<p>CREATE TABLE statements do not commit a transaction if the TEMPORARY keyword is used</p>",
                    "<p>To create a table in another user's schema, you must have the CREATE ANY TABLE system privilege</p>",
                    "<p>It implicitly rolls back any pending transactions</p>",
                    "<p>The owner of the table must have the UNLIMITED TABLESPACE system privilege</p>"
                ]
            },
            "correct_response": [
                "b",
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements about the CREATE TABLE command. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943751,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about conditional.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "In conditional INSERT ALL, each WHEN condition is evaluated for every row returned by the subquery. If the condition is met, the corresponding INTO clause is executed for that specific row.",
                    "The total number of rows inserted using conditional INSERT ALL may not always be equal to the number of rows returned by the subquery. Depending on the WHEN conditions specified, some rows may not meet the conditions and therefore not be inserted.",
                    "Conditional INSERT ALL allows a single WHEN condition to be used for multiple INTO clauses. This means that multiple target tables can be specified within the same WHEN condition for different insertion scenarios.",
                    "Conditional INSERT ALL can have an ELSE clause, which specifies the action to be taken if none of the WHEN conditions are met. This allows for a default behavior in case none of the specified conditions are satisfied.",
                    "Each row returned by the subquery in conditional INSERT ALL can be inserted into multiple target tables if the WHEN conditions for those tables are met. This flexibility allows for conditional insertion of rows into different tables based on specific criteria."
                ],
                "explanation": "<p>The <strong>two true statements</strong> about <strong>conditional </strong><code><strong>INSERT ALL</strong></code> are:</p><ol><li><p><strong>\"Each WHEN condition is tested for each row returned by the subquery.\"</strong></p><ul><li><p>This is correct because <strong>conditional </strong><code><strong>INSERT ALL</strong></code> evaluates each <code>WHEN</code> condition against every row returned by the subquery. If a condition matches, the row is inserted into the corresponding table.</p></li></ul></li><li><p><strong>\"A single WHEN condition can be used for multiple INTO clauses.\"</strong></p><ul><li><p>This is true because a single <code>WHEN</code> condition can specify multiple <code>INTO</code> clauses, allowing the same row to be inserted into multiple tables based on one condition.</p></li></ul></li></ol><p><strong>False Statements Explained:</strong></p><ul><li><p><strong>\"The total number of rows inserted is always equal to the number of rows returned by the subquery.\"</strong></p><ul><li><p>Incorrect because <strong>a single row from the subquery can be inserted into multiple tables</strong>, meaning the number of inserted rows <strong>can be greater</strong> than the number of rows in the subquery result.</p></li></ul></li><li><p><strong>\"It cannot have an ELSE clause.\"</strong></p><ul><li><p>Incorrect because <strong>conditional </strong><code><strong>INSERT ALL</strong></code><strong> can include an ELSE clause</strong>, which handles cases where none of the <code>WHEN</code> conditions match.</p></li></ul></li><li><p><strong>\"Each row returned by the subquery can be inserted into only a single target table.\"</strong></p><ul><li><p>Incorrect because a single row <strong>can be inserted into multiple tables</strong> if it satisfies multiple <code>WHEN</code> conditions.</p></li></ul></li></ul><p>For you to insert rows into a table, the table must be in your own schema, or you must have the <code>INSERT</code> object privilege on the table.</p><p>For you to insert rows into the base table of a view, the owner of the schema containing the view must have the <code>INSERT</code> object privilege on the base table. Also, if the view is in a schema other than your own, then you must have the <code>INSERT</code> object privilege on the view.</p><p>If you have the <code>INSERT</code> <code>ANY</code> <code>TABLE</code> system privilege, then you can also insert rows into any table or the base table of any view.</p><p><strong>ELSE clause </strong></p><p>For a given row, if no <code>WHEN</code> clause evaluates to true, then:</p><p>• If you have specified an <code>ELSE</code> clause, then the database executes the <code>INTO</code> clause list associated with the <code>ELSE</code> clause.</p><p>• If you did not specify an else clause, then the database takes no action for that row.</p><p><strong>WHEN condition</strong></p><p>Oracle Database filters each <code>insert_into_clause</code> through the corresponding <code>WHEN</code> condition, which determines whether that <code>insert_into_clause</code> is executed. Each expression in the <code>WHEN</code> condition must refer to columns returned by the select list of the subquery. A single multitable insert statement can contain up to 127 <code>WHEN</code> clauses.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9014.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9014.htm</a></p><p><br></p><p>The Oracle INSERT ALL statement is used to add multiple rows with a single INSERT statement. The rows can be inserted into one table or multiple tables using only one SQL command.</p><p>The syntax for the INSERT ALL statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">INSERT ALL\n  INTO my_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO my_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO my_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\nSELECT * FROM dual;</pre><p><br></p><p>You can also use the INSERT ALL statement to insert multiple rows into more than one table in one command. The columns referenced in each table must be present in the table where the data is being inserted.</p><pre class=\"prettyprint linenums\">INSERT ALL\n  INTO my_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO my_other_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO my_yet_other_table (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\nSELECT * FROM dual;</pre><p><a href=\"https://www.techonthenet.com/oracle/questions/insert_rows.php\">https://www.techonthenet.com/oracle/questions/insert_rows.php</a></p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert-all/\">The Ultimate Guide to Oracle INSERT ALL Statement</a></p>",
                "answers": [
                    "<p>Each WHEN condition is tested for each row returned by the subquery.</p>",
                    "<p>The total number of rows inserted is always equal to the number of rows returned by the subquery.</p>",
                    "<p>A single WHEN condition can be used for multiple INTO clauses.</p>",
                    "<p>It cannot have an ELSE clause.</p>",
                    "<p>Each row returned by the subquery can be inserted into only a single target table.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two true statements about conditional.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943753,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the data in the PROJ_TASK_DETAILS table.</p><p><strong>Table: PROJ_TASK_DETAILS</strong></p><pre class=\"prettyprint linenums\">TASK_ID            BASED_ON        TASK_IN_CHARGE        TASK_START_DATE        TASK_END_DATE\nP01                                KING                  10-SEPT-19             12-SEPT-19\nP02                P01             KOCHAR                13-SEPT-19             14-SEPT-19\nP03                                GREEN                 14-SEPT-19             18-SEPT-19\nP04                P03             SCOTT                 19-SEPT-19             20-SEPT-19</pre><p><br></p><p><strong>Given: </strong></p><ul><li><p>The PROJ_TASK_DETAILS table stores information about project tasks and the relationship between them.</p></li><li><p>The BASED_ON column indicates dependencies between tasks.</p></li><li><p>Some tasks do not depend on the completion of other tasks.</p></li></ul><p><strong>Required:</strong> Generate a report listing all task IDs, the task ID of any task upon which it depends, and the name of the employee in charge of the task upon which it depends.</p><p><br></p><p>Identify the SQL query that would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query uses an inner join to match task IDs with their dependencies, but it does not account for tasks that do not have dependencies. It may not include all the required information in the report.",
                    "This query uses a full outer join, which includes all rows from both tables, regardless of whether there is a match. This may result in duplicate or unnecessary information in the report and does not specifically address the requirement to list only the task IDs and employee names for tasks with dependencies.",
                    "This query uses an inner join to match task IDs with their dependencies, but it does not consider tasks that do not have dependencies. It may not provide a complete report as it only includes tasks with dependencies.",
                    "This query uses a left outer join to match task IDs with their dependencies, ensuring that all tasks are included in the report, even if they do not have dependencies. It correctly lists the task IDs, the task ID of any task upon which it depends, and the name of the employee in charge of the task upon which it depends, meeting the required output criteria."
                ],
                "explanation": "<p>The correct SQL query to generate the required report is:</p><pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nLEFT OUTER JOIN proj_task_details d\nON (p.based_on = d.task_id);</pre><p><br></p><ol><li><p>The report needs <strong>all task IDs</strong>, their dependent tasks (if any), and the <strong>task_in_charge</strong> of the task they depend on.</p></li><li><p>The <code>BASED_ON</code> column in <code>p</code> (alias for <code>proj_task_details</code>) refers to another <code>TASK_ID</code> in the same table.</p></li><li><p>We need a <strong>self-join</strong>, where <code>p.based_on = d.task_id</code> links each task with its dependency.</p></li><li><p>Tasks <strong>without dependencies (NULL in BASED_ON)</strong> should still appear in the output. This requires a <strong>LEFT OUTER JOIN</strong> so that tasks with no dependencies are still listed, with <code>NULL</code> in the <code>task_in_charge</code> column.</p></li></ol><p>The records that are returned are as follows: </p><p> <code>task_id (P01, P02, P03, P04 ), based_on (NULL, P02, NULL, P03)</code></p><p><br></p><p><strong>Why Other Queries Are Incorrect:</strong></p><ul><li><pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nJOIN proj_task_details d\nON (p.task_id = d.task_id);</pre><ul><li><p>This is incorrect because it <strong>joins on </strong><code><strong>task_id = task_id</strong></code>, which does not establish the dependency relationship.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nFULL OUTER JOIN proj_task_details d\nON (p.based_on = d.task_id);</pre><ul><li><p>A <strong>FULL OUTER JOIN</strong> would include rows from both tables even when there is no match, which is unnecessary here.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nJOIN proj_task_details d\nON (p.based_on = d.task_id);</pre><ul><li><p>A <strong>regular INNER JOIN</strong> would exclude tasks with <code>NULL</code> in the <code>BASED_ON</code> column, which we want to include.</p></li></ul></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nJOIN proj_task_details d\nON (p.task_id = d.task_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nFULL OUTER JOIN proj_task_details d\nON (p.based_on = d.task_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nJOIN proj_task_details d\nON (p.based_on = d.task_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT p.task_id, p.based_on, d.task_in_charge\nFROM proj_task_details p \nLEFT OUTER JOIN proj_task_details d\nON (p.based_on = d.task_id);</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View the exhibit and examine the data in the PROJ_TASK_DETAILS table.Table: PROJ_TASK_DETAILSTASK_ID            BASED_ON        TASK_IN_CHARGE        TASK_START_DATE        TASK_END_DATE\nP01                                KING                  10-SEPT-19             12-SEPT-19\nP02                P01             KOCHAR                13-SEPT-19             14-SEPT-19\nP03                                GREEN                 14-SEPT-19             18-SEPT-19\nP04                P03             SCOTT                 19-SEPT-19             20-SEPT-19Given: The PROJ_TASK_DETAILS table stores information about project tasks and the relationship between them.The BASED_ON column indicates dependencies between tasks.Some tasks do not depend on the completion of other tasks.Required: Generate a report listing all task IDs, the task ID of any task upon which it depends, and the name of the employee in charge of the task upon which it depends.Identify the SQL query that would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943755,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify statements that are true about Data Manipulation Language (DML) statements. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL: Combining the AND and OR Conditions](http://www.techonthenet.com/sql/and_or.php)"
                ],
                "feedbacks": [
                    "An INSERT INTO...VALUES.. statement can add multiple rows per execution to a table. This is a valid statement as the INSERT INTO...VALUES.. syntax allows for the insertion of multiple rows in a single statement, making it efficient for adding multiple records at once.",
                    "An UPDATE... SET... statement can modify multiple rows based on multiple conditions on a table. This statement is correct as the UPDATE...SET... syntax allows for updating multiple rows in a table based on various conditions specified in the WHERE clause, providing flexibility in modifying data.",
                    "A DELETE FROM..... statement removes a row based on each condition on a table. This statement is incorrect as the DELETE FROM... syntax in SQL removes all rows that meet the specified condition, not just one row per condition.",
                    "An INSERT INTO... VALUES..... statement can add a single row based on multiple conditions on a table. This statement is incorrect because the INSERT INTO...VALUES... syntax is used to insert a single row into a table with specific values, not based on conditions.",
                    "A DELETE FROM..... statement can remove multiple rows based on multiple conditions on a table. This statement is correct as the DELETE FROM... syntax allows for the deletion of multiple rows in a table based on multiple conditions specified in the WHERE clause, enabling the removal of specific data.",
                    "An UPDATE....SET.... statement can only modify multiple rows based on a single condition on a table. This statement is incorrect because the UPDATE...SET... syntax in SQL allows for updating multiple rows in a table based on multiple conditions specified in the WHERE clause, not limited to just a single condition."
                ],
                "explanation": "<p><strong>Correct Options:</strong></p><ul><li><p><strong>An INSERT INTO...VALUES.. statement can add multiple rows per execution to a table.</strong></p></li></ul><p>Here's an example demonstrating how <code>INSERT INTO ... VALUES</code> can add multiple rows in one execution:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO students (id, name, age) VALUES (1, 'Alice', 20), (2, 'Bob', 21), (3, 'Charlie', 22);\n\n</pre><p>In this case:</p><ul><li><p>The <code>students</code> table is receiving three new records.</p></li><li><p>Each row contains values for the <code>id</code>, <code>name</code>, and <code>age</code> columns.</p></li></ul><p><br></p><ul><li><p><strong>An UPDATE... SET... statement can modify multiple rows based on multiple conditions on a table.</strong></p></li></ul><p>An <code>UPDATE ... SET ...</code> statement can modify multiple rows at once when conditions are applied using the <code>WHERE</code> clause. Here's an example:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE employees SET salary = salary * 1.1 WHERE department = 'Sales' AND years_experience &gt; 5;\n</pre><p>In this case:</p><ul><li><p>The <code>UPDATE</code> statement adjusts the <code>salary</code> column for employees in the <code>Sales</code> department who have more than 5 years of experience.</p></li><li><p>Multiple rows can be updated in one execution if they match the specified conditions.</p></li></ul><p>This makes updates more efficient, avoiding the need for separate statements per row.</p><p><br></p><ul><li><p><strong>A DELETE FROM..... statement can remove multiple rows based on multiple conditions on a table.</strong></p></li></ul><p>A <code>DELETE FROM ...</code> statement can remove multiple rows from a table based on multiple conditions. Here's an example:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM orders WHERE status = 'Cancelled' AND order_date &lt; '2024-01-01';\n</pre><p>In this case:</p><ul><li><p>The <code>DELETE</code> statement targets the <code>orders</code> table.</p></li><li><p>It removes all rows where the <code>status</code> is <code>'Cancelled'</code> and the <code>order_date</code> is before January 1, 2024.</p></li><li><p>If multiple records match these conditions, they will all be deleted in one execution.</p></li></ul><p>It's important to be careful with <code>DELETE</code> operations, as they <strong>permanently</strong> remove data unless a rollback mechanism like transactions is in place.</p><p><br></p><p><strong>Data Manipulation Language,</strong> which deals with data manipulation and includes the most common SQL statements such as SELECT, INSERT, UPDATE, DELETE, etc., and is used to store, modify, retrieve, delete, and update data in a database.</p><p><a href=\"https://www.w3schools.in/mysql/php-mysql-select/\">SELECT</a> - retrieve data from a database</p><p><a href=\"https://www.w3schools.in/mysql/php-mysql-insert/\">INSERT</a> - insert data into a table</p><p><a href=\"https://www.w3schools.in/mysql/php-mysql-update/\">UPDATE</a> - updates existing data within a table</p><p><a href=\"https://www.w3schools.in/mysql/php-mysql-delete/\">DELETE</a> - Delete all records from a database table</p><p>MERGE - UPSERT operation (insert or update)</p><p>CALL - call a PL/SQL or Java subprogram</p><p>EXPLAIN PLAN - interpretation of the data access path</p><p>LOCK TABLE - Concurrency Control</p><p><br></p><p><strong>Incorrect Options:</strong></p><ul><li><p><strong>A DELETE FROM..... statement removes a row based on each condition in a table.</strong></p></li></ul><p>A <code>DELETE FROM ...</code> statement removes rows that <strong>match all the specified conditions</strong> rather than removing a row for each condition separately.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM employees WHERE department = 'HR' AND salary &lt; 50000;\n</pre><p><br></p><p>This statement will delete <strong>only the rows</strong> where both conditions (<code>department = 'HR'</code> <strong>and</strong> <code>salary &lt; 50000</code>) are met. If multiple rows match these conditions, they will all be deleted at once.</p><p>If you want to delete rows that match <strong>either</strong> condition, you can use <code>OR</code> instead:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM employees WHERE department = 'HR' OR salary &lt; 50000;\n</pre><p><br></p><p>This would remove <strong>any row</strong> where either the department is <code>'HR'</code> <strong>or</strong> the salary is below 50,000.</p><p><br></p><p><br></p><ul><li><p><strong>An INSERT INTO... VALUES..... statement can add a single row based on multiple conditions on a table.</strong></p></li></ul><p>The <code>INSERT INTO ... VALUES ...</code> statement is used to add new rows to a table, but it does <strong>not</strong> use conditions in the same way that <code>UPDATE</code> or <code>DELETE</code> statements do.</p><p>An <code>INSERT</code> statement simply <strong>adds data</strong> to a table, without checking conditions. You must specify the values explicitly. For example:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO orders (id, customer_name, amount) VALUES (101, 'John Doe', 250.00);\n</pre><p>If you want to <strong>conditionally insert</strong> data based on certain criteria, you'd typically use an <code>INSERT ... SELECT</code> statement combined with a <code>WHERE</code> clause. Here's an example:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO orders (id, customer_name, amount) SELECT 102, 'Jane Smith', 300.00 FROM customers WHERE customer_id = 5;\n</pre><p>This approach allows insertion <strong>only if the condition (customer_id = 5) is met</strong>.</p><p><br></p><p><br></p><ul><li><p><strong>An UPDATE....SET.... statement can only modify multiple rows based on a single condition on a table.</strong></p></li></ul><p>An <code>UPDATE ... SET ...</code> statement can modify multiple rows based on <strong>one or more conditions</strong> in a table.</p><p>For example, if you have a condition like this:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE employees SET salary = salary * 1.1 WHERE department = 'Sales';\n</pre><p>This updates the <code>salary</code> for <strong>all</strong> employees in the <code>Sales</code> department—so multiple rows can be affected based on a single condition.</p><p>However, you can also use <strong>multiple conditions</strong>:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE employees SET salary = salary * 1.1 WHERE department = 'Sales' AND years_experience &gt; 5;\n</pre><p>This updates salaries <strong>only for employees in Sales who have more than 5 years of experience</strong>—modifying multiple rows based on more than one condition.</p><p>So the statement <strong>does not limit updates to a single condition</strong>—you can use multiple conditions to refine which rows get updated.</p>",
                "answers": [
                    "<p>An INSERT INTO...VALUES.. statement can add multiple rows per execution to a table.</p>",
                    "<p>An UPDATE... SET... statement can modify multiple rows based on multiple conditions on a table.</p>",
                    "<p>A DELETE FROM..... statement removes a row based on each condition on a table.</p>",
                    "<p>An INSERT INTO... VALUES..... statement can add a single row based on multiple conditions on a table.</p>",
                    "<p>A DELETE FROM..... statement can remove multiple rows based on multiple conditions on a table.</p>",
                    "<p>An UPDATE....SET.... statement can only modify multiple rows based on a single condition on a table.</p>"
                ]
            },
            "correct_response": [
                "b",
                "e",
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify statements that are true about Data Manipulation Language (DML) statements. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943757,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the MERGE statement. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[https://stackoverflow.com/questions/34774089/sql-server-merge-with-insert-subquery](https://stackoverflow.com/questions/34774089/sql-server-merge-with-insert-subquery)"
                ],
                "feedbacks": [
                    "The MERGE statement in Oracle Database SQL can indeed combine rows from multiple tables based on a specified condition and insert them into a single table. This feature allows for efficient data manipulation and consolidation.",
                    "The statement is not limited to merging rows only from tables. It can also work with subqueries, views, and other data sources to produce the source rows for the merge operation.",
                    "The MERGE statement can indeed use subqueries to generate the rows that need to be merged into the target table. This flexibility allows for dynamic and complex data manipulation scenarios.",
                    "The statement can update, insert, or delete rows conditionally in a single table, not multiple tables. It provides a powerful mechanism for performing multiple data manipulation operations in a single statement.",
                    "The MERGE statement does not update the same row of the target table multiple times. It ensures that each row is processed only once during the merge operation to maintain data integrity and consistency.",
                    "The MERGE statement can use views as a data source to produce the rows that need to be merged into the target table. This capability enhances the flexibility and usability of the MERGE statement in handling complex data scenarios."
                ],
                "explanation": "<p>The true statements about the MERGE statement are:</p><ol><li><p><strong>It can use subqueries to produce source rows.</strong></p></li><li><p><strong>It can use views to produce source rows.</strong></p></li><li><p><strong>It can combine rows from multiple tables conditionally to insert into a single table.</strong></p></li></ol><p>The MERGE statement in SQL allows for conditional insert, update, and delete operations based on the comparison between the target table and the source data, which can include subqueries and views.</p><p>Please note that it cannot update the same row of the target table multiple times, and it typically operates on a single target table.</p><p><br></p><p>Use the <code>MERGE</code> statement to select rows from one or more sources for update or insertion into a table or view. You can specify conditions to determine whether to update or insert into the target table or view.</p><p>You must have the <code>INSERT</code> and <code>UPDATE</code> object privileges on the target table and the <code>SELECT</code> object privilege on the source table. To specify the <code>DELETE</code> clause of the <code>merge_update_clause</code>, you must also have the <code>DELETE</code> object privilege on the target table</p><p>This statement is a convenient way to combine multiple operations. It lets you avoid multiple <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> DML statements.</p><p><code>MERGE</code> is a deterministic statement. You cannot update the same row of the target table multiple times in the same <code>MERGE</code> statement.</p><p><strong>USING Clause</strong></p><p>Use the <code>USING</code> clause to specify the source of the data to be updated or inserted. The source can be a table, view, or the result of a subquery.</p><p><strong>ON Clause</strong></p><p>Use the <code>ON</code> clause to specify the condition upon which the <code>MERGE</code> operation either updates or inserts. For each row in the target table for which the search condition is true, Oracle Database updates the row with corresponding data from the source table. If the condition is not true for any rows, then the database inserts into the target table based on the corresponding source table row.</p><p><strong>merge_insert_clause</strong></p><p>The <code>merge_insert_clause</code> specifies values to insert into the column of the target table if the condition of the <code>ON</code> clause is false. If the insert clause is executed, then all insert triggers defined on the target table are activated. If you omit the column list after the <code>INSERT</code> keyword, then the number of columns in the target table must match the number of values in the <code>VALUES</code> clause.</p><p><br></p><p><strong>Sample MERGE with INSERT subquery</strong></p><p><br></p><pre class=\"prettyprint linenums\"> MERGE ApplicationTeams AS Target\n    USING TempApplicationTeams AS Source\n    ON (Target.ServerId = (SELECT ID from Servers WHERE Name='Source.ServerName') AND Target.Team = Source.Team)\n    WHEN MATCHED THEN\n    UPDATE SET Target.Team = Target.Team\n    WHEN NOT MATCHED BY TARGET THEN\n    INSERT (ServerId, Team) VALUES((SELECT ID from Servers WHERE Name='Source.ServerName'), Source.Team)\n    WHEN NOT MATCHED BY SOURCE THEN\n    DELETE\n    ;</pre><p><br></p><p><strong>Using Views</strong></p><p>Use the <code>CREATE</code> <code>VIEW</code> statement to define a view, which is a logical table based on one or more tables or views. You can also create an object view or a relational view that supports LOBs, object types, <code>REF</code> datatypes, nested tables, or varray types on top of the existing view mechanism. An object view is a view of a user-defined type, where each row contains objects, each object with a unique updatable object identifier.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_8004.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_8004.htm</a></p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-merge/\">Diving Into <strong>Oracle</strong> <strong>MERGE</strong> <strong>Statement</strong></a></p>",
                "answers": [
                    "<p>It can combine rows from multiple tables conditionally to insert into a single table.</p>",
                    "<p>It can merge rows only from tables.</p>",
                    "<p>It can use subqueries to produce source rows.</p>",
                    "<p>It can update, insert, or delete rows conditionally in multiple tables.</p>",
                    "<p>It can update the same row of the target table multiple times.</p>",
                    "<p>It can use views to produce source rows.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "f"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements about the MERGE statement. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943759,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given:</strong> All fields and data referenced in the required statement are valid.</p><p><strong>Required:</strong> Select all fields from the contacts table whose last_name is 'Smith', contact_id is greater than or equal to 1000, and contact_id is less than or equal to 2000.</p><p>Indicate the SQL query that does not fulfill the requirement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>This query does not fulfil the requirement as it uses the OR operator instead of the AND operator between the conditions for contact_id. This would result in selecting all fields where the last_name is 'Smith' and either the contact_id is greater than or equal to 1000 or less than or equal to 2000, which is not the desired outcome.</p>",
                    "<p>This query correctly selects all fields from the contacts table where the last_name is 'Smith' and the contact_id is between 1000 and 2000, fulfilling the requirement.</p>",
                    "<p>This query fulfils the requirement by selecting all fields from the contacts table where the last_name is 'Smith' and the contact_id falls within the range of 1000 to 2000.</p>",
                    "<pre class=\"prettyprint linenums\">The following statement does NOT fulfil the requirement:\nSELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nOR contact_id &lt;= 2000;</pre>",
                    "<pre class=\"prettyprint linenums\">Only the following statement does NOT fulfil the requirement:\nSELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nOR contact_id &lt;= 2000;</pre>"
                ],
                "explanation": "<p>The question is asking which <strong>DOES NOT</strong> fulfil the requirement. The question is not asking which fulfills the requirement. </p><p>I know this is tricky, but you may run across a question like this on the exam to be sure you are reading the question.</p><p><br></p><p>The queries that are required are:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nAND contact_id &lt;= 2000;</pre><p><br></p><p>or</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id BETWEEN 1000 AND&nbsp; 2000;</pre><p><br></p><p>The <code>WHERE</code> and <code>AND</code> conditions dominate this query, and although there is a guarantee that the contact_id will be greater than or equal to 1000.</p><p>There is NO guarantee that it will be less than or equal to 2000 because of the <code>OR</code> clause.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nOR contact_id &lt;= 2000;</pre><p><br></p><p>The problem with this statement is the <code>OR</code>.</p><p>If the last_name = 'Smith' and the contact_id is &gt;= 1000, for example, 1001, then this would be a desired selection and it would fit both tests for contact_id.</p><p>However, if the contact_id were 999, for example, this would fail the <em>test one</em> of being &gt;= 1000, but it would pass the <em>test two</em> of &lt;=2000 and would be populated in the results. With an <code>OR</code>, the contact_id must meet <em>test one</em> <code>OR</code> <em>test two</em> to be included in the query results.</p><p>The <code>AND</code> test requires the contact_id to pass <em>test one</em> <code>AND</code> <em>test two</em> → be between 999 and 2001; or, as the requirement is stated, contact_id must be &gt;= 1000 <code>AND</code> &lt;= 2000.</p><p>...997, 998, 999, [desired contact ID list], 2001, 2001, 2003...</p><p><br></p><p><a href=\"https://www.techonthenet.com/oracle/and_or.php\">https://www.techonthenet.com/oracle/and_or.php</a></p><p><a href=\"https://www.techonthenet.com/oracle/where.php\">https://www.techonthenet.com/oracle/where.php</a></p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-between/\">https://www.oracletutorial.com/oracle-basics/oracle-between/</a></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nOR contact_id &lt;= 2000;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id &gt;= 1000\nAND contact_id &lt;= 2000;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM contacts\nWHERE last_name = 'Smith'\nAND contact_id BETWEEN 1000 AND&nbsp; 2000;</pre>",
                    "<p>All of the statements solve the requirement.</p>",
                    "<p>None of the statements solve the requirement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Given: All fields and data referenced in the required statement are valid.Required: Select all fields from the contacts table whose last_name is 'Smith', contact_id is greater than or equal to 1000, and contact_id is less than or equal to 2000.Indicate the SQL query that does not fulfill the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943761,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required:</strong>&nbsp; Create a table for a banking application with the following attributes.</p><ol><li><p>A column is to store the duration of a short-term loan.</p></li><li><p>The data should be stored in a format supporting DATE arithmetic with DATE datatypes without using conversion.</p></li><li><p>The maximum loan period is 30 days.</p></li><li><p>Interest must be calculated based on the number of days the loan is outstanding.</p></li></ol><p>Identify the data type that should be used.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>The INTERVAL DAY TO SECOND data type is specifically designed for storing durations or intervals in terms of days, hours, minutes, and seconds. It is suitable for representing the loan period in this scenario as it allows for direct arithmetic operations on date and time intervals without the need for conversion. Using INTERVAL DAY TO SECOND would enable accurate calculation of interest based on the number of days the loan is outstanding.</p>",
                    "<p>Using the DATE data type for storing the duration of a short term loan may not be the most appropriate choice as it is primarily used for storing dates and times, not for durations or intervals. DATE data type does not support direct arithmetic operations for calculating the interest based on the number of days the loan is outstanding.</p>",
                    "<p>The NUMBER data type is typically used for storing numeric values, such as integers or floating-point numbers, and is not suitable for storing durations or intervals like the loan period in this scenario. It does not provide built-in support for DATE arithmetic required for calculating interest based on the loan duration.</p>",
                    "<p>The TIMESTAMP data type is used for storing date and time values with fractional seconds precision, but it is not specifically designed for storing durations or intervals like the loan period in this scenario. While TIMESTAMP can support DATE arithmetic, it may not be the most efficient choice for handling the loan duration and interest calculations.</p>",
                    "<p>The INTERVAL YEAR TO MONTH data type is designed for storing durations or intervals in terms of years and months, which may not be the most precise choice for representing the loan period in terms of days. While INTERVAL YEAR TO MONTH can be used for some date calculations, it may not provide the necessary granularity for calculating interest based on the number of days the loan is outstanding in this scenario.</p>"
                ],
                "explanation": "<p>The <code>INTERVAL DAY TO SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds.</p><p>The following shows the syntax of the <code>INTERVAL DAY TO SECOND</code> data type:</p><p><code>1 INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]</code></p><p>In this syntax:<br>– <code>day_precision</code> is the number of digits in the <code>DAY</code> field. It ranges from 0 to 9. By default, its value is set to 2.<br>– <code>fractional_seconds_precision</code> is the number of digits in the fractional part of the <code>SECOND</code> field. It ranges from 0 through 9. If you omit the <code>fractional_seconds_precision</code>, it defaults to 6.</p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-interval/\">https://www.oracletutorial.com/oracle-basics/oracle-interval/</a></p><p><br></p><p><strong>Requirements checklist:</strong></p><p>✓ A column can be used to store the duration of a short-term loan.</p><p>✓ Supports DATE arithmetic with DATE datatypes without using conversion.</p><p>✓ Able to use for 30-day loan periods.</p><p>✓ Allows interest calculation based on the days the loan is outstanding.</p><p><br></p><p><strong>The other options do not meet the requirements.</strong></p>",
                "answers": [
                    "<p><code>INTERVAL DAY TO SECOND</code> </p>",
                    "<p><code>DATE</code> </p>",
                    "<p><code>NUMBER</code> </p>",
                    "<p><code>TIMESTAMP</code> </p>",
                    "<p><code>INTERVAL YEAR TO MONTH</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following scenario.Required:&nbsp; Create a table for a banking application with the following attributes.A column is to store the duration of a short-term loan.The data should be stored in a format supporting DATE arithmetic with DATE datatypes without using conversion.The maximum loan period is 30 days.Interest must be calculated based on the number of days the loan is outstanding.Identify the data type that should be used.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943763,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You have created a <code>customers</code> table in a database that is not case-sensitive. The table has the following columns:</p><ul><li><p><code>name</code></p></li><li><p><code>address</code></p></li><li><p><code>website</code></p></li><li><p><code>credit_limit</code>.</p></li></ul><p>The <code>customers</code> table has data in the following columns.</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/07/customers-table.png\"></p><p><br></p><p>Which of the following is the correct <code>SELECT</code> statement to list </p>",
                "relatedLectureIds": [],
                "links": [
                    "[Using SELECT ](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html)",
                    "[Oracle SELECT Statement](https://www.oracletutorial.com/oracle-basics/oracle-select/)"
                ],
                "feedbacks": [
                    "The SELECT * FROM customers; statement is correct as it retrieves all columns and rows from the customers table in the database. The asterisk (*) symbol is used to select all columns in a table.",
                    "The SELECT * FROM TABLE(customers); statement is incorrect. The correct syntax to select data from a table in SQL is SELECT * FROM table_name; without the TABLE keyword.",
                    "The SELECT * FROM 'customers'; statement is incorrect. Single quotes are used for string literals in SQL, not for table names. Therefore, this statement will result in a syntax error.",
                    "The SELECT * FROM \"customers\"; statement is incorrect. Double quotes are used to specify case-sensitive identifiers in SQL, but in this case, the table name \"customers\" is not case-sensitive. Therefore, using double quotes is unnecessary and may result in an error.",
                    "The SELECT * FROM \\'customers\\'; statement is incorrect. The backslash (\\) character is used as an escape character in SQL to represent special characters. In this case, the backslash before the single quote is unnecessary and may result in a syntax error."
                ],
                "explanation": "<p>The correct SQL <code>SELECT</code> statement to list all data from a table named <code>customers</code> is:</p><pre class=\"prettyprint linenums\">SELECT * FROM customers;</pre><p><br></p><p><strong>Incorrect Options Explained:</strong></p><ul><li><p><code>SELECT * FROM TABLE(customers);</code></p><ul><li><p>Incorrect in standard SQL syntax. <code>TABLE()</code> is used in some specific contexts (like Oracle PL/SQL) but is <strong>not required for basic SELECTs</strong>.</p></li></ul></li><li><p><code>SELECT * FROM 'customers';</code></p><ul><li><p>Incorrect. <strong>Single quotes</strong> are for <strong>string literals</strong>, not table names.</p></li></ul></li><li><p><code>SELECT * FROM \"customers\";</code></p><ul><li><p>Can work in some databases (e.g., PostgreSQL) <strong>if the table was created with case-sensitive or reserved keywords</strong> — but it's not standard or required unless quoting is needed.</p></li></ul></li><li><p><code>SELECT * FROM \\'customers\\';</code></p><ul><li><p>Invalid syntax. <strong>Escaped single quotes</strong> like this are not used to refer to table names in SQL.</p></li></ul></li></ul><p><br></p><p><strong>Oracle SELECT Statement</strong></p><p>Use a <code>SELECT</code> statement or subquery to retrieve data from one or more tables, object tables, views, object views, materialized views, analytic views, or hierarchies.</p><p>If part or all of the result of a <code>SELECT</code> statement is equivalent to an existing materialized view, then Oracle Database may use the materialized view in place of one or more tables specified in the <code>SELECT</code> statement.</p><p>For example, the <code>customers</code> table in the <a href=\"https://www.oracletutorial.com/getting-started/oracle-sample-database/\">sample database</a> has the following columns:</p><ul><li><p><code>customer_id</code></p></li><li><p><code>name</code></p></li><li><p><code>address</code></p></li><li><p><code>website</code></p></li><li><p><code>credit_limit</code>.</p></li></ul><p>The <code>customers</code> table has data in the following columns.</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/07/customers-table.png\"></p><p><br></p><p>You can use the shorthand asterisk (*) to instruct Oracle to return data from all columns of a table as follows:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * FROM customers;</pre><p><br></p><p>To retrieve data from one or more columns of a table, you use the <code>SELECT</code> statement with the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n  column_1, \n  column_2, \n  ...\nFROM\n  table_name;</pre><p><br></p><p>In this <code>SELECT</code> statement:</p><ul><li><p>First, specify the table name from which you want to query the data.</p></li><li><p>Second, indicate the columns from which you want to return the data. If you have more than one column, you need to separate each by a comma (,).</p></li></ul><p><strong>Note:</strong></p><p><em>The </em><code><em>SELECT</em></code><em> statement is very complex and consists of many clauses, such as </em><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code><em>ORDER BY</em></code></a><em>, </em><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\"><code><em>GROUP BY</em></code></a><em>, </em><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-having/\"><code><em>HAVING</em></code></a><em>, </em><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\"><code><em>JOIN</em></code></a><em>. To make it simple, in this tutorial, we are focusing on the </em><code><em>SELECT</em></code><em> and </em><code><em>FROM</em></code><em> clauses only.</em></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT * FROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT * FROM TABLE(customers);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT * FROM 'customers';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT * FROM \"customers\";</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT * FROM \\'customers\\';</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "You have created a customers table in a database that is not case-sensitive. The table has the following columns:nameaddresswebsitecredit_limit.The customers table has data in the following columns.Which of the following is the correct SELECT statement to list",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 129943765,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>You are working with the table <code>EMP</code> (alias e), which has the following columns:</p><ul><li><p><code>emp_no</code></p></li><li><p><code>mgr_no</code></p></li><li><p><code>department_id</code></p></li></ul><p><strong>Required: </strong>Find employees whose managers are in different departments.</p><p>Which of the following options can be used to meet the requirements using different join types in a <code>SELECT</code> statement?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[EXISTS Condition ](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/EXISTS-Condition.html)",
                    "[Oracle NOT EXISTS](https://www.oracletutorial.com/oracle-basics/oracle-not-exists/)",
                    "[Oracle FULL OUTER JOIN](https://www.oracletutorial.com/oracle-basics/oracle-full-outer-join/)"
                ],
                "feedbacks": [
                    "<p>This choice uses a WHERE clause to filter out the employees whose department_id is not equal to the manager's department_id. It is a valid way to find employees whose managers are in different departments.</p>",
                    "<p>A <code>FULL OUTER JOIN</code> is not appropriate here since it includes all rows regardless of a match. This is unnecessary for the given problem, and the condition <code>department_id &lt;&gt; department_id</code> does not logically fit with this join.</p>",
                    "<p>This choice tries to perform a RIGHT JOIN on the EMP table with itself based on the condition that the department_id of the employee is not equal to the manager's department_id. The syntax is incorrect as it joins the same table with itself, which is not needed for this query.</p>",
                    "<p>An <code>INNER JOIN</code> ensures that only rows meeting the condition (<code>e.department_id &lt;&gt; m.department_id</code>) are included. This is a valid solution.</p>",
                    "<p>This choice attempts to perform a LEFT JOIN on the EMP table with itself based on the condition that the department_id of the employee is not equal to the manager's department_id. However, the syntax is incorrect as it joins the same table with itself, which is not necessary for this query.</p>"
                ],
                "explanation": "<p>✅ <strong>Solution Using an INNER JOIN</strong></p><pre class=\"prettyprint linenums\">SELECT e.emp_no, e.mgr_no, e.department_id AS emp_department, \n       m.department_id AS mgr_department\nFROM EMP e\nINNER JOIN EMP m \n    ON e.mgr_no = m.emp_no  -- Self-join: Match employees to their managers\nWHERE e.department_id &lt;&gt; m.department_id; -- Employees whose managers are in different departments</pre><p><br></p><p><strong>1️⃣ LEFT JOIN (If Some Employees Have No Manager)</strong></p><p>If some employees <strong>don’t have a manager (</strong><code><strong>NULL mgr_no</strong></code><strong>)</strong>, use <code>LEFT JOIN</code>:</p><pre class=\"prettyprint linenums\">SELECT e.emp_no, e.mgr_no, e.department_id AS emp_department, \n       m.department_id AS mgr_department\nFROM EMP e\nLEFT JOIN EMP m \n    ON e.mgr_no = m.emp_no\nWHERE m.department_id IS NOT NULL -- Ensures a valid manager exists\nAND e.department_id &lt;&gt; m.department_id;\n</pre><p><br></p><p><strong>2️⃣ CROSS JOIN (Not Recommended for This Case)</strong></p><p>A <code>CROSS JOIN</code> would generate <strong>all possible employee-manager pairs</strong>, which is inefficient here.</p><p><br></p><p><br></p><p><strong>EXISTS Condition</strong></p><p>An <code>EXISTS</code> condition tests for the existence of rows in a subquery.</p><p><img src=\"https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img/exists_condition.gif\"></p><p>Example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT department_id\n  FROM departments d\n  WHERE EXISTS\n  (SELECT * FROM employees e\n    WHERE d.department_id \n    = e.department_id)\n   ORDER BY department_id;</pre><p><br></p><p><strong>Oracle NOT EXISTS</strong></p><p>The <code>NOT EXISTS</code> or <code>&lt;&gt;</code> operator works the opposite of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-exists/\"><code>EXISTS</code></a> operator. We often use the <code>NOT EXISTS</code> operator with a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\">subquery</a> to subtract one set of data from another.</p><p>Consider the following statement that uses the <code>NOT EXISTS</code> operator:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    *\nFROM\n    table_name\nWHERE\n    NOT EXISTS (subquery);</pre><p><br></p><p>The <code>NOT EXISTS</code> operator returns true if the subquery returns no rows. Otherwise, it returns false.</p><p>Note that the <code>NOT EXISTS</code> operator returns false if the subquery returns any rows with a NULL value.</p><p><br></p><p><strong>Oracle NOT EXISTS examples</strong></p><p>See the following <code>customers</code> and <code>orders</code> tables in the <a href=\"https://www.oracletutorial.com/getting-started/oracle-sample-database/\">sample database</a>:</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/08/customers_orders_tables.png\"></p><p><br></p><p>The following statement finds all customers who have no orders:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    name\nFROM\n    customers\nWHERE\n    NOT EXISTS (\n        SELECT\n            NULL\n        FROM\n            orders\n        WHERE\n            orders.customer_id = customers.customer_id\n    )\nORDER BY\n    name;</pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/10/Oracle-NOT-EXISTS-example.png\"></p><p><br></p><p><strong>Oracle FULL OUTER JOIN</strong></p><p>Suppose you have two tables, T1 and T2. The following illustrates the full outer join of the two tables:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    select_list\nFROM\n    T1\nFULL OUTER JOIN T2 ON join_condition;</pre><p><br></p><p>For each row in the T1 table, the full outer join compares it with every row in the T2 table.</p><p>If rows from both tables meet the <code>join_condition</code>, the full outer join includes columns of both rows in the result set. We say that the row in the T1 table matches the row in the T2 table in this case.</p><p>If a row from the T1 table does not have any matching row from the T2 table, the full outer join will include columns from the T1 table with null values for all columns from the T2 table.</p><p>Similarly, if a row in the T2 table does not have a matching row in the T1 table, the full outer join will include columns from the T2 table with null values for the columns in the T1 table.</p><p>Note that the <code>OUTER</code> keyword is optional; therefore, the <code>FULL OUTER JOIN</code> and <code>FULL JOIN</code> are the same.</p><p>This Venn diagram illustrates the full outer join of two tables:</p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2019/02/Oracle-Joins-Full-Outer-Join.png\"></p><p><strong>Oracle FULL OUTER JOIN examples</strong></p><p>First, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-create-table/\">create two tables</a> <code>members</code> and <code>projects</code>. Suppose each member can join zero or one project, and each project can have zero or more members:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE projects(\n    project_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n    project_name VARCHAR2(100) NOT NULL\n);\n\nCREATE TABLE members(\n    member_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n    member_name VARCHAR2(100) NOT NULL,\n    project_id INT,\n    FOREIGN KEY (project_id) REFERENCES projects(project_id)\n);</pre><p><br></p><p>Second, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\">insert</a> some projects and members into the <code>projects</code> and <code>members</code> tables:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO projects(project_name) \nVALUES('ERP');\n\nINSERT INTO projects(project_name) \nVALUES('Sales CRM');\n\nINSERT INTO members(member_name, project_id)\nVALUES('John Doe',1);\n\nINSERT INTO members(member_name, project_id)\nVALUES ('Jane Doe',1);\n\nINSERT INTO members(member_name, project_id)\nVALUES ('Jack Daniel',null);</pre><p><br></p><p>Third, use the full outer join to query data from <code>members</code> and <code>projects</code> tables:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT \n    member_name, \n    project_name\nFROM \n    members m\nFULL OUTER JOIN projects p ON p.project_id = m.project_id\nORDER BY \n    member_name;    </pre><p><br></p><p>Here is the output:</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2019/06/oracle-full-outer-join-example.png\"></p><p><br></p><p>Jack Daniel does not join any project; Jane Doe and John Doe join the ERP project, and the Sales CRM project has no members.</p><p>To find the project that does not have any members, you use the following query:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT \n    project_name,\n    member_name\nFROM \n    members m\n    FULL OUTER JOIN projects p \n        ON p.project_id = m.project_id\nWHERE \n    member_name IS NULL\nORDER BY \n    member_name;    </pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2019/06/oracle-full-outer-join-with-where-clause.png\"></p><p><br></p><p>Similarly, you can find members who do not participate in any project by using the following query:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT \n    member_name, \n    project_name\nFROM \n    members m\n    FULL OUTER JOIN projects p \n        ON p.project_id = m.project_id\nWHERE \n    project_name IS NULL\nORDER BY \n    member_name;    </pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2019/06/oracle-full-outer-join-with-where-clause-example-2.png\"></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE e.department_id &lt;&gt; m.department_id </pre>",
                    "<pre class=\"prettyprint linenums\">e FULL OUTER JOIN e ON e.department_id &lt;&gt; m.department_id </pre>",
                    "<pre class=\"prettyprint linenums\">e RIGHT JOIN e ON e.department_id &lt;&gt; m.department_id </pre>",
                    "<pre class=\"prettyprint linenums\">INNER JOIN EMP m ON e.mgr_no = m.emp_no</pre>",
                    "<pre class=\"prettyprint linenums\">e LEFT JOIN e ON e.department_id &lt;&gt; m.department_id</pre>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "You are working with the table EMP (alias e), which has the following columns:emp_nomgr_nodepartment_idRequired: Find employees whose managers are in different departments.Which of the following options can be used to meet the requirements using different join types in a SELECT statement?",
            "related_lectures": []
        }
    ]
}