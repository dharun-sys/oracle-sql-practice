{
    "count": 40,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 130068229,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two statements that are true regarding SAVEPOINTS (Choose two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Transaction Management](https://docs.oracle.com/cd/B19306_01/server.102/b14220/transact.htm)"
                ],
                "feedbacks": [
                    "SAVEPOINTS can indeed be used to rollback transactions to a specific point in time, allowing for partial rollbacks within a larger transaction.",
                    "SAVEPOINTS can be used for Data Manipulation Language (DML) statements such as INSERT, UPDATE, and DELETE to create points within a transaction that can be rolled back to if needed.",
                    "SAVEPOINTS are not effective only for COMMIT. They are used to mark points within a transaction that can be rolled back to, regardless of whether a COMMIT has been issued.",
                    "SAVEPOINTS are effective for both COMMIT and ROLLBACK operations. They allow for greater control over transactions by providing intermediate points to which the transaction can be rolled back.",
                    "SAVEPOINTS can be used for both Data Manipulation Language (DML) and Data Definition Language (DDL) statements. They provide flexibility in managing transactions involving both types of statements."
                ],
                "explanation": "<ol><li><p><strong>SAVEPOINTS may be used to ROLLBACK.</strong><br><strong>True</strong> – A <strong>SAVEPOINT</strong> marks a point in a transaction to which you can later <strong>ROLLBACK</strong> without affecting the entire transaction.</p></li><li><p><strong>SAVEPOINTS can be used for only DML statements.</strong><br><strong>True</strong> – SAVEPOINTS apply to <strong>DML (Data Manipulation Language)</strong> operations like <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.<br>They <strong>do not</strong> apply to <strong>DDL (Data Definition Language)</strong> operations, such as <code>CREATE</code>, <code>ALTER</code>, or <code>DROP</code>, because DDL commands perform an <strong>implicit COMMIT</strong>.</p></li><li><p><strong>SAVEPOINTS are effective only for COMMIT.</strong><br><strong>False</strong> – SAVEPOINTS are mainly useful for <strong>ROLLBACK</strong>, not COMMIT. COMMIT ends a transaction and invalidates all savepoints.</p></li><li><p><strong>SAVEPOINTS are effective for both COMMIT and ROLLBACK.</strong><br><strong>False</strong> – Savepoints are <strong>not effective for COMMIT</strong>. Once a COMMIT is issued, all savepoints are released and cannot be used anymore.</p></li><li><p><strong>SAVEPOINTS can be used for both DML and DDL statements.</strong><br><strong>False</strong> – As mentioned above, SAVEPOINTS do <strong>not apply</strong> to DDL because DDL causes an automatic COMMIT.</p></li><li><p><br></p></li></ol><p><br></p><p>The <code>SAVEPOINT</code> statement names and marks the current point in the processing of a transaction. With the <code>ROLLBACK</code> <code>TO</code> statement, savepoints undo parts of a transaction instead of the whole transaction.</p><p>A simple rollback or commit erases all savepoints. When you roll back to a save point, any save points marked after that save point are erased. The savepoint to which you roll back remains.</p><p>You can reuse savepoint names within a transaction. The savepoint moves from its old position to the current point in the transaction.</p><p>If you mark a savepoint within a recursive subprogram, new instances of the <code>SAVEPOINT</code> statement are executed at each level in the recursive descent. You can only roll back to the most recently marked save point.</p><p>An implicit savepoint is marked before executing an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/savepoint_statement.htm\">https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/savepoint_statement.htm</a></p><p><br></p><p><strong>COMMITT</strong></p><p>In a <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-0680EB2C-ADF4-431A-A259-FB2227E5AA93\">commit</a>, a user explicitly or implicitly requested that the changes in the transaction be made permanent.</p><p>Use the <code>COMMIT</code> statement to end your current transaction and make permanent all changes performed in the transaction. A transaction is a sequence of SQL statements that Oracle Database treats as a single unit. <strong>This statement also erases all savepoints in the transaction and releases transaction locks.</strong></p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_4010.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_4010.htm</a></p><p><br></p><p><strong>Data definition language (DDL) statements</strong> let you perform these tasks:</p><p>• Create, alter, and drop schema objects</p><p>• Grant and revoke privileges and roles</p><p>• Analyze information on a table, index, or cluster</p><p>• Establish auditing options</p><p>• Add comments to the data dictionary</p><p>Oracle Database implicitly commits the current transaction before and after every DDL statement.</p><p>The DDL statements are:</p><p><code>ALTER</code>&nbsp; |&nbsp; <code>ANALYZE</code>&nbsp; |&nbsp; <code>ASSOCIATE STATISTICS</code>&nbsp; |&nbsp; <code>AUDIT</code>&nbsp; |&nbsp; <code>COMMENT</code>&nbsp; |&nbsp; <code>CREATE</code>&nbsp; &nbsp;|&nbsp; <code>DISASSOCIATE STATISTICS</code>&nbsp; |&nbsp; <code>DROP</code>&nbsp; &nbsp;|&nbsp; <code>FLASHBACK</code>&nbsp; &nbsp;|&nbsp; <code>GRANT</code>&nbsp; |&nbsp; <code>NOAUDIT</code>&nbsp; |&nbsp; <code>PURGE</code>&nbsp; |&nbsp; <code>RENAME</code>&nbsp; |&nbsp; <code>REVOKE</code>&nbsp; | <code>TRUNCATE</code>&nbsp; |&nbsp; <code>UNDROP</code></p><p><br></p><p><strong>Data manipulation language (DML) statements</strong> access and manipulate data in existing schema objects. These statements do not implicitly commit the current transaction. The data manipulation language statements are:</p><p><code>CALL</code> |&nbsp; <code>DELETE</code>&nbsp; |&nbsp; <code>EXPLAIN PLAN</code>&nbsp; |&nbsp; <code>INSERT</code>&nbsp; &nbsp;|&nbsp; <code>LOCK TABLE</code>&nbsp; |&nbsp; <code>MERGE</code>&nbsp; |&nbsp; <code>SELECT</code> |&nbsp; <code>UPDATE</code></p><p><br></p><p><strong>Transaction control statements </strong>manage changes made by DML statements. The transaction control statements are:</p><p><code>COMMIT</code>&nbsp; |&nbsp; <code>ROLLBACK</code>&nbsp; |&nbsp; <code>SAVEPOINT</code>&nbsp; |&nbsp; <code>SET TRANSACTION</code></p><p><a href=\"https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm\">https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm</a></p><p><br></p><p>Rolling back means undoing any changes to data that have been performed by SQL statements within an <strong>uncommitted </strong>transaction. Oracle uses undo tablespaces (or rollback segments) to store old values. The redo log contains a record of changes.</p><p>Oracle lets you roll back an entire uncommitted transaction. Alternatively, you can roll back the trailing portion of an uncommitted transaction to a marker called a savepoint.</p><p>All types of rollbacks use the same procedures:</p><p>• Statement-level rollback (due to statement or deadlock execution error)</p><p>• Rollback to a savepoint</p><p>• Rollback of a transaction due to user request</p><p>• Rollback of a transaction due to abnormal process termination</p><p>• Rollback of all outstanding transactions when an instance terminates abnormally</p><p>• Rollback of incomplete transactions during recovery</p>",
                "answers": [
                    "<p>SAVEPOINTS may be used to ROLLBACK.</p>",
                    "<p>SAVEPOINTS can be used for only DML statements.</p>",
                    "<p>SAVEPOINTS are effective only for COMMIT.</p>",
                    "<p>SAVEPOINTS are effective for both COMMIT and ROLLBACK.</p>",
                    "<p>SAVEPOINTS can be used for both DML and DDL statements.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two statements that are true regarding SAVEPOINTS (Choose two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068231,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the MEMBERS table and the exhibit.</p><p><strong>Table: MEMBERS</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nMEMBER_ID        NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME        NOT NULL          VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(25)\nSTATE                              VARCHAR2(3)</pre><p><br></p><p>Examine the SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT city, last_name LNAME\nFROM members\nORDER BY 1,\nLNAME DESC;</pre><p><br></p><p>Identify the result of the query. (Choose the best answer)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice is incorrect because the query is ordering the cities in ascending order, not descending order as stated in this choice.",
                    "This choice is incorrect because column aliases can be used in the ORDER BY clause, so the query does not fail for that reason.",
                    "This choice is incorrect because a column number and a column alias can be used together in the ORDER BY clause, so the query does not fail for that reason.",
                    "This choice is correct because the query orders the cities in ascending order and the last names within each city in descending order, which matches the result described in this choice."
                ],
                "explanation": "<p>Let's break down the SQL statement:</p><pre class=\"prettyprint linenums\">SELECT city, last_name LNAME\nFROM members\nORDER BY 1, LNAME DESC;</pre><p><br></p><ul><li><p><code>ORDER BY 1</code>: This means the result is ordered <strong>by the first selected column</strong>, which is <code>city</code>, <strong>in ascending order by default</strong>.</p></li><li><p><code>LNAME DESC</code>: This is an alias for <code>last_name</code>, and the <code>ORDER BY</code> clause is validly using that alias to <strong>sort last names in descending order within each city</strong>.</p></li></ul><p><strong>Important Notes:</strong></p><ul><li><p>Column <strong>aliases <em>can</em> be used</strong> in the <code>ORDER BY</code> clause.</p></li><li><p>Mixing a column <strong>position (like 1)</strong> and a column <strong>alias (like LNAME)</strong> in <code>ORDER BY</code> is perfectly valid in SQL.</p></li></ul><p><strong>Incorrect Options:</strong></p><p>\"It displays all cities in descending order, within which the last names are further sorted in descending order.\"</p><ul><li><p><strong>Why it's wrong:</strong><br><code>ORDER BY 1</code> sorts <strong>by the first column (</strong><code><strong>city</strong></code><strong>) in ascending order by default</strong>, not descending.<br>You would need to explicitly say <code>ORDER BY 1 DESC, LNAME DESC</code> for this option to be true.</p></li></ul><p>\"It fails because a column alias cannot be used in the ORDER BY clause.\"</p><ul><li><p><strong>Why it's wrong:</strong><br>SQL <strong>does allow</strong> using column <strong>aliases</strong> (like <code>LNAME</code>) in the <code>ORDER BY</code> clause.<br>This is standard and valid syntax. So the query <strong>will not fail</strong> because of alias usage.</p></li></ul><p>\"It fails because a column number and a column alias cannot be used together in the ORDER BY clause.\"</p><ul><li><p><strong>Why it's wrong:</strong><br>SQL allows <strong>mixing column positions (e.g., </strong><code><strong>1</strong></code><strong>) and aliases (e.g., </strong><code><strong>LNAME</strong></code><strong>)</strong> in <code>ORDER BY</code>.<br>So this combination is valid and <strong>does not cause failure</strong>.</p></li></ul>",
                "answers": [
                    "<p>It displays all cities in descending order, within which the last names are further sorted in descending order.</p>",
                    "<p>It fails because a column alias cannot be used in the ORDER BY clause.</p>",
                    "<p>It fails because a column number and a column alias cannot be used together in the ORDER BY clause.</p>",
                    "<p>It displays all cities in ascending order, within which the last names are further sorted in descending order.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the MEMBERS table and the exhibit.Table: MEMBERSName             Null??            Type\nMEMBER_ID        NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME        NOT NULL          VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(25)\nSTATE                              VARCHAR2(3)Examine the SQL statement.Exhibit: 1SELECT city, last_name LNAME\nFROM members\nORDER BY 1,\nLNAME DESC;Identify the result of the query. (Choose the best answer)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068233,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE hire date&gt; '&amp;1';</pre><p><br></p><p><strong>Required:</strong>&nbsp; &nbsp;Prevent prompting for a hire date value when this query is executed</p><p>Identify the responses which would meet the requirement. (Select two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Using Substitution Variables](https://www.oreilly.com/library/view/oracle-sqlplus-the/1565925785/ch04s02.html)"
                ],
                "feedbacks": [
                    "Replacing '&amp;1' with '&amp;&amp;1' in the query will cause the substitution variable to be defined and not prompt for a value each time the query is executed. This will prevent the need for manual input of the hire date value.",
                    "Using the DEFINE command before executing the query allows for the substitution variable to be defined and prevents the query from prompting for a value. This ensures that the hire date value is provided without manual intervention.",
                    "Using the UNDEFINE command before executing the query will remove any previously defined substitution variables. However, this will not prevent the query from prompting for a hire date value when executed.",
                    "Executing the SET VERIFY ON command before running the query will enable the verification of substitution variables, but it will not prevent the query from prompting for a hire date value.",
                    "Storing the query in a script and passing the substitution value to the script when executing it allows for the hire date value to be provided as an argument. This method avoids the need for manual input and prevents the query from prompting for the value.",
                    "Executing the SET VERIFY OFF command before running the query will disable the verification of substitution variables, but it will not prevent the query from prompting for a hire date value."
                ],
                "explanation": "<p><strong>Use the DEFINE command before executing the query.</strong></p><p><strong>True</strong> – The <code>DEFINE</code> command can be used to assign a fixed value to a substitution variable in advance, so the system doesn't prompt the user.</p><p>Example:</p><pre class=\"prettyprint linenums\">sql\nDEFINE 1 = '01-JAN-2020'</pre><p>This way, when the query runs, <code>&amp;1</code> is automatically replaced by <code>'01-JAN-2020'</code>, and no prompt occurs.</p><p><br></p><p><strong>Store the query in a script and pass the substitution value to the script when executing it.</strong></p><p><strong>True</strong> – You can avoid prompting by <strong>passing values at runtime</strong> from the command line or script.</p><p>Example:</p><pre class=\"prettyprint linenums\">bash\n@your_script.sql '01-JAN-2020'</pre><p>Inside the script:</p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id, first_name, salary\nFROM employees\nWHERE hire_date &gt; '&amp;1';</pre><p>Since the value is passed as an argument, there is no need for a prompt.</p><p><br></p><p><strong>Incorrect Answers:</strong></p><p>\"Replace '&amp;1' with '&amp;&amp;1' in the query.\"</p><ul><li><p>This actually <strong>caches the value</strong> the <strong>first time</strong> it's entered, so future uses don't prompt again.</p></li><li><p>But the <strong>first execution still prompts</strong>, which violates the requirement.</p></li></ul><p>\"Use the UNDEFINE command before executing the query.\"</p><ul><li><p><code>UNDEFINE</code> <strong>removes the definition</strong> of a substitution variable.</p></li><li><p>If you use <code>UNDEFINE 1</code>, it guarantees that <strong>&amp;1 will prompt again</strong>, so this is <strong>not what you want</strong>.</p></li></ul><p>\"Execute the SET VERIFY ON command before executing the query.\"</p><ul><li><p><code>SET VERIFY ON</code> just <strong>shows</strong> the old and new lines after substitution. It <strong>does not affect prompting</strong>.</p></li></ul><p>\"Execute the SET VERIFY OFF command before executing the query.\"</p><ul><li><p><code>SET VERIFY OFF</code> <strong>hides</strong> the substitution echo. Again, this has <strong>nothing to do with disabling prompting</strong>.</p></li></ul><p><br></p><p>Setting the <code>DEFINE </code>command before executing the query on SQL Plus will still prompt for user input for '&amp;2'. It went straight to query execution (without user prompt) after running the query:</p><p><code>SELECT '&amp;2' FROM DUAL;</code><br><br><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-11_14-11-53-32a52d6dd683b2a7e1e259d5dc90dc59.png\"></p><p>SET VERIFY ON only displays the 'old' and 'new' rows but it will still prompt for user input on '&amp;[variable]'</p><p><strong>Set</strong> <strong>Verify</strong> is a SQL*Plus <strong>command</strong> - it has nothing to do with the database or SQL. The <strong>'Verify'</strong> <strong>command</strong> will only display the old and new if there is a substitution variable involved in the SQL statement.</p><p><a href=\"https://community.oracle.com/thread/332058\">https://community.oracle.com/thread/332058</a></p><p><br></p><p><strong>Using Substitution Variables</strong></p><p>Substitution variables allow you to write generic SQL*Plus scripts. They allow you to mark places in a script where you want to substitute values at runtime.</p><p>A <em>substitution variable</em> is the same thing as a user variable. It is possible to get the contents of a database column into a user variable and place the contents of that user variable. SQL*Plus also allows you to place user variables in your script to mark places where you want to supply a value at runtime. When you use them this way, they are called substitution variables.</p><p>A substitution variable is not like a true variable used in a programming language. Instead, a substitution variable marks places in the text where SQL*Plus does the equivalent of a search and replace at runtime, replacing the reference to a substitution variable with its value.</p><p>Substitution variables are set off in the text of a script by preceding them with either one or two ampersand characters.</p><p>The only difference between using a double ampersand rather than a single ampersand is that when a double ampersand is used, SQL*Plus will save the value (carries the value). All subsequent references to the same variable use that same value. It doesn’t even matter if subsequent references use a double ampersand or a single. Once the table_name variable has been defined this way, any other reference to &amp;table_name or &amp;&amp;table_name will be replaced with the defined value.</p>",
                "answers": [
                    "<p>Replace '&amp;1' with '&amp;&amp;1' in the query.</p>",
                    "<p>Use the DEFINE command before executing the query.</p>",
                    "<p>Use the UNDEFINE command before executing the query.</p>",
                    "<p>Execute the SET VERIFY ON command before executing the query.</p>",
                    "<p>Store the query in a script and pass the substitution value to the script when executing it.</p>",
                    "<p>Execute the SET VERIFY OFF command before executing the query.</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL query.Exhibit: 1SELECT employee_id, first_name, salary\nFROM employees\nWHERE hire date&gt; '&amp;1';Required:&nbsp; &nbsp;Prevent prompting for a hire date value when this query is executedIdentify the responses which would meet the requirement. (Select two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068235,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE rate_list (rate NUMBER(6,2));</pre><p><br></p><p>Identify the true statements about the result of the query. (Select two )</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query attempts to insert a negative value into a column that likely has a constraint set to only allow positive values. This would result in an error as the value does not meet the constraint criteria.",
                    "The query attempts to insert a decimal value with precision into a column that likely has a defined precision. The value will be rounded to fit the defined precision, which in this case is 87654.6.",
                    "The query attempts to insert a decimal value into a column that likely has a defined precision. The value will be rounded to fit the defined precision, which in this case is 0.55.",
                    "The query attempts to insert a negative value into a column that likely does not allow negative values. The negative sign will be removed, and the value will be inserted as 99.99.",
                    "The query attempts to insert a decimal value into a column that likely has a defined precision. The value will be rounded to fit the defined precision, which in this case is 1.0. This may result in an error if the precision is not set to allow three decimal places.",
                    "The query attempts to insert a negative decimal value into a column that likely has a defined precision. The value will be inserted as -.9 without any rounding or modification."
                ],
                "explanation": "<p>Let's break it down! The SQL statement is:</p><pre class=\"prettyprint linenums\">sql\nCREATE TABLE rate_list (rate NUMBER(6,2));</pre><p>This creates a table with one column <code>rate</code> of type <code><strong>NUMBER(6,2)</strong></code>, which means:</p><ul><li><p><strong>Total digits (precision)</strong>: Up to <strong>6 digits</strong> (including both sides of the decimal).</p></li><li><p><strong>Scale (digits after decimal)</strong>: Exactly <strong>2 digits</strong> can be stored after the decimal point.</p></li></ul><p><br></p><p><strong>Correct Statements:</strong></p><p>1. INSERT INTO rate_list VALUES (0.551) inserts the value as .55.</p><ul><li><p><strong>True</strong> – 0.551 rounds to <strong>0.55</strong> (since only 2 decimal places are allowed).</p></li><li><p>Fits well in <code>NUMBER(6,2)</code>. </p></li></ul><p>2. INSERT INTO rate_list VALUES (-.9) inserts the value as -.9.</p><ul><li><p><strong>True</strong> – <code>-.9</code> is stored as <code>-0.90</code>, and it fits well in <code>NUMBER(6,2)</code>.</p></li></ul><p><br></p><p><strong>Incorrect Statements:</strong></p><p>1. INSERT INTO rate_list VALUES (-10) produces an error.</p><ul><li><p><strong>False</strong> – <code>-10</code> fits easily in <code>NUMBER(6,2)</code> (it’s stored as <code>-10.00</code>). No error.</p></li></ul><p>2. INSERT INTO rate_list VALUES (87654.556) inserts the value as 87654.6.</p><ul><li><p><strong>True</strong> – 87654.556 rounds to <strong>87654.56</strong>, which is 7 digits (too big).</p></li><li><p>But <strong>87654.556</strong> rounds to <strong>87654.56</strong>, which has 7 total digits.</p></li><li><p><strong>Wait! That actually exceeds the 6-digit limit</strong>, so this <strong>actually throws an error</strong>.</p></li></ul><p><strong>CORRECTION</strong>: This is <strong>False</strong> – the rounded value (87654.56) has <strong>7 digits</strong>, which <strong>exceeds</strong> <code>NUMBER(6,2)</code> → it will <strong>fail</strong>.</p><p>3. INSERT INTO rate_list VALUES (-99.99) inserts the value as 99.99.</p><ul><li><p><strong>False</strong> – The value <code>-99.99</code> is inserted <strong>as-is</strong>. It <strong>does not</strong> become positive.</p></li></ul><p>4. INSERT INTO rate_list VALUES (0.999) produces an error.</p><ul><li><p><strong>False</strong> – 0.999 rounds to <strong>1.00</strong>, which is within range.</p></li><li><p>1.00 is just 3 digits → fits easily in <code>NUMBER(6,2)</code>.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-08_15-03-30-be882045a35890a7fde0e2f4e02a1670.png\"></p>",
                "answers": [
                    "<p>INSERT INTO rate_list VALUES (-10) produces an error.</p>",
                    "<p>INSERT INTO rate_list VALUES (87654.556) inserts the value as 87654.6.</p>",
                    "<p>INSERT INTO rate_list VALUES (0.551) inserts the value as .55.</p>",
                    "<p>INSERT INTO rate_list VALUES (-99.99) inserts the value as 99.99.</p>",
                    "<p>INSERT INTO rate_list VALUES (0.999) produces an error.</p>",
                    "<p>INSERT INTO rate_list VALUES (-.9) inserts the value as -.9.</p>"
                ]
            },
            "correct_response": [
                "c",
                "f"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL query.Exhibit: 1CREATE TABLE rate_list (rate NUMBER(6,2));Identify the true statements about the result of the query. (Select two )",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068237,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS and NEW_PRODUCTS tables.</p><p><strong>Table: PRODUCTS</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPROD_ID                            CHAR(2)\nPROD_NAME                          CHAR(4)\nEXP_DATE                           TIMESTAMP(6)</pre><p><br></p><p><strong>Table: NEW_PRODUCTS</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPROD_ID                            CHAR(4)\nPROD_NAME                          VARCHAR(10)\nEXP_DATE                           DATE</pre><p><br></p><p>Identify the queries which execute successfully? (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query successfully executes as it combines the columns prod_id and exp_date from the PRODUCTS table with the columns prod_id and NULL from the NEW_PRODUCTS table using the UNION ALL operator. The number of columns and their data types match in both tables.",
                    "This query successfully executes as it combines all columns from the PRODUCTS table with all columns from the NEW_PRODUCTS table using the UNION operator. The number of columns and their data types must match in both tables for the UNION operation to work.",
                    "This query successfully executes as it retrieves the columns prod_id and prod_name from the PRODUCTS table that intersect with the values '25' and prod_name from the NEW_PRODUCTS table using the INTERSECT operator. The number of columns and their data types must match in both tables for the INTERSECT operation to work.",
                    "This query will not execute successfully as the MINUS operator is not supported in Oracle SQL. The correct operator to use for set difference is the EXCEPT operator. Therefore, this query will result in a syntax error.",
                    "This query will not execute successfully as the number of columns in the SELECT statements do not match. The first SELECT statement only retrieves the prod_id column from the PRODUCTS table, while the second SELECT statement tries to retrieve both prod_id and prod_name columns from the NEW_PRODUCTS table. The number of columns and their data types must match in both SELECT statements for the UNION ALL operation to work."
                ],
                "explanation": "<p>Table Definitions Recap</p><ul><li><p><strong>PRODUCTS</strong></p><ul><li><p><strong>PROD_ID</strong>: CHAR(2)</p></li><li><p><strong>PROD_NAME</strong>: CHAR(4)</p></li><li><p><strong>EXP_DATE</strong>: TIMESTAMP(6)</p></li></ul></li><li><p><strong>NEW_PRODUCTS</strong></p><ul><li><p><strong>PROD_ID</strong>: CHAR(4)</p></li><li><p><strong>PROD_NAME</strong>: VARCHAR(10)</p></li><li><p><strong>EXP_DATE</strong>: DATE</p></li></ul></li></ul><p>For set operators (such as UNION, INTERSECT, MINUS) the two subqueries must have the same number of columns and the corresponding columns must be of compatible data types (or implicitly convertible).</p><p><br></p><p>Query-by-Query Analysis</p><ol><li><p><strong>Query 1:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT prod_id, exp_date\nFROM products\nUNION ALL\nSELECT prod_id, NULL FROM new_products;</pre><ul><li><p><strong>Column Count:</strong> Both subqueries return 2 columns.</p></li><li><p><strong>Column Types:</strong></p><ul><li><p><strong>Column 1:</strong> <code>prod_id</code> from <em>PRODUCTS</em> is CHAR(2) and from <em>NEW_PRODUCTS</em> is CHAR(4). These character types are compatible (the CHAR(2) value may be padded if needed).</p></li><li><p><strong>Column 2:</strong> In the first subquery, <code>exp_date</code> is TIMESTAMP(6); in the second, <code>NULL</code> is provided. In SQL, a NULL literal can adopt any type, so it can be seen as a TIMESTAMP(6) in this context.</p></li></ul></li><li><p><strong>Conclusion:</strong> This query is valid.</p></li></ul></li><li><p><strong>Query 2:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT *\nFROM products\nUNION\nSELECT * FROM new_products;</pre><ul><li><p><strong>Column Count:</strong> Both tables have 3 columns.</p></li><li><p><strong>Column Types:</strong></p><ul><li><p><strong>Column 1:</strong> PRODUCTS.PROD_ID is CHAR(2) versus NEW_PRODUCTS.PROD_ID which is CHAR(4). These are compatible via implicit conversion.</p></li><li><p><strong>Column 2:</strong> PRODUCTS.PROD_NAME is CHAR(4) versus NEW_PRODUCTS.PROD_NAME which is VARCHAR(10). These are compatible.</p></li><li><p><strong>Column 3:</strong> PRODUCTS.EXP_DATE is TIMESTAMP(6) versus NEW_PRODUCTS.EXP_DATE which is DATE. In many SQL systems (for example, Oracle), DATE values can be implicitly converted to TIMESTAMP values when needed.</p></li></ul></li><li><p><strong>Conclusion:</strong> This query should execute successfully.</p></li></ul></li><li><p><strong>Query 3:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT prod_id, prod_name\nFROM products\nINTERSECT\nSELECT '25', prod_name FROM new_products;</pre><ul><li><p><strong>Column Count:</strong> Both subqueries return 2 columns.</p></li><li><p><strong>Column Types:</strong></p><ul><li><p><strong>Column 1:</strong> In the first query, <code>prod_id</code> is CHAR(2). The literal <code>'25'</code> in the second query is a character literal that fits a CHAR(2) value.</p></li><li><p><strong>Column 2:</strong> <code>prod_name</code> from PRODUCTS is CHAR(4) and from NEW_PRODUCTS is VARCHAR(10). These types are compatible.</p></li></ul></li><li><p><strong>Conclusion:</strong> This query is valid.</p></li></ul></li><li><p><strong>Query 4:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT * \nFROM products\nMINUS\nSELECT prod_id FROM new_products;</pre><ul><li><p><strong>Column Count:</strong> The first query returns 3 columns, while the second returns only 1 column.</p></li><li><p><strong>Conclusion:</strong> This mismatch in the number of columns will cause the query to fail.</p></li></ul></li><li><p><strong>Query 5:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT prod_id\nFROM products\nUNION ALL\nSELECT prod_id, prod_name FROM new_products;</pre><ul><li><p><strong>Column Count:</strong> The first query returns 1 column; the second returns 2 columns.</p></li><li><p><strong>Conclusion:</strong> This query will also fail because the number of columns does not match.</p></li></ul></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, exp_date\nFROM products\nUNION ALL\nSELECT prod_id, NULL FROM new_products;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM products\nUNION\nSELECT * FROM new_products;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, prod_name\nFROM products\nINTERSECT\nSELECT '25', prod_name FROM new_products;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT * \nFROM products\nMINUS\nSELECT prod_id FROM new_products;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id\nFROM products\nUNION ALL\nSELECT prod_id, prod_name FROM new_products;</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the PRODUCTS and NEW_PRODUCTS tables.Table: PRODUCTSName             Null??            Type\nPROD_ID                            CHAR(2)\nPROD_NAME                          CHAR(4)\nEXP_DATE                           TIMESTAMP(6)Table: NEW_PRODUCTSName             Null??            Type\nPROD_ID                            CHAR(4)\nPROD_NAME                          VARCHAR(10)\nEXP_DATE                           DATEIdentify the queries which execute successfully? (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068239,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query which has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE emp(\nemp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\nename VARCHAR2(15),\nsalary NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp(emp_no));\n\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;\n\nALTER TABLE emp\nENABLE TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;</pre><p><br></p><p>Indicate the status of the foreign key EMP_MGR_FK.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Modifying, Renaming, or Dropping Existing Integrity Constraints](https://docs.oracle.com/cd/B28359_01/server.111/b28310/general005.htm#ADMIN11546%20)"
                ],
                "feedbacks": [
                    "This choice is incorrect because the foreign key EMP_MGR_FK would not be automatically enabled by dropping and recreating the foreign key constraint. The constraint would remain disabled until explicitly enabled.",
                    "This choice is correct because the foreign key EMP_MGR_FK would remain disabled after execution and would have to be manually enabled using the ALTER TABLE command. The constraint will not be automatically enabled.",
                    "This choice is incorrect because the foreign key EMP_MGR_FK would not be automatically enabled and immediate. The constraint would remain disabled until explicitly enabled.",
                    "This choice is incorrect because the foreign key EMP_MGR_FK would not be automatically enabled and deferred. The constraint would remain disabled until explicitly enabled."
                ],
                "explanation": "<p><em>Correct Answer: It would remain disabled and has to be enabled manually using the ALTER TABLE command.</em></p><p><strong>Step-by-Step Breakdown:</strong></p><p>1. <strong>Table Creation:</strong></p><pre class=\"prettyprint linenums\">sql\nCREATE TABLE emp(\n  emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\n  ename VARCHAR2(15),\n  salary NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp(emp_no)\n);</pre><ul><li><p>This creates a self-referencing table:</p><ul><li><p><code>emp_emp_no_pk</code>: Primary Key on <code>emp_no</code></p></li><li><p><code>emp_mgr_fk</code>: Foreign Key referencing the same table's <code>emp_no</code></p></li></ul></li></ul><p>2. <strong>Disable the Primary Key with CASCADE:</strong></p><pre class=\"prettyprint linenums\">sql\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;</pre><ul><li><p>Disables the <strong>primary key</strong>, and with <code>CASCADE</code>, also <strong>automatically disables all dependent foreign keys</strong> — here, <code>emp_mgr_fk</code> is disabled too.</p></li></ul><p>3. <strong>Attempt to Re-enable the Primary Key:</strong></p><pre class=\"prettyprint linenums\">sql\nALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;</pre><ul><li><p>Corrects the syntax from your original: assumes proper syntax is used.</p></li><li><p>This <strong>only re-enables the primary key</strong>, <strong>not</strong> the foreign key.</p></li></ul><p>❗ Important Oracle Behavior:</p><ul><li><p>Disabling a foreign key via <code>CASCADE</code> <strong>does not automatically re-enable it</strong> when the primary key is re-enabled.</p></li><li><p>You <strong>must manually re-enable</strong> the foreign key using:</p><pre class=\"prettyprint linenums\">sql\nALTER TABLE emp ENABLE CONSTRAINT emp_mgr_fk;</pre></li></ul><p><br></p><p>The CASCADE option disables FK dependants. The PK is reactivated on line 11 but not the FK</p><p>You have to enable in other ALTER command. </p><p>To disable or drop a UNIQUE key or PRIMARY KEY constraint and all dependent FOREIGN KEY constraints in a single step, use the CASCADE option of the DISABLE or DROP clauses. For example, the following statement disables a PRIMARY KEY constraint and any FOREIGN KEY constraints that depend on it: </p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE emp \nDISABLE PRIMARY KEY CASCADE;</pre><p><br></p><p><strong>Modifying, Renaming, or Dropping Existing Integrity Constraints</strong></p><p>You can use the ALTER TABLE statement to enable, disable, modify, or drop a constraint. When the database is using a UNIQUE or PRIMARY KEY index to enforce a constraint, and constraints associated with that index are dropped or disabled, the index is dropped, unless you specify otherwise.</p><p>While enabled foreign keys reference a PRIMARY or UNIQUE key, you cannot disable or drop the PRIMARY or UNIQUE key constraint or the index.</p>",
                "answers": [
                    "<p>It would remain disabled and can be enabled only by dropping the foreign key constraint and recreating it.</p>",
                    "<p>It would remain disabled and has to be enabled manually using the ALTER TABLE command.</p>",
                    "<p>It would be automatically enabled and immediate.</p>",
                    "<p>It would be automatically enabled and deferred.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL query which has been executed.Exhibit: 1CREATE TABLE emp(\nemp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\nename VARCHAR2(15),\nsalary NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp(emp_no));\n\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;\n\nALTER TABLE emp\nENABLE TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;Indicate the status of the foreign key EMP_MGR_FK.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068241,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES table and the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-03-16-b64c1b208438cb11ff6aaaad443662e7.png\"></p><p><br></p><p>The following SQL query has been executed.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">SELECT first_name, department_id, salary\nFROM employees\nORDER BY department_id, first_name, salary desc;</pre><p><br></p><p>Indicate two statements which are true regarding the result. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query specifies ordering by SALARY in descending order, so the values in the SALARY column would indeed be returned in descending order for all employees having the same value in the DEPARTMENT_ID and FIRST_NAME columns.",
                    "The query specifies ordering by FIRST_NAME in ascending order, so the values in the FIRST_NAME column would be returned in ascending order for all employees having the same value in the DEPARTMENT_ID column.",
                    "The query does not specify ordering by DEPARTMENT_ID, so the values in the SALARY column would not necessarily be returned in descending order for all employees having the same value in the DEPARTMENT_ID column.",
                    "The query only specifies ordering by SALARY and FIRST_NAME, so the values in all columns would not be returned in descending order.",
                    "The query specifies ordering by FIRST_NAME in ascending order, so the values in the FIRST_NAME column would not be returned in descending order for all employees having the same value in the DEPARTMENT_ID column."
                ],
                "explanation": "<pre class=\"prettyprint linenums\">SELECT first_name, department_id, salary\nFROM employees\nORDER BY department_id, first_name, salary desc;</pre><p><br></p><p>This query <strong>sorts rows using three columns in the following order</strong>:</p><ol><li><p><code>department_id</code> → default order (ascending)</p></li><li><p><code>first_name</code> → default order (ascending)</p></li><li><p><code>salary</code> → explicitly specified as descending (<code>DESC</code>)</p></li></ol><p><strong>How ORDER BY works:</strong></p><ul><li><p>Sorting is <strong>hierarchical</strong>:</p><ul><li><p>First by <code>department_id</code> (ascending),</p></li><li><p>Then by <code>first_name</code> (ascending) <strong>within the same </strong><code><strong>department_id</strong></code>,</p></li><li><p>Then by <code>salary</code> (descending) <strong>within the same </strong><code><strong>department_id</strong></code><strong> and </strong><code><strong>first_name</strong></code>.</p></li></ul></li></ul><p><strong>Evaluating the Statements:</strong></p><ol><li><p>\"The values in the SALARY column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID and FIRST_NAME column.\"</p><ul><li><p><strong>True</strong> — this matches the sorting logic of the query. Within the same department and name, salary is sorted descending.</p></li></ul></li><li><p>\"The values in the FIRST_NAME column would be returned in ascending order for all employees having the same value in the DEPARTMENT_ID column.\"</p><ul><li><p><strong>True</strong> — after sorting by department_id, first_name is the next level, and it defaults to ascending.</p></li></ul></li><li><p>\"The values in the SALARY column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID column.\"</p><ul><li><p><strong>False</strong> — salary is not sorted descending unless <code>first_name</code> is also the same.</p></li></ul></li><li><p>\"The values in all columns would be returned in descending order.\"</p><ul><li><p><strong>False</strong> — only <code>salary</code> is explicitly sorted in descending order.</p></li></ul></li><li><p>\"The values in the FIRST_NAME column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID column.\"</p><ul><li><p><strong>False</strong> — <code>first_name</code> is sorted in <strong>ascending</strong> order by default.</p></li></ul></li></ol>",
                "answers": [
                    "<p>The values in the SALARY column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID and FIRST_NAME column.</p>",
                    "<p>The values in the FIRST_NAME column would be returned in ascending order for all employees having the same value in the DEPARTMENT_ID column.</p>",
                    "<p>The values in the SALARY column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID column.</p>",
                    "<p>The values in all columns would be returned in descending order.</p>",
                    "<p>The values in the FIRST_NAME column would be returned in descending order for all employees having the same value in the DEPARTMENT_ID column.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the EMPLOYEES table and the exhibit.The following SQL query has been executed.Exhibit: 1 SELECT first_name, department_id, salary\nFROM employees\nORDER BY department_id, first_name, salary desc;Indicate two statements which are true regarding the result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068243,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate two true statements regarding the UNION and UNION ALL operators. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The output of the UNION ALL operator does not sort the result set. It simply combines the results of two or more SELECT statements into a single result set without any sorting.",
                    "While it is recommended to have the same column names in each SELECT statement when using the UNION or UNION ALL operator for clarity, it is not a strict requirement. The column names do not have to be identical for the UNION or UNION ALL to work.",
                    "The number of columns selected in each SELECT statement must be the same when using the UNION or UNION ALL operator. This ensures that the result sets can be combined properly without any issues.",
                    "Duplicates are not automatically eliminated by the UNION ALL operator. It includes all rows from all SELECT statements, even if there are duplicates present in the result set.",
                    "NULL values are not ignored during duplicate checking when using the UNION ALL operator. If there are NULL values in the result sets being combined, they will be included in the final result set without any elimination."
                ],
                "explanation": "<p><em>Correct Answers:</em></p><ul><li><p><em>The number of columns selected in each SELECT statement must be identical</em></p></li><li><p><em>NULLs are not ignored during duplicate checking</em></p></li></ul><p><strong>Background:</strong></p><ul><li><p><code><strong>UNION</strong></code>: Combines results from two queries and <strong>removes duplicates</strong>.</p></li><li><p><code><strong>UNION ALL</strong></code>: Combines results from two queries <strong>without removing duplicates</strong> (i.e., includes all rows).</p></li><li><p>Both require:</p><ul><li><p>Same <strong>number of columns</strong></p></li><li><p><strong>Compatible data types</strong> for corresponding columns (not necessarily same names)</p></li></ul></li></ul><p><strong>Statement Evaluation:</strong></p><ol><li><p>\"The output is sorted by the UNION ALL operator\"</p><ul><li><p><strong>False</strong> — <code>UNION ALL</code> <strong>does not automatically sort</strong> the output. If you want sorting, you need to use an explicit <code>ORDER BY</code> at the end.</p></li></ul></li><li><p>\"The names of columns selected in each SELECT statement must be identical\"</p><ul><li><p><strong>False</strong> — Only the <strong>number</strong> and <strong>data types</strong> of the columns must match. The <strong>names</strong> do <strong>not</strong> have to be identical.</p></li></ul></li><li><p>\"The number of columns selected in each SELECT statement must be identical\"</p><ul><li><p><strong>True</strong> — This is a requirement for both <code>UNION</code> and <code>UNION ALL</code>.</p></li></ul></li><li><p>\"Duplicates are eliminated automatically by the UNION ALL operator\"</p><ul><li><p><strong>False</strong> — <code>UNION ALL</code> <strong>includes duplicates</strong>; only <code>UNION</code> removes them.</p></li></ul></li><li><p>\"NULLs are not ignored during duplicate checking\"</p><ul><li><p><strong>True</strong> — <code>UNION</code> considers <strong>rows with NULLs as duplicates</strong> if all columns match (including NULLs in the same positions). So <strong>NULLs are included</strong> in duplicate checks.</p></li></ul></li></ol><p><br></p><p>The Oracle <code>UNION ALL</code> operator is used to combine the result sets of 2 or more <code>SELECT</code> statements. It returns all rows from the query and it does not remove duplicate rows between the various <code>SELECT</code> statements.</p><p><a href=\"https://www.techonthenet.com/oracle/union_all.php\">https://www.techonthenet.com/oracle/union_all.php</a></p><p><br></p><p>The Oracle <code>UNION </code>operator is used to combine the result sets of 2 or more<a href=\"https://www.techonthenet.com/oracle/select.php\"> Oracle SELECT statements</a>. It removes duplicate rows between the various <code>SELECT</code> statements.</p><p>Each <code>SELECT</code> statement within the <code>UNION</code> and <code>UNION ALL</code> operator <strong>must have the same number of fields</strong> in the result sets with similar data types.</p><p><a href=\"https://www.techonthenet.com/oracle/union.php\">https://www.techonthenet.com/oracle/union.php</a></p><p><br></p><p><code>UNION</code> removes duplicate records (where all columns in the results are the same), <code>UNION ALL</code> does not.</p><p><a href=\"https://stackoverflow.com/questions/49925/what-is-the-difference-between-union-and-union-all\">https://stackoverflow.com/questions/49925/what-is-the-difference-between-union-and-union-all</a></p><p><br></p><p><code>NULL</code> values are not ignored during duplicate checking.</p><p><a href=\"https://stackoverflow.com/questions/31958304/union-to-handle-null-values\">https://stackoverflow.com/questions/31958304/union-to-handle-null-values</a></p><p><br></p><p>If you need to ignor the <code>NULL</code>&nbsp;values, then <code>COALESCE</code> returns the first non-null <code>expr</code> in the expression list. You must specify at least two expressions. However, if all occurrences of <code>expr</code> evaluate to null, then the function returns null.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/functions023.htm#SQLRF00617/ms190349.aspx\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/functions023.htm#SQLRF00617/ms190349.aspx</a></p>",
                "answers": [
                    "<p>The output is sorted by the UNION ALL operator</p>",
                    "<p>The names of columns selected in each SELECT statement must be identical</p>",
                    "<p>The number of columns selected in each SELECT statement must be identical</p>",
                    "<p>Duplicates are eliminated automatically by the UNION ALL operator</p>",
                    "<p>NULLS are not ignored during duplicate checking</p>"
                ]
            },
            "correct_response": [
                "c",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Indicate two true statements regarding the UNION and UNION ALL operators. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068245,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDER_ITEMS table and the exhibit.</p><p><strong>Required: </strong>Display the PRODUCT_ID of the product that has the highest UNIT_PRICE per ORDER_ID.</p><p>The following SQL query has been executed.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">SELECT order_id, product_id, unit_price\nFROM order_items\nWHERE (unit_price, order_id) = \n(SELECT MAX(unit_price), order_id\nFROM order_items\nGROUP BY order_id);</pre><p><br></p><p>Indicate the correction which should be made in the above SQL statement to achieve this?</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Removing the GROUP BY clause from the subquery and placing it in the main query would result in the correct aggregation of data by ORDER_ID, allowing the query to correctly identify the PRODUCT_ID with the highest UNIT_PRICE per ORDER_ID.",
                    "Replacing the = operator with the &gt;ANY operator would not be appropriate in this context as it is used for comparisons with a single value, not for identifying the highest UNIT_PRICE per ORDER_ID.",
                    "Replacing the = operator with the &gt;ALL operator would not be suitable for this scenario as it is used to compare a value to all values in a list, not for finding the highest UNIT_PRICE per ORDER_ID.",
                    "Replacing the = operator with the IN operator would be the correct correction to make in this SQL statement to achieve the desired result of displaying the PRODUCT_ID of the product with the highest UNIT_PRICE per ORDER_ID. The IN operator allows for comparing a value to a list of values, which is necessary in this case to identify the highest UNIT_PRICE."
                ],
                "explanation": "<p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2022-09-23_11-34-45-f07b8e0cd55fc7c882f8abb5f154c97a.png\"><strong>Requirement:</strong></p><p><strong>Display the </strong><code><strong>PRODUCT_ID</strong></code><strong> of the product that has the highest </strong><code><strong>UNIT_PRICE</strong></code><strong> per </strong><code><strong>ORDER_ID</strong></code><strong>.</strong></p><p>This means <strong>for each </strong><code><strong>ORDER_ID</strong></code>, we want the <strong>product with the maximum </strong><code><strong>UNIT_PRICE</strong></code>.</p><p><strong>Given SQL Query (Exhibit 1):</strong></p><pre class=\"prettyprint linenums\">SELECT order_id, product_id, unit_price\nFROM order_items\nWHERE (unit_price, order_id) =\n  (SELECT MAX(unit_price), order_id\n   FROM order_items\n   GROUP BY order_id);</pre><p><br></p><p><strong>What’s wrong with this query?</strong></p><ul><li><p>The <strong>subquery returns multiple rows</strong> — one <code>(MAX(unit_price), order_id)</code> pair <strong>per </strong><code><strong>ORDER_ID</strong></code>.</p></li><li><p>The <strong>main query uses </strong><code><strong>=</strong></code>, which <strong>only works with a subquery returning a single row</strong>.</p></li><li><p>Using <code>=</code> with a <strong>multi-row subquery</strong> causes an <strong>error</strong>.</p></li></ul><p><strong>Correct Fix:</strong></p><p>To compare a tuple against <strong>multiple values</strong>, use the <code><strong>IN</strong></code> operator instead of <code>=</code>:</p><pre class=\"prettyprint linenums\">SELECT order_id, product_id, unit_price\nFROM order_items\nWHERE (order_id, unit_price) IN\n  (SELECT order_id, MAX(unit_price)\n   FROM order_items\n   GROUP BY order_id);</pre><p>Note: You must <strong>match the column order</strong> in the <code>WHERE</code> clause and subquery.</p><p>Evaluate the options:</p><ol><li><p><strong>Remove the GROUP BY clause from the subquery and place it in the main query</strong></p><ul><li><p>Incorrect. You need the <code>GROUP BY</code> in the subquery to get <code>MAX(unit_price)</code> per <code>order_id</code>.</p></li></ul></li><li><p><strong>Replace = with the &gt;ANY operator</strong></p><ul><li><p>Incorrect. That would give you rows with <code>unit_price</code> greater than <strong>any</strong> max — not what’s asked.</p></li></ul></li><li><p><strong>Replace = with the &gt;ALL operator</strong></p><ul><li><p>Incorrect. That gives you rows greater than <strong>all</strong> max prices, also not what’s asked.</p></li></ul></li><li><p><strong>Replace = with the IN operator</strong></p><ul><li><p><strong>Correct.</strong> This allows comparison with <strong>multiple rows</strong>, which is what the subquery returns.</p></li></ul></li></ol><p>Note: When evaluating the tables, the Primary and Foreign Keys are colour coded and the table with the 3 prong connector is the upper level. There may be more than one Primary Key per table and the Foreign Key to a given table may be the linked to a lower level Foreign Key.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-02-28_17-34-43-d9545d247d2a8f99bcd6b3a06abe4505.png\"></p>",
                "answers": [
                    "<p>Remove the GROUP BY clause from the subquery and place it in the main query</p>",
                    "<p>Replace = with the &gt;ANY operator</p>",
                    "<p>Replace = with the &gt;ALL operator</p>",
                    "<p>Replace = with the IN operator</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the ORDER_ITEMS table and the exhibit.Required: Display the PRODUCT_ID of the product that has the highest UNIT_PRICE per ORDER_ID.The following SQL query has been executed.Exhibit: 1 SELECT order_id, product_id, unit_price\nFROM order_items\nWHERE (unit_price, order_id) = \n(SELECT MAX(unit_price), order_id\nFROM order_items\nGROUP BY order_id);Indicate the correction which should be made in the above SQL statement to achieve this?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068247,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES&nbsp; and JOB_HISTORY tables, as well as the exhibits.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-03-16-b64c1b208438cb11ff6aaaad443662e7.png\"></p><p><br></p><p><strong>Required:</strong> Select the employee IDs of all the employees who have held the job SA_MAN at any time during their employment. </p><p><br></p><p>The following SQL queries have been prepared.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id\nFROM employees\nWHERE job_id = 'SA_MAN'</pre><p><br></p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id\nFROM job_history\nWHERE job_id = 'SA_MAN'</pre><p><br></p><p>Indicate two correct SET operators that would cause the query to return the desired result. (Choose two) </p>",
                "relatedLectureIds": [],
                "links": [
                    "[Set Operators](https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators005.htm)",
                    "[The UNION [ALL], INTERSECT, MINUS Operators](https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries004.htm)"
                ],
                "feedbacks": [
                    "The UNION operator combines the result sets of two or more SELECT statements into a single result set. It removes duplicate rows from the result set, which is useful when combining the results of multiple queries to find the unique employee IDs who have held the job SA_MAN at any time during their employment.",
                    "The MINUS operator returns all distinct rows selected by the first query but not by the second query. It is not suitable for this scenario as it would only return the employee IDs who have held the job SA_MAN but have not held any other job, which is not the desired result.",
                    "The INTERSECT operator returns all distinct rows selected by both queries. It is not suitable for this scenario as it would only return the employee IDs who have held the job SA_MAN and another job simultaneously, which is not the desired result.",
                    "The UNION ALL operator combines the result sets of two or more SELECT statements into a single result set, including duplicate rows. It is suitable for this scenario as it would return all employee IDs who have held the job SA_MAN at any time during their employment, including duplicates if an employee has held the job multiple times."
                ],
                "explanation": "<p>To get the <strong>employee IDs of all employees who have held the job 'SA_MAN' at any time</strong>, we need to consider both:</p><ol><li><p>Employees who <strong>currently</strong> have the job 'SA_MAN' (from the <code>EMPLOYEES</code> table)</p></li><li><p>Employees who <strong>previously</strong> held the job 'SA_MAN' (from the <code>JOB_HISTORY</code> table)</p></li></ol><p>Let’s look at what the queries return:</p><ul><li><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id FROM employees WHERE job_id = 'SA_MAN'</pre><p>→ Current SA_MAN employees</p></li><li><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id FROM job_history WHERE job_id = 'SA_MAN'</pre><p>→ Former SA_MAN employees</p></li></ul><p>Goal: Get <strong>all</strong> employee IDs who have <strong>ever</strong> had the job SA_MAN — current or past.</p><p>To achieve this, we want to combine results from both queries, <strong>avoiding duplicates</strong>.</p><p><strong>Correct SET Operators:</strong></p><ol><li><p><code><strong>UNION</strong></code> — Combines results from both queries and removes duplicates.</p></li><li><p><code><strong>UNION ALL</strong></code> — Combines results <strong>with duplicates</strong>.</p></li></ol><p>Either could be correct depending on whether you want duplicates or not — but since <strong>employee ID</strong> is usually unique, both will give the same result here, <strong>assuming no duplicates</strong> in the individual tables. However, if an employee had SA_MAN in both current and history, then <code>UNION</code> will remove the duplicate, while <code>UNION ALL</code> will keep both.</p><p>Incorrect:</p><ul><li><p><code>INTERSECT</code> — Would return only those who are in <strong>both</strong> tables with SA_MAN, not all who have ever had the role.</p></li><li><p><code>MINUS</code> — Subtracts one result set from the other — not relevant here.</p></li></ul><p><strong>Set Operators</strong></p><p>Set operators combine the results of two component queries into a single result. Queries containing set operators are called compound queries.</p><p><code>UNION</code> - Displays all distinct rows selected by either query</p><p><code>UNION ALL</code> - Displays all rows selected by either query, including all duplicates</p><p><code>INTERSECT</code> - Displays all distinct rows selected by both queries</p><p><code>MINUS</code> - Displays all distinct rows selected by the first query but not the second</p><p><br></p><p><strong>The UNION [ALL], INTERSECT, MINUS Operators</strong></p><p>All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from left to right unless parentheses explicitly specify another order.</p>",
                "answers": [
                    "<p><code>UNION</code> </p>",
                    "<p><code>MINUS</code> </p>",
                    "<p><code>INTERSECT</code> </p>",
                    "<p><code>UNION ALL</code> </p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the EMPLOYEES&nbsp; and JOB_HISTORY tables, as well as the exhibits.Required: Select the employee IDs of all the employees who have held the job SA_MAN at any time during their employment. The following SQL queries have been prepared.Exhibit: 1SELECT employee_id\nFROM employees\nWHERE job_id = 'SA_MAN'Exhibit: 2SELECT employee_id\nFROM job_history\nWHERE job_id = 'SA_MAN'Indicate two correct SET operators that would cause the query to return the desired result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068249,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS and SALES tables as well as the exhibit.</p><p><strong>Table: PRODUCTS </strong></p><pre class=\"prettyprint linenums\">PRODUCT_ID           PRODUCT_NAME\n1                    INKJET C/8/HQ\n2                    CPU D300\n3                    HD 8GB /I\n4                    HD 12 GB /R</pre><p><strong>Table: SALES</strong></p><pre class=\"prettyprint linenums\">ORDER_ID           PRODUCT_ID        QTY         UNIT PRICE\n11                 1                 10          100\n22                 2                 15          120\n33                 3                 10          50\n44                 1                 5           20\n66                 2                 20          125</pre><p><br></p><p><strong>Required: </strong>Display PRODUCT_NAME and the number of times the product has been ordered.</p><p><br></p><p>The following SQL query has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT p.prod_name, i.item_cnt\nFROM (\n     SELECT prod_id, COUNT(*) item_cnt\n     FROM sales\n     GROUP BY prod_id)\nI RIGHT OUTER JOIN products p\nON i.prod_id - p.prod_id;</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement will execute successfully to produce the required output. The query uses an inline view to calculate the count of each product in the SALES table and then joins it with the PRODUCTS table to display the PRODUCT_NAME and the number of times the product has been ordered.",
                    "This statement is incorrect. Inline views and outer joins can be used together in a query, so there is no restriction that would prevent the execution of the given SQL statement.",
                    "This statement is incorrect. The ITEM_CNT alias can be displayed in the outer query as it is a valid column alias created in the inline view. There is no issue with displaying the calculated count in the final result.",
                    "This statement is incorrect. The GROUP BY clause can be used in an inline view to aggregate data before joining it with another table. There is no restriction on using the GROUP BY clause in an inline view in this scenario."
                ],
                "explanation": "<p><strong>Query Analysis</strong></p><pre class=\"prettyprint linenums\">SELECT p.prod_name, i.item_cnt\nFROM (\n     SELECT prod_id, COUNT(*) item_cnt\n     FROM sales\n     GROUP BY prod_id)\nI RIGHT OUTER JOIN products p\nON i.prod_id - p.prod_id;</pre><p><br></p><p><strong>What this query does:</strong></p><ul><li><p>The inline view (<code>i</code>) counts how many times each product ID appears in the <code>SALES</code> table — essentially, the number of <strong>orders</strong> per product.</p></li><li><p><code>RIGHT OUTER JOIN</code> ensures <strong>all products</strong> from the <code>PRODUCTS</code> table appear in the result — even if they have no sales.</p></li><li><p>The join condition <code>i.prod_id = p.prod_id</code> is valid.</p></li><li><p>Selecting <code>p.prod_name</code> and <code>i.item_cnt</code> is valid — <code>item_cnt</code> is a valid alias from the inline view.</p></li></ul><p><strong>Important Points</strong></p><ul><li><p><strong>Inline views with GROUP BY</strong>: Allowed.</p></li><li><p><strong>Outer joins with inline views</strong>: Allowed.</p></li><li><p><strong>Using aliases like </strong><code><strong>item_cnt</strong></code><strong> in the outer query</strong>: Allowed.</p></li></ul><p><strong>Final Result:</strong></p><p>This query <strong>will execute successfully</strong> and <strong>return the product name and number of times it was ordered</strong>, including any products with no orders (which will show <code>NULL</code> for <code>item_cnt</code>).</p>",
                "answers": [
                    "<p>The statement would execute successfully to produce the required output.</p>",
                    "<p>The statement would not execute because inline views and outer joins cannot be used together.</p>",
                    "<p>The statement would not execute because the ITEM_CNT alias cannot be displayed in the outer query.</p>",
                    "<p>The statement would not execute because the GROUP BY clause cannot be used in the inline.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the PRODUCTS and SALES tables as well as the exhibit.Table: PRODUCTS PRODUCT_ID           PRODUCT_NAME\n1                    INKJET C/8/HQ\n2                    CPU D300\n3                    HD 8GB /I\n4                    HD 12 GB /RTable: SALESORDER_ID           PRODUCT_ID        QTY         UNIT PRICE\n11                 1                 10          100\n22                 2                 15          120\n33                 3                 10          50\n44                 1                 5           20\n66                 2                 20          125Required: Display PRODUCT_NAME and the number of times the product has been ordered.The following SQL query has been executed.Exhibit: 1SELECT p.prod_name, i.item_cnt\nFROM (\n     SELECT prod_id, COUNT(*) item_cnt\n     FROM sales\n     GROUP BY prod_id)\nI RIGHT OUTER JOIN products p\nON i.prod_id - p.prod_id;Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068251,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the SQL statements that would display the value 1890.55 as $1,890.55. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL statement uses the TO_CHAR function with the format model '$99G999D00' to display the value 1890.55 as $1,890.55. The format model specifies the dollar sign, comma as the group separator, and period as the decimal separator.",
                    "This SQL statement uses the TO_CHAR function with the format model '$9,999V99' to format the value 1890.55. However, this format model does not correctly display the value as $1,890.55.",
                    "The SQL statement uses the TO_CHAR function with the format model '$0G000D00' to display the value 1890.55 as $1,890.55. The format model includes the dollar sign, comma as the group separator, and period as the decimal separator, correctly formatting the value.",
                    "This SQL statement uses the TO_CHAR function with the format model '$99,999D99' to format the value 1890.55. However, this format model does not correctly display the value as $1,890.55.",
                    "The SQL statement uses the TO_CHAR function with the format model '$99G999D99' to display the value 1890.55 as $1,890.55. The format model specifies the dollar sign, comma as the group separator, and period as the decimal separator, correctly formatting the value."
                ],
                "explanation": "<p>Let's break down each <code>TO_CHAR</code> format and see which ones will correctly display the number <code>1890.55</code> as <code><strong>$1,890.55</strong></code>.</p><p>Key Format Elements in Oracle <code>TO_CHAR</code>:</p><ul><li><p><code><strong>$</strong></code>: Currency symbol.</p></li><li><p><code><strong>9</strong></code>: A digit placeholder (suppresses leading zeros).</p></li><li><p><code><strong>0</strong></code>: A digit placeholder (shows leading zeros).</p></li><li><p><code><strong>G</strong></code>: Group separator (e.g., comma).</p></li><li><p><code><strong>D</strong></code>: Decimal separator (e.g., period).</p></li><li><p><code><strong>V</strong></code>: Multiplies the number by 10^n (used for decimal places, not suitable here).</p></li></ul><p>Evaluate Each Option:</p><p>1. <code>SELECT TO_CHAR(1890.55, '$99G999D00') FROM DUAL;</code></p><ul><li><p><code>$99G999D00</code> = $ _ _ , _ _ _ . 00 → Good for 4-digit numbers</p></li><li><p><strong>Result</strong>: <code>$1,890.55</code><br><strong>Correct</strong></p></li></ul><p>2. <code>SELECT TO_CHAR(1890.55, '$9,999V99') FROM DUAL;</code></p><ul><li><p><code>V99</code> multiplies by 100 (turns 1890.55 into 189055.00), displays decimal after scaling</p></li><li><p><strong>Result</strong>: Incorrect decimal placement<br><strong>Incorrect</strong></p></li></ul><p>3. <code>SELECT TO_CHAR(1890.55, '$0G000D00') FROM DUAL;</code></p><ul><li><p><code>$0G000D00</code> = forces leading 0s, uses group and decimal separators</p></li><li><p><strong>Result</strong>: <code>$1,890.55</code><br><strong>Correct</strong></p></li></ul><p>4. <code>SELECT TO_CHAR(1890.55, '$99,999D99') FROM DUAL;</code></p><ul><li><p>Oracle <strong>does not allow literal commas (</strong><code><strong>,</strong></code><strong>)</strong> directly in the format model for <code>TO_CHAR</code> <strong>with numbers</strong>.<br>Instead, it expects you to use:</p><ul><li><p><code><strong>G</strong></code> for <strong>group (thousands) separator</strong></p></li><li><p><code><strong>D</strong></code> for <strong>decimal separator</strong></p></li></ul><p>The character that actually appears (<code>,</code> or <code>.</code>) is then determined by <strong>NLS settings</strong>, but the model <strong>must use </strong><code><strong>G</strong></code><strong> and </strong><code><strong>D</strong></code>, not literal <code>,</code> or <code>.</code>.</p></li><li><p><strong>Result</strong>: ORA-01481: invalid number format model</p></li><li><p>The format model in <code>TO_CHAR</code> function is <strong>not valid</strong></p></li><li><p>To avoid <strong>ORA-01481</strong>, <strong>do not use literal commas or dots</strong> in the number format model. Always use <code>G</code> (group separator) and <code>D</code> (decimal separator) instead.<br><strong>Incorrect</strong></p></li></ul><p>5. <code>SELECT TO_CHAR(1890.55, '$99G999D99') FROM DUAL;</code></p><ul><li><p><code>G</code> for group separator, <code>D</code> for decimal, 2 digits after decimal</p></li><li><p><strong>Result</strong>: <code>$1,890.55</code><br><strong>Correct</strong></p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1890.55, '$99G999D00')\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1890.55, '$9,999V99')\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1890.55, '$0G000D00')\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1890.55, '$99,999D99')\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1890.55, '$99G999D99')\nFROM DUAL;</pre>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the SQL statements that would display the value 1890.55 as $1,890.55. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068253,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PROMOTIONS table.</p><p><strong>Table: PROMOTIONS </strong></p><pre class=\"prettyprint linenums\">Name                           Null??            Type\nPROMO_ID                       NOT NULL          NUMBER(6)\nPROMO_NAME                     NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY              NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY_ID           NOT NULL          NUMBER\nPROMO_CATEGORY                 NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY_ID              NOT NULL          NUMBER\nPROMO_COST                     NOT NULL          NUMBER(10,2)\nPROMO_BEGIN_DATE               NOT NULL          DATE\nPROMO_END_DATE                 NOT NULL          DATE</pre><p><br></p><p><strong>Required:</strong> Generate a report that displays the promo name and start date for all promos that started after the last promo in the 'INTERNET' category.&nbsp; </p><p>Identify the SQL query that would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query selects promo_name and promo_begin_date from the PROMOTIONS table where the promo_begin_date is greater than all the promo_begin_dates that are the maximum in the PROMOTIONS table. It also filters the results based on the promo_category being 'INTERNET'. However, this query does not compare the start date of the last promo in the 'INTERNET' category.",
                    "This query selects promo_name and promo_begin_date from the PROMOTIONS table where the promo_begin_date is in the set of promo_begin_dates from the PROMOTIONS table with the promo_category 'INTERNET'. This query does not compare the start date of the last promo in the 'INTERNET' category.",
                    "This query selects promo_name and promo_begin_date from the PROMOTIONS table where the promo_begin_date is greater than all the promo_begin_dates from the PROMOTIONS table with the promo_category 'INTERNET'. This query correctly identifies and compares the start date of the last promo in the 'INTERNET' category.",
                    "This query selects promo_name and promo_begin_date from the PROMOTIONS table where the promo_begin_date is greater than any of the promo_begin_dates from the PROMOTIONS table with the promo_category 'INTERNET'. However, this query does not specifically compare the start date of the last promo in the 'INTERNET' category."
                ],
                "explanation": "<p><strong>Requirement: </strong>Generate a report that displays the <strong>promo name</strong> and <strong>start date</strong> for all <strong>promos that started after the <em>last promo</em> in the 'INTERNET' category</strong>.</p><p>So what do we need?</p><ul><li><p>Find the <strong>latest </strong><code><strong>promo_begin_date</strong></code> where <code>promo_category = 'INTERNET'</code></p></li><li><p>Return all rows where <code>promo_begin_date &gt; that date</code></p></li></ul><p>Best Approach: We want to compare <code>promo_begin_date</code> to the <strong>maximum date</strong> in the <code>'INTERNET'</code> category.</p><p>The ideal query looks like this:</p><pre class=\"prettyprint linenums\">sql\nSELECT promo_name, promo_begin_date\nFROM promotions\nWHERE promo_begin_date &gt; (\n    SELECT MAX(promo_begin_date)\n    FROM promotions\n    WHERE promo_category = 'INTERNET'\n);</pre><p><br></p><p>Now let’s evaluate each of the given choices.</p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date &gt; ALL (\n     SELECT MAX(promo_begin_date) \n     FROM promotions) \nAND promo_category = 'INTERNET';\nThis compares the promo_begin_date to the max of all promotions, not just 'INTERNET'.</pre><p><br></p><ul><li><p>Wrong comparison scope, and it also limits results to the 'INTERNET' category, which is the opposite of what we want. </p></li><li><p>Incorrect</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date IN (\n     SELECT promo_begin_date \n     FROM promotions \n     WHERE promo_category = 'INTERNET');</pre><ul><li><p>This returns promos that have the same start date as promos in the 'INTERNET' category.</p></li><li><p>It does not compare to the latest 'INTERNET' promo. </p></li><li><p>Incorrect</p><p><br></p></li></ul><pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date &gt; ALL (\n     SELECT promo_begin_date \n     FROM promotions \n     WHERE promo_category = 'INTERNET');</pre><ul><li><p>This compares to all start dates in the 'INTERNET' category.</p></li><li><p>&gt; ALL means greater than the largest of them, i.e., the latest 'INTERNET' start date.</p></li><li><p>This means we don’t need to use a separate MAX(promo_begin_date) function.</p></li><li><p>Correct</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-08_21-16-01-950420225be580a965f58147dbbbfe24.png\"></p><p><br></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date &gt; ANY (\n     SELECT promo_begin_date \n     FROM promotions \n     WHERE promo_category = 'INTERNET');</pre><ul><li><p>&gt; ANY means greater than the earliest promo in 'INTERNET'.</p></li><li><p>So it may include promos that started before the latest 'INTERNET' promo. </p></li><li><p>Incorrect</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date &gt; ALL (\n&nbsp; &nbsp; &nbsp;SELECT MAX (promo_begin_date) \n&nbsp; &nbsp; &nbsp;FROM promotions) \nAND promo_category= 'INTERNET';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date \nIN (\n&nbsp; &nbsp; &nbsp;SELECT promo_begin_date \n&nbsp; &nbsp; &nbsp;FROM promotions \n&nbsp; &nbsp; &nbsp;WHERE promo_category= 'INTERNET');</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date &gt; ALL (\n&nbsp; &nbsp; SELECT promo_begin_date \n&nbsp; &nbsp; FROM promotions \n&nbsp; &nbsp; WHERE promo_category = 'INTERNET');</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_begin_date \nFROM promotions \nWHERE promo_begin_date&gt; ANY (\n&nbsp; &nbsp; &nbsp;SELECT promo_begin_date \n&nbsp; &nbsp; &nbsp;FROM promotions \n&nbsp; &nbsp; &nbsp;WHERE promo_category= 'INTERNET');</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the PROMOTIONS table.Table: PROMOTIONS Name                           Null??            Type\nPROMO_ID                       NOT NULL          NUMBER(6)\nPROMO_NAME                     NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY              NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY_ID           NOT NULL          NUMBER\nPROMO_CATEGORY                 NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY_ID              NOT NULL          NUMBER\nPROMO_COST                     NOT NULL          NUMBER(10,2)\nPROMO_BEGIN_DATE               NOT NULL          DATE\nPROMO_END_DATE                 NOT NULL          DATERequired: Generate a report that displays the promo name and start date for all promos that started after the last promo in the 'INTERNET' category.&nbsp; Identify the SQL query that would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068255,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate the true statement about aggregate functions. </p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The AVG function does not implicitly convert NULLs to zero. Instead, it ignores NULL values when calculating the average.",
                    "Aggregate functions can be nested to a limited number of levels, typically up to two levels. Nesting beyond this limit can result in errors or unexpected results.",
                    "The MAX and MIN functions can indeed be used on columns with character data types. These functions compare the values based on their ASCII values and return the maximum or minimum value accordingly.",
                    "Aggregate functions can be used in the SELECT clause, GROUP BY clause, HAVING clause, and ORDER BY clause of a SELECT statement. They are commonly used to perform calculations on groups of rows or the entire result set."
                ],
                "explanation": "<p>Explanation of each option:</p><ol><li><p><strong>The AVG function implicitly converts NULLs to zero.</strong><br>This is <strong>false</strong> — NULLs are <strong>ignored</strong>, not converted to zero. If all values are NULL, the result is NULL.</p></li><li><p><strong>Aggregate functions can be nested to any number of levels.</strong><br>This is generally <strong>not allowed</strong> in most SQL dialects — aggregate functions <strong>cannot be nested</strong> (e.g., <code>AVG(SUM(...))</code> is invalid).</p></li><li><p><strong>The MAX and MIN functions can be used on columns with character data types.</strong><br>This is <strong>true</strong> — for character data types, MAX returns the <strong>last</strong> value alphabetically, and MIN returns the <strong>first</strong>.</p></li><li><p><strong>Aggregate functions can be used in any clause of a SELECT statement.</strong><br>This is <strong>false</strong> — aggregate functions are typically used in the <strong>SELECT</strong>, <strong>HAVING</strong>, and <strong>ORDER BY</strong> clauses, but <strong>not</strong> in the <strong>WHERE</strong> clause.</p></li></ol><p>Aggregate functions are functions that allow you to view a single piece of data from multiple pieces of data. However, aggregate functions are different because you can use them on multiple rows and get a single value as a result. An example of an aggregate function is <a href=\"https://www.databasestar.com/oracle-sum/\">SUM</a>. This function allows you to input a range of values, such as those in a column, and get the total of those numbers.</p><p><a href=\"https://www.databasestar.com/oracle-sql-aggregate-functions/\">https://www.databasestar.com/oracle-sql-aggregate-functions/</a></p><p><strong>Oracle Built-in Aggregate Functions</strong></p><p>Aggregate</p><p><code>max</code> returns the maximum value of <code>expr</code>. Its datatype depends on the datatype of the argument.</p><p><code>min</code> returns the minimum value of <code>expr</code>. Its datatype depends on the datatype of its argument.</p><p><code>xmlagg</code> returns a collection of XML fragments as an aggregated XML document. Arguments that return null are dropped from the result.</p><p><br></p><p>Aggregate (incremental computation)</p><p><code>avg</code> returns the average value of <code>expr</code>.</p><p><code>count</code> returns the number of tuples returned by the query as an <code>int</code> value.</p><p><code>sum</code> returns the sum of the values of <code>expr</code>. This function takes as an argument any <code>bigint</code>, <code>float</code>, or <code>integer</code> expression. The function returns the same datatype as the numeric datatype of the argument.</p><p><br></p><p>Extended aggregate</p><p><code>first</code> returns the value of the specified stream element the first time the specified pattern is matched.</p><p><code>last</code> returns the value of the specified stream element the last time the specified pattern is matched.</p><p><a href=\"https://docs.oracle.com/cd/E12839_01/apirefs.1111/e12048/funcbltag.htm#BHCEHFJE\">https://docs.oracle.com/cd/E12839_01/apirefs.1111/e12048/funcbltag.htm#BHCEHFJE</a></p><p><br></p><p>Aggregate functions return a single result row based on groups of rows, rather than on single rows. Aggregate functions can appear in select lists and in <code>ORDER</code> <code>BY</code> and <code>HAVING</code> clauses. They are commonly used with the <code>GROUP</code> <code>BY</code> clause in a <code>SELECT</code> statement, where Oracle Database divides the rows of a queried table or view into groups. In a query containing a <code>GROUP</code> <code>BY</code> clause, the elements of the select list can be aggregate functions, <code>GROUP</code> <code>BY</code> expressions, constants, or expressions involving one of these. Oracle applies the aggregate functions to each group of rows and returns a single result row for each group.</p><p>If you omit the <code>GROUP</code> <code>BY</code> clause, then Oracle applies aggregate functions in the select list to all the rows in the queried table or view. You use aggregate functions in the <code>HAVING</code> clause to eliminate groups from the output based on the results of the aggregate functions, rather than on the values of the individual rows of the queried table or view.</p><p><a href=\"https://docs.oracle.com/database/121/SQLRF/functions003.htm#SQLRF20035\">https://docs.oracle.com/database/121/SQLRF/functions003.htm#SQLRF20035</a></p><p><br></p><p>Aggregate functions can be nested. A query containing a nested aggregation requires one group by clause and returns one row.</p><p>The <code>CUBE</code>, <code>ROLLUP</code> and <code>GROUPING SETS</code> functions are used in the <code>GROUP BY</code> clause to generate totals and subtotals. <code>ROLLUP</code> can have more than one dimension, generating grand totals and subtotals. It is also possible to mix <code>ROLLUP</code> groups with normal groups in the GROUP BY clause.</p><p><a href=\"http://www.dba-oracle.com/t_advanced_sql_nested_aggregates.htm\">http://www.dba-oracle.com/t_advanced_sql_nested_aggregates.htm</a></p>",
                "answers": [
                    "<p>The AVG function implicitly converts NULLS to zero.</p>",
                    "<p>Aggregate functions can be nested to any number of levels.</p>",
                    "<p>The MAX and MIN functions can be used on columns with character data types.</p>",
                    "<p>Aggregate functions can be used in any clause of a SELECT statement.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Indicate the true statement about aggregate functions.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068257,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required:</strong> Display 5 percent of the rows from the SALES table for products with the lowest AMOUNT_SOLD and include the rows that have the same AMOUNT_SOLD even if this causes the output to exceed 5 percent of the rows.&nbsp; </p><p>Identify the response that would meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query correctly orders the rows in the SALES table by the AMOUNT_SOLD column and fetches the first 5 percent of the rows. The 'WITH TIES' option ensures that rows with the same AMOUNT_SOLD value are included in the output, even if it exceeds 5 percent of the total rows.",
                    "This query orders the rows by AMOUNT_SOLD and fetches the first 5 percent of the rows. However, the 'ONLY WITH TIES' option is not a valid syntax for the FETCH FIRST clause in Oracle SQL.",
                    "This query correctly orders the rows by AMOUNT_SOLD and fetches the first 5 percent of the rows. However, placing 'ONLY' before 'WITH TIES' is not a valid syntax in Oracle SQL.",
                    "This query orders the rows by AMOUNT_SOLD and fetches the first 5 percent of the rows. However, the 'ONLY' keyword without 'WITH TIES' will only return exactly 5 percent of the rows without including ties, which does not meet the requirement of including rows with the same AMOUNT_SOLD value."
                ],
                "explanation": "<p><strong>Requirement</strong>: Display <strong>5 percent of rows</strong> with the <strong>lowest </strong><code><strong>AMOUNT_SOLD</strong></code>, and <strong>include any ties</strong> — i.e., rows that have the same <code>AMOUNT_SOLD</code> value as the last row in the 5% range.</p><ul><li><p><code>FETCH FIRST 5 PERCENT ROWS WITH TIES</code>:</p><ul><li><p>This fetches the first 5% of rows based on the <code>ORDER BY amount_sold</code>.</p></li><li><p>It <strong>includes all rows with the same value</strong> as the last row in the 5% range.</p></li><li><p>This is exactly what is needed.</p></li></ul></li></ul><p>Incorrect Options:</p><ul><li><p><code>FETCH FIRST 5 PERCENT ROWS ONLY WITH TIES</code> – Invalid syntax.</p></li><li><p><code>FETCH FIRST 5 PERCENT ROWS WITH TIES ONLY</code> – Invalid syntax.</p></li><li><p><code>FETCH FIRST 5 PERCENT ROWS ONLY</code> – Valid syntax, but it <strong>excludes ties</strong>, which doesn't meet the requirement.</p></li></ul><p>A Top-N query is used to retrieve the top or bottom N rows from an ordered set. Combining two Top-N queries gives you the ability to page through an ordered set.</p><p>Using a top-n query, it's easy to exclude trailing rows to answer a question such as \"Who are the highest <em>n</em> salary earners?\" The legacy top-n query uses the <code>ROWNUM</code> pseudo column, or even the <code>ROW_NUMBER</code> and <code>PERCENT_RANK</code> analytic functions, to exclude trailing rows. Excluding rows as a percentage makes the top-n query even more versatile, and means it's possible to answer the more difficult question of \"Who are the highest <em>n</em> percent of salary earners?\"</p><p>Arguably, the most common query to retrieve the top-n rows is one that utilizes the <code>ROWNUM</code> pseudo-column. The top-n query that is guaranteed to sort first, and then return the first five rows, is done using the <code>ROWNUM</code> pseudo column outside of an inline view.</p><p>It's cleaner to determine the top five salary earners using the Oracle Database 12<em>c</em> syntax with a <code>FETCH FIRST n ROWS ONLY </code>clause. Using the Oracle Database 12<em>c</em> <code>FETCH ROWS WITH TIES</code> clause, it's very easy to include the extra rows that are ties. When there are ties for the value sought, the <code>WITH TIES</code> subclause ensures the result set includes them.</p><p><br></p><p><strong>Query Format for Top-N Percent of Rows with Ties</strong></p><pre class=\"prettyprint linenums\">SELECT field1, field2, field3, fieldn\nFROM table_name\nORDER BY fieldn DESC\nFETCH FIRST 10 PERCENT ROWS WITH TIES;</pre><p><br></p><p><strong>Query Format for Top-N Rows with Ties</strong></p><pre class=\"prettyprint linenums\">SELECT field1, field2, field3, fieldn\nFROM table_name\nORDER BY fieldn DESC\nFETCH FIRST 2 ROWS WITH TIES;</pre><p><strong>Note: There is no 'ONLY' in the FETCH line.</strong></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, cust_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS WITH TIES;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, cust_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS ONLY WITH TIES;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, cust_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS WITH TIES ONLY;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, cust_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS ONLY;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Required: Display 5 percent of the rows from the SALES table for products with the lowest AMOUNT_SOLD and include the rows that have the same AMOUNT_SOLD even if this causes the output to exceed 5 percent of the rows.&nbsp; Identify the response that would meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068259,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDER_ITEMS and ORDERS tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-05-36-5b909f4c526c6bd5c81410f3524d5709.png\"></p><p><br></p><p><strong>Required:</strong> Remove from the ORDER_ITEMS table all rows that have an order status of 0 or 1 in the ORDERS table.&nbsp; </p><p>Identify the responses that would meet the requirement. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice has a syntax error in the DELETE statement. The asterisk (*) should not be used after DELETE, and the subquery in the WHERE clause is not correctly structured. The SELECT statement inside the subquery should be used to filter the order_ids that have an order status of 0 or 1 in the ORDERS table.",
                    "This choice correctly uses a subquery to filter the rows in the ORDER_ITEMS table based on the order status in the ORDERS table. It joins the ORDER_ITEMS and ORDERS tables on the order_id column and deletes the rows where the order status is 0 or 1.",
                    "This choice has a syntax error in the subquery. The alias 'I' is used in the DELETE statement, but it is not defined in the subquery. Additionally, the subquery should be used to filter the order_ids that have an order status of 0 or 1 in the ORDERS table.",
                    "<p>– <em>Assuming one-to-one match </em>This choice correctly uses a subquery to filter the rows in the ORDER_ITEMS table based on the order status in the ORDERS table. It selects the order_ids from the ORDERS table where the order status is 0 or 1 and deletes the corresponding rows from the ORDER_ITEMS table.</p>"
                ],
                "explanation": "<p>Analyze each provided SQL statement to determine if it meets the requirement of removing rows from the <code>ORDER_ITEMS</code> table where the corresponding order in the <code>ORDERS</code> table has a status of 0 or 1.</p><p><strong>Requirement:</strong> Remove from the <code>ORDER_ITEMS</code> table all rows that have an order status of 0 or 1 in the <code>ORDERS</code> table.</p><p><br></p><p>1. </p><pre class=\"prettyprint linenums\">DELETE FROM order_items \nWHERE order_id IN (\n    SELECT order_id FROM orders \n    WHERE order_status \n    IN (0,1));</pre><p><br></p><ul><li><p><strong>Analysis:</strong> This statement uses a subquery to first select all <code>order_id</code>s from the <code>ORDERS</code> table where <code>order_status</code> is either 0 or 1. Then, the outer <code>DELETE</code> statement removes rows from <code>ORDER_ITEMS</code> where their <code>order_id</code> is present in the set of <code>order_id</code>s returned by the subquery. This is a standard and correct way to achieve the desired result.</p></li><li><p><strong>Meets Requirement:</strong> Yes.</p></li></ul><p><br></p><p>2. </p><pre class=\"prettyprint linenums\">DELETE FROM order_items I \nWHERE order_id IN (\n    SELECT order_id \n    FROM orders o \n    WHERE order_status IN (0,1));</pre><p><br></p><ul><li><p><strong>Analysis:</strong> This statement is functionally identical to the first one. It uses an alias <code>I</code> for <code>order_items</code> and <code>o</code> for <code>orders</code>, which is good practice but doesn't change the logic in this specific <code>IN</code> subquery context. The subquery correctly identifies the relevant <code>order_id</code>s, and the outer <code>DELETE</code> statement removes the corresponding <code>ORDER_ITEMS</code> rows.</p></li><li><p><strong>Meets Requirement:</strong> Yes.</p></li></ul><p><br></p><p>3. </p><pre class=\"prettyprint linenums\">DELETE FROM order_items I \nWHERE order_id = (\n    SELECT order_id \n    FROM orders o \n    WHERE i.order_id = o.order_id \n    AND order_status IN (0,1));</pre><p><br></p><ul><li><p><strong>Analysis:</strong> This statement uses a correlated subquery. The <code>WHERE i.order_id = o.order_id</code> part links the outer query's <code>order_id</code> with the inner query. However, the critical issue is the <code>=</code> operator used with the subquery. For the <code>=</code> operator, the subquery must return at most one row. If there are multiple orders with status 0 or 1, or if there's any scenario where the subquery could return more than one <code>order_id</code> for a given <code>i.order_id</code> (which shouldn't happen if <code>order_id</code> is a unique identifier in <code>ORDERS</code>, but using <code>=</code> is inherently risky if the subquery <em>could</em> return multiple values), this query would fail with an error like \"subquery returns more than 1 row.\" The <code>IN</code> operator is appropriate when the subquery can return multiple values.</p></li><li><p><strong>Meets Requirement:</strong> No (due to potential runtime error if the subquery returns more than one row, which <code>IN</code> is designed to handle).</p></li></ul><p><br></p><p>4. </p><pre class=\"prettyprint linenums\">DELETE *\nFROM order_items\nWHERE order_id \nIN (\n&nbsp; &nbsp; SELECT order_id)\n&nbsp; &nbsp; FROM orders\n&nbsp; &nbsp; &nbsp;WHERE order_status IN (0,1));</pre><p><br></p><ul><li><p><strong>Analysis:</strong> This statement contains multiple syntax errors:</p><ul><li><p><code>DELETE *</code>: The correct syntax for deleting all columns is <code>DELETE FROM table_name</code>. <code>DELETE *</code> is not standard SQL.</p></li><li><p>The parentheses for the subquery are malformed: <code>SELECT order_id)</code> and <code>FROM orders</code> are incorrectly separated and parenthesized. The <code>FROM orders</code> clause should be inside the subquery's parentheses.</p></li></ul></li><li><p><strong>Meets Requirement:</strong> No (due to syntax errors).</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">DELETE *\nFROM order_items\nWHERE order_id \nIN (\n&nbsp; &nbsp; SELECT order_id)\n&nbsp; &nbsp; FROM orders\n&nbsp; &nbsp; &nbsp;WHERE order_status IN (0,1));</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE FROM order_items \nWHERE order_id IN (\n    SELECT order_id FROM orders \n    WHERE order_status \n    IN (0,1));</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE FROM order_items I \nWHERE order_id IN (\n    SELECT order_id \n    FROM orders o \n    WHERE order_status IN (0,1));</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE FROM order_items I \nWHERE order_id = (\n    SELECT order_id \n    FROM orders o \n    WHERE i.order_id = o.order_id \n    AND order_status IN (0,1));</pre>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the ORDER_ITEMS and ORDERS tables.Required: Remove from the ORDER_ITEMS table all rows that have an order status of 0 or 1 in the ORDERS table.&nbsp; Identify the responses that would meet the requirement. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068261,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the Exhibit and examine the description of the EMPLOYEES table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-03-16-b64c1b208438cb11ff6aaaad443662e7.png\"></p><p><br></p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">SELECT first_name, employee_id, NEXT_DAY(ADD_Months(hire_date, 6), 1) \"Review\")\nFROM employees;</pre><p><br></p><p><strong>Given: </strong>The review date is the first Monday after the completion of six months of the hiring. The NLS_TERRITORY parameter is set to AMERICA in the session.&nbsp; </p><p><strong>Required:</strong> </p><ol><li><p>Retrieve the FIRST_NAME, EMPLOYEE_ID, and review date for employees.</p></li><li><p>Avoid the review dates where the given Monday is a holiday.</p></li></ol><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query is valid and will execute successfully to retrieve the desired output of FIRST_NAME, EMPLOYEE_ID, and review date for employees.",
                    "Date functions can be nested in SQL queries, so the query will execute without any issues related to nesting date functions.",
                    "The query will execute successfully, but it may result in review dates that fall on weekends due to the nature of the calculation based on the first Monday after six months of hiring.",
                    "The NEXT_DAY function in Oracle SQL does not require a string as an argument, so the query will execute without any issues related to the argument type for the function."
                ],
                "explanation": "<p><em>The query would execute successfully and return a Monday after 6 months, but there is no built-in provision to check whether that Monday is a recognized business day (e.g., not a public holiday).</em></p><p><br></p><p>The query:</p><pre class=\"prettyprint linenums\">SELECT first_name, employee_id, NEXT_DAY(ADD_Months(hire_date, 6), 1) \"Review\")\nFROM employees;</pre><ol><li><p><strong>will execute without errors</strong>.</p></li><li><p><code><strong>NEXT_DAY(..., 1)</strong></code> correctly finds the next <strong>Monday</strong> after 6 months from <code>hire_date</code> (with <code>1</code> meaning Monday under <code>NLS_TERRITORY='AMERICA'</code>).</p></li><li><p>However, the query <strong>does not account for holidays or company-specific non-business days</strong> — it only avoids weekends <strong>implicitly</strong>, by choosing Monday.</p></li></ol>",
                "answers": [
                    "<p>The query would execute to give the desired output.</p>",
                    "<p>The query would not execute because date functions cannot be nested.</p>",
                    "<p>The query would execute but the output would give review dates that are on weekends.</p>",
                    "<p>The query would not execute because the NEXT_DAY function accepts a string as argument.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View the Exhibit and examine the description of the EMPLOYEES table. Evaluate the following SQL statement.Exhibit: 1 SELECT first_name, employee_id, NEXT_DAY(ADD_Months(hire_date, 6), 1) \"Review\")\nFROM employees;Given: The review date is the first Monday after the completion of six months of the hiring. The NLS_TERRITORY parameter is set to AMERICA in the session.&nbsp; Required: Retrieve the FIRST_NAME, EMPLOYEE_ID, and review date for employees.Avoid the review dates where the given Monday is a holiday.Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068263,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate two statements that best describe the benefits of using the WITH clause. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The WITH clause, also known as Common Table Expressions (CTE), can improve query performance by storing the result of a query block in the session's temporary tablespace. This allows the query to be executed once and reused multiple times within the same query, reducing the overall execution time for complex queries.",
                    "The WITH clause enables sessions to reuse the same query block in a SELECT statement if it occurs more than once in a complex query. This can help in simplifying the query structure, making it easier to read and maintain, and reducing the overall query execution time by avoiding redundant computations.",
                    "Storing a query block permanently in memory and using it to create complex queries is not a benefit of using the WITH clause. The WITH clause does not permanently store query blocks in memory; it is used to define temporary result sets that can be referenced within the same query.",
                    "The WITH clause does not enable sessions to store the results of a query permanently. It is used to define temporary result sets that can be referenced within the same query, but the results are not stored permanently in the database."
                ],
                "explanation": "<p>The two statements that best describe the benefits of using the <strong>WITH</strong> clause are:</p><ol><li><p><strong>It can improve the performance of a large query by storing the result of a query block having the WITH clause in the session's temporary tablespace.</strong></p></li><li><p><strong>It enables sessions to reuse the same query block in a SELECT statement if it occurs more than once in a complex query.</strong></p></li></ol><p>Explanation:</p><ul><li><p>The <strong>WITH</strong> clause (also known as a <strong>Common Table Expression</strong>, or CTE) helps break complex SQL queries into simpler, modular parts.</p></li><li><p>It can improve performance <strong>by allowing intermediate results to be calculated once</strong> and reused multiple times within the same query.</p></li><li><p>These intermediate results are often stored in temporary space for the duration of the query execution, which can reduce redundant computation.</p></li></ul><p>Incorrect Statements:</p><ul><li><p><strong>\"Store a query block permanently in memory\"</strong> – CTEs are not persistent; they're used only during the query execution.</p></li><li><p><strong>\"Store the results of a query permanently\"</strong> – CTEs are temporary and exist only during the query runtime.</p></li></ul><p><br></p><p>The <code>WITH</code> clause can be used to reduce repetition and simplify complex SQL statements because it may be processed as an inline view or resolved as a temporary table. </p><p>The advantage is that repeated references to the subquery may be more efficient as the data is easily retrieved from the temporary table, rather than being requeried by each reference. It is best to assess the performance implications of the <code>WITH</code> clause on a case-by-case basis.</p><p><a href=\"https://oracle-base.com/articles/misc/with-clause\">https://oracle-base.com/articles/misc/with-clause</a></p>",
                "answers": [
                    "<p>It can improve the performance of a large query by storing the result of a query block having the WITH clause in the session's temporary tablespace.</p>",
                    "<p>It enables sessions to reuse the same query block in a SELECT statement, if it occurs more than once in a complex query.</p>",
                    "<p>It enables sessions to store a query block permanently in memory and use it to create complex queries.</p>",
                    "<p>It enables sessions to store the results of a query permanently.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Indicate two statements that best describe the benefits of using the WITH clause. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068303,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDERS and CUSTOMERS tables. </p><p><strong>Table: ORDERS </strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nORDER_ID         NOT NULL          NUMBER(4)\nORDER_DATE       NOT NULL          DATE\nORDER_MODE                         VARCHAR(8)\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nORDER_TOTAL                        NUMBER(8,2)</pre><p><br></p><p><strong>Table: CUSTOMERS</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nCUSTOMER_ID                   NOT NULL          NUMBER(6)\nCUSTOMER_FIRST_NAME           NOT NULL          VARCHAR(20)\nCUSTOMER_LAST_NAME            NOT NULL          VARCHAR(20)\nCREDIT_LIMIT                                    NUMBER(9,2)\nCUST_ADDRESS                                    VARCHAR(40)</pre><p><br></p><p><strong>Given</strong>: Assume there exists only one row with CUSTOMER_LAST_NAME as Roberts and CREDIT_LIMIT as 600.</p><p><strong>Required:</strong> Add a row into the ORDERS table for the customer whose CUSTOMER_LAST_NAME is Roberts and CREDIT_LIMIT is 600.</p><p>Identify the SQL query that would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query attempts to insert values into the ORDERS table by selecting data from both the ORDERS and CUSTOMERS tables based on the specified conditions. However, the syntax for the INSERT INTO statement is incorrect as it does not specify the table name before the SELECT statement. Additionally, the VALUES keyword is used incorrectly in this query.",
                    "This query also attempts to insert values into the ORDERS table by selecting data from the CUSTOMERS table based on the specified conditions. However, the syntax for the INSERT INTO statement is incorrect as it does not specify the column names before the SELECT statement. The use of &amp;customer_id as a placeholder is also incorrect in this context.",
                    "This query correctly inserts values into the ORDERS table by selecting the customer_id from the CUSTOMERS table where the customer_last_name is 'Roberts' and the credit_limit is 600. The syntax for the INSERT INTO statement is correct, and the values are provided in the correct order.",
                    "This query attempts to insert values into the ORDERS table by selecting data from the CUSTOMERS table based on the specified conditions. However, similar to the previous choices, the syntax for the INSERT INTO statement is incorrect as it does not specify the column names before the SELECT statement. The use of &amp;&amp;customer_id as a placeholder is also incorrect in this context."
                ],
                "explanation": "<p>The <strong>correct SQL query</strong> to insert a row into the <code>ORDERS</code> table for the customer named <strong>Roberts</strong> with a <strong>credit limit of 600</strong> is:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO orders\nVALUES (1,'01/MAR/2020', 'direct',\n    (SELECT customer_id\n&nbsp; &nbsp; &nbsp;FROM customers\n&nbsp; &nbsp; &nbsp;WHERE customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND credit_limit=600),1000);</pre><p><br></p><p>Why this works:</p><ul><li><p>The query:</p><ul><li><p>Inserts values into the <code>ORDERS</code> table.</p></li><li><p>Uses a <strong>subquery</strong> to dynamically fetch the <code>customer_id</code> for the customer <strong>Roberts</strong> with <strong>credit_limit = 600</strong>.</p></li><li><p>Assumes the subquery returns only <strong>one</strong> row (which is safe here as the problem states there's only one such customer).</p></li></ul></li><li><p>The column order in <code>INSERT INTO orders VALUES (...)</code> matches the order of columns defined in the table: <code>ORDER_ID, ORDER_DATE, ORDER_MODE, CUSTOMER_ID, ORDER_TOTAL</code>.</p></li></ul><p>Why are the other options incorrect:</p><ol><li><p><strong>First Option (INSERT INTO (SELECT ...))</strong><br>Invalid syntax – you cannot insert using a <code>SELECT</code> statement in the <code>INSERT INTO</code> clause like that.</p></li><li><p><strong>Second Option (INSERT INTO orders (..., (SELECT ...), ...))</strong><br>Invalid – You can't use a subquery directly inside the <strong>column list</strong>.</p></li><li><p><strong>Fourth Option (similar to the second)</strong><br>Also incorrect – again uses a subquery inside the column list, which is syntactically invalid.</p></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">INSERT INTO(\n&nbsp; &nbsp; &nbsp;SELECT o.order_id, o.order_date, o.order_mode, c.customer_id, o.order_total\n&nbsp; &nbsp; &nbsp;FROM orders o, customers c\n&nbsp; &nbsp; &nbsp;WHERE o.customer_id = c.customer_id \n&nbsp; &nbsp; &nbsp;AND c.customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND c.credit_limit=600)\nVALUES (1,'01/MAR/2020', 'direct', (\n&nbsp; &nbsp; &nbsp;SELECT customer_id\n&nbsp; &nbsp; &nbsp;FROM customers\n&nbsp; &nbsp; &nbsp;WHERE customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND credit_limit=600), 1000);</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO orders (\norder_id, order_date, \norder_mode,(\n&nbsp; &nbsp; &nbsp;SELECT customer_id\n&nbsp; &nbsp; &nbsp;FROM customers\n&nbsp; &nbsp; &nbsp;WHERE customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND credit_limit=600), order_total)\nVALUES (1,'01/MAR/2020', 'direct', &amp;customer_id, 1000);</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO orders\nVALUES (1,'01/MAR/2020', 'direct',\n    (SELECT customer_id\n&nbsp; &nbsp; &nbsp;FROM customers\n&nbsp; &nbsp; &nbsp;WHERE customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND credit_limit=600),1000);</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO orders (order_id, order_date, order_mode,(\n&nbsp; &nbsp; &nbsp;SELECT customer_id\n&nbsp; &nbsp; &nbsp;FROM customers\n&nbsp; &nbsp; &nbsp;WHERE customer_last_name='Roberts' \n&nbsp; &nbsp; &nbsp;AND credit_limit=600), order_total)\nVALUES (1,'01/MAR/2020', 'direct', &amp;&amp;customer_id, 1000);</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the ORDERS and CUSTOMERS tables. Table: ORDERS Name             Null??            Type\nORDER_ID         NOT NULL          NUMBER(4)\nORDER_DATE       NOT NULL          DATE\nORDER_MODE                         VARCHAR(8)\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nORDER_TOTAL                        NUMBER(8,2)Table: CUSTOMERSName                          Null??            Type\nCUSTOMER_ID                   NOT NULL          NUMBER(6)\nCUSTOMER_FIRST_NAME           NOT NULL          VARCHAR(20)\nCUSTOMER_LAST_NAME            NOT NULL          VARCHAR(20)\nCREDIT_LIMIT                                    NUMBER(9,2)\nCUST_ADDRESS                                    VARCHAR(40)Given: Assume there exists only one row with CUSTOMER_LAST_NAME as Roberts and CREDIT_LIMIT as 600.Required: Add a row into the ORDERS table for the customer whose CUSTOMER_LAST_NAME is Roberts and CREDIT_LIMIT is 600.Identify the SQL query that would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068265,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required:</strong> Produce a report where each customer's credit limit has been incremented by $1000. In the output, the customer's last name should have the heading \"Name\" and the incremented credit limit should be labelled \"New Credit Limit\".&nbsp; &nbsp;</p><p>Identify the response that would meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle SELECT - Double quotes or no double quotes?](https://stackoverflow.com/questions/17471948/oracle-select-double-quotes-or-no-double-quotes)"
                ],
                "feedbacks": [
                    "<p>This choice correctly selects the customer's last name as \"Name\" and increments the credit limit by $1000, labelling it as \"New Credit Limit\". The syntax is valid and meets the requirement stated in the question.</p>",
                    "<p>This choice also selects the customer's last name as \"Name\" and increments the credit limit by $1000, labelling it as \"New Credit Limit\". The syntax is valid, but the missing quotation marks around the column aliases may cause issues in some SQL environments.</p>",
                    "<p>This choice contains a syntax error with \"SO Name\" instead of \"AS Name\" for the column alias. Additionally, the labelling of the incremented credit limit is incorrect. This choice does not meet the requirement specified in the question.</p>",
                    "This choice uses the INITCAP function to format the customer's last name as \"Name\" but incorrectly applies the function to the \"NEW CREDIT LIMIT\" label. The syntax for the column aliases is also incorrect. This choice does not meet the requirement stated in the question."
                ],
                "explanation": "<p>The <strong>correct SQL query</strong> that meets the requirement is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT customer_last_name AS \"Name\", credit_limit + 1000 AS \"New Credit Limit\"\nFROM customers;</pre><p><br></p><p>Why this works:</p><ul><li><p>Uses <strong>column aliasing with double quotes</strong> to format the headers exactly as required:</p><ul><li><p><code>\"Name\"</code> for <code>customer_last_name</code></p></li><li><p><code>\"New Credit Limit\"</code> for the incremented <code>credit_limit</code></p></li></ul></li><li><p>Performs arithmetic correctly: <code>credit_limit + 1000</code></p></li></ul><p>Why are the other options incorrect:</p><ol><li><p><code><strong>SELECT customer_last_name AS Name, credit_limit + 1000 AS New Credit Limit</strong></code><br><em>Incorrect aliasing</em>: Without double quotes, SQL treats <code>New</code> and <code>Credit</code> and <code>Limit</code> as separate identifiers and throws an error.</p></li><li><p><code><strong>SELECT customer_last_name SO Name, credit_limit + 1000 \"New Credit Limit\"</strong></code><br><em>Syntax error</em>: <code>\"SO\"</code> should be <code>AS</code>. This is an invalid keyword in this context.</p></li><li><p><code><strong>SELECT INITCAP(customer_last_name) \"Name\", credit_limit + 1000 INITCAP (\"NEW CREDIT LIMIT\")</strong></code><br><em>Incorrect use of </em><code><em>INITCAP</em></code>: <code>INITCAP</code> is for strings, not column aliases. <code>INITCAP(\"NEW CREDIT LIMIT\")</code> makes no sense as a column label.</p></li></ol><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-09_18-09-09-1709f0f83602fd80989c52f09e90bcaf.png\"></p><p><br></p><p>There is a difference if you put an alias in double-quotes or without double-quotes. When you omit them, you get completely uppercase output. On the other side, an alias in double-quotes will be the same.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT customer_last_name AS \"Name\", credit_limit + 1000 AS \"New Credit Limit\"\nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT customer_last_name AS Name, credit_limit + 1000 AS New Credit Limit\nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT customer_last_name SO Name, credit_limit + 1000 \"New Credit Limit\"\nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT INITCAP (customer_last_name ) \"Name\", credit_limit + 1000 INITCAP (\"NEW CREDIT LIMIT\")\nFROM customers;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following scenario.Required: Produce a report where each customer's credit limit has been incremented by $1000. In the output, the customer's last name should have the heading \"Name\" and the incremented credit limit should be labelled \"New Credit Limit\".&nbsp; &nbsp;Identify the response that would meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068267,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate the true statement about the INTERSECT operator used in compound queries.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL Union, Intersect, and Except](https://www.essentialsql.com/get-ready-to-learn-sql-server-17-how-to-use-the-intersect-operator/)",
                    "[The UNION [ALL], INTERSECT, MINUS Operators](https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries004.htm)"
                ],
                "feedbacks": [
                    "INTERSECT has the same precedence as UNION and UNION ALL in compound queries. The order of evaluation is determined by the position of the operators in the SQL statement, not by their precedence levels.",
                    "Multiple INTERSECT operators can be used in the same SQL statement to compare the results of multiple queries and return only the rows that appear in all result sets.",
                    "INTERSECT does not ignore NULL values. If NULL values are present in the selected columns, they will be considered during the comparison and matching process.",
                    "The INTERSECT operator processes NULL values in the selected columns. It treats NULL values as distinct values and includes them in the comparison to determine the final result set."
                ],
                "explanation": "<p>The <code>INTERSECT</code> operator is used to combine like rows from two queries. It returns rows that are in common between both results. To use the INTERSECT operator, both queries must return the same number of columns, and those columns must be of compatible data types.</p><p>Why are the other options incorrect:</p><ol><li><p><strong>INTERSECT is of lower precedence than UNION or UNION ALL.</strong><br>This is false. <strong>INTERSECT</strong> has <strong>higher precedence</strong> than <strong>UNION</strong> or <strong>UNION ALL</strong>, so if you use them together, the INTERSECT operation will be processed first unless parentheses dictate otherwise.</p></li><li><p><strong>Multiple INTERSECT operators are not possible in the same SQL statement.</strong><br>This is false. You <strong>can</strong> use multiple <strong>INTERSECT</strong> operators in the same query, chaining them together to find the intersection of more than two result sets.</p></li><li><p><strong>It ignores NULLs.</strong><br>This is false. <strong>INTERSECT</strong> does not ignore <code>NULLs</code>; it <strong>includes</strong> rows with <code>NULL</code> values when they appear in both result sets.</p></li></ol><p><code>INTERSECT</code></p><p>Before its introduction to the language, you had to mimic the <code>INTERSECT</code> behaviour using an <a href=\"https://www.essentialsql.com/get-ready-to-learn-sql-13-introduction-to-inner-joins/\" title=\"Get Ready to Learn SQL Server: 13. Introduction to Inner Joins\">INNER JOIN</a>.</p><p><strong>NOTE:</strong> These are equivalent to a point. AS <a href=\"https://www.essentialsql.com/get-ready-to-learn-sql-server-what-is-a-null-value/\" title=\"Get Ready to Learn SQL Server: What is a Database NULL Value?\">NULL isn’t a value</a>, therefore NULL = NULL is always false. Given this, the INNER JOIN will fail to match on joins; however, <strong>the </strong><code><strong>INTERSECT</strong></code><strong> operator does match NULLS</strong>.</p><p><br></p><p>The <code>UNION [ALL]</code>, <code>INTERSECT</code>, <code>MINUS</code> Operators</p><p>You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from left to right unless parentheses explicitly specify another order.</p><p><code>INTERSECT</code> Example: The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those rows returned by both queries:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id FROM inventories\nINTERSECT\nSELECT product_id FROM order_items;</pre>",
                "answers": [
                    "<p>INTERSECT is of lower precedence than UNION or UNION ALL.</p>",
                    "<p>Multiple INTERSECT operators are not possible in the same SQL statement.</p>",
                    "<p>It ignores NULLs.</p>",
                    "<p>It processes NULLs in the selected columns.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Indicate the true statement about the INTERSECT operator used in compound queries.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068271,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDERS table and exhibits.</p><p><strong>Table: ORDERS </strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nORDER_ID         NOT NULL          NUMBER(4)\nORDER_DATE       NOT NULL          TIMESTAMP(6)\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nORDER_STATUS                       NUMBER(2)\nORDER_TOTAL                        NUMBER(8,2)</pre><p><br></p><p><strong>Required: </strong>Find the total value of all the orders for each year.</p><p>This command has been executed.&nbsp; &nbsp;</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(order_date, 'rr'), SUM(order_total)\nFROM orders\nGROUP&nbsp;BY TO_CHAR(order_date, 'yyyy');</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query returns an error because the GROUP BY clause does not match the SELECT list. The GROUP BY clause should match the columns in the SELECT list that are not aggregated functions like SUM. In this case, the TO_CHAR function in the SELECT list is different from the TO_CHAR function in the GROUP BY clause, causing a mismatch and resulting in an error.",
                    "This choice is incorrect. The query executes successfully and gives the correct output. The query correctly uses the TO_CHAR function to extract the year from the order_date and then sums the order_total for each year, providing the total value of all orders for each year.",
                    "This choice is incorrect. The query does not return an error because the TO_CHAR function is not valid. The TO_CHAR function is valid in this context for converting the order_date to the year format 'yyyy'.",
                    "<p>This choice is incorrect. The query executes successfully but does not give the correct output. The issue lies in the mismatch between the GROUP BY clause and the SELECT list, which causes the query to provide inaccurate results for the total value of orders for each year.</p>"
                ],
                "explanation": "<p>Correct option: The query returns an error because the <code>GROUP BY</code> clause does not match the <code>SELECT</code> list.</p><p><br></p><p>The <code>SELECT</code> statement uses <code><strong>TO_CHAR(order_date, 'rr')</strong></code> to extract the year in a two-digit format, while the <code>GROUP BY</code> clause uses <code><strong>TO_CHAR(order_date, 'yyyy')</strong></code> to group the results by the year in a four-digit format. For a query with an aggregate function like <code>SUM</code>, any non-aggregated column in the <code>SELECT</code> list must also be present in the <code>GROUP BY</code> clause. Since <code>'rr'</code> and <code>'yyyy'</code> produce different values for the same date, they are considered different expressions, leading to a mismatch and causing the query to fail.</p><p>To get the correct output, both the <code>SELECT</code> and <code>GROUP BY</code> clauses should use the same format specifier, for example:</p><p><strong>Corrected Query:</strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(order_date, 'yyyy'), SUM(order_total)\nFROM orders\nGROUP BY TO_CHAR(order_date, 'yyyy');\n</pre><p>This corrected query would successfully execute and provide the total value of orders for each year.</p><p><br></p><p>Why are the other options incorrect:</p><p>The other options are incorrect for the following reasons:</p><ul><li><p>\"It executes successfully but does not give the correct output.\"</p></li></ul><p>This is wrong because the query will not execute successfully in most SQL databases. The fundamental rule of using a <code>GROUP BY</code> clause with an aggregate function (like <code>SUM</code>) is that any column in the <code><strong>SELECT</strong></code> list that is not part of an aggregate function must also be included in the <code><strong>GROUP BY</strong></code> clause. In this case, <code>TO_CHAR(order_date, 'rr')</code> is in the <code>SELECT</code> list, but the <code>GROUP BY</code> clause uses <code>TO_CHAR(order_date, 'yyyy')</code>. Since these are different expressions, the query violates this rule and will fail with an error.</p><p><br></p><ul><li><p>\"It executes successfully and gives the correct output.\"</p></li></ul><p>This is incorrect for two reasons:</p><ol><li><p>The query will fail to execute due to the mismatch between the <code>SELECT</code> and <code>GROUP BY</code> clauses, as explained above.</p></li><li><p>Even if it did execute for some reason (which it won't), the output would not be correct. The <code>RR</code> format code gives a two-digit year, while <code>yyyy</code> gives a four-digit year. The grouping would be done on the full four-digit year, while the selected column would only show the last two digits. This inconsistency would lead to confusing and incorrect results.</p></li></ol><ul><li><p>\"It returns an error because the TO_CHAR function is not valid.\"</p></li></ul><p>This is wrong because the <code><strong>TO_CHAR</strong></code> function is a perfectly valid and standard Oracle SQL function for converting dates to character strings. The issue isn't with the function itself, but with how it's being used inconsistently in the <code>SELECT</code> and <code>GROUP BY</code> clauses.</p>",
                "answers": [
                    "<p>The query returns an error because the <code>GROUP BY</code> clause does not match the <code>SELECT</code> list.</p>",
                    "<p>It executes successfully and gives the correct output.</p>",
                    "<p>It returns an error because the <code>TO_CHAR</code> function is not valid.</p>",
                    "<p>It executes successfully but does not give the correct output.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the ORDERS table and exhibits.Table: ORDERS Name             Null??            Type\nORDER_ID         NOT NULL          NUMBER(4)\nORDER_DATE       NOT NULL          TIMESTAMP(6)\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nORDER_STATUS                       NUMBER(2)\nORDER_TOTAL                        NUMBER(8,2)Required: Find the total value of all the orders for each year.This command has been executed.&nbsp; &nbsp;Exhibit: 1SELECT TO_CHAR(order_date, 'rr'), SUM(order_total)\nFROM orders\nGROUP&nbsp;BY TO_CHAR(order_date, 'yyyy');Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068269,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the valid CREATE TABLE statement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>This contains syntax errors in the CREATE TABLE statement. The PRIMARY KEY constraint should be applied to a single column, not multiple columns. Additionally, the UNIQUE constraint is not correctly placed in the statement.</p>",
                    "<p>This contains syntax errors in the CREATE TABLE statement. The PRIMARY KEY constraint should be applied to a single column, not multiple columns. The DEFAULT keyword is not correctly used with the SYSDATE function.</p>",
                    "<p>This contains syntax errors in the CREATE TABLE statement. The DEFAULT keyword is not correctly used with the NOT NULL constraint. The UNIQUE and PRIMARY KEY constraints are defined separately instead of directly in the column definitions.</p>",
                    "<p>This is the correct CREATE TABLE statement. It defines the columns ord_no, item_no, and ord_date with their respective data types and constraints. The PRIMARY KEY constraint is correctly applied to the ord_no column, and the ord_pk constraint is defined as a composite primary key on ord_no and item_no columns.</p>"
                ],
                "explanation": "<p>Correct Answer:</p><pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\nord_no NUMBER(2), \nitem_no NUMBER(3), \nord_date DATE DEFAULT SYSDATE NOT NULL, \nCONSTRAINT ord_pk PRIMARY KEY (ord_no, item_no));</pre><p><br></p><p>Why it's correct:</p><ul><li><p>The table is syntactically valid.</p></li><li><p><code>ord_no</code> and <code>item_no</code> are both declared normally, and the <strong>composite primary key</strong> is correctly defined at the table level.</p></li><li><p><code>ord_date</code> is given a default value of <code>SYSDATE</code> and marked <code>NOT NULL</code> – this is a <strong>valid syntax</strong>.</p></li></ul><p><br></p><p>Why are the others incorrect:</p><p><strong>First Option:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\n  ord_no NUMBER(2) PRIMARY KEY, UNIQUE, NOT NULL, \n  item_no NUMBER(3) PRIMARY KEY, \n  ord_date DATE NOT NULL);</pre><ul><li><p>You <strong>cannot declare two columns</strong> with <code>PRIMARY KEY</code> directly. A table can only have <strong>one primary key constraint</strong>, though it can include multiple columns.</p></li></ul><p><br></p><p><strong>Second Option:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\n  ord_no NUMBER(2) UNIQUE, NOT NULL, \n  item_no NUMBER(3), \n  ord_date DATE DEFAULT SYSDATE NOT NULL);</pre><ul><li><p>While this syntax is <strong>mostly correct</strong>, it lacks a <strong>primary key constraint</strong>, which is generally recommended.</p></li><li><p>Also, technically, column-level constraints should be separated. <code>UNIQUE, NOT NULL</code> is not invalid, but placing multiple constraints together like that can confuse.</p></li></ul><p><strong>Third Option:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE ord_details(\n  ord_no NUMBER(2), \n  item_no NUMBER(3), \n  ord_date DATE DEFAULT NOT NULL, \n  CONSTRAINT ord_uq UNIQUE (ord_no), \n  CONSTRAINT ord_pk PRIMARY KEY (ord_no));</pre><ul><li><p><code>DEFAULT NOT NULL</code> is <strong>invalid syntax</strong>. <code>DEFAULT</code> must be followed by a <strong>default value</strong>, like <code>DEFAULT SYSDATE</code>, before the <code>NOT NULL</code> constraint.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\nord_no NUMBER(2) PRIMARY KEY, UNIQUE, NOT NULL, \nitem_no NUMBER(3) PRIMARY KEY, \nord_date DATE NOT NULL);</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\nord_no NUMBER(2) UNIQUE, NOT NULL, \nitem_no NUMBER(3), \nord_date DATE DEFAULT SYSDATE NOT NULL);</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE ord_details(\nord_no NUMBER(2), \nitem_no NUMBER(3), \nord_date DATE DEFAULT NOT NULL, \nCONSTRAINT ord_uq UNIQUE (ord_no), \nCONSTRAINT ord_pk PRIMARY KEY (ord_no));</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE ord_details (\nord_no NUMBER(2), \nitem_no NUMBER(3), \nord_date DATE DEFAULT SYSDATE NOT NULL, \nCONSTRAINT ord_pk PRIMARY KEY (ord_no, item_no));</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the valid CREATE TABLE statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068273,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding subqueries (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "A subquery can indeed appear on either side of a comparison operator, allowing for more flexible and dynamic query conditions.",
                    "The statement that subqueries can be nested at a maximum of two levels deep is incorrect. Subqueries can actually be nested to multiple levels, providing more complex and detailed data retrieval options.",
                    "A subquery can retrieve zero or more rows, making it a powerful tool for fetching data based on specific conditions and criteria.",
                    "The statement that a subquery can be used only in SQL query statements is incorrect. Subqueries can be used in various SQL statements, including SELECT, INSERT, UPDATE, and DELETE, to enhance data manipulation and retrieval.",
                    "The statement that there is no limit on the number of subquery levels in the WHERE clause of a SELECT statement is incorrect. While subqueries can be nested to multiple levels, there may be practical limitations on the complexity and readability of the query.",
                    "The statement that there is no limit on the number of subquery levels in the FROM clause of a SELECT statement is correct. Subqueries in the FROM clause can be nested to multiple levels, allowing for more advanced data processing and aggregation in SQL queries."
                ],
                "explanation": "<p>The <strong>three true statements</strong> regarding <strong>subqueries</strong> are:</p><p><strong>1. A subquery can appear on either side of a comparison operator.</strong></p><ul><li><p>Subqueries can be used on the <strong>left or right</strong> side of comparison operators like <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>IN</code>, <code>ANY</code>, <code>ALL</code>, etc.</p></li></ul><p><strong>2. A subquery can retrieve zero or more rows.</strong></p><ul><li><p>A subquery may return <strong>no rows</strong>, <strong>one row</strong>, or <strong>many rows</strong>, depending on the logic and structure of the query.</p></li></ul><p><strong>3. There is no limit on the number of subquery levels in the WHERE clause of a SELECT statement.</strong></p><ul><li><p><strong>Oracle and many other RDBMSs</strong> allow subqueries to be nested <strong>many levels deep</strong> (sometimes with system-dependent practical limits), but <strong>SQL syntax itself does not restrict this</strong>.</p></li></ul><p>False statements:</p><ul><li><p><strong>\"Subqueries can be nested at a maximum of two levels deep.\"</strong><br>Incorrect. There is <strong>no fixed maximum of two levels</strong>—subqueries can be nested many times (though deeply nested queries may impact readability and performance).</p></li><li><p><strong>\"A subquery can be used only in SQL query statements.\"</strong><br>Subqueries are most often used in <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>, but they can also appear in places like <code>CHECK</code> constraints and even DDL scripts in some DBMSs.</p></li><li><p><strong>\"There is no limit on the number of subquery levels in the FROM clause of a SELECT statement.\"</strong><br>Technically incorrect. While the <strong>SQL standard</strong> allows deep nesting, <strong>some RDBMSs (like Oracle)</strong> <strong>impose internal limits</strong> on nesting levels for performance and stack depth reasons.</p></li></ul><p><strong>A subquery is a SQL query nested inside a larger query.</strong></p><p>• A subquery may occur in : </p><p>&nbsp; &nbsp; &nbsp;- A <code>SELECT</code> clause </p><p>&nbsp; &nbsp; &nbsp;- A <code>FROM</code> clause </p><p>&nbsp; &nbsp; &nbsp;- A <code>WHERE</code> clause</p><p>• The subquery can be nested inside a <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE </code>statement or inside another subquery.</p><p>• A subquery is usually added within the <code>WHERE</code> Clause of another SQL <code>SELECT</code> statement.</p><p>• You can use the comparison operators, such as <code>&gt;</code>, <code>&lt;</code>, or <code>=</code>. The comparison operator can also be a multiple-row operator, such as <code>IN</code>, <code>ANY</code>, or <code>ALL</code>.</p><p>• A subquery is also called an inner query or inner select, while the statement containing a subquery is also called an outer query or outer select.</p><p>• The inner query executes first before its parent query so that the results of an inner query can be passed to the outer query.</p><p><br></p><p>You can use a subquery in a <code>SELECT</code>, <code>INSERT</code>, <code>DELETE</code>, or <code>UPDATE</code> statement to perform the following tasks:</p><p>• Compare an expression to the result of the query.</p><p>• Determine if an expression is included in the results of the query.</p><p>• Check whether the query selects any rows.</p><p><br></p><p><strong>Syntax :</strong></p><p>• The subquery (inner query) executes once before the main query (outer query) executes.</p><p>• The main query (outer query) uses the subquery result.</p><p><br></p><p><strong>Subquery Guidelines</strong></p><p>There are some guidelines to consider when using subqueries :</p><p>• A subquery must be enclosed in parentheses.</p><p>• A subquery should be placed on either side of the comparison operator.</p><p>• Subqueries cannot manipulate their results internally; therefore ORDER BY clause cannot be added into a subquery. You can use an ORDER BY clause in the main SELECT statement (outer query), which will be the last clause.</p><p>• Use single-row operators with single-row subqueries.</p><p>• If a subquery (inner query) returns a null value to the outer query, the outer query will not return any rows when using certain comparison operators in a WHERE clause.</p><p><br></p><p>A subquery CAN appear on both sides of the comparison operator; however, for readability, it is recommended to put it on the right.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \nFROM EMPLOYEES \nWHERE (SELECT FIRST_NAME \n       FROM EMPLOYEES FETCH FIRST 1 ROW ONLY) = FIRST_NAME;</pre><p><br></p><p><strong>Type of Subqueries</strong></p><p>• Single row subquery: Returns zero or one row.</p><p>• Multiple row subquery: Returns one or more rows.</p><p>• Multiple column subqueries: Returns one or more columns.</p><p>• Correlated subqueries: Reference one or more columns in the outer SQL statement. The subquery is known as a correlated subquery because the subquery is related to the outer SQL statement.</p><p>• Nested subqueries: Subqueries are placed within another subquery.</p><p><a href=\"https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php\">https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php</a></p><p><br></p><p><strong>Limits on the number of subquery levels </strong></p><p>There is a limit to subqueries in the <code>WHERE</code> clause. </p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries007.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries007.htm</a></p><p><br></p><p>A subquery can contain another subquery. Oracle Database imposes no limit on the number of subquery levels in the <code>FROM</code> clause of the top-level query. You can nest up to 255 levels of subqueries in the <code>WHERE</code> clause.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Using-Subqueries.html#GUID-53A705B6-0358-4E2B-92ED-A83DE83DFD20\">https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Using-Subqueries.html#GUID-53A705B6-0358-4E2B-92ED-A83DE83DFD20</a></p><p><br></p><p><strong>Nesting subqueries</strong></p><p>Oracle doesn't correlate the subqueries nested more than one level deep</p><p><a href=\"https://stackoverflow.com/questions/2048244/oracle-subquery-does-not-see-the-variable-from-the-outer-block-2-levels-up#2048265\">https://stackoverflow.com/questions/2048244/oracle-subquery-does-not-see-the-variable-from-the-outer-block-2-levels-up#2048265</a></p>",
                "answers": [
                    "<p>A subquery can appear on either side of a comparison operator.</p>",
                    "<p>Subqueries can nested at a maximum of two levels deep.</p>",
                    "<p>A subquery can retrieve zero or more rows.</p>",
                    "<p>A subquery can be used only in SQL query statements.</p>",
                    "<p>There is no limit on the number of subquery levels in the WHERE clause of a SELECT statement.</p>",
                    "<p>There is no limit on the number of subquery levels in the FROM clause of a SELECT statement.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "f"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding subqueries (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068275,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify three actions that can be performed using the ALTER TABLE command.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Locking a set of rows in a table is not an action that can be performed using the ALTER TABLE command. This operation is typically handled through the use of locking mechanisms in SQL queries.",
                    "Dropping pseudocolumns from a table is not an action that can be performed using the ALTER TABLE command. Pseudocolumns are system-generated columns that provide additional information about rows.",
                    "Renaming a table is a valid action that can be performed using the ALTER TABLE command. This operation allows you to change the name of an existing table in the database.",
                    "Dropping several columns simultaneously from a table is a valid action that can be performed using the ALTER TABLE command. This operation allows you to remove multiple columns from a table in a single command.",
                    "Enabling or disabling constraints on a table is a valid action that can be performed using the ALTER TABLE command. Constraints ensure data integrity and can be enabled or disabled as needed.",
                    "Restricting all DML statements on a table is not an action that can be performed using the ALTER TABLE command. This type of restriction is typically implemented through the use of database permissions and access control mechanisms."
                ],
                "explanation": "<p>The <strong>three actions</strong> that can be performed using the <code><strong>ALTER TABLE</strong></code> command are:</p><p><strong>1. Rename a table</strong></p><ul><li><p>You can rename a table using:</p><pre class=\"prettyprint linenums\">sql\nALTER TABLE old_table_name RENAME TO new_table_name;</pre></li></ul><p><strong>2. Enable or disable constraints on a table</strong></p><ul><li><p>You can <strong>enable or disable</strong> constraints like:</p><pre class=\"prettyprint linenums\">sql\nALTER TABLE table_name DISABLE CONSTRAINT constraint_name;\nALTER TABLE table_name ENABLE CONSTRAINT constraint_name;</pre></li></ul><p><strong>3. Drop several columns simultaneously from a table</strong></p><ul><li><p>You can drop multiple columns at once using:</p><pre class=\"prettyprint linenums\">sql\nALTER TABLE table_name DROP (column1, column2);</pre></li></ul><p>Actions that <strong>cannot</strong> be done using <code>ALTER TABLE</code>:</p><ul><li><p><strong>Lock a set of rows in a table</strong><br>This is done using <code>SELECT ... FOR UPDATE</code>, <strong>not</strong> via <code>ALTER TABLE</code>.</p></li><li><p><strong>Drop pseudocolumns from a table</strong><br><strong>Pseudocolumns</strong> (like <code>ROWID</code>, <code>ROWNUM</code>) are <strong>virtual</strong> and cannot be dropped—they aren't actual columns stored in the table.</p></li><li><p><strong>Restrict all DML statements on a table</strong><br>You’d use <code><strong>ALTER TABLE ... READ ONLY</strong></code> in some DBMSs, but generally <strong>DML restrictions</strong> are managed via <strong>privileges</strong> or <strong>triggers</strong>, not solely through <code>ALTER TABLE</code>.</p></li></ul><p><strong>THE ALTER TABLE statement</strong> can be used to add a column, modify a column, drop a column, rename a column, or rename a table.</p><p>• Add single or multiple columns in a table</p><p>• Drop single or multiple columns in the table</p><p>• Modify (add or drop) single or multiple column types, attributes, constraints, foreign keys, or primary keys</p><p>• Rename the table, or single or multiple columns in the table</p><p><a href=\"https://www.techonthenet.com/oracle/tables/alter_table.php\">https://www.techonthenet.com/oracle/tables/alter_table.php</a></p><p><br></p><p>Use the <code>ALTER</code> <code>TABLE</code> statement to alter the definition of a nonpartitioned table, a partitioned table, a table partition, or a table subpartition. For object tables or relational tables with object columns, use <code>ALTER</code> <code>TABLE</code> to convert the table to the latest definition of its referenced type after the type has been altered.</p><p><br></p><p><strong>Groups of ALTER TABLE syntax:</strong></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2192749\"><strong><em>alter_table_properties::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2103924\"><strong><em>column_clauses::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2103997\"><strong><em>constraint_clauses::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2087440\"><strong><em>alter_table_partitioning ::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2104234\"><strong><em>alter_external_table_clauses ::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2081902\"><strong><em>move_table_clause ::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_3001.htm#i2183600\"><strong><em>enable_disable_clause ::=</em></strong></a></p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_3001.htm#SQLRF01001\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_3001.htm#SQLRF01001</a></p><p><br></p><p><strong>Limitations of the ALTER TABLE command</strong></p><p>- Column can’t be deleted with the ALTER command.</p><p>- Column can’t be renamed a column.</p><p>- Column can’t be added between the existing columns.</p><p>- When a column is added, it will be added at the end of the table.</p><p><a href=\"https://www.careerride.com/oracle-db-alter-table-command-limitations.aspx\">https://www.careerride.com/oracle-db-alter-table-command-limitations.aspx</a></p><p><br></p><p>A <strong>pseudo-column</strong> is an Oracle-assigned value (pseudo-field) used in the same context as an Oracle Database <a href=\"https://www.orafaq.com/wiki/Column\" title=\"Column\">column</a>, but not stored on disk. SQL and PL/SQL recognize the following <strong>SQL pseudocolumns</strong>, which return specific data items: SYSDATE, SYSTIMESTAMP, <a href=\"https://www.orafaq.com/wiki/ROWID\" title=\"ROWID\">ROWID</a>, <a href=\"https://www.orafaq.com/wiki/ROWNUM\" title=\"ROWNUM\">ROWNUM</a>, <a href=\"https://www.orafaq.com/wiki/UID\" title=\"UID\">UID</a>, <a href=\"https://www.orafaq.com/wiki/USER\" title=\"USER\">USER</a>, LEVEL, CURRVAL, NEXTVAL, ORA_ROWSCN, etc.</p><p>Pseudocolumns are not actual columns in a table, but they behave like columns. For example, you can select values from a pseudocolumn. However, you cannot insert into, update, or delete from a pseudocolumn. Also note that pseudocolumns are allowed in SQL statements, but not in procedural statements.</p><p><a href=\"https://www.orafaq.com/wiki/Pseudo-column\">https://www.orafaq.com/wiki/Pseudo-column</a></p><p><br></p><p><strong>Row Locks (TX)</strong> A row lock, also called a TX lock, is a lock on a single row of a table. A transaction acquires a row lock for each row modified by one of the following statements: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>MERGE</code>, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code>. The row lock exists until the transaction commits or rolls back.</p><p>When a transaction obtains a row lock for a row, the transaction also acquires a table lock for the table in which the row resides. The table lock prevents conflicting DDL operations that would override data changes in a current transaction.</p><p><strong>Manual Data Locking</strong></p><p>Oracle Database always performs locking automatically to ensure data concurrency, data integrity, and statement-level read consistency. However, you can override the Oracle default locking mechanisms. This can be useful in situations such as the following:</p><p>• When your application requires consistent data for the duration of the transaction, not reflecting changes by other transactions, you can achieve transaction-level read consistency by using explicit locking, read-only transactions, serializable transactions, or by overriding default locking.</p><p>• When your application requires that a transaction have exclusive access to a resource so that the transaction does not have to wait for other transactions to complete, you can explicitly lock the data for the duration of the transaction.</p><p><br></p><p><strong>You can override automatic locking at two levels:</strong></p><p>• <strong>Transaction.</strong> You can override transaction-level locking with the following SQL statements:</p><p>&nbsp; &nbsp; &nbsp;• SET TRANSACTION ISOLATION LEVEL</p><p>&nbsp; &nbsp; &nbsp;• LOCK TABLE</p><p>&nbsp; &nbsp; &nbsp;• SELECT ... FOR UPDATE</p><p>Locks acquired by these statements are released after the transaction commits or rolls back.</p><p>• <strong>Session.</strong> A session can set the required transaction isolation level with an ALTER SESSION SET ISOLATION LEVEL statement.</p><p><a href=\"https://docs.oracle.com/database/121/SQLRF/ap_locks003.htm#SQLRF55513\">https://docs.oracle.com/database/121/SQLRF/ap_locks003.htm#SQLRF55513</a></p>",
                "answers": [
                    "<p>Lock a set of rows in a table.</p>",
                    "<p>Drop pseudocolumns from a table.</p>",
                    "<p>Rename a table.</p>",
                    "<p>Drop several columns simultaneously from a table.</p>",
                    "<p>Enable or disable constraints on a table.</p>",
                    "<p>Restrict all DML statements on a table.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify three actions that can be performed using the ALTER TABLE command.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068277,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about sequences created in a single instance Oracle database. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "When the MAXVALUE limit for a sequence is reached, it can be increased by using the ALTER SEQUENCE statement. This allows for the continuation of generating sequence numbers beyond the previous limit set for the sequence.",
                    "DELETE  would not remove a sequence from the database. Sequences are typically dropped using the DROP SEQUENCE statement in Oracle Database, not through a DELETE command.",
                    "The numbers generated by an explicitly defined sequence can be used to insert data in multiple tables, not just one table. Sequences are independent objects in the database and can be referenced by multiple tables for generating unique identifiers.",
                    "CURRVAL is used to refer to the most recent sequence number that has been generated for a particular sequence. It allows for retrieving the current value of the sequence without incrementing it, providing a way to access the last generated value.",
                    "When a database instance shuts down abnormally, sequence numbers that have been cached but not used are not available again when the instance is restarted. The cached sequence numbers are lost in such cases, and the sequence will continue generating numbers from where it left off before the shutdown."
                ],
                "explanation": "<p>The <strong>two true statements</strong> about sequences in a single-instance Oracle database are:</p><p><strong>1. When the MAXVALUE limit for a sequence is reached, it can be increased by using the ALTER SEQUENCE statement.</strong></p><ul><li><p>You can use <code>ALTER SEQUENCE</code> to <strong>change the MAXVALUE</strong> of a sequence, allowing it to generate more values:</p><pre class=\"prettyprint linenums\">sql\nALTER SEQUENCE seq_name MAXVALUE 999999;</pre></li></ul><p><strong>2. CURRVAL is used to refer to the most recent sequence number that has been generated for a particular sequence.</strong></p><ul><li><p><code>CURRVAL</code> returns the <strong>current value</strong> of the sequence <strong>in your session</strong>, but only <strong>after</strong> <code>NEXTVAL</code> has been called at least once.</p></li></ul><p>False statements:</p><ul><li><p><strong>DELETE &lt;sequencename&gt; would remove a sequence from the database.</strong><br>Incorrect syntax. You use <code>DROP SEQUENCE sequence_name;</code> to remove a sequence, not <code>DELETE</code>.</p></li><li><p><strong>The numbers generated by an explicitly defined sequence can only be used to insert data into one table.</strong><br>False. A sequence is <strong>not bound to any table</strong>—it can be used to insert data into <strong>multiple tables</strong> or for any other purpose.</p></li><li><p><strong>When a database instance shuts down abnormally, sequence numbers that have been cached but not used are available again when the instance is restarted.</strong><br>Incorrect. <strong>Cached sequence numbers are lost</strong> during an abnormal shutdown and <strong>are not recovered</strong>.</p></li></ul><p>Use the <code>ALTER</code> <code>SEQUENCE</code> statement to change the increment, minimum and maximum values, cached numbers, and behaviour of an existing sequence. This statement affects only future sequence numbers.</p><p><strong>Semantics</strong></p><p>The keywords and parameters in this statement serve the same purposes they serve when you create a sequence.</p><p>To restart the sequence at a different number, you must drop and re-create it.</p><p>If you change the <code>INCREMENT</code> <code>BY</code> value before the first invocation of <code>NEXTVAL</code>, then some sequence numbers will be skipped. Therefore, if you want to retain the original <code>START</code> <code>WITH</code> value, you must drop the sequence and re-create it with the original <code>START</code> <code>WITH</code> value and the new <code>INCREMENT</code> <code>BY</code> value.</p><p>Oracle Database performs some validations. For example, a new <code>MAXVALUE</code> cannot be imposed that is less than the current sequence number.</p><p>Modifying a Sequence: Examples. This statement sets a new maximum value for the <code>customers_seq</code> sequence, which was created in <a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_6015.htm#i2092099\">\"Creating a Sequence: Example\"</a>:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER SEQUENCE customers_seq \n   MAXVALUE 1500;</pre><p><br></p><p><a href=\"http://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_2012.htm#SQLRF00817 \">http://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_2012.htm#SQLRF00817 </a><a href=\"https://docs.oracle.com/cd/A84870_01/doc/server.816/a76989/ch26.htm\">https://docs.oracle.com/cd/A84870_01/doc/server.816/a76989/ch26.htm</a></p><p><br></p><p><strong>Sequence Pseudocolumns</strong></p><p>A sequence is a schema object that can generate unique sequential values. These values are often used for primary and unique keys. You can refer to sequence values in SQL statements with these pseudocolumns:</p><p><code>CURRVAL</code>: Returns the current value of a sequence</p><p><code>NEXTVAL</code>: Increments the sequence and returns the next value</p><p>You must qualify <code>CURRVAL</code> and <code>NEXTVAL</code> with the name of the sequence:</p><pre class=\"prettyprint linenums\">sequence.CURRVAL\nsequence.NEXTVAL</pre><p><br></p><p>You can use <code>CURRVAL</code> and <code>NEXTVAL</code> in the following locations:</p><p>• The select list of a <code>SELECT</code> statement that is not contained in a subquery, materialized view, or view</p><p>• The select list of a subquery in an <code>INSERT</code> statement</p><p>• The <code>VALUES</code> clause of an <code>INSERT</code> statement</p><p>• The <code>SET</code> clause of an <code>UPDATE</code> statement</p><p><br></p><p>Restrictions on Sequence Values: You cannot use <code>CURRVAL</code> and <code>NEXTVAL</code> in the following constructs:</p><p>• A subquery in a <code>DELETE</code>, <code>SELECT</code>, or <code>UPDATE</code> statement</p><p>• A query of a view or of a materialized view</p><p>• A <code>SELECT</code> statement with the <code>DISTINCT</code> operator</p><p>• A <code>SELECT</code> statement with a <code>GROUP</code> <code>BY</code> clause or <code>ORDER</code> <code>BY</code> clause</p><p>• A <code>SELECT</code> statement that is combined with another <code>SELECT</code> statement with the <code>UNION</code>, <code>INTERSECT</code>, or <code>MINUS</code> set operator</p><p>• The <code>WHERE</code> clause of a <code>SELECT</code> statement</p><p>• The <code>DEFAULT</code> value of a column in a <code>CREATE</code> <code>TABLE</code> or <code>ALTER</code> <code>TABLE</code> statement</p><p>• The condition of a <code>CHECK</code> constraint</p><p>Within a single SQL statement that uses <code>CURRVAL</code> or <code>NEXTVAL</code>, all referenced <code>LONG</code> columns, updated tables, and locked tables must be located on the same database.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns002.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns002.htm</a></p>",
                "answers": [
                    "<p>When the MAXVALUE limit for a sequence is reached, it can be increased by using the ALTER SEQUENCE statement.</p>",
                    "<p>DELETE &lt;sequencename&gt; would remove a sequence from the database.</p>",
                    "<p>The numbers generated by an explicitly defined sequence can only be used to insert data in one table.</p>",
                    "<p>CURRVAL is used to refer to the most recent sequence number that has been generated for a particular sequence.</p>",
                    "<p>When a database instance shuts down abnormally, sequence numbers that have been cached but not used are available again when the instance is restarted.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two true statements about sequences created in a single instance Oracle database. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068279,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about single row functions.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Single-Row Functions](https://docs.oracle.com/database/121/SQLRF/functions002.htm#SQLRF51178)"
                ],
                "feedbacks": [
                    "Single row functions can accept multiple arguments, not just a single argument. These arguments can be columns, expressions, constants, or functions.",
                    "Single row functions can be nested to multiple levels, not limited to just two levels. This nesting allows for more complex transformations and calculations in SQL queries.",
                    "Arguments for single row functions can be column values, expressions, constants, functions, or even subqueries. They are not limited to just column values or constants.",
                    "Single row functions always return a single result row for every row of a queried table. This means that the function is applied individually to each row in the result set, producing a corresponding result for each row.",
                    "Single row functions have the capability to return a data type value different from the one that is referenced in the function. This flexibility allows for data type conversions and transformations to be performed within the function."
                ],
                "explanation": "<p>The <strong>two true statements</strong> about <strong>single-row functions</strong> are:</p><p><strong>1. They always return a single result row for every row of a queried table.</strong></p><ul><li><p>Single-row functions operate on <strong>each row individually</strong> and return <strong>one result per input row</strong>. For example, <code>UPPER(name)</code> returns one value per row.</p></li></ul><p><strong>2. They can return a data type value different from the one that is referenced.</strong></p><ul><li><p>A function can <strong>accept one data type</strong> and <strong>return a different one</strong>.<br>For example:</p><pre class=\"prettyprint linenums\">sql\nLENGTH('abc') -- accepts a VARCHAR2, returns a NUMBER\nTO_CHAR(SYSDATE) -- accepts a DATE, returns a VARCHAR2</pre></li></ul><p>False statements:</p><ul><li><p><strong>\"They accept only a single argument.\"</strong><br>False. Some functions take <strong>multiple arguments</strong>, like <code>REPLACE(column, 'a', 'b')</code>.</p></li><li><p><strong>\"They can be nested only to two levels.\"</strong><br>False. Nesting is <strong>not limited to two levels</strong>; you can nest many levels deep (practical limit depends on DBMS and readability).</p></li><li><p><strong>\"Arguments can only be column values or constants.\"</strong><br>False. Arguments can also be <strong>expressions</strong>, <strong>literals</strong>, <strong>other functions</strong>, etc.</p></li></ul><p>Oracle provides single-row functions to manipulate the data values. The single-row functions operate on single rows and return only one result per row. In general, <strong>the functions take one or more inputs as arguments and return a single value as output</strong>. The arguments can be a user-supplied constant, variable, column name, or expression.</p><p>The features of single row functions are:</p><ul><li><p>Act on each row returned in the query.</p></li><li><p> Perform calculations on data. </p></li><li><p>Modify the data items. </p></li><li><p>Manipulate the output for groups of rows. </p></li><li><p>Format numbers and dates. </p></li><li><p>Converts column data types. </p></li><li><p>Returns one result per row. </p></li><li><p>Used in SELECT, WHERE, and ORDER BY clauses. </p></li><li><p>Single-row functions can be nested.</p></li></ul><p>The single row functions are categorized into:</p><ul><li><p><strong>Character Functions:</strong> Character functions accept character inputs and can return either character or number values as output.</p></li><li><p> <strong>Number Functions:</strong> Number functions accept numeric inputs and return only numeric values as output. </p></li><li><p><strong>Date Functions:</strong> Date functions operate on the date data type and return a date value or a numeric value. </p></li><li><p><strong>Conversion Functions:</strong> Converts from one data type to another data type. </p></li><li><p><strong>General Functions:&nbsp; </strong>These functions can appear in select lists, <code>WHERE</code> clauses, <code>START WITH</code> and <code>CONNECT BY </code>clauses, and <code>HAVING</code> clauses.</p></li></ul>",
                "answers": [
                    "<p>They accept only a single argument.</p>",
                    "<p>They can be nested only to two levels.</p>",
                    "<p>Arguments can only be column values or constants.</p>",
                    "<p>They always return a single result row for every row of a queried table.</p>",
                    "<p>They can return a data type value different from the one that is referenced.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two true statements about single row functions.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068281,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE orders\nSET UNUSED (ORDER_DATE);</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "After executing the ALTER TABLE command, a new column called ORDER_DATE can be added to the ORDERS table. This command allows for the addition of a new column to an existing table in the database schema.",
                    "The presence or absence of data in the ORDER_DATE column does not affect the execution of the ALTER TABLE command. The command is focused on modifying the structure of the table by adding a new column, regardless of the data within the table.",
                    "ROLLBACK is used to undo changes made during a transaction, such as adding a new column to a table. However, in this scenario, the question does not mention any transaction or changes that need to be rolled back, so this option is not applicable.",
                    "The DESCRIBE command is used to display the structure of a table, including its columns. After executing the ALTER TABLE command to add the ORDER_DATE column, the DESCRIBE command would indeed display the newly added column in the ORDERS table."
                ],
                "explanation": "<p>The <strong>correct result</strong> of the query:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE orders\nSET UNUSED (ORDER_DATE);</pre><p><br></p><p>Is: After executing the ALTER TABLE command, a new column called ORDER_DATE can be added to the ORDERS table.</p><p><br></p><p>Explanation:</p><ul><li><p>The <code>SET UNUSED</code> command <strong>logically removes</strong> a column from the table by marking it as <strong>UNUSED</strong>.</p></li><li><p>The column <strong>is not physically dropped immediately</strong>, but it <strong>no longer appears</strong> in queries or <code>DESCRIBE</code> outputs.</p></li><li><p>Since it is considered unused, <strong>you can add a new column with the same name</strong> (<code>ORDER_DATE</code>) after this command.</p></li><li><p><strong>ROLLBACK will not restore</strong> the column—it is a <strong>DDL operation</strong>, which commits automatically.</p></li><li><p>The <code>DESCRIBE</code> command <strong>will not display</strong> the unused column.</p></li></ul><p>Incorrect options:</p><ul><li><p><strong>\"The ORDER_DATE column must be empty...\"</strong><br>False – the column <strong>does not need to be empty</strong> to be marked UNUSED.</p></li><li><p><strong>\"ROLLBACK can be used...\"</strong><br>False – <code>ALTER TABLE ... SET UNUSED</code> is a DDL statement and <strong>commits automatically</strong>, so <strong>ROLLBACK won't undo it</strong>.</p></li><li><p><strong>\"The DESCRIBE command would still display...\"</strong><br>False – <strong>UNUSED columns are hidden</strong> from <code>DESCRIBE</code> and cannot be accessed in queries.</p></li></ul><p>A column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.</p><p>This is done by using the <code>ALTER TABLE...SET UNUSED</code> statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. </p><p>To mark the <code>hiredate</code> and <code>mgr</code> columns as unused, execute the following statement:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE hr.admin_emp SET UNUSED (hiredate, mgr);</pre><p><br></p><p>You can later remove columns that are marked as unused by issuing an <code>ALTER TABLE...DROP UNUSED COLUMNS</code> statement. Unused columns are also removed from the target table whenever an explicit drop of any particular column or columns of the table is issued.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables006.htm#ADMIN11660\">https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables006.htm#ADMIN11660</a></p><p><br></p><p>Once you mark the column unused, there is no practical way to get that column and its data back into the table, short of a database restore.</p><p><a href=\"https://community.oracle.com/thread/569809\">https://community.oracle.com/thread/569809</a></p><p><br></p><p><code>DESCRIBE </code>lists the column definitions for the specified table, view, or synonym, or the specifications for the specified function or procedure. </p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14357/ch12019.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14357/ch12019.htm</a></p><p><br></p><p>Once a column has been marked as <code>UNUSED</code> it is no longer part of the table and is not displayed in the table description. That said, the data dictionary views <code>USER_UNUSED_COL_TABS</code>, <code>ALL_UNUSED_COL_TABS</code>, or <code>DBA_UNUSED_COL_TABS</code> can be used to list all tables containing unused columns. The <code>COUNT</code> field shows the number of unused columns in the table.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables006.htm#ADMIN11660\">https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables006.htm#ADMIN11660</a></p>",
                "answers": [
                    "<p>After executing the ALTER TABLE command, a new column called ORDER_DATE can be added to the ORDERS table.</p>",
                    "<p>The ORDER_DATE column must be empty for the ALTER TABLE command to execute successfully.</p>",
                    "<p>ROLLBACK can be used to restore the ORDER_DATE column.</p>",
                    "<p>The DESCRIBE command would still display the ORDER_DATE column.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL query.Exhibit: 1ALTER TABLE orders\nSET UNUSED (ORDER_DATE);Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068283,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify three true statements about system and object privileges (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The WITH GRANT OPTION can be used when granting an object privilege to both users and roles, allowing the recipient to further grant the same privilege to other users or roles.",
                    "Adding a primary key constraint to an existing table in another schema requires a system privilege, as it involves modifying the structure of the table, which is a system-level operation.",
                    "Adding a foreign key constraint pointing to a table in another schema requires the REFERENCES object privilege, as it involves referencing columns from another table, which is considered an object-level operation.",
                    "Revoking a system privilege that was granted with WITH ADMIN OPTION does not have a cascading effect, as the WITH ADMIN OPTION only allows the grantee to further grant the same privilege to others.",
                    "Revoking an object privilege that was granted with the WITH GRANT OPTION clause has a cascading effect, as it also revokes the privilege from any users or roles that were granted the privilege by the original grantee.",
                    "The WITH GRANT OPTION cannot be used when granting an object privilege to PUBLIC, as granting privileges to the PUBLIC role automatically grants the privilege to all users in the database, and the WITH GRANT OPTION is not applicable in this scenario."
                ],
                "explanation": "<p>The <strong>three true statements</strong> about <strong>system and object privileges</strong> are:</p><p><strong>1. Adding a primary key constraint to an existing table in another schema requires a system privilege</strong></p><ul><li><p>To modify objects <strong>in another schema</strong>, including adding constraints like a <strong>primary key</strong>, you need system privileges such as <code>ALTER ANY TABLE</code>.</p></li></ul><p><strong>2. Adding a foreign key constraint pointing to a table in another schema requires the REFERENCES object privilege</strong></p><ul><li><p>To <strong>reference</strong> a table (i.e., create a foreign key pointing to it), you must have the <code>REFERENCES</code> <strong>object privilege</strong> on the parent table.</p></li></ul><p><strong>3. Revoking an object privilege that was granted with the WITH GRANT OPTION clause has a cascading effect</strong></p><ul><li><p>If a user is granted an object privilege <strong>with </strong><code><strong>WITH GRANT OPTION</strong></code>, and they in turn grant it to others, <strong>revoking</strong> their privilege will also <strong>revoke it from everyone they granted it to</strong>—this is the <strong>cascading effect</strong>.</p></li></ul><p>False statements:</p><ul><li><p><strong>\"WITH GRANT OPTION can be used when granting an object privilege to both users and roles.\"</strong><br>False. You <strong>cannot</strong> grant an object privilege <strong>with </strong><code><strong>WITH GRANT OPTION</strong></code><strong> to a role</strong>—only to users.</p></li><li><p><strong>\"Revoking a system privilege that was granted with WITH ADMIN OPTION has a cascading effect.\"</strong><br>False. <strong>System privileges</strong> do <strong>not cascade</strong> when revoked, even if granted with <code>WITH ADMIN OPTION</code>.</p></li><li><p><strong>\"WITH GRANT OPTION cannot be used when granting an object privilege to PUBLIC\"</strong><br>False. While <strong>rarely done</strong>, it <strong>is allowed</strong> to grant an object privilege <strong>with </strong><code><strong>WITH GRANT OPTION</strong></code><strong> to PUBLIC</strong>—though it's <strong>highly discouraged</strong> for security reasons.</p></li></ul><p>In a database, every user account can be granted a number of <em>privileges</em>, which are also known as <em>permissions</em>. These privileges allow a particular user account to do certain things, like <code>DELETE</code> and <code>UPDATE</code> certain tables, <code>CREATE</code> a database, <code>SELECT</code> from a certain table, and many other things.</p><p>Privileges are further divided into two different categories: </p><p>1. System privileges </p><p>2 Object privileges.</p><p><strong>System Privileges</strong></p><p>System privileges are privileges given to users to allow them to perform certain functions that deal with <em>managing the database and the server</em>. Most of the different types of permissions supported by the database vendors fall under the system privilege category. Only the instance administrator or a user with <code>ADMIN</code> privilege can <code>GRANT</code> or <code>REVOKE</code> system privileges.</p><p><strong>Object Privileges</strong></p><p>Object privileges are privileges given to users so that they can perform certain actions upon certain database objects, where database objects are things like tables, stored procedures, indexes, etc. Some examples of object privileges include granting a particular database user the right to DELETE and/or SELECT from a particular table. This is done using the GRANT clause</p><p><strong>The difference</strong> between system and object privileges is that system privileges are used for server and database privileges. But object privileges are used to grant privileges on database objects like tables, stored procedures, indexes, etc.</p><p><a href=\"https://www.programmerinterview.com/database-sql/system-privileges-vs-object-privileges/\">https://www.programmerinterview.com/database-sql/system-privileges-vs-object-privileges/</a></p><p><br></p><p>To create an index in another schema, you must have the <code>CREATE ANY INDEX</code> system privilege. Also, for the owner of the schema to contain the index, they must have either the <code>UNLIMITED TABLESPACE</code> system privilege or a space quota on the tablespaces to contain the index or index partitions.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm</a></p><p><br></p><p><strong>Application Roles</strong></p><p>You grant an application role all privileges necessary to run a given database application. Then, you grant the application role to other roles or to specific users. An application can have several different roles, with each role assigned a different set of privileges that allow for more or less data access while using the application.</p><p><strong> User Roles</strong></p><p>You create a user role for a group of database users with common privilege requirements. You manage user privileges by granting application roles and privileges to the user role and then granting the user role to appropriate users.</p><p><strong>The Mechanisms of Roles</strong></p><p>Database roles have the following functionality:</p><p>• A role can be granted system or schema object privileges.</p><p>• A role can be granted to other roles. However, a role cannot be granted to itself and cannot be granted circularly (for example, role A cannot be granted to role B if role B has previously been granted to role A).</p><p>• Any role can be granted to any database user.</p><p>Each role granted to a user is, at a given time, either enabled or disabled. A user's security domain includes the privileges of all roles currently enabled for the user and excludes the privileges of any roles currently disabled for the user. Oracle allows database applications and users to enable and disable roles to provide selective availability of privileges.</p><p>An indirectly granted role (a role granted to a role) can be explicitly enabled or disabled for a user. However, by enabling a role that contains other roles, you implicitly enable all indirectly granted roles of the directly granted role.</p><p><strong> Granting and Revoking Roles</strong></p><p>You grant or revoke roles from users or other roles using the following options:</p><p>• the Grant System Privileges/Roles dialog box and Revoke System Privileges/Roles dialog box of Oracle Enterprise Manager</p><p>• the SQL commands GRANT and REVOKE</p><p>Privileges are granted to and revoked from roles using the same options. Roles can also be granted to and revoked from users using the operating system that executes Oracle, or through network services.</p><p><a href=\"https://docs.oracle.com/cd/A58617_01/server.804/a58227/ch18.htm\">https://docs.oracle.com/cd/A58617_01/server.804/a58227/ch18.htm</a></p><p><br></p><p>The <code>REFERENCES</code> privilege <code>on</code> a parent table implicitly grants <code>SELECT</code> privilege on the parent table, so a user can create a foreign key dependency on a table or materialized view.</p><p><a href=\"https://docs.oracle.com/database/121/TTSQL/privileges.htm#TTSQL338\">https://docs.oracle.com/database/121/TTSQL/privileges.htm#TTSQL338</a></p><p><br></p><p>To grant an object privilege on all other types of objects, you must own the object, or the owner of the object must have granted you the object privileges with the <code>WITH GRANT OPTION</code>, or you must have been granted the <code>GRANT ANY OBJECT</code> <code>PRIVILEGE</code> system privilege. If you have the <code>GRANT ANY OBJECT PRIVILEGE</code>, then you can grant the object privilege only if the object owner could have granted the same object privilege. In this case, the <code>GRANTOR</code> column of the <code>*_TAB_PRIVS</code> views displays the object owner rather than the user who issued the <code>GRANT</code> statement.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/GRANT.html#GUID-20B4E2C0-A7F8-4BC8-A5E8-BE61BDC41AC3\">https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/GRANT.html#GUID-20B4E2C0-A7F8-4BC8-A5E8-BE61BDC41AC3</a></p><p><br></p><p><code>WITH GRANT OPTION</code> cannot be used with roles. The owner of an object can grant it to another user/PUBLIC (but not to a role), and the new grantee can then grant the same level of access to other users or roles. You can specify <code>WITH GRANT OPTION</code> only when granting to a user or to PUBLIC, not when granting to a role.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9013.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9013.htm</a></p>",
                "answers": [
                    "<p>WITH GRANT OPTION can be used when granting an object privilege to both users and roles</p>",
                    "<p>Adding a primary key constraint to an existing table in another schema requires a system privilege</p>",
                    "<p>Adding a foreign key constraint pointing to a table in another schema requires the REFERENCES object privilege</p>",
                    "<p>Revoking a system privilege that was granted with WITH ADMIN OPTION has a cascading effect</p>",
                    "<p>Revoking an object privilege that was granted with the WITH GRANT OPTION clause has a cascading effect</p>",
                    "<p>WITH GRANT OPTION cannot be used when granting an object privilege to PUBLIC</p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify three true statements about system and object privileges (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068285,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements regarding a SAVEPOINT (Choose two).</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "A SAVEPOINT does not issue a COMMIT, which means that it does not permanently save the changes made in the transaction. It allows for a partial rollback without committing the entire transaction.",
                    "Contrary to the statement, multiple SAVEPOINTs can be issued within a single transaction. Each SAVEPOINT allows for a specific point within the transaction to be marked for potential rollback.",
                    "Rolling back to a SAVEPOINT cannot undo a TRUNCATE statement. TRUNCATE is a DDL (Data Definition Language) statement that cannot be rolled back using a SAVEPOINT.",
                    "Rolling back to a SAVEPOINT cannot undo a CREATE INDEX statement. CREATE INDEX is a DDL (Data Definition Language) statement that cannot be rolled back using a SAVEPOINT.",
                    "Rolling back to a SAVEPOINT can undo a DELETE statement. DELETE is a DML (Data Manipulation Language) statement that can be rolled back using a SAVEPOINT to revert the changes made by the DELETE operation."
                ],
                "explanation": "<p>The <strong>two true statements</strong> regarding a <strong>SAVEPOINT</strong> are:</p><p><strong>1. A SAVEPOINT does not issue a COMMIT</strong></p><ul><li><p>A <code>SAVEPOINT</code> simply <strong>marks a point</strong> within a transaction to which you can roll back—<strong>it does not commit</strong> the transaction or any changes.</p></li></ul><p><strong>2. Rolling back to a SAVEPOINT can undo a DELETE statement</strong></p><ul><li><p>A <code>ROLLBACK TO SAVEPOINT</code> <strong>can undo DML operations</strong> like <code>DELETE</code>, <code>INSERT</code>, or <code>UPDATE</code> performed after the savepoint was set.</p></li></ul><p>False statements:</p><ul><li><p><strong>\"Only one SAVEPOINT may be issued in a transaction.\"</strong><br>False. You can create <strong>multiple SAVEPOINTs</strong> in a single transaction.</p></li><li><p><strong>\"Rolling back to a SAVEPOINT can undo a TRUNCATE statement.\"</strong><br>False. <code>TRUNCATE</code> is a <strong>DDL</strong> statement that performs an <strong>implicit COMMIT</strong>, so it <strong>cannot be rolled back</strong>.</p></li><li><p><strong>\"Rolling back to a SAVEPOINT can undo a CREATE INDEX statement.\"</strong><br>False. <code>CREATE INDEX</code> is also <strong>DDL</strong>, which <strong>auto-commits</strong>—so it's <strong>not affected</strong> by savepoints.</p></li></ul><p>A <code>SAVEPOINT</code> is a marker within a transaction that allows for a partial <code>ROLLBACK</code>. As changes are made in a transaction, we can create <code>SAVEPOINTS</code> to mark different points within the transaction. If we encounter an error, we can rollback to a <code>SAVEPOINT</code> or all the way back to the beginning of the transaction.</p><p>Row locks are NOT released by <code>SETTING</code> a <code>SAVEPOINT</code>. Row locks are released by one of three events - <code>COMMIT</code>, <code>ROLLBACK</code>, or <code>ROLLBACK</code> to <code>SAVEPOINT</code>. A <code>SAVEPOINT</code> does not issue a <code>COMMIT</code>.</p><p><a href=\"http://www.dba-oracle.com/t_savepoint.htm\">http://www.dba-oracle.com/t_savepoint.htm</a></p><p><br></p><p>Note that a <code>COMMIT</code> removes all the <code>SAVEPOINTS</code> that may have been set earlier in the transaction.</p><p><a href=\"http://psoug.org/definition.htm/SAVEPOINT.htm\">http://psoug.org/definition.htm/SAVEPOINT.htm</a></p><p><br></p><p>To create a <code>SAVEPOINT</code>, specify the name of the <code>SAVEPOINT</code> to be created. <code>SAVEPOINT</code> names must be distinct within a given transaction. If you create a second <code>SAVEPOINT</code> with the same identifier as an earlier <code>SAVEPOINT</code>, then the earlier <code>SAVEPOINT</code> is erased. After a <code>SAVEPOINT</code> has been created, you can either continue processing, <code>COMMIT</code> your work, roll back the entire transaction, or <code>ROLLBACK</code> to the <code>SAVEPOINT</code>. More than one <code>SAVEPOINT</code> can be issued per transaction. </p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_10001.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_10001.htm</a></p><p><br></p><p>There is no actual limit on the number of <code>SAVEPOINTS</code> allowed in a transaction; it is more a question of system resources.</p><p><a href=\"https://stackoverflow.com/questions/39542862/how-many-savepoints-are-allowed-in-oracle-sql\">https://stackoverflow.com/questions/39542862/how-many-savepoints-are-allowed-in-oracle-sql</a></p><p><br></p><p>In Oracle, a DDL statement is a transaction in its own right simply because an implicit <code>COMMIT</code> is issued before the statement is executed and again afterwards. </p><p>This means that when a DDL statement is issued, it cannot be <code>ROLLEDBACK</code>. This also means that statements which do not <code>COMMIT</code> can be <code>ROLLEDBACK</code>.</p><p><a href=\"https://stackoverflow.com/questions/9541013/oracle-what-statements-need-to-be-committed\">https://stackoverflow.com/questions/9541013/oracle-what-statements-need-to-be-committed</a></p><p><br></p><p><strong>DDL - Data Definition Language</strong>: statements used to define the database structure or schema <strong>CANNOT BE </strong><code><strong>ROLLEDBACK</strong></code><strong> </strong>because they issue an implicit <code>COMMIT</code>. </p><p> CREATE - to create objects in the database (All statements beginning with CREATE)</p><p> ALTER - alters the structure of the database (All statements beginning with ALTER)</p><p> DROP - delete objects from the database</p><p> TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed</p><p> COMMENT - add comments to the data dictionary</p><p> RENAME - rename an object</p><p><a href=\"http://www.orafaq.com/wiki/SQL_FAQ#What_are_the_difference_between_DDL.2C_DML_and_DCL_commands.3F\">http://www.orafaq.com/wiki/SQL_FAQ#What_are_the_difference_between_DDL.2C_DML_and_DCL_commands.3F</a></p>",
                "answers": [
                    "<p>A SAVEPOINT does not issue a COMMIT</p>",
                    "<p>Only one SAVEPOINT may be issued in a transaction</p>",
                    "<p>Rolling back to a SAVEPOINT can undo a TRUNCATE statement</p>",
                    "<p>Rolling back to a SAVEPOINT can undo a CREATE INDEX statement</p>",
                    "<p>Rolling back to a SAVEPOINT can undo a DELETE statement</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two true statements regarding a SAVEPOINT (Choose two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068287,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit and the available responses.</p><p><strong>Required:</strong> Match the relationship examples which follow.</p><p><strong>Exhibit: 1</strong></p><ol><li><p>One-to-one</p></li><li><p>One-to-many</p></li><li><p>Many-to-one</p></li><li><p>Many-to-many</p></li></ol><p><strong>Exhibit: 2</strong></p><p>a. Teacher-to-student</p><p>b. Employee-to-manager</p><p>c. Person-to-SSN</p><p>d. Customers-to-products</p><p><br></p><p>Identify the response that indicates correctly matched relationships.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Define a relationship](https://docs.oracle.com/html/E79061_01/Content/Data%2520model/Define_a_relationship.htm)"
                ],
                "feedbacks": [
                    "This choice does not correctly match the relationships provided in the SQL exhibit. It is important to carefully examine the relationships and their corresponding examples to ensure accurate matching.",
                    "This choice does not correctly match the relationships provided in the SQL exhibit. It is crucial to review the relationships and examples to accurately match them.",
                    "This choice does not correctly match the relationships provided in the SQL exhibit. It is essential to analyze the relationships and examples to make the correct matches.",
                    "This choice correctly matches the relationships provided in the SQL exhibit. It is crucial to carefully evaluate the relationships and examples to accurately match them."
                ],
                "explanation": "<p>Correct Response: <strong>1-c, 2-a, 3-b, and 4-d</strong></p><p>To solve this, we need to match the types of relationships from <strong>Exhibit 1</strong> to the examples in <strong>Exhibit 2</strong>:</p><p><strong>Exhibit 1: Relationship Types</strong></p><ol><li><p><strong>One-to-one</strong></p></li><li><p><strong>One-to-many</strong></p></li><li><p><strong>Many-to-one</strong></p></li><li><p><strong>Many-to-many</strong></p></li></ol><p><strong>Exhibit 2: Relationship Examples</strong></p><p>a. <strong>Teacher-to-student</strong> – One teacher has many students → <strong>One-to-many</strong><br>b. <strong>Employee-to-manager</strong> – Many employees can have the same manager → <strong>Many-to-one</strong><br>c. <strong>Person-to-SSN</strong> – One person has one SSN, and one SSN is assigned to one person → <strong>One-to-one</strong><br>d. <strong>Customers-to-products</strong> – Many customers can buy many products → <strong>Many-to-many</strong></p><p><strong>Correct Matching:</strong></p><ol><li><p><strong>One-to-one</strong> → <strong>c. Person-to-SSN</strong></p></li><li><p><strong>One-to-many</strong> → <strong>a. Teacher-to-student</strong></p></li><li><p><strong>Many-to-one</strong> → <strong>b. Employee-to-manager</strong></p></li><li><p><strong>Many-to-many</strong> → <strong>d. Customers-to-products</strong></p></li></ol><p><br></p><p><strong>Understand the different types of relationships</strong></p><p><strong>One-to-One</strong></p><p>A one-to-one relationship is where one entity instance interacts only with one other entity instance.</p><p>One person can only have one SSN (Social Security Number), which is an identification number issued to each citizen in the USA. This is equivalent to other countries, which use identifiers such as SIN (Social Insurance Number), Cédula de Ciudadanía, etc.</p><p><img src=\"https://docs.oracle.com/html/E79061_01/Content/Resources/Images/Diagrams/Relationship%20one%20to%20one.png\"></p><p><br></p><p><strong>One-to-Many</strong></p><p>A one-to-many relationship is where one entity instance interacts with many other entity instances. This is the traditional hierarchical model relationship.</p><p>Teachers can have more than one student.</p><p><img src=\"https://docs.oracle.com/html/E79061_01/Content/Resources/Images/Diagrams/Relationship%20one%20to%20many.png\"></p><p><br></p><p><strong>Many-to-One</strong></p><p>A many-to-one relationship is where many entity instances belong to only one entity instance.</p><p>More than one employee can report to one manager.</p><p><img src=\"https://docs.oracle.com/html/E79061_01/Content/Resources/Images/Diagrams/Relationship%20many%20to%20one.png\"></p><p><br></p><p><strong>Many-to-Many</strong></p><p>A many-to-many relationship is where multiple instances can interact with many other entity instances.</p><p>Many customers purchase more than one product.</p><p><img src=\"https://docs.oracle.com/html/E79061_01/Content/Resources/Images/Diagrams/Relationship%20many%20to%20many.png\"></p>",
                "answers": [
                    "<p>1-d, 2-b, 3-a, and 4-c</p>",
                    "<p>1-a, 2-d, 3-c, and 4-b</p>",
                    "<p>1-a, 2-b, 3-c, and 4-d</p>",
                    "<p>1-c, 2-a, 3-b, and 4-d</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL exhibit and the available responses.Required: Match the relationship examples which follow.Exhibit: 1One-to-oneOne-to-manyMany-to-oneMany-to-manyExhibit: 2a. Teacher-to-studentb. Employee-to-managerc. Person-to-SSNd. Customers-to-productsIdentify the response that indicates correctly matched relationships.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068289,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the BOOKS table and exhibits.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DESC books</pre><p><br></p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">Name                 Null??            Type\nBOOK_ID              NOT NULL          CHAR(6)\nTITLE                NOT NULL          VARCHAR2(100)\nPUBLISHER                              VARCHAR2(4)\nAUTHOR_ID                              VARCHAR2(50)</pre><p><br></p><p><strong>Given</strong>: The BOOKS table contains details of 100 books. </p><p>Examine the following commands executed and their outcomes.&nbsp;</p><p><strong>Exhibit: 3</strong></p><pre class=\"prettyprint linenums\">INSERT INTO books\nVALUES\n('ADV112', 'Adventures of Tom Sawyer', null, null);\n\n1 row created.\n\nSAVEPOINT A;\nSavepoint created.\n\nDELETE FROM books;\n101 rows deleted.\n\nROLLBACK TO SAVEPOINT A;\nRollback complete\n\nROLLBACK;\nRollback complete.</pre><p><br></p><p>Indicate the statement that is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Both ROLLBACK commands cannot restore more rows than the total number of rows that were deleted. It is not possible for the first rollback to restore 101 rows when only 100 rows were deleted.",
                    "Both ROLLBACK commands cannot restore more rows than the total number of rows that were deleted. It is not possible for the first rollback to restore 100 rows when only 100 rows were deleted.",
                    "<p>The first rollback command can only restore the changes made by the last transaction, which in this case is the deletion of 101 rows. </p>",
                    "The first rollback command can only restore the changes made by the last transaction, which in this case is the deletion of 101 rows. The second rollback command does not commit any changes, it only undoes the last transaction."
                ],
                "explanation": "<p><strong>What we know: Table Structure (BOOKS)</strong></p><ul><li><p>Has 100 existing rows.</p></li></ul><p><strong>Executed SQL Commands (in order):</strong></p><pre class=\"prettyprint linenums\">sql\n-- Step 1: Insert a new row\nINSERT INTO books VALUES ('ADV112', 'Adventures of Tom Sawyer', null, null);\n-- Table now has 101 rows.\n\n-- Step 2: Create a savepoint after the insert\nSAVEPOINT A;\n\n-- Step 3: Delete all rows\nDELETE FROM books;\n-- Table now has 0 rows.\n\n-- Step 4: Roll back to savepoint A\nROLLBACK TO SAVEPOINT A;\n-- Deletes are undone, insert remains. Table has 101 rows again.\n\n-- Step 5: Full rollback\nROLLBACK;\n-- Undoes everything in the transaction (including the INSERT). Table returns to 100 rows (original state).</pre><p><br></p><p><strong>Breakdown of Behaviour:</strong></p><p><code>ROLLBACK TO SAVEPOINT A;</code></p><ul><li><p>Reverts all changes made <em>after</em> savepoint A.</p></li><li><p>The delete is undone, but the insert (before the savepoint) remains.</p></li><li><p>Table state: <strong>101 rows (inserted row still present)</strong>.</p></li><li><p>The inserted row is <strong>still uncommitted</strong>, because there's been <strong>no COMMIT</strong> yet.</p></li></ul><p><code>ROLLBACK;</code></p><ul><li><p>Reverts the entire transaction — both the insert and the delete.</p></li><li><p>The inserted row is also removed.</p></li><li><p>Final state: <strong>100 rows (original data only).</strong></p></li></ul><p>Now, Let’s Review the Options:</p><ol><li><p><strong>\"Both ROLLBACK commands restore the 101 rows that were deleted.\"</strong></p><ul><li><p>Incorrect. The second rollback removes the inserted row. Final count = 100 rows.</p></li></ul></li><li><p><strong>\"Both ROLLBACK commands restore the 100 rows that were deleted.\"</strong></p><ul><li><p>Incorrect phrasing — the first rollback restores <strong>101</strong> rows (including inserted), not just 100.</p></li></ul></li><li><p><strong>\"The first rollback restores the 101 rows that were deleted, leaving the inserted row uncommitted.\"</strong></p><ul><li><p><strong>Correct.</strong> This is the best and most accurate description.</p></li></ul></li><li><p><strong>\"The first rollback restores the 100 rows that were deleted, and the second rollback commits only the changes.\"</strong></p><ul><li><p>Completely incorrect — rollback never <strong>commits</strong> anything; it <strong>reverts</strong>.</p></li></ul></li></ol><p><strong>Correct Answer:</strong></p><p><strong>\"The first rollback restores the 101 rows that were deleted, leaving the inserted row uncommitted.\"</strong></p><p>The first <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROLLBACK.html\">ROLLBACK</a> undoes everything back to but not including the specified <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/SAVEPOINT.html\">SAVEPOINT</a>, which is 'SAVEPOINT A'. </p><p>The second ROLLBACK command undoes the insert.</p>",
                "answers": [
                    "<p>Both ROLLBACK commands restore the 101 rows that were deleted.</p>",
                    "<p>Both ROLLBACK commands restore the 100 rows that were deleted.</p>",
                    "<p>The first rollback restores the 101 rows that were deleted leaving the inserted row uncommitted.</p>",
                    "<p>The first rollback restores the 100 rows that were deleted and the second rollback commits only the changes.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the BOOKS table and exhibits.Exhibit: 1DESC booksExhibit: 2Name                 Null??            Type\nBOOK_ID              NOT NULL          CHAR(6)\nTITLE                NOT NULL          VARCHAR2(100)\nPUBLISHER                              VARCHAR2(4)\nAUTHOR_ID                              VARCHAR2(50)Given: The BOOKS table contains details of 100 books. Examine the following commands executed and their outcomes.&nbsp;Exhibit: 3INSERT INTO books\nVALUES\n('ADV112', 'Adventures of Tom Sawyer', null, null);\n\n1 row created.\n\nSAVEPOINT A;\nSavepoint created.\n\nDELETE FROM books;\n101 rows deleted.\n\nROLLBACK TO SAVEPOINT A;\nRollback complete\n\nROLLBACK;\nRollback complete.Indicate the statement that is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068291,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the SQL WHERE and HAVING clauses (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Difference Between HAVING and WHERE clause](https://community.oracle.com/thread/492935)",
                    "[Aggregate Functions](https://docs.oracle.com/database/121/SQLRF/functions003.htm#SQLRF20035)"
                ],
                "feedbacks": [
                    "The HAVING clause is used to filter rows after the GROUP BY clause has grouped the data. It allows the use of aggregating functions such as SUM, AVG, COUNT, etc., to filter the grouped data based on specific conditions.",
                    "The HAVING clause operates on the result set that is produced by the GROUP BY clause. It can reference the column aliases defined in the SELECT statement, making it possible to use aliases in the conditions specified in the HAVING clause.",
                    "The WHERE and HAVING clauses serve different purposes in a SQL statement. The WHERE clause is used to filter rows before any grouping is done, while the HAVING clause is used to filter grouped data after the grouping has been applied. They can be used together in a SQL statement to apply both row-level and group-level filters.",
                    "The WHERE clause is used to filter rows before any grouping is done in a SQL statement. It is applied to individual rows in the result set, excluding rows that do not meet the specified conditions before any grouping is performed.",
                    "The HAVING clause is used to filter grouped data after the GROUP BY clause has been applied. It allows for the exclusion of aggregated results based on specific conditions, providing a way to filter the grouped data based on aggregate values."
                ],
                "explanation": "<p>Let's evaluate each of the given statements about the <code><strong>WHERE</strong></code> and <code><strong>HAVING</strong></code> clauses, and identify the <strong>three true</strong> ones.</p><p><strong>True Statements:</strong></p><ol><li><p><strong>The HAVING clause conditions can have aggregating functions.</strong><br><strong>True</strong> – The <code>HAVING</code> clause is specifically designed to filter on <strong>aggregated values</strong>, like:</p><pre class=\"prettyprint linenums\">sql\nHAVING COUNT(*) &gt; 5</pre></li><li><p><strong>The WHERE clause is used to exclude rows before grouping data.</strong><br><strong>True</strong> – <code>WHERE</code> filters <strong>individual rows</strong> before <code>GROUP BY</code> is applied.</p></li><li><p><strong>The HAVING clause is used to exclude one or more aggregated results after grouping data.</strong><br><strong>True</strong> – <code>HAVING</code> is used <strong>after aggregation</strong>, for example:</p><pre class=\"prettyprint linenums\">sql\nGROUP BY department\nHAVING AVG(salary) &gt; 50000</pre></li></ol><p><strong>False Statements:</strong></p><ol><li><p><strong>The HAVING clause conditions can use aliases for the columns.</strong><br><strong>False</strong> – You typically <strong>cannot</strong> use an alias defined in the <code>SELECT</code> clause inside <code>HAVING</code>. You should repeat the full expression or use the aggregate directly.</p></li><li><p><strong>The WHERE and HAVING clauses cannot be used together in a SQL statement.</strong><br><strong>False</strong> – You <strong>can absolutely</strong> use both together:</p><pre class=\"prettyprint linenums\">sql\nSELECT department, COUNT(*) AS total\nFROM employees\nWHERE active = 'Y'\nGROUP BY department\nHAVING COUNT(*) &gt; 10</pre></li></ol><p><br></p><p><strong>Where and Having</strong></p><ul><li><p><code>WHERE</code> clause executes just after the <code>FROM</code> clause.</p></li><li><p><code>WHERE</code> comes before the group by clause</p></li><li><p><code>WHERE</code> cannot use group functions</p></li><li><p><code>WHERE</code> clause restricts a few rows from taking part in any other operation like joins, functions, etc...</p></li></ul><p><br></p><ul><li><p><code>HAVING</code> comes after the group by clause</p></li><li><p><code>HAVING</code> can use the aggregate/group functions like <code>MAX</code> , <code>MIN</code> , <code>AVG</code>, <code>SUM</code>, etc.</p></li><li><p><code>HAVING</code> clause just hides a few rows from your eyes from the result set produced by the query.</p></li><li><p><code>HAVING</code> is the last clause to be executed.</p></li></ul><p><br></p><p>Aggregate functions can appear in select lists and in <code>ORDER BY</code> and <code>HAVING</code> clauses. They are commonly used with the <code>GROUP BY</code> clause in a <code>SELECT</code> statement, where Oracle Database divides the rows of a queried table or view into groups. In a query containing a <code>GROUP BY</code> clause, the elements of the select list can be aggregate functions, <code>GROUP BY</code> expressions, constants, or expressions involving one of these. Oracle applies the aggregate functions to each group of rows and returns a single result row for each group.</p>",
                "answers": [
                    "<p>The HAVING clause conditions can have aggregating functions.</p>",
                    "<p>The HAVING clause conditions can use aliases for the columns.</p>",
                    "<p>The WHERE and HAVING clauses cannot be used together in a SQL statement.</p>",
                    "<p>The WHERE clause is used to exclude rows before grouping data.</p>",
                    "<p>The HAVING clause is used to exclude one or more aggregated results after grouping data.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the SQL WHERE and HAVING clauses (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068293,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the TRANSACTIONS table.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">Name                  Null??               Type\nTRANS_ID              NOT NULL             NUMBER(6)\nCUST_NAME             NOT NULL             VARCHAR(20)\nCUST_STATUS           NOT NULL             CHAR\nTRANS_DATE            NOT NULL             DATE\nCUST_CREDIT_LIMIT                          NUMBER</pre><p><br></p><p>Identify the true statements regarding the creation and storage of data in the above table structure. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The CUST_STATUS column is defined as CHAR(1), which means it can store exactly one character. This statement is true based on the table structure provided.",
                    "<p>If the table read TRANS_VALIDITY VARCHAR2(1), then this would be a correct answer.</p>",
                    "The CUST_CREDIT_LIMIT column is defined as NUMBER, which can store decimal values. This statement is incorrect as the column can indeed store decimal values.",
                    "The CUST_STATUS column is defined as CHAR(1), which allows for exactly one character to be stored. There should not be an error related to this column based on the provided table structure.",
                    "<p>The TRANS_DATE column is defined as DATE, which can store day, month, century, year, hour, minutes, and seconds. This statement is true as DATE data type can store all the mentioned components.</p>",
                    "<p>These components are included in the <code>DATE</code> type. (Note: \"century\" is implicitly stored in the year.)</p>"
                ],
                "explanation": "<p><strong>Table Structure Analysis:</strong></p><ol><li><p><strong>TRANS_ID</strong> - <code>NUMBER(6) NOT NULL</code></p><ul><li><p>Stores numeric values <strong>up to 6 digits</strong> (integers only).</p></li></ul></li><li><p><strong>CUST_NAME</strong> - <code>VARCHAR(20) NOT NULL</code></p><ul><li><p>Stores <strong>up to 20 characters</strong>.</p></li></ul></li><li><p><strong>CUST_STATUS</strong> - <code>CHAR NOT NULL</code></p><ul><li><p>Since the length is <strong>not specified</strong>, it defaults to <strong>CHAR(1)</strong>, meaning it will store <strong>exactly one character</strong>.</p></li></ul></li><li><p><strong>TRANS_DATE</strong> - <code>DATE NOT NULL</code></p><ul><li><p>Oracle's <code>DATE</code> data type stores <strong>day, month, year, century, hour, minutes, and seconds</strong>.</p></li></ul></li><li><p><strong>CUST_CREDIT_LIMIT</strong> - <code>NUMBER</code></p><ul><li><p>The <code>NUMBER</code> data type <strong>can store both integers and decimal values</strong> unless explicitly restricted.</p></li></ul></li></ol><p><strong>Evaluating the Given Statements:</strong></p><ol><li><p><strong>The CUST_STATUS column would store exactly one character.</strong></p><ul><li><p><strong>True</strong>, because <code>CHAR</code> without a specified length defaults to <strong>CHAR(1)</strong>, meaning it stores exactly <strong>one</strong> character.</p></li></ul></li><li><p><strong>The TRANS_VALIDITY column would have a maximum size of one character.</strong></p><ul><li><p><strong>False</strong>, because <strong>there is no TRANS_VALIDITY column</strong> in the table.</p></li></ul></li><li><p><strong>The CUST_CREDIT_LIMIT column would not be able to store decimal values.</strong></p><ul><li><p><strong>False</strong>, because <code>NUMBER</code> <strong>can store both integers and decimal values</strong> unless explicitly defined with a specific scale.</p></li></ul></li><li><p><strong>The CUST_STATUS column would give an error.</strong></p><ul><li><p><strong>False</strong>, because <code>CHAR</code> is a valid data type, and without a length specified, it defaults to <code>CHAR(1)</code>, which does <strong>not</strong> cause an error.</p></li></ul></li><li><p><strong>The TRANS_DATE column would be able to store day, month, century, year, hour, minutes, and seconds.</strong></p><ul><li><p><strong>True</strong>, because Oracle’s <code>DATE</code> type includes all these components.</p></li></ul></li><li><p><strong>The TRANS_DATE column would be able to store day, month, year, hour, minutes, and seconds.</strong></p><ul><li><p><strong>True</strong>, because these components are <strong>also</strong> included in the <code>DATE</code> type. (Note: \"century\" is implicitly stored in the year.)</p></li></ul></li></ol><p><br></p><p>The CUST_STATUS column can store a decimal. Refer to section 2.2 in the link below. Also tested on SQL*Plus</p><p><a href=\"https://docs.oracle.com/database/121/SQLRF/sql_elements001.htm\">https://docs.oracle.com/database/121/SQLRF/sql_elements001.htm</a></p><p><br></p><p>CUST_STATUS&nbsp; is a <code>CHAR </code>datatype. The length of a <code>CHAR</code> column is fixed to the length that you declare when you create the table. When <code>CHAR</code> values are stored, they are right-padded with spaces to the specified length. Since the length is not declared, it will store exactly one character.</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/char.html\">https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/char.html</a></p><p><br></p><p><code>char</code> can be any of the datatypes <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions076.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions076.htm</a></p><p><br></p><p>CUST_CREDIT_LIMIT is a <code>NUMBER </code>datatype, and to store decimals, it must be declared. Example NUMBER(8,2) where the 8 means the total number of characters and the 2 is the number of decimal places. This gives you a range of <code>-999999.99</code> to <code>999999.99</code></p><p><br></p><p>TRANS_VALIDITY tries to use the <code>VARCHAR2 </code>datatype, which must have a specified length. In the table, the length is not specified, so it will cause an error when the attempt to create the table is executed; therefore, it has no maximum size. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-10_16-00-58-9d572f2692ec911d096aaa4761829233.png\"></p><p>By adding a specified length to the VARCHAR2 datatype, the table creation will execute, and the capacity of the table is shown.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-10_16-03-47-93fd0def654552b49a33c0d6e2a30b43.png\"></p><p>By adding precision to the CUST_CREDIT_LIMIT field as NUMBER(8,2), it can be made to accept decimals as shown below.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-10_16-12-45-6b28d04fad733d98ddebe25ce159b8f7.png\"></p><p><br></p><p><strong>DATE Datatype</strong></p><p>Oracle uses its own internal format to store dates. Date data is stored in fixed-length fields of seven bytes each, corresponding to century, year, month, day, hour, minute, and second.</p><p>For input and output of dates, the standard Oracle default date format is DD-MON-YY, as below:</p><pre class=\"prettyprint linenums\">'13-NOV-92' </pre><p><a href=\"https://docs.oracle.com/cd/A87860_01/doc/server.817/a76965/c10datyp.htm\">https://docs.oracle.com/cd/A87860_01/doc/server.817/a76965/c10datyp.htm</a></p><p><br></p><p><strong>Trans Date</strong></p><p>DATE definition from Oracle documentation - Valid date range from January 1, 4712 BC, to December 31, 9999 AD. The default format is determined explicitly by the <code>NLS_DATE_FORMAT</code> parameter or implicitly by the <code>NLS_TERRITORY</code> parameter. The size is fixed at 7 bytes. This data type contains the datetime fields <code>YEAR</code>, <code>MONTH</code>, <code>DAY</code>, <code>HOUR</code>, <code>MINUTE</code>, and <code>SECOND</code>. It does not have fractional seconds or a time zone.</p>",
                "answers": [
                    "<p>The CUST_STATUS column would store exactly one character.</p>",
                    "<p>The TRANS_VALIDITY column would have a maximum size of one character.</p>",
                    "<p>The CUST_CREDIT_LIMIT column would not be able to store decimal values.</p>",
                    "<p>The CUST_STATUS column would give an error.</p>",
                    "<p>The TRANS_DATE column would be able to store day, month, century, year, hour, minutes, seconds.</p>",
                    "<p>The TRANS_DATE column would be able to store day, month, year, hour, minutes, seconds.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e",
                "f"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the TRANSACTIONS table.Exhibit: 1Name                  Null??               Type\nTRANS_ID              NOT NULL             NUMBER(6)\nCUST_NAME             NOT NULL             VARCHAR(20)\nCUST_STATUS           NOT NULL             CHAR\nTRANS_DATE            NOT NULL             DATE\nCUST_CREDIT_LIMIT                          NUMBERIdentify the true statements regarding the creation and storage of data in the above table structure. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068295,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the UNION operator.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Union to handle NULL values](https://stackoverflow.com/questions/31958304/union-to-handle-null-values#31958465)",
                    "[Oracle UNION](https://www.oracletutorial.com/oracle-basics/oracle-union/)"
                ],
                "feedbacks": [
                    "The UNION operator combines the result sets of two or more SELECT statements into a single result set. By default, the output order of the combined result set is not guaranteed to be in any specific order unless an ORDER BY clause is used to explicitly specify the desired sorting criteria.",
                    "The UNION operator does not guarantee that the rows from the result sets will be stored in sequential blocks. The order in which the rows are stored in memory or on disk is determined by the underlying storage mechanism and is not controlled by the UNION operator.",
                    "When using the UNION operator, the names of the columns selected in all the SELECT statements must be identical. This is necessary to ensure that the columns from each SELECT statement can be properly matched and combined in the resulting output.",
                    "In a UNION operation, the number of columns selected in each SELECT statement must be the same. This is because the UNION operator combines the result sets by matching the columns from each SELECT statement, and having a different number of columns would result in a mismatch.",
                    "The default behavior of the UNION operator does not guarantee that the output will be sorted based on the order in which the columns were inserted in the SELECT statement. If a specific order is desired, an ORDER BY clause should be used to explicitly specify the sorting criteria."
                ],
                "explanation": "<p>Let’s break down each of the statements about the <code><strong>UNION</strong></code> operator.</p><p><strong>True Statement:</strong></p><ul><li><p><strong>By default, the output order cannot be relied upon without using ORDER BY.</strong><br><strong>True</strong> – SQL does <strong>not guarantee</strong> any specific row order in the result set <strong>unless</strong> you explicitly use an <code>ORDER BY</code> clause at the <strong>end</strong> of the final <code>SELECT</code> statement.<br>Even with <code>UNION</code>, the output might <strong>appear</strong> ordered due to internal processing, but it's <strong>not reliable</strong> or guaranteed.</p></li></ul><p><strong>False Statements:</strong></p><ul><li><p><strong>Rows stored in blocks are guaranteed to be sequential.</strong><br><strong>False</strong> – SQL storage mechanics are abstracted away; there's no guarantee of sequential physical storage or retrieval order at the query level.</p></li><li><p><strong>Names of all columns must be identical across all select statements.</strong><br><strong>False</strong> – The <strong>number and data types</strong> must match, <strong>not</strong> the column <strong>names</strong>. Only the first <code>SELECT</code> determines the column names in the final output.</p></li><li><p><strong>The number of columns selected in all select statements need not be the same.</strong><br><strong>False</strong> – All <code>SELECT</code> statements in a <code>UNION</code> <strong>must return the same number of columns</strong> and <strong>compatible data types</strong>.</p></li><li><p><strong>By default, the output will be sorted in the order the columns were inserted in the select statement.</strong><br><strong>False</strong> – Again, SQL result order is <strong>not guaranteed</strong> unless <code>ORDER BY</code> is explicitly used.</p></li></ul><p><br></p><p><strong>Oracle UNION</strong></p><p>The <code>UNION</code> query allows you to combine the result sets of two or more <code>SELECT</code> statements. It removes duplicate rows between the various <code>SELECT</code> statements.</p><p>Each&nbsp; <code>SELECT</code> statement within the <code>UNION</code> query must have the same number of fields (columns) in the result sets with similar data types.</p><p><code>UNION</code> adds rows from different tables one after the other, and then removes duplicates.</p><p>The <code>UNION</code> operator is a set operator that combines result sets of two or more <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statements into a single result set.</p><p>By default, the <code>UNION</code> operator returns the unique rows from both result sets. If you want to retain the duplicate rows, you explicitly use <code>UNION ALL</code>.</p><p>To <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\">sort the result set</a> returned by the <code>UNION</code> operator, you add an <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code>ORDER BY</code></a> clause to the last <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement.</p><p>A <code>UNION</code> places a result set on top of another, meaning that it appends result sets vertically (shows combined records). However, a join such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\"><code>INNER JOIN</code></a> or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-left-join/\"><code>LEFT JOIN</code></a> combines result sets horizontally (shows common records).</p>",
                "answers": [
                    "<p>By default, the output order cannot be relied assured without using ORDER&nbsp;BY.</p>",
                    "<p>Rows are stored in blocks are guaranteed to be sequential.</p>",
                    "<p>Names of all columns must be identical across all select statements.</p>",
                    "<p>The number of columns selected in all select statements need not be the same.</p>",
                    "<p>By default, the output will be sorted in the order the columns were inserted in the select statement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the UNION operator.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068297,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p>Consider default SQL standards and common behaviour in the Oracle relational database management system (RDBMS).</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP TABLE employees;</pre><p><br></p><p><strong>Given:</strong> This query has been executed successfully.</p><p>Identify the true statements from the available responses (Select three.)&nbsp; </p>",
                "relatedLectureIds": [],
                "links": [
                    "[How to Use Sequence Values](https://docs.oracle.com/cd/B28359_01/server.111/b28286/pseudocolumns002.htm#SQLRF51138)",
                    "[Dropping Tables](https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables010.htm#ADMIN01505)",
                    "[Does a drop table also drop the constraints?](https://stackoverflow.com/questions/43488105/does-a-drop-table-also-drop-the-constraints)"
                ],
                "feedbacks": [
                    "Sequences are separate database objects and are not directly tied to tables. Dropping a table does not affect the validity of sequences used in the table.",
                    "When a table is dropped, any uncommitted transactions in the session are automatically committed. This is because dropping a table is a DDL operation that implicitly commits the current transaction.",
                    "When a table is dropped, all indexes and constraints defined on that table are also dropped. This is to ensure data integrity and consistency within the database.",
                    "The space used by a dropped table is not always immediately reclaimed. The space may be marked as available for reuse, but it is not immediately released back to the operating system.",
                    "Once a table is dropped, it cannot be recovered using the ROLLBACK command. The DROP TABLE operation is irreversible and permanently removes the table and its data.",
                    "In Oracle Database, when a table is dropped, it is moved to the recycle bin by default. This allows for the table to be recovered if needed, but it is not automatically deleted from the database."
                ],
                "explanation": "<p><strong>True Statements: </strong></p><ul><li><p><strong>All indexes and constraints defined on the table are dropped with the table is dropped.</strong></p></li><li><p><strong>The EMPLOYEES table may be moved to the recycle bin.</strong></p></li><li><p><strong>If there is an uncommitted transaction in the session, it has become committed with this execution.</strong></p></li></ul><p>Let's examine each statement in the context of the <code>DROP TABLE employees;</code> command, which is a Data Definition Language (DDL) operation. We'll consider general SQL standards and common behaviour in the Oracle relational database management system (RDBMS), where the default \"recycle bin\" option is present.</p><p>Here's the analysis:</p><ol><li><p><strong>\"All indexes and constraints defined on the table are dropped with the table being dropped.\"</strong></p><ul><li><p><strong>TRUE.</strong> This is fundamental to how <code>DROP TABLE</code> works across almost all RDBMS. When a table is dropped, all associated schema objects that directly depend on it—such as indexes, primary key constraints, unique constraints, foreign key constraints (where the dropped table is the parent in the relationship), check constraints, and triggers—are also automatically dropped.</p></li></ul></li><li><p><strong>\"The EMPLOYEES table may be moved to the recycle bin.\"</strong></p><ul><li><p><strong>TRUE.</strong> This is a specific feature of Oracle Database. By default, when a table is <code>dropped</code> in Oracle, it's not immediately and permanently removed. Instead, it's placed in the \"recycle bin,\" from which it can be recovered using the <code>FLASHBACK TABLE</code> command (e.g., <code>FLASHBACK TABLE employees TO BEFORE DROP;</code>). This statement is true in an Oracle context, which is often implied in such questions when this option is present.</p></li></ul></li><li><p><strong>\"If there is an uncommitted transaction in the session, it has become committed with this execution.\"</strong></p><ul><li><p><strong>TRUE.</strong> In Oracle Database (and many other RDBMS), DDL statements like <code>DROP TABLE</code> issue an implicit <code>COMMIT</code> both <em>before</em> and <em>after</em> their execution. This means that any uncommitted Data Manipulation Language (DML) changes (e.g., <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) that were pending in the current session prior to the <code>DROP TABLE</code> command will be automatically committed to the database.</p></li></ul></li><li><p><strong>\"Sequences used in the EMPLOYEES table become invalid.\"</strong></p><ul><li><p><strong>FALSE.</strong> Sequences are independent database objects. While a sequence might have been used to generate primary key values for rows in the <code>EMPLOYEES</code> table, dropping the table does not affect the sequence itself. The sequence continues to exist and operate normally, incrementing its value independently. You would need a separate <code>DROP SEQUENCE</code> command to remove it.</p></li></ul></li><li><p><strong>\"The space used by the EMPLOYEES table is always reclaimed immediately.\"</strong></p><ul><li><p><strong>FALSE.</strong> This is not always the case. If the table is moved to the recycle bin (as in Oracle), the space is <em>not</em> immediately reclaimed for general use; it remains allocated within the recycle bin until explicitly purged or until the database needs to reclaim that space. Even in systems without a recycle bin, the exact timing of space reclamation can depend on the underlying storage management and automatic space management features.</p></li></ul></li><li><p><strong>\"The EMPLOYEES table can be recovered using the ROLLBACK command.\"</strong></p><ul><li><p><strong>FALSE.</strong> The <code>ROLLBACK</code> command is used to undo DML operations within the current transaction. DDL operations, because they perform implicit commits, cannot be undone using <code>ROLLBACK</code>. To recover a dropped table, you would need specific database features (like Oracle's <code>FLASHBACK TABLE TO BEFORE DROP</code>) or a database backup and restore process.</p></li></ul><p><br></p></li></ol><p>Sequences are special database objects that provide numbers in sequence for input to a table. They are useful for providing generated primary key values and for input of number-type columns, such as purchase order, employee number, sample number, and sales order number, where the input must be unique and in some form of numerical sequence.</p><p>When you create a sequence, you can define its initial value and the increment between its values. The first reference to <code>NEXTVAL</code> returns the initial value of the sequence. Subsequent references to <code>NEXTVAL</code> increment the sequence value by the defined increment and return the new value. Any reference to <code>CURRVAL</code> always returns the current value of the sequence, which is the value returned by the last reference to <code>NEXTVAL</code>.</p><p>Before you use <code>CURRVAL</code> for a sequence in your session, you must first initialize the sequence with <code>NEXTVAL</code>.</p><p><br></p><p><strong>Dropping tables </strong></p><p>• Dropping a table removes the table definition from the data dictionary. All rows of the table are no longer accessible.</p><p>• All indexes and triggers associated with a table are dropped.</p><p>• All views and PL/SQL program units dependent on a dropped table remain, yet become invalid (not usable).</p><p>• All synonyms for a dropped table remain, but return an error when used.</p><p>• All extents allocated for a table that is dropped are returned to the free space of the tablespace and can be used by any other object requiring new extents or new objects. All rows corresponding to a clustered table are deleted from the blocks of the cluster.</p><p>• All sequences for a dropped table remain and become orphaned, but are not affected by dropping a table.</p><p><br></p><p><code>DROP</code> is a <strong>Data Definition Language (DDL) Statement</strong> and therefore implies a <code>COMMIT</code> of any uncommitted transactions. Transactions that have been <code>COMMITTED</code> cannot be <code>ROLLEDBACK</code>. </p><p>When you drop a table, normally the database does not immediately release the space associated with the table. Rather, the database renames the table and places it in a recycle bin, where it can later be recovered with the <code>FLASHBACK TABLE</code> statement if you find that you dropped the table in error. </p><p>If you want to immediately release the space associated with the table at the time you issue the <code>DROP TABLE</code> statement, include the <code>PURGE</code> clause.</p>",
                "answers": [
                    "<p>Sequences used in the EMPLOYEES table become invalid.</p>",
                    "<p>If there is an uncommitted transaction in the session, it has become committed with this execution.</p>",
                    "<p>All indexes and constraints defined on the table are dropped with the table being dropped. </p>",
                    "<p>The space used by the EMPLOYEES table is always reclaimed immediately.</p>",
                    "<p>The EMPLOYEES table can be recovered using the ROLLBACK command.</p>",
                    "<p>The EMPLOYEES table may be moved to the recycle bin.</p>"
                ]
            },
            "correct_response": [
                "c",
                "f",
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL exhibit.Consider default SQL standards and common behaviour in the Oracle relational database management system (RDBMS).Exhibit: 1DROP TABLE employees;Given: This query has been executed successfully.Identify the true statements from the available responses (Select three.)&nbsp;",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068299,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about the Data Definition Language (Select two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Manipulation Language (DML) Statements](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Types-of-SQL-Statements.html#GUID-2E008D4A-F6FD-4F34-9071-7E10419CA24D)",
                    "[Types of SQL Statements](https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm)",
                    "[The DDL statements are:](https://docs.oracle.com/database/121/SQLRF/statements_1001.htm#SQLRF30001)"
                ],
                "feedbacks": [
                    "DDL statements such as CREATE, ALTER, and DROP are used to define, modify, and remove schema objects like tables, indexes, and views in a database. These statements are essential for managing the structure of the database.",
                    "<p>In Oracle site <a href=\"http://docs.oracle.com/database/121/SQLRF/statements_1001.htm#SQLRF30001\" rel=\"noopener noreferrer\" target=\"_blank\">Types of SQL Statements</a> Grant and Revoke belongs to DDL but in lot of other sites&nbsp; <code>GRANT</code> and <code>REVOKE</code> are considered DCL. In most (but not all) cases you are best off following Oracle's definition unless you have a strong reason to do otherwise, especially since you are preparing for an Oracle exam.</p>",
                    "COMMIT, ROLLBACK, and SAVEPOINT commands are part of Data Manipulation Language (DML) rather than Data Definition Language (DDL). DML statements are used to manipulate data in the database, while DDL statements are used to define and manage the structure of the database.",
                    "INSERT, MERGE, and UPDATE are examples of Data Manipulation Language (DML) statements used to insert, update, and merge data in database tables. These statements are not part of Data Definition Language (DDL), which is focused on defining and managing the structure of database objects.",
                    "SELECT, DELETE, and DROP are examples of Data Manipulation Language (DML) statements used to retrieve, delete, and drop data from database tables. These statements are not part of Data Definition Language (DDL), which is used for defining and managing the structure of database objects."
                ],
                "explanation": "<p><strong>What is DDL?</strong></p><p><strong>DDL</strong> (Data Definition Language) is a category of SQL commands used to <strong>define and manage database structure</strong> or schema objects like tables, indexes, and views.</p><p><strong>Evaluation of the Options:</strong></p><p><strong>DDL statements include CREATE, ALTER, and DROP schema objects</strong></p><ul><li><p><strong>True</strong> – This is the correct definition of DDL. The <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code> commands are used to define, modify, or remove schema objects in the database (such as tables, indexes, and views).</p></li></ul><p><strong>DDL statements do not include GRANT and REVOKE privileges and roles</strong></p><ul><li><p><strong>True</strong> – In the Oracle site, <a href=\"http://docs.oracle.com/database/121/SQLRF/statements_1001.htm#SQLRF30001\">Types of SQL Statements</a> Grant and Revoke belong to DDL, but in a lot of other sites,&nbsp; <code>GRANT</code> and <code>REVOKE</code> are considered DCL. In most (but not all) cases, you are best off following Oracle's definition unless you have a strong reason to do otherwise, especially since you are preparing for an Oracle exam.</p></li></ul><p><strong>DDL statements include COMMIT, ROLLBACK, and SAVEPOINT commands</strong></p><ul><li><p><strong>False</strong> – <code>COMMIT</code>, <code>ROLLBACK</code>, and <code>SAVEPOINT</code> are <strong>Transaction Control Language (TCL)</strong> commands. They manage the state of transactions, not the structure of the database schema.</p></li></ul><p><strong>DDL statements include INSERT, MERGE, and UPDATE</strong></p><ul><li><p><strong>False</strong> – These are <strong>Data Manipulation Language (DML)</strong> statements. They are used to manipulate the data in the tables, not the schema objects themselves.</p></li></ul><p><strong>DDL statements include SELECT, DELETE, and DROP</strong></p><ul><li><p><strong>False</strong> – While <code>DROP</code> is a DDL statement, <code>SELECT</code> and <code>DELETE</code> are <strong>DML</strong> commands. <code>SELECT</code> is used to query data, and <code>DELETE</code> is used to remove data from tables.</p></li></ul><p><br></p><p>On the Oracle site, <a href=\"http://docs.oracle.com/database/121/SQLRF/statements_1001.htm#SQLRF30001\">Types of SQL Statements</a> Grant and Revoke belong to DDL, but on a lot of other sites,&nbsp; <code>GRANT</code> and <code>REVOKE</code> are considered DCL. In most (but not all) cases, you are best off following Oracle's definition unless you have a strong reason to do otherwise, especially since you are preparing for an Oracle exam.</p><p><br></p><p><strong>Data Definition Language (DDL) Statements</strong> allow you to perform these tasks:</p><ul><li><p>Create, alter, and drop schema objects</p></li><li><p>Grant and revoke privileges and roles</p></li><li><p>Analyze information on a table, index, or cluster</p></li><li><p>Establish auditing options</p></li><li><p>Add comments to the data dictionary</p></li></ul><p>The <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code> commands require exclusive access to the specified object. For example, an <code>ALTER</code> <code>TABLE</code> statement fails if another user has an open transaction on the specified table.</p><p>The <code>GRANT</code>, <code>REVOKE</code>, <code>ANALYZE</code>, <code>AUDIT</code>, and <code>COMMENT</code> commands do not require exclusive access to the specified object. For example, you can analyze a table while other users are updating the table.</p><p>Oracle Database implicitly commits the current transaction before and after every DDL statement.</p><p>A DDL statement is either blocking or nonblocking, and both types of DDL statements require exclusive locks on internal structures.</p><ul><li><p><code>ALTER </code>... (All statements beginning with ALTER)</p></li><li><p><code>ANALYZE</code></p></li><li><p><code>ASSOCIATE STATISTICS</code></p></li><li><p><code>AUDIT</code></p></li><li><p><code>COMMENT</code></p></li><li><p><code>CREATE </code>... (All statements beginning with CREATE)</p></li><li><p><code>DISASSOCIATE STATISTICS</code></p></li><li><p><code>DROP </code>... (All statements beginning with DROP)</p></li><li><p><code>FLASHBACK </code>... (All statements beginning with FLASHBACK)</p></li><li><p><code>GRANT</code></p></li><li><p><code>NOAUDIT</code></p></li><li><p><code>PURGE</code></p></li><li><p><code>RENAME</code></p></li><li><p><code>REVOKE</code></p></li><li><p><code>TRUNCATE</code></p></li><li><p><code>UNDROP</code></p></li></ul><p>These statements DO implicitly commit the current transaction.</p><p><br></p><p><strong>Data Manipulation Language (DML) Statements</strong></p><p>Data manipulation language (DML) statements access and manipulate data in existing schema objects. These statements do not implicitly commit the current transaction. The data manipulation language statements are:</p><ul><li><p><code>CALL</code></p></li><li><p><code>DELETE</code></p></li><li><p><code>EXPLAIN PLAN</code></p></li><li><p><code>INSERT</code></p></li><li><p><code>LOCK TABLE</code></p></li><li><p><code>MERGE</code></p></li><li><p><code>SELECT</code></p></li><li><p><code>UPDATE</code></p></li></ul><p>The <code>SELECT</code> statement is a limited form of DML statement in that it can only access data in the database. It cannot manipulate data stored in the database, although it can manipulate the accessed data before returning the results of the query.</p><p>The <code>SELECT</code> statement is supported in PL/SQL only when executed dynamically. However, you can use a similar PL/SQL statement <a href=\"https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&amp;id=LNPLS01345\"><code>SELECT</code> <code>INTO</code></a> in PL/SQL code, and you do not have to execute it dynamically. The <code>CALL</code> and <code>EXPLAIN</code> <code>PLAN</code> statements are supported in PL/SQL only when executed dynamically. All other DML statements are fully supported in PL/SQL.</p><p>Data manipulation language (DML) statements access and manipulate data in existing schema objects. These statements DO NOT implicitly commit the current transaction.</p><p><br></p><p><strong>Transaction Control Statements</strong> </p><p>Transaction control statements manage changes made by DML statements. The transaction control statements are:</p><ul><li><p><code>COMMIT</code></p></li><li><p><code>ROLLBACK</code></p></li><li><p><code>SAVEPOINT</code></p></li><li><p><code>SET TRANSACTION</code></p></li></ul><p>Transaction control statements manage changes made by DML statements. Only COMMIT will commit the current transaction.</p><p><br></p><p><strong>Session Control Statements allow you to perform these tasks:</strong></p><ul><li><p><code>ALTER SESSION</code></p></li><li><p><code>SET ROLE</code></p></li></ul><p>Session control statements dynamically manage the properties of a user session. These statements do not implicitly commit the current transaction.</p><p><strong>System Control Statements allow you to perform these tasks:</strong></p><p>The single system control statement, <code>ALTER SYSTEM</code>, dynamically manages the properties of an Oracle Database instance. This statement does not implicitly commit the current transaction</p><p><strong>Embedded SQL Statements allow you to perform these tasks:</strong></p><p>Embedded SQL statements place DDL, DML, and transaction control statements within a procedural language program.</p>",
                "answers": [
                    "<p>DDL statements include <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code> schema objects</p>",
                    "<p>DDL statements include <code>GRANT</code> and <code>REVOKE</code> privileges and roles</p>",
                    "<p>DDL statements include <code>COMMIT</code>, <code>ROLLBACK</code>, and <code>SAVEPOINT</code> commands</p>",
                    "<p>DDL statements include <code>INSERT</code>, <code>MERGE</code>, and <code>UPDATE</code> </p>",
                    "<p>DDL statements include&nbsp; <code>SELECT</code>, <code>DELETE</code>, and <code>DROP</code></p>"
                ]
            },
            "correct_response": [
                "b",
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify two true statements about the Data Definition Language (Select two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068301,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about working with dates (Select two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[How are dates stored in Oracle?](https://stackoverflow.com/questions/13568193/how-are-dates-stored-in-oracle)",
                    "[DATE_FORMAT](https://docs.oracle.com/cd/B28359_01/olap.111/b28126/dml_commands_1029.htm#OLADM780)"
                ],
                "feedbacks": [
                    "The default internal storage of dates in Oracle Database is in the numeric format, which allows for efficient storage and manipulation of date values in the database system.",
                    "The default internal storage of dates in Oracle Database is not in the character format. Storing dates as characters can lead to data conversion issues and hinder date manipulation operations.",
                    "The RR date format does not automatically calculate the century from the SYSDATE function. Instead, it interprets the year input based on a pivot year, which can lead to ambiguity in date representations.",
                    "The RRRR date format automatically calculates the century from the SYSDATE function, providing a more reliable and accurate representation of dates. It also allows the user to explicitly enter the century if necessary for specific date requirements.",
                    "The RR date format is not interchangeable with the YY element. The RR format uses a pivot year to determine the century, while the YY element represents the year in a two-digit format without considering the century."
                ],
                "explanation": "<p><strong>Evaluation of the Options:</strong></p><p><strong>The default internal storage of dates is in the numeric format.</strong></p><ul><li><p><strong>True</strong> – Internally, <strong>Oracle stores dates in a numeric format</strong> (as a number representing the date and time in a precise manner). This allows for easy manipulation and comparison. The internal storage is not in <strong>character</strong> format, but as a <strong>numeric value</strong>.</p></li></ul><p><strong>The default internal storage of dates is in the character format.</strong></p><ul><li><p><strong>False</strong> – As mentioned, dates are <strong>stored in numeric</strong> format internally (not character format), allowing more efficient date arithmetic and comparisons.</p></li></ul><p><strong>The RR date format automatically calculates the century from the SYSDATE function and does not allow the user to enter the century.</strong></p><ul><li><p><strong>False</strong> – The <code>RR</code> format <strong>calculates</strong> the century based on a 100-year window, but <strong>it still allows the user</strong> to enter the century manually if needed (i.e., it’s not strictly automatic). The century is derived using the <strong>last two digits</strong> of the year provided.</p></li></ul><p><strong>The RRRR date format automatically calculates the century from the SYSDATE function, but allows the user to enter the century if required.</strong></p><ul><li><p><strong>True</strong> – The <code>RRRR</code> format automatically calculates the century from the <code>SYSDATE</code> function. It <strong>also allows the user</strong> to enter the century explicitly, making it more flexible than the <code>RR</code> format. This format was introduced to ensure that dates like <code>99</code> can be interpreted correctly, falling within the appropriate century.</p></li></ul><p><strong>The RR date format is interchangeable with the YY element.</strong></p><ul><li><p><strong>False</strong> – The <code>RR</code> format is not completely interchangeable with the <code>YY</code> element. While both are designed to work with 2-digit years, the behavior is slightly different:</p></li></ul><ul><li><p><code>RR</code> tries to automatically determine the century based on the current date.</p></li><li><p><code>YY</code> doesn’t have this automatic century adjustment.</p></li></ul><p><br></p><p><strong>Oracle Storage</strong></p><p>Oracle stores dates internally as numbers. Dates are stored in fixed-length fields of 7 bytes each, corresponding to century, year, month, day, hour, minute, and second.</p><p><br></p><p>The <code>DATE</code>&nbsp; data is stored internally as follows: </p><ul><li><p>CENTURY YEAR MONTH DAY HOUR MINUTE SECOND </p></li><li><p>20 21 06 17 17 10 43</p></li><li><p><code>DATE</code> default display and input format for any date is DD-MON-RR.</p></li></ul><p><br></p><p><strong>The RR Datetime Format Element</strong></p><p>The <code>RR</code> datetime format element is similar to the <code>YY</code> datetime format element, but it provides additional flexibility for storing date values in other centuries. The <code>RR</code> datetime format element lets you store 20th-century dates in the 21st century by specifying only the last two digits of the year.</p><p>If you use the <code>TO_DATE</code> function with the <code>YY</code> datetime format element, then the year returned always has the same first 2 digits as the current year. If you use the <code>RR</code> datetime format element instead, then the century of the return value varies according to the specified two-digit year and the last two digits of the current year.</p><p>That is:</p><p>• If the specified two-digit year is 00 to 49, then</p><p>• If the last two digits of the current year are 00 to 49, then the returned year has the same first two digits as the current year.</p><p>• If the last two digits of the current year are 50 to 99, then the first 2 digits of the returned year are 1 greater than the first 2 digits of the current year.</p><p>• If the specified two-digit year is 50 to 99, then</p><p>• If the last two digits of the current year are 00 to 49, then the first 2 digits of the returned year are 1 less than the first 2 digits of the current year.</p><p>• If the last two digits of the current year are 50 to 99, then the returned year has the same first two digits as the current year.</p><p><br></p><p><strong>The RRRR Datetime Format Element</strong></p><p>Let's you store 20th-century dates in the 21st century using only two digits. It accepts either 4-digit or 2-digit input. If 2-digit, provides the same return as <code>RR</code>. If you do not want this functionality, then enter the 4-digit year.</p>",
                "answers": [
                    "<p>The default internal storage of dates is in the numeric format.</p>",
                    "<p>The default internal storage of dates is in the character format.</p>",
                    "<p>The RR date format automatically calculates the century from the SYSDATE function and does not allow the user to enter the century.</p>",
                    "<p>The RRRR date format automatically calculates the century from the SYSDATE function but allows the user to enter the century if required.</p>",
                    "<p>The RR date format is interchangeable with the YY element</p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements about working with dates (Select two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068305,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>The following query was successfully executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT ROUND(150.23, -2)\nFROM dual;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The result of the query execution is 200. This is the correct value returned by the query.",
                    "The result of the query execution is not 150. This value is incorrect based on the query.",
                    "The result of the query execution is not 100. This value is incorrect based on the query.",
                    "The result of the query execution is not 152. This value is incorrect based on the query.",
                    "The result of the query execution is not 150.20. This value is incorrect based on the query.",
                    "The result of the query execution is not 150.24. This value is incorrect based on the query.",
                    "The result of the query execution is not 150.23. This value is incorrect based on the query."
                ],
                "explanation": "<p>Explanation of the <code>ROUND</code> function with <strong>negative precision</strong>:</p><p>The second argument, <code>-2</code>, specifies rounding to the nearest <strong>hundred</strong> (since the <code>-2</code> means we round to the place of the <strong>hundreds</strong> digit).</p><ul><li><p>The number <strong>150.23</strong> is rounded to the nearest <strong>100</strong>.</p></li><li><p><strong>150.23</strong> is closer to <strong>200</strong> than to <strong>100</strong>, so the result of rounding <strong>150.23</strong> to the nearest hundred is <strong>200</strong>.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-10_19-15-45-e2797d75786288455b75813ef0f92af3.png\"></p><p><br></p><p>For <code>NUMBER</code> values, the value <code>n</code> is rounded away from 0 based on the element <code>x</code></p><p>Sample: <code>SELECT ROUND(n,x)</code></p><p><strong>Example1: n = 0</strong></p><ul><li><p><code>SELECT ROUND(0.5,1) FROM dual;</code>&nbsp; |&nbsp; Result: .5 (+1 rounds a number to one decimal point)</p></li><li><p><code>SELECT ROUND(0.5,0) FROM dual; </code>&nbsp; |&nbsp; Result: 1 (0 rounds a number one digit to the left of the decimal point)</p></li><li><p><code>SELECT ROUND(0.5,-1) FROM dual; </code> |&nbsp; Result: 0 (-1 rounds a number two digits to the left of the decimal point)</p></li></ul><p><br></p><p><strong>Example1: n = 0.519254</strong></p><ul><li><p><code>SELECT ROUND(0.519254,5) FROM dual; </code>| Result: .51925 (+5 rounds a number to five decimal points)</p></li><li><p><code>SELECT ROUND(0.519254,2) FROM dual; </code>| Result: .52 (+2 rounds a number to two decimal points)</p></li><li><p><code>SELECT ROUND(0.519254,0) FROM dual;</code>&nbsp; &nbsp;|&nbsp; Result: 1</p></li><li><p><code>SELECT ROUND(0.519254,-1) FROM dual;</code> | Result: 0</p></li></ul><p><br></p><p><strong>Example3: n = 158.23</strong></p><ul><li><p><code>SELECT ROUND(158.23,2) FROM dual; </code> |&nbsp; Result: 158.23</p></li><li><p><code>SELECT ROUND(158.23,1) FROM dual; </code> |&nbsp; Result: 158.2</p></li><li><p><code>SELECT ROUND(158.23,0) FROM dual; </code> |&nbsp; Result: 158</p></li><li><p><code>SELECT ROUND(158.23,-1) FROM dual; </code> |&nbsp; Result: 160</p></li><li><p><code>SELECT ROUND(158.23,-2) FROM dual; </code> |&nbsp; Result: 200 (-2 rounds a number three digits to the left of the decimal point)</p></li></ul>",
                "answers": [
                    "<p>200</p>",
                    "<p>150</p>",
                    "<p>100</p>",
                    "<p>152</p>",
                    "<p>150.20</p>",
                    "<p>150.24</p>",
                    "<p>150.23</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.The following query was successfully executed.Exhibit: 1SELECT ROUND(150.23, -2)\nFROM dual;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130068307,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Which of the following are true statements about the Oracle database Data Dictionary?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[The Data Dictionary](https://docs.oracle.com/cd/B28359_01/server.111/b28318/datadict.htm#CNCPT1210)",
                    "[ The Data Dictionary (more)](https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c04dicti.htm)"
                ],
                "feedbacks": [
                    "<p>Any Oracle Database user can use the data dictionary as a read-only reference for information about the database, it is <strong>not fully publicly accessible</strong>.</p>",
                    "<p>The Oracle user SYS owns all base tables and user-accessible views of the data dictionary. Therefore, no Oracle user should <strong>ever</strong> alter (update, delete, or insert) any rows or schema objects contained in the SYS schema, because such activity can compromise data integrity. The security administrator should keep strict control of this central account.</p>",
                    "<p>A data dictionary contains the privileges and roles each user has been granted.</p>",
                    "<p>Base tables are the underlying tables that store information about the associated database. Only Oracle should write to and read these tables.</p>",
                    "<p>The data dictionary is always available when the database is open. Data dictionary resides in the <code>SYSTEM</code> tablespace, which is always online, regardless if any users are logged in or not.</p>",
                    "<p>The data dictionary consists of sets of views. In many cases, a set consists of three views containing similar information and distinguished from each other by their prefixes:</p><ul><li><p><code>USER</code></p></li><li><p><code>ALL</code></p></li><li><p><code>DBA</code></p></li></ul>"
                ],
                "explanation": "<p>Let's evaluate each statement regarding the <strong>Oracle database Data Dictionary</strong> to determine which are true.</p><p>1. <strong>The data dictionary is publicly accessible to all users.</strong></p><ul><li><p><strong>False</strong> – While the data dictionary contains crucial information about the database, it is <strong>not fully publicly accessible</strong>. Certain views and tables in the data dictionary are accessible to all users, but <strong>others require elevated privileges</strong> (like DBA privileges).</p></li></ul><p>2. <strong>SYS owns all base tables and user-accessible views in the Data Dictionary.</strong></p><ul><li><p><strong>True</strong> – The <code>SYS</code> schema owns the base tables, views, and other objects that make up the Oracle <strong>Data Dictionary</strong>. These base tables store metadata about the database, and user-accessible views are often created on top of these base tables for easier querying.</p></li></ul><p>3. <strong>The data dictionary contains the privileges and roles each user has been granted.</strong></p><ul><li><p><strong>True</strong> – The data dictionary includes views such as <code>USER_ROLE_PRIVS</code>, <code>DBA_ROLE_PRIVS</code>, <code>USER_TAB_PRIVS</code>, etc., that store information about <strong>roles</strong>, <strong>privileges</strong>, and <strong>permissions</strong> granted to users.</p></li></ul><p>4. <strong>Base tables are the underlying tables that store information about the associated database. Only the DBA should write to and read these tables.</strong></p><ul><li><p><strong>True</strong> – The <strong>base tables</strong> are internal Oracle tables that store metadata about the database (such as users, tables, indexes, etc.). Only DBAs and system-level accounts like <code>SYS</code> should directly access these base tables, as improper manipulation could compromise the integrity of the data dictionary.</p></li></ul><p>5. <strong>The data dictionary resides in the SYSTEM tablespace, which is online as long as at least 1 user is logged in.</strong></p><ul><li><p><strong>False</strong> – The data dictionary typically resides in the <strong>SYSTEM</strong> tablespace, but its availability is not directly tied to whether a user is logged in. The SYSTEM tablespace will remain online as long as the database is online, regardless of user sessions.</p></li></ul><p>6. <strong>Base tables always have the table names starting with DBA_.</strong></p><ul><li><p><strong>False</strong> – While many views that display data about the database start with <code>DBA_</code> (e.g., <code>DBA_USERS</code>, <code>DBA_TABLES</code>), <strong>base tables</strong> do not necessarily follow this naming convention. For example, base tables may have names like <code>USER$</code>, <code>OBJ$</code>, and others that don’t follow the <code>DBA_</code> prefix.</p></li></ul><p><br></p><p><strong>An Introduction to the Data Dictionary</strong></p><p>One of the most important parts of an Oracle database is its <em>data dictionary</em>, which is a <strong>read-only</strong> set of tables that provides information about its associated database. A data dictionary contains:</p><ul><li><p>The definitions of all schema objects in the database (tables, views, indexes, clusters, synonyms, sequences, procedures, functions, packages, triggers, and so on)</p></li><li><p>How much space has been allocated for, and is currently used by, the schema objects</p></li><li><p>default values for columns</p></li><li><p>integrity constraint information</p></li><li><p>the names of Oracle users</p></li><li><p>privileges and roles each user has been granted</p></li><li><p>auditing information, such as who has accessed or updated various schema objects</p></li><li><p>other general database information</p></li></ul><p>The data dictionary is structured in tables and views, just like other database data. All the data dictionary tables and views for a given database are stored in that database's SYSTEM tablespace (see <a href=\"https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c03space.htm#1003\">\"The SYSTEM Tablespace\"</a>).</p><p>Not only is the data dictionary central to every Oracle database, but it is also an important tool for all users, from end users to application designers and database administrators. To access the data dictionary, you use SQL statements. Because the data dictionary is read-only, you can issue only queries (SELECT statements) against the tables and views of the data dictionary.</p><p>In Oracle Database, <strong>most users</strong> can access certain <strong>data dictionary views</strong> as <strong>read-only references</strong> to get information about the database schema, objects, and privileges. These views are designed to provide metadata and can be queried to retrieve details about the database's structure, such as tables, columns, constraints, indexes, users, roles, privileges, and more.</p><p>However, there are some important things to note:</p><ol><li><p><strong>Public Access</strong>: Not all data dictionary views are available to every user by default. Some views are accessible to <strong>all users</strong> (such as <code>USER_TABLES</code>, <code>USER_TAB_COLUMNS</code>, <code>USER_OBJECTS</code>), while others may require <strong>additional privileges</strong> or access granted by the DBA (e.g., <code>DBA_USERS</code>, <code>DBA_TABLES</code>).</p></li><li><p><strong>Read-Only Access</strong>: The data dictionary is <strong>read-only</strong> for users. Users can query the dictionary views to gather information, but they cannot modify the underlying data dictionary tables directly.</p></li><li><p><strong>Granular Access</strong>: Users with <strong>higher privileges</strong> (such as <code>DBA</code> users or <code>SYS</code>) can access a wider range of dictionary views, such as <code>DBA_*</code> views, which contain more comprehensive details about all users and objects in the database.</p></li></ol><p><strong>The Structure of the Data Dictionary</strong></p><p>A database's data dictionary consists of:</p><ul><li><p>Base tables: The underlying tables that store information about the associated database. Only Oracle should write to and read these tables. Users rarely access them directly because they are normalized, and most of the data is stored in a cryptic format.</p></li><li><p>User-accessible views: The views that summarize and display the information stored in the base tables of the data dictionary. These views decode the base table data into useful information, such as user or table names, using joins and WHERE clauses to simplify the information. Most users are given access to the views rather than the base tables.</p></li></ul><p>The views of the data dictionary serve as a reference for all database users. Access the data dictionary views with SQL statements. Some views are accessible to all Oracle Database users, and others are intended for database administrators only.</p><p>The data dictionary is always available when the database is open. It resides in the <code>SYSTEM</code> tablespace, which is always online.</p><p>The data dictionary consists of sets of views. In many cases, a set consists of three views containing similar information and distinguished from each other by their prefixes:</p><ul><li><p><code>USER</code></p><ul><li><p>User's view (what is in the user's schema)</p></li></ul></li><li><p><code>ALL</code></p><ul><li><p>Expanded user's view (what the user can access)</p></li></ul></li><li><p><code>DBA</code></p><ul><li><p>Database administrator's view (what is in all users' schemas)</p></li></ul></li></ul><p><strong>SYS, the Owner of the Data Dictionary</strong></p><p>The Oracle user SYS owns all base tables and user-accessible views of the data dictionary. Therefore, no Oracle user should <strong>ever</strong> alter (update, delete, or insert) any rows or schema objects contained in the SYS schema, because such activity can compromise data integrity. The security administrator should keep strict control of this central account.</p>",
                "answers": [
                    "<p>Data dictionary is accessible to all users publicly</p>",
                    "<p>SYS owns all base tables and user accessible views in Data Dictionary</p>",
                    "<p>Data dictionary contains the privileges and roles each user has been granted</p>",
                    "<p>Base tables are the underlying tables that store information about the associated database. Only the DBA should write to and read these tables.</p>",
                    "<p>Data dictionary resides in the <code>SYSTEM</code> tablespace, which is online as long as at least 1 user is logged in</p>",
                    "<p>Base tables always have the table names starting with DBA_</p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "d"
            ],
            "section": "",
            "question_plain": "Which of the following are true statements about the Oracle database Data Dictionary?",
            "related_lectures": []
        }
    ]
}