{
    "count": 80,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 128919367,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibits.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE SEQUENCE order_seq\nINCREMENT BY 10\nSTART WITH 120\nMAXVALUE 9999\nNOCYCLE;</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE orders (\n    order_no NUMBER(4) PRIMARY KEY,\n    order_date DATE,\n    customer_id NUMBER(6)\n);</pre><p><br></p><p><strong>Exhibit 3:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE order_items (\n    order_no NUMBER(4) NOT NULL,\n    item_no NUMBER(3) NOT NULL,\n    qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n    expiry_date DATE,\n    CONSTRAINT it_pk PRIMARY KEY (order_no, item_no),\n    CONSTRAINT ord_fk FOREIGN KEY (order_no) REFERENCES orders (order_no),\n    CONSTRAINT expiry_date_check CHECK (expiry_date &gt; SYSDATE)\n);</pre><p><br></p><p><strong>Given: </strong> The command in Exhibit 3 to create a table fails. </p><p>Identify the reason for the SQL statement failure. </p>",
                "relatedLectureIds": [],
                "links": [
                    "[Constraint](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/constraint.html)",
                    "[How would I add a check constraint for making sure a date ...](https://stackoverflow.com/questions/60142870/how-would-i-add-a-check-constraint-for-making-sure-a-date-is-not-in-the-future)"
                ],
                "feedbacks": [
                    "This statement is incorrect. You can use a column that is also a foreign key in a composite primary key. This is a common practice in database design to ensure data integrity and relationships between tables.",
                    "This statement is incorrect. The use of the BETWEEN clause in the condition of a CHECK constraint is valid and allowed in SQL. It is used to specify a range of values that a column must fall within.",
                    "This statement is incorrect. You can use the NEXTVAL sequence value as a DEFAULT value for a column in Oracle SQL. It is a common practice to use sequences to generate unique values for columns in a table.",
                    "This statement is correct. The CREATE TABLE order_items statement fails because the CHECK constraint on the expiry_date column references the SYSDATE function, which is not allowed in a CHECK constraint. The SYSDATE function is non-deterministic and cannot be used in a CHECK constraint."
                ],
                "explanation": "<p><strong>Reason for Failure</strong></p><p>The statement fails because the constraint <code>CONSTRAINT expiry_date_check CHECK (expiry_date &gt; SYSDATE)</code> uses a <strong>non-deterministic function</strong> (<code>SYSDATE</code>).</p><p>A <code>CHECK</code> constraint must be deterministic, meaning it has to provide a consistent true/false result based solely on the data within the row. The value of <code>SYSDATE</code> changes with every passing moment, so a row that is valid now could be considered invalid later without any data in the row itself changing. Because of this unpredictable nature, database systems like Oracle <strong>prohibit the use of non-deterministic functions</strong> like <code>SYSDATE</code> or <code>CURRENT_TIMESTAMP</code> directly within a <code>CHECK</code> constraint.</p><p><br></p><p>To avoid the error, you can remove the <code>CHECK</code> constraint that references <code>SYSDATE</code> and instead enforce the rule using a <strong>trigger</strong>. Here's how you can modify your table definition:</p><p>Step 1: Remove the problematic constraint</p><p>Instead of:</p><pre class=\"prettyprint linenums\">CONSTRAINT expiry_date_check CHECK (expiry_date &gt; SYSDATE)\n</pre><p>You <strong>do not</strong> include this constraint in the table definition.</p><p><br></p><p>Step 2: Create a trigger to enforce the rule</p><p>Now, define a <strong>BEFORE INSERT OR UPDATE</strong> trigger that checks the condition dynamically:</p><pre class=\"prettyprint linenums\">CREATE OR REPLACE TRIGGER check_expiry_date\nBEFORE INSERT OR UPDATE ON order_items\nFOR EACH ROW\nBEGIN\n    IF :NEW.expiry_date &lt;= SYSDATE THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Expiry date must be in the future.');\n    END IF;\nEND;</pre><p><br></p><p>Why this works:</p><ul><li><p><strong>Triggers</strong> allow validation of dynamic conditions like <code>SYSDATE</code>.</p></li><li><p>The <code>RAISE_APPLICATION_ERROR</code> function ensures invalid entries cannot be inserted or updated.</p></li></ul>",
                "answers": [
                    "<p>You cannot use ORDER_NO and ITEM_NO columns as a composite primary key because ORDER_NO is also the FOREIGN KEY.</p>",
                    "<p>You cannot use the BETWEEN clause in the condition of a CHECK constraint.</p>",
                    "<p>You cannot use the NEXTVAL sequence value as a DEFAULT value for a column.</p>",
                    "<p>The CREATE TABLE order_items statement fails because of the CHECK constraint on the expiry_date column.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following SQL exhibits.Exhibit 1:CREATE SEQUENCE order_seq\nINCREMENT BY 10\nSTART WITH 120\nMAXVALUE 9999\nNOCYCLE;Exhibit 2:CREATE TABLE orders (\n    order_no NUMBER(4) PRIMARY KEY,\n    order_date DATE,\n    customer_id NUMBER(6)\n);Exhibit 3:CREATE TABLE order_items (\n    order_no NUMBER(4) NOT NULL,\n    item_no NUMBER(3) NOT NULL,\n    qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n    expiry_date DATE,\n    CONSTRAINT it_pk PRIMARY KEY (order_no, item_no),\n    CONSTRAINT ord_fk FOREIGN KEY (order_no) REFERENCES orders (order_no),\n    CONSTRAINT expiry_date_check CHECK (expiry_date &gt; SYSDATE)\n);Given:  The command in Exhibit 3 to create a table fails. Identify the reason for the SQL statement failure.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919361,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the description of the EMP_DETAILS table.</p><p><strong>Table: EMP_DETAILS </strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nEMP_ID           NOT NULL          NUMBER\nEMP_NAME                           VARCHAR2(40)\nEMP_IMAGE                          LONG</pre><p><br></p><p><strong>Given: </strong>All records have an image.</p><p>Identify the true statements regarding SQL statements that can be executed on the EMP_DETAIL TABLE. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Working with long columns](http://www.oracle-developer.net/display.php?id=430)",
                    "[LONG](http://www.orafaq.com/wiki/LONG)"
                ],
                "feedbacks": [
                    "The ORDER BY clause is used to sort the result set based on specified columns. Since the EMP_IMAGE column likely contains binary data or images, it cannot be used in the ORDER BY clause as it does not have a natural sort order.",
                    "The NOT NULL constraint is used to ensure that a column cannot contain NULL values. You can alter the table to include the NOT NULL constraint on the EMP_IMAGE column if you want to enforce this restriction on the column.",
                    "The LONG data type is deprecated in Oracle and should not be used for new columns. You cannot add a new column to the table with LONG as the data type. It is recommended to use CLOB or BLOB data types instead for large text or binary data.",
                    "The GROUP BY clause is used to group rows that have the same values into summary rows. Since the EMP_IMAGE column likely contains binary data or images, it is not suitable for use in the GROUP BY clause, which typically works with columns containing numeric or string data."
                ],
                "explanation": "<p>Correct Options:</p><p><strong>1. An EMP_IMAGE column cannot be included in the ORDER BY clause.</strong></p><ul><li><p>Oracle <strong>does not allow</strong> LONG columns to be used in <code>ORDER BY</code>, <code>GROUP BY</code>, or <code>DISTINCT</code> clauses.</p></li><li><p>So you <strong>cannot</strong> sort by <code>EMP_IMAGE</code>.</p></li></ul><p><strong>2. You can alter the table to include the NOT NULL constraint on the EMP_IMAGE column.</strong></p><ul><li><p>Even though <code>EMP_IMAGE</code> is of type LONG, you <strong>can</strong> alter the table to add a <code>NOT NULL</code> constraint <strong>if all existing rows already have values</strong> (which the question states).</p></li><li><p>The statement would be:</p><pre class=\"prettyprint linenums\">sql\nCopyEditALTER TABLE emp_details MODIFY emp_image NOT NULL;\n</pre></li></ul><p><strong>3. You cannot add a new column to the table with LONG as the data type.</strong></p><ul><li><p>The table <strong>already has one LONG column</strong>, so <strong>you cannot add another</strong>.</p></li><li><p>Oracle restricts <strong>only one LONG column per table</strong>.</p></li></ul><p>Incorrect Option:</p><p><strong>An EMP_IMAGE column can be included in the GROUP BY clause.</strong></p><ul><li><p>As with <code>ORDER BY</code>, Oracle <strong>does not allow</strong> <code>LONG</code> columns to be used in <code>GROUP BY</code> clauses.</p></li><li><p>Attempting to do so will result in an error.</p></li></ul><p><br></p><p><strong>LONG Datatype</strong></p><p><code>LONG</code> is an Oracle <a href=\"http://www.orafaq.com/wiki/Data_type\" title=\"Data type\">data type</a> for storing character data of variable length up to 2 Gigabytes in length (bigger version of the <a href=\"http://www.orafaq.com/wiki/VARCHAR2\" title=\"VARCHAR2\">VARCHAR2</a> datatype). Note that a <a href=\"http://www.orafaq.com/wiki/Table\" title=\"Table\">table</a> can only have one <code>LONG</code> column.</p><p>The <code>LONG</code> and <code>LONG RAW</code> datatypes have been deprecated in favour of <code>LOB</code> for many Oracle versions, yet they still exist in the data dictionary and legacy systems. For this reason, it is still quite common to see questions in Oracle forums about querying and manipulating <code>LONG</code>. These questions are prompted because the <code>LONG</code> datatype is extremely inflexible and is subject to a number of restrictions. In fact, it's fair to say that there isn't much we can do with a <code>LONG</code> value once it has been inserted into a table.</p><p><strong>LONG value restrictions: </strong></p><p>• A table can contain only one <code>LONG</code> column.</p><p>• You cannot create an object type with a <code>LONG</code> attribute. </p><p>• <code>LONG</code>columns cannot appear in <code>WHERE</code> clauses or in integrity constraints (except that they can appear in NULL and NOT NULL constraints). </p><p>• <code>LONG</code> columns cannot be indexed. </p><p>• <code>LONG</code> data cannot be specified in regular expressions. </p><p>• A stored function cannot return a <code>LONG</code> value. </p><p>• You can declare a variable or argument of a PL/SQL program unit using the <code>LONG</code> data type. However, you cannot then call the program unit from SQL. </p><p>• Within a single SQL statement, all <code>LONG</code> columns, updated tables, and locked tables must be located on the same database. </p><p>• <code>LONG</code> and <code>LONG</code> RAW columns cannot be used in distributed SQL statements and cannot be replicated. </p><p>• If a table has both <code>LONG</code> and <code>LOB</code> columns, then you cannot bind more than 4000 bytes of data to both the <code>LONG</code> and <code>LOB</code> columns in the same SQL statement. However, you can bind more than 4000 bytes of data to either the <code>LONG</code> or the <code>LOB</code> column.</p><p><br></p><p><strong>LONG columns SQL statement restrictions: </strong></p><p>• <code>GROUP BY</code> clauses, <code>ORDER BY</code> clauses, or <code>CONNECT BY</code> clauses or with the <code>DISTINCT</code> operator in <code>SELECT</code> statements</p><p>• The <code>UNIQUE</code> operator of a <code>SELECT</code> statement </p><p>• The column list of a <code>CREATE CLUSTER</code> statement </p><p>• The <code>CLUSTER</code> clause of a <code>CREATE MATERIALIZED VIEW</code> statement </p><p>• SQL built-in functions, expressions, or conditions </p><p>• <code>SELECT</code> lists of queries containing GROUP BY clauses </p><p>• <code>SELECT</code> lists of subqueries or queries combined by the <code>UNION</code>, <code>INTERSECT</code>, or <code>MINUS</code> set operators </p><p>• <code>SELECT</code> lists of <code>CREATE TABLE ... AS SELECT</code> statements </p><p>• <code>ALTER TABLE ... MOVE</code> statements <code>SELECT</code> lists in subqueries in <code>INSERT</code> statements</p>",
                "answers": [
                    "<p>An EMP_IMAGE column cannot be included in the ORDER BY clause.</p>",
                    "<p>You can alter the table to include the NOT NULL constraint on the EMP_IMAGE column.</p>",
                    "<p>You cannot add a new column to the table with LONG as the data type.</p>",
                    "<p>An EMP_IMAGE column can be included in the GROUP BY clause.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "LONG",
            "question_plain": "View and examine the description of the EMP_DETAILS table.Table: EMP_DETAILS Name             Null??            Type\nEMP_ID           NOT NULL          NUMBER\nEMP_NAME                           VARCHAR2(40)\nEMP_IMAGE                          LONGGiven: All records have an image.Identify the true statements regarding SQL statements that can be executed on the EMP_DETAIL TABLE. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919363,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>The following command has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE employees;\n</pre><p><br></p><p>Identify three true statements regarding the result. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle DROP TABLE](https://www.oracletutorial.com/oracle-basics/oracle-drop-table/)",
                    "[DROP TABLE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/DROP-TABLE.html)"
                ],
                "feedbacks": [
                    "When dropping a table, all uncommitted transactions are automatically committed, as the table is being removed from the database.",
                    "When dropping a table, all indexes and constraints defined on that table are also dropped along with the table itself to maintain data integrity.",
                    "Sequences used in the employees table do not become invalid when the table is dropped. Sequences are independent database objects and are not affected by the dropping of a table.",
                    "The space used by the employees table is not immediately reclaimed when the table is dropped. The space will be marked as available for reuse, but it will not be reclaimed until a subsequent operation like a tablespace reorganization.",
                    "Once a table is dropped, it cannot be recovered using the rollback command. Dropping a table is a DDL operation that cannot be rolled back.",
                    "When a table is dropped, it is moved to the recycle bin in Oracle Database. The recycle bin acts as a safety net, allowing the dropped table to be recovered if needed before it is permanently removed from the database."
                ],
                "explanation": "<p>Correct options:</p><ol><li><p><strong>All indexes and constraints defined on the table being dropped are also dropped.</strong></p><ul><li><p>When a table is dropped, any indexes, constraints, and triggers associated with it are automatically removed.</p></li></ul></li><li><p><strong>Sequences used in the employees table become invalid.</strong></p><ul><li><p>If a sequence was used to generate values for a column in <code>employees</code>, it remains in the database but may no longer be relevant since the table is gone.</p></li></ul></li><li><p><strong>The employees table is moved to the recycle bin (if supported).</strong></p></li></ol><ul><li><p>In Oracle databases with <strong>Flashback Drop</strong> enabled, the table is not immediately removed but is moved to the <strong>Recycle Bin</strong>, allowing potential recovery.</p></li></ul><p>Incorrect or misleading options:</p><ul><li><p><strong>\"All uncommitted transactions are committed.\"</strong> → <strong>False</strong><br>Dropping a table does <strong>not</strong> automatically commit any uncommitted transactions. However, <strong>the drop itself is committed</strong> immediately and cannot be rolled back.</p></li><li><p><strong>\"The space used by the employees table is reclaimed immediately.\"</strong> → <strong>False</strong><br>Space may not be fully reclaimed until a manual cleanup (<code>PURGE</code>) is done, especially if the table is in the <strong>Recycle Bin</strong>.</p></li><li><p><strong>\"The employees table can be recovered using the rollback command.\"</strong> → <strong>False</strong><br>You cannot use <code>ROLLBACK</code> to undo a <code>DROP TABLE</code> statement. If Flashback technology is available, you can restore it from the Recycle Bin.</p></li></ul><p><strong>DROP TABLE</strong></p><p>Dropping a table invalidates dependent objects and removes object privileges on the table. </p><p>If you want to re-create the table, then you must regrant object privileges on the table, re-create the indexes, integrity constraints, and triggers for the table, and respecify its storage parameters. Truncating has none of these effects. Therefore, removing rows with the <code>TRUNCATE</code> statement can be more efficient than dropping and re-creating a table.</p><p>Use the <code>DROP TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely.</p><p>To move a table to the recycle bin or remove it entirely from the database, you use the <code>DROP TABLE</code> statement:</p><pre class=\"prettyprint linenums\">DROP TABLE schema_name.table_name\n[CASCADE CONSTRAINTS | PURGE];</pre><p><br></p><p>In this statement:</p><p>First, indicate the table and its schema that you want to drop after the <code>DROP TABLE</code> clause. If you don’t specify the schema name explicitly, the statement assumes that you are removing the table from your own schema.</p><p>Second, specify <code>CASCADE CONSTRAINTS</code> clause to remove all referential integrity constraints which refer to primary and unique keys in the table. In case such referential integrity constraints exist and you don’t use this clause, Oracle returns an error and stops removing the table.</p><p>Third, specify <code>PURGE</code> clause if you want to drop the table and release the space associated with it at once. By using the <code>PURGE</code> clause, Oracle will not place the table and its dependent objects into the recycle bin.</p><p>Notice that the <code>PURGE</code> clause does not allow you to roll back or recover the table that you dropped. Therefore, it is useful if you don’t want the sensitive data to appear in the recycle bin.</p><p><strong>Implicit Commit</strong></p><p>The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a <code>COMMIT</code> before executing the statement.</p><p> <strong>Data definition language (DDL) statements</strong> that define or modify database objects. <code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>, <code>ALTER EVENT</code>, <code>ALTER PROCEDURE</code>, <code>ALTER SERVER</code>, <code>ALTER TABLE</code>, <code>CREATE DATABASE</code>, <code>CREATE EVENT</code>, <code>CREATE INDEX</code>, <code>CREATE PROCEDURE</code>, <code>CREATE SERVER</code>, <code>CREATE TABLE</code>, <code>DROP DATABASE</code>, <code>DROP EVENT</code>, <code>DROP INDEX</code>, <code>DROP PROCEDURE</code>, <code>DROP SERVER</code>, <code>DROP TABLE</code>, <code>RENAME TABLE</code>, <code>TRUNCATE TABLE</code>. </p>",
                "answers": [
                    "<p>All uncommitted transactions are committed.</p>",
                    "<p>All indexes and constraints defined on the table being dropped are also dropped.</p>",
                    "<p>Sequences used in the employees table become invalid.</p>",
                    "<p>The space used by the employees table is reclaimed immediately.</p>",
                    "<p>The employees table can be recovered using the rollback command.</p>",
                    "<p>The employees table is moved to the recycle bin</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "f"
            ],
            "section": "DROP TABLE",
            "question_plain": "View and examine the following available responses.The following command has been executed.Exhibit: 1DROP&nbsp;TABLE employees;\nIdentify three true statements regarding the result. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919365,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements regarding constraints. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Constraint](https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/constraint.html#GUID-1055EA97-BA6F-4764-A15F-1024FD5B6DFE)"
                ],
                "feedbacks": [
                    "This statement is incorrect. Constraints can be defined at both the column level and the table level, but not all constraints can be defined at both levels. For example, the PRIMARY KEY constraint can only be defined at the column level.",
                    "This statement is correct. A constraint can be disabled even if the constraint column contains data. Disabling a constraint allows data manipulation operations that would otherwise violate the constraint.",
                    "This statement is correct. A column with the UNIQUE constraint can contain NULL values. The UNIQUE constraint ensures that all values in the column are unique, but it allows multiple rows to have NULL values.",
                    "This statement is incorrect. A foreign key column can contain NULL values. However, if a foreign key column is defined as NOT NULL, then it cannot contain NULL values.",
                    "This statement is incorrect. A constraint is enforced for all data manipulation operations, including INSERT, UPDATE, and DELETE operations. Constraints ensure data integrity by enforcing rules on the data in the database."
                ],
                "explanation": "<p>Correct options:</p><ol><li><p><strong>A constraint can be disabled even if the constraint column contains data.</strong></p><ul><li><p>Constraints, such as <code>CHECK</code>, <code>FOREIGN KEY</code>, or <code>UNIQUE</code>, can be <strong>disabled</strong> using <code>ALTER TABLE ... DISABLE CONSTRAINT ...</code>, even if the column contains existing data. However, disabling constraints means integrity rules are no longer enforced.</p></li></ul></li><li><p><strong>A column with the UNIQUE constraint can contain NULLs.</strong></p></li></ol><ul><li><p>The <code>UNIQUE</code> constraint ensures that values in a column are distinct, but it <strong>allows multiple NULLs</strong>, since NULLs are considered \"unknown\" and not treated as duplicate values.</p></li></ul><p>Incorrect statements:</p><ul><li><p><strong>\"All constraints can be defined at the column level and at the table level.\"</strong> → <strong>False</strong><br>Some constraints (like <code>NOT NULL</code>) can only be defined at the <strong>column level</strong>, not at the <strong>table level</strong>.</p></li><li><p><strong>\"A foreign key column cannot contain NULLs.\"</strong> → <strong>False</strong><br>Foreign key columns <strong>can contain NULLs</strong>, meaning a row can exist without a referenced value in the parent table.</p></li><li><p><strong>\"A constraint is enforced only for INSERT operations.\"</strong> → <strong>False</strong><br>Constraints apply to <strong>INSERT, UPDATE, and DELETE</strong> operations, ensuring data integrity at all times.</p></li></ul><p><strong>Integrity constraints</strong></p><p>Key descriptors of integrity constraints:</p><p>• A <code>NOT NULL</code> constraint prohibits a database value from being null.</p><p>• A <code>UNIQUE</code> constraint prohibits multiple rows from having the same value in the same column or combination of columns but allows some values to be null.</p><p>• A <code>PRIMARY KEY</code> constraint combines a <code>NOT NULL</code> constraint and a <code>UNIQUE</code> constraint in a single declaration. It prohibits multiple rows from having the same value in the same column or combination of columns and prohibits values from being null.</p><p>• A <code>FOREIGN KEY</code> constraint requires values in one table to match values in another table.</p><p>• A <code>CHECK</code> constraint requires a value in the database to comply with a specified condition.</p><p>• A <code>REF</code> column by definition references an object in another object type or in a relational table. A REF constraint lets you further describe the relationship between the <code>REF</code> column and the object it references.</p><p>Any number of rows can include nulls for columns without <code>NOT NULL</code> constraints because <code>NULL</code> are not considered equal to anything.</p><p>Constraints can be added, dropped, enabled, disabled, or validated. <code>DISABLE</code> allows incoming data, regardless of whether it conforms to the constraint.</p><p>The relational model permits the value of <code>FOREIGN KEY</code> either to match the referenced <code>PRIMARY</code> or <code>UNIQUE</code> key value, or be <code>NULL</code>.</p><p><br></p><p><strong>Constraints at the Column Level : </strong></p><p>• <code>PRIMARY KEY</code> </p><p>• <code>FOREIGN KEY </code></p><p>• <code>UNIQUE </code></p><p>• <code>CHECK</code> </p><p>• <code>NOT NULL</code> ( can be created only at the column level) </p><p>A <code>UNIQUE</code> constraint allows <code>NULL</code> values, which aren’t permitted with a <code>PRIMARY KEY</code> constraint</p><p>All constraints can be defined at the column level and at the table level is incorrect because <code>NOT NULL</code> can be created only at the column level.</p>",
                "answers": [
                    "<p>All constraints can be defined at the column level and at the table level.</p>",
                    "<p>A constraint can be disabled even if the constraint column contains data.</p>",
                    "<p>A column with the UNIQUE constraint can contain NULLs.</p>",
                    "<p>A foreign key column cannot contain NULLs.</p>",
                    "<p>A constraint is enforced only for INSERT operations.</p>"
                ]
            },
            "correct_response": [
                "b",
                "c"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following available responses.Identify two true statements regarding constraints. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919369,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement TRUNCATE and DELETE.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Difference Between DELETE and TRUNCATE in SQL](https://techdifferences.com/difference-between-delete-and-truncate-in-sql.html)",
                    "[Why is Truncate faster than delete in SQL?](https://www.quora.com/Why-is-Truncate-faster-than-delete-in-SQL-server?share=1)"
                ],
                "feedbacks": [
                    "<p>This statement is incorrect. You can never TRUNCATE a table if foreign key constraints will be violated.</p>",
                    "This statement is correct. TRUNCATE is generally faster than DELETE for large tables because TRUNCATE does not generate individual row delete operations like DELETE does. Instead, TRUNCATE deallocates the data pages and resets the identity column value.",
                    "This statement is incorrect. For tables with multiple indexes and triggers, TRUNCATE is usually faster than DELETE. TRUNCATE does not fire triggers or log individual row deletions, making it more efficient for large-scale operations.",
                    "This statement is incorrect. You can DELETE rows from a table even if foreign key constraints will be violated. However, you may need to handle the constraint violations manually or use cascading deletes to remove related rows."
                ],
                "explanation": "<p>Correct option:</p><p><strong>For large tables TRUNCATE is faster than DELETE.</strong></p><ul><li><p><code>TRUNCATE</code> is a <strong>DDL (Data Definition Language)</strong> operation, meaning it removes all rows <strong>without logging individual row deletions</strong>, making it significantly faster.</p></li><li><p><code>DELETE</code>, on the other hand, is a <strong>DML (Data Manipulation Language)</strong> operation that logs each row deletion, which can slow down performance for large tables.</p></li></ul><p>Incorrect options:</p><ul><li><p><strong>\"You can TRUNCATE a table if foreign key constraints will be violated.\"</strong> → <strong>False</strong></p><ul><li><p>You cannot truncate a table that is <strong>referenced by a foreign key</strong> unless the foreign key constraint is first removed or disabled.</p></li></ul></li><li><p><strong>\"For tables with multiple indexes and triggers DELETE is faster than TRUNCATE.\"</strong> → <strong>False</strong></p><ul><li><p><code>DELETE</code> processes row-by-row, meaning triggers and indexes are affected <strong>for each row deleted</strong>, making it <strong>slower</strong> than <code>TRUNCATE</code>.</p></li></ul></li><li><p><strong>\"You can never DELETE rows from a table if foreign key constraints will be violated.\"</strong> → <strong>False</strong></p></li></ul><ul><li><p>You <strong>can</strong> delete rows, but only if the foreign key constraint allows it (for example, using <strong>ON DELETE CASCADE</strong> or <strong>ON DELETE SET NULL</strong> in the foreign key definition).</p></li></ul><p><em>The option begins with \"You can never\" which makes it incorrect. Sometimes things may be possible even though they may not be proper or a good practice, or may cause undesirable consequences.</em></p><p><em>In the test it is important to recognize between \"should\" or \"can\". Should refers to something that follows a proper practice like \"one can do something\" but they \"should not\".</em></p><p><br></p><p><strong>DELETE and TRUNCATE</strong></p><p><code>DELETE</code> and <code>TRUNCATE</code> are the commands use to remove tuples from a relation, but they differ in many contexts. In SQL, <code>DELETE</code> command is a <strong>Data Manipulation Language</strong> command whereas, <code>TRUNCATE</code> command is a <strong>Data Definition Language</strong> command.</p><p>However, the point that allows us to differentiate between <code>DELETE</code> and <code>TRUNCATE</code> is that <code>DELETE</code> is able to remove specified tuples from a relation, Whereas, the <code>TRUNCATE</code> command removes entire tuples from a relation.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-20_23-34-06-40df94a28d7d9e585bde1daebbbf96a3.png\"></p><p><br></p><p><br></p><p><strong>TRUNCATE is faster than DELETE</strong></p><p><code>DELETE</code> is a logged operation on a per row. This means that the deletion of each row is recorded &amp; removed physically. You can delete any row that does not involve a violation of restriction, while leaving the foreign key or any other restrictions in place.</p><p><code>TRUNCATE</code> is a logged operation, but in a different way. <code>TRUNCATE</code> logs the deal location of information pages in which information exist. The de allocation of information pages means that your information rows still actually exist in the information pages, but the extensions are marked as empty for reuse. This is what makes TRUNCATE a faster operation to perform over <code>DELETE</code>. Can not truncate a table that has foreign key constraints. You must remove the constraints, truncate the table, &amp; reapply the constraints.</p><p><code>TRUNCATE</code> will reset any identity columns to default value initialization. This means that if you have a table with an identity column &amp; has 264 rows with a seed value of 1, his latest record will have the value 264 (assuming you started with value 1 in the columns of your identity. After truncating your table when you insert a new record in to the empty table, the identity column will have a value of 1 DELETE won't. In the same scenario, if the current row, inserting a new row in to the empty table, the identity column has a value of 265.</p><p><br></p><p><strong>Why Truncate is faster than Delete</strong></p><p>In writing to delete all information is copied to the rollback table space &amp; then delete operation is performed. So when you type ROLLBACK after deleting a table, you can get back the information (the method get it for the pace of Rollback Tables). This whole technique will take time, but when using <code>TRUNCATE</code>, it removes information directly without copying it to Rollback table space. <code>TRUNCATE</code> is faster.</p>",
                "answers": [
                    "<p>You can TRUNCATE a table if foreign key constraints will be violated.</p>",
                    "<p>For large tables TRUNCATE is faster than DELETE.</p>",
                    "<p>For tables with multiple indexes and triggers DELETE is faster than TRUNCATE.</p>",
                    "<p>You can never DELETE rows from a table if foreign key constraints will be violated.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "TRUNCATE",
            "question_plain": "View and examine the following available responses.Identify the true statement TRUNCATE and DELETE.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919483,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES1 table.</p><p><strong>Table: EMPLOYEES1</strong></p><pre class=\"prettyprint linenums\">EMPLOYEE_ID                                 FIRST_NAME                               LAST_NAME\n          1                                      Adela                                  Jasper\n          2                                     Viola                                  Carroll\n          3                                      Mike                                     Khan\n          4                                       Raj                                    Smith\n          5                                       Raj                                     Khan\n          6                                     Adela                                     Jobs\n          7                                     Adela                                    Munoz</pre><p><br></p><p><strong>Required:</strong> Display the customer names that have the letter 'a' in their first name and the letter 'o' at the fourth position in their last name only. </p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)",
                    "[Oracle / PLSQL: LIKE Condition](https://www.techonthenet.com/oracle/like.php)",
                    "[Oracle / PLSQL: INSTR Function](https://www.techonthenet.com/oracle/functions/instr.php)"
                ],
                "feedbacks": [
                    "This query correctly uses the INSTR function to check if the first name contains the letter 'a' and the SUBSTR function to check if the fourth position of the last name is 'o'. It accurately filters the results based on the specified conditions.",
                    "This query uses the INSTR function to check if the first name contains the letter 'a', but it is missing the comparison operator in the WHERE clause. The SUBSTR function is correctly used to check the fourth position of the last name for 'o', but the query is incomplete without the proper comparison.",
                    "This query incorrectly uses the LIKE operator with incorrect syntax for checking the first name and last name. The '%' wildcard is used incorrectly, and the query does not accurately filter the results based on the specified conditions.",
                    "This query correctly uses the LIKE operator to check if the first name ends with 'a' and the last name contains 'o'. However, the query does not specify the exact position of the letters 'a' and 'o' in the first name and last name, which is a requirement for the desired output.",
                    "<p>This query correctly uses the INSTR function to check if the first name contains the letter 'a' and the SUBSTR function to check if the fourth position of the last name is 'o'. It accurately filters the results based on the specified conditions.</p><pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE INSTR(first_name, 'a') &lt;&gt; 0 \nAND SUBSTR(last_name, 4, 1) = 'o';\n</pre>"
                ],
                "explanation": "<p>The correct SQL query for the requirements is:</p><pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE INSTR(first_name, 'a') &lt;&gt; 0 \nAND SUBSTR(last_name, 4, 1) = 'o';</pre><ul><li><p><code>INSTR(first_name, 'a') &lt;&gt; 0</code>: This ensures that the first name contains the letter 'a' <strong>anywhere</strong> in the name.</p></li><li><p><code>SUBSTR(last_name, 4, 1) = 'o'</code>: This checks if the <strong>fourth character</strong> in the last name is 'o'.</p><p><br></p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_11-36-34-2b162206ad02706d22eaf0f889f19b89.png\"></p><p><br></p><p>Incorrect Queries:</p><ul><li><p><code><strong>INSTR(first_name,'a')</strong></code><strong> (without </strong><code><strong>&lt;&gt; 0</strong></code><strong>)</strong> → This would cause logical issues as <code>INSTR</code> returns <strong>position</strong>, not a boolean value.</p></li><li><p><code><strong>LIKE first_name 'a%'</strong></code><strong> AND </strong><code><strong>LIKE last_name '%o'</strong></code> → Invalid syntax, <code>LIKE</code> must be used with <code>WHERE column LIKE 'pattern%'</code>.</p></li><li><p><code><strong>first_name LIKE '%a%'</strong></code><strong> AND </strong><code><strong>last_name LIKE '%o%'</strong></code> → This incorrectly searches for <strong>any 'o'</strong> in the last name, not necessarily at position 4.</p></li></ul><p><br></p><p><strong>LIKE </strong></p><p>The Oracle <code>LIKE</code> condition allows wildcards to be used in the<a href=\"https://www.techonthenet.com/oracle/where.php\"> WHERE clause</a> of a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement. This allows you to perform pattern matching.</p><p><br></p><p><strong>Syntax</strong></p><p>The syntax for the <code>LIKE</code> condition in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">expression LIKE pattern [ ESCAPE 'escape_character' ]</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - A character expression such as a column or field. </p><p>pattern - A character expression that contains pattern matching. </p><p>&nbsp; &nbsp; &nbsp;The patterns that you can choose from are:</p><p>&nbsp; &nbsp; &nbsp;• Wildcard Explanation % Allows you to match any string of any length (including zero length) _ Allows you to match on a single character</p><p>escape_character Optional. - It allows you to test for literal instances of a wildcard character such as % or _.</p><p><br></p><p><strong>INSTR </strong></p><p>The Oracle/PLSQL <code>INSTR</code> function returns the location of a substring in a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">INSTR( string, substring [, start_position [, th_appearance ] ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string The string to search. <em>string</em> can be CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. substring The substring to search for in <em>string</em>. <em>substring</em> can be CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. start_position Optional. The position in <em>string</em> where the search will start. If omitted, it defaults to 1. The first position in the string is 1. If the <em>start_position</em> is negative, the INSTR function counts back <em>start_position</em> number of characters from the end of <em>string</em> and then searches towards the beginning of <em>string</em>. nth_appearance Optional. The nth appearance of <em>substring</em>. If omitted, it defaults to 1.</p><p><strong>Returns</strong></p><p>The <code>INSTR</code> function returns a numeric value. The first position in the string is 1.<br>If <em>substring</em> is not found in <em>string</em>, then the <code>INSTR</code> function will return 0.</p><p><br></p><p><strong>SUBSTR </strong></p><p>The Oracle/PLSQL <code>SUBSTR</code> functions allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string The source string. start_position The starting position for extraction. The first position in the string is always 1. length Optional. It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a NULL value.</p><p>Note</p><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE INSTR(first_name, 'a') &lt;&gt; 0 \nAND SUBSTR(last_name, 4, 1) = 'o';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE INSTR(first_name,'a')\nAND SUBSTR(last_name, 4, 1) = 'o';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE LIKE first_name 'a%'\nAND LIKE last_name '%o';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees1 \nWHERE first_name LIKE '%a%'\nAND last_name LIKE '%o%';</pre>",
                    "<p>None of the listed queries meets the specified requirements.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "INSTR",
            "question_plain": "View and examine the structure of the EMPLOYEES1 table.Table: EMPLOYEES1EMPLOYEE_ID                                 FIRST_NAME                               LAST_NAME\n          1                                      Adela                                  Jasper\n          2                                     Viola                                  Carroll\n          3                                      Mike                                     Khan\n          4                                       Raj                                    Smith\n          5                                       Raj                                     Khan\n          6                                     Adela                                     Jobs\n          7                                     Adela                                    MunozRequired: Display the customer names that have the letter 'a' in their first name and the letter 'o' at the fourth position in their last name only. Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919371,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify three true statements regarding dropping and unused columns in an Oracle database.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Dropping Columns](https://www.red-gate.com/simple-talk/sql/oracle/dropping-columns/)",
                    "[Logical Database Limits](https://docs.oracle.com/cd/B28359_01/server.111/b28320/limits003.htm#i288032)",
                    "[SQL Reference](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/ALTER-TABLE.html)"
                ],
                "feedbacks": [
                    "Dropping a partition key column is not allowed in Oracle databases because it can lead to data loss and integrity issues within the partitioned table.",
                    "An unused column still counts towards the column per table limit in Oracle databases. Even though the column is not being used, it still occupies space and contributes to the overall table structure.",
                    "There is a maximum of 1000 columns per table in Oracle Logical Databases. Exceeding this limit can lead to performance issues and potential data management challenges.",
                    "The statement about the maximum number of WHERE clauses in the top-level query of Oracle Logical Databases is incorrect. The number of WHERE clauses is not limited in Oracle databases.",
                    "There is no specific limit on the number of constraints per column in Oracle Logical Databases. Constraints can be added to columns as needed to enforce data integrity and business rules.",
                    "The statement that there is no limit on the number of columns per table in Oracle Logical Databases is incorrect. There is a maximum limit of 1000 columns per table in Oracle databases.",
                    "When an unused column is marked as UNUSED in Oracle databases, the tablespace used by that column is not automatically reclaimed. Manual intervention is required to reclaim the space occupied by the unused column.",
                    "An unused column still counts towards the column per table limit in Oracle databases, even though it is not actively being used. Unused columns contribute to the overall table structure and can impact performance and storage considerations."
                ],
                "explanation": "<p>Here are <strong>three true statements</strong> regarding dropping and unused columns in an Oracle database:</p><ol><li><p><strong>Dropping a partition key column is not allowed.</strong></p><ul><li><p><strong>True.</strong> In Oracle, you cannot drop a column that is part of the partition key because it is essential for maintaining the partitioning structure.</p></li></ul></li><li><p><strong>An unused column does not count towards the column per table limit.</strong></p><ul><li><p><strong>True.</strong> Once a column is marked as UNUSED, it is logically dropped and no longer counts toward the table's column limit (which is 1000 columns per table).</p></li></ul></li><li><p><strong>There is a maximum of 1000 columns per table in Oracle Logical Databases.</strong></p><ul><li><p><strong>True.</strong> Oracle enforces a hard limit of 1000 columns per table.</p></li></ul></li></ol><p>False or Misleading Statements:</p><ul><li><p><strong>An unused column counts towards the column per table limit.</strong></p><ul><li><p>Incorrect; unused columns do <strong>not</strong> count toward the limit.</p></li></ul></li><li><p><strong>There is a maximum of 255 WHERE clauses in the top-level query of Oracle Logical Databases.</strong></p><ul><li><p>No such documented limit on WHERE clauses; this is likely inaccurate or misinterpreted.</p></li></ul></li><li><p><strong>There is a maximum of 1000 constraints per column in Oracle Logical Databases.</strong></p><ul><li><p>Oracle has limits on constraints, but not specifically 1000 <strong>per column</strong>—this is misleading.</p></li></ul></li><li><p><strong>There is no limit of columns per table in Oracle Logical Databases.</strong></p><ul><li><p>Incorrect; the limit is <strong>1000 columns per table</strong>.</p></li></ul></li><li><p><strong>An unused column's tablespace is reclaimed automatically when the column is marked as UNUSED.</strong></p><ul><li><p>Incorrect; marking a column UNUSED does <strong>not</strong> immediately reclaim space. Space is reclaimed when you <strong>DROP UNUSED COLUMNS</strong> explicitly.</p></li></ul></li></ul><p><br></p><p><strong>Logical Database Limits</strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_17-02-30-8d8ddd2314d6aa3ffdbd5153c0c04019.png\"></p><p>It's not possible to drop a column that’s part of the partition key of a partitioned table. Similarly you can’t drop a column that’s part of the primary key of an index organized table, and there are other restrictions relating to constraints and virtual columns.</p><p><br></p><p><strong>Marking Columns Unused</strong></p><p>If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the <code>ALTER TABLE...SET UNUSED</code> statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.</p><p>To mark the <code>hiredate</code> and <code>mgr</code> columns as unused, execute the following statement:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE hr.admin_emp SET UNUSED (hiredate, mgr);</pre><p><br></p><p>You can later remove columns that are marked as unused by issuing an <code>ALTER TABLE...DROP UNUSED COLUMNS</code> statement. Unused columns are also removed from the target table whenever an explicit drop of any particular column or columns of the table is issued.</p>",
                "answers": [
                    "<p>Dropping a partition key columns is not allowed.</p>",
                    "<p>An unused column counts towards the column per table limit.</p>",
                    "<p>There is a maximum of 1000 columns per table in Oracle Logical Databases.</p>",
                    "<p>There is a maximum of 255 WHERE clauses in the top-level query of Oracle Logical Databases.</p>",
                    "<p>There is a maximum of 1000 constraints per column in Oracle Logical Databases.</p>",
                    "<p>There no limit of columns per table in Oracle Logical Databases.</p>",
                    "<p>An unused column's tablespace is reclaimed automatically when the column is marked as UNUSED.</p>",
                    "<p>An unused column does not counts towards the column per table limit.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify three true statements regarding dropping and unused columns in an Oracle database.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919373,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the INVOICE table. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nINV_NO                  NOT NULL          NUMBER(3)\nINV_DATE                                  DATE\nINV_AMT                                   NUMBER(10,2)\n</pre><p><br></p><p>Identify two SQL statements which would execute successfully. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>This SQL statement successfully executes because it uses the NVL2 function to check if the inv_date column is null. If it is not null, it returns 'Pending'; otherwise, it returns 'Incomplete'. The syntax and logic of the NVL2 function are correctly applied in this statement.</p>",
                    "<p>This SQL statement will not execute successfully because the NVL2 function expects three arguments: the column to check, the value to return if the column is not null, and the value to return if the column is null. In this statement, the second argument is inv_date, which is not a valid value to return if inv_amt is null.</p>",
                    "<p>This SQL statement will execute successfully as it correctly uses the NVL2 function to check if the inv_date column is null. If it is not null, it returns the difference between the current date (sysdate) and the inv_date; otherwise, it returns the current date (sysdate). The syntax and logic of the NVL2 function are correctly applied in this statement.</p>",
                    "<p>This SQL statement will not execute successfully because the NVL2 function expects three arguments: the column to check, the value to return if the column is not null, and the value to return if the column is null. In this statement, the second argument is inv_amt multiplied by 0.25, which is not a valid value to return if inv_amt is null.</p>"
                ],
                "explanation": "<p>The Oracle/PLSQL <code>NVL2</code> function extends the functionality found in the <a href=\"https://www.techonthenet.com/oracle/functions/nvl.php\">NVL function</a>. It lets you substitutes a value when a null value is encountered as well as when a non-null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL2</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">NVL2( string1, value_if_not_null, value_if_null )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 The string to test for a null value. value_if_not_null The value returned if <em>string1</em> is <strong>not</strong> null. value_if_null The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL2</code> function returns a substitute value.</p><p><strong>Applies To</strong></p><p>The <code>NVL2</code> function can be used in the following versions of Oracle/PLSQL:</p><p>Oracle 12c, Oracle 11g, Oracle 10g, Oracle 9i, Oracle 8i</p><p><a href=\"https://www.techonthenet.com/oracle/functions/nvl2.php\">https://www.techonthenet.com/oracle/functions/nvl2.php</a></p><p><br></p><p>Correct: <code>SELECT inv_no,NVL2(inv_date,'Pending','Incomplete') FROM invoice;</code></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-06-09-342b7c0b729374b4d7d1fb238ee8967d.png\"></p><p><br></p><p>Correct: <code>SELECT inv_no,NVL2(inv_date,sysdate-inv_date,sysdate) FROM invoice;</code></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-07-06-7aa948c322771d2456fd8f5510143b11.png\"></p><p><br></p><p>Incorrect: <code>SELECT inv_no,NVL2(inv_amt,inv_date,'Not Available') FROM invoice;</code></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2024-10-07_20-05-27-ca3861f69e59528fcc201afae93832c1.png\"></p><p>Incorrect: <code>SELECT inv_no,NVL2(inv_amt,inv_amt*.25,'Not Available') FROM invoice;</code></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2024-10-07_20-05-27-320fbf1f18f55738eb75e12a4930bae1.png\"></p>",
                "answers": [
                    "<p>SELECT inv_no,NVL2(inv_date,'Pending','Incomplete') FROM invoice;</p>",
                    "<p>SELECT inv_no,NVL2(inv_amt,inv_date,'Not Available') FROM invoice;</p>",
                    "<p>SELECT inv_no,NVL2(inv_date,sysdate-inv_date,sysdate) FROM invoice;</p>",
                    "<p>SELECT inv_no,NVL2(inv_amt,inv_amt*.25,'Not Available') FROM invoice;</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the INVOICE table. Exhibit: 1Name                    Null??            Type\nINV_NO                  NOT NULL          NUMBER(3)\nINV_DATE                                  DATE\nINV_AMT                                   NUMBER(10,2)\nIdentify two SQL statements which would execute successfully. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919375,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE DEPARTMENT_DETAILS(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ndepartment_name VARCHAR2(50),\nhod VARCHAR2(50),\n);\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE course_details(\ncourse_id NUMBER PRIMARY KEY,\ncourse_name VARCHAR2(50),\ndepartment_id NUMBER REFERENCES department_details (department_id)\n);</pre><p><br></p><p><strong>Required: </strong>Generate a report that shows all course IDs irrespective of whether they have corresponding department IDs or not but no department IDs if they do not have any courses.&nbsp; </p><p><strong>Required: </strong>Generate a report that shows the following:</p><ul><li><p>All course IDs irrespective of whether they have corresponding department IDs or not</p></li><li><p>Do not have department IDs listed if they have no courses.&nbsp; </p></li></ul><p>Identify the best SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>Best and simplest option. This query uses a LEFT OUTER JOIN to include all records from the course_details table, regardless of whether they have corresponding department IDs in the department_details table. If there is no matching department ID, the department ID will be NULL, as per the requirement.</p>",
                    "<p>Functionally same as Best option, just uses a verbose <code>CASE</code> instead of directly showing <code>d.department_id</code>. Also correct, but not preferred due to redundancy</p>",
                    "This query uses a RIGHT OUTER JOIN, which is not suitable for this scenario as it will include all records from the department_details table, even if they do not have corresponding course IDs. This does not meet the requirement of only showing department IDs with courses.",
                    "<p>RIGHT JOIN from departments to courses = same effect as LEFT JOIN from courses. Shows all courses, with department_id if available. Also satisfies both requirements but it is not a simple as the Best option.</p>",
                    "This query uses a RIGHT OUTER JOIN with a syntax error (a dot before department_details table). This will not provide the correct output as it does not meet the requirement of only showing department IDs with courses.",
                    "This query uses a FULL OUTER JOIN, which will include all records from both tables, regardless of whether they have matching records in the other table. This does not meet the requirement of only showing department IDs with courses."
                ],
                "explanation": "<p>Best Option (Simple and correct): </p><pre class=\"prettyprint linenums\">SELECT c.course_id, \n       d.department_id\nFROM course_details c\nLEFT OUTER JOIN department_details d ON c.department_id = d.department_id;\n</pre><p><strong>Preferred Option </strong>— Clean, readable, and fully meets the specified output requirement.</p><p><strong><em>When asked for the Best Answer, where there are multiple answers that do the same job, the Best is always the simplest. </em></strong><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-06-14_15-05-07-3c38bc5c899a90bfc036790b4820dc02.png\"></p><p><br></p><p><strong>Requirement Recap:</strong></p><p>You want a report that:</p><ol><li><p><strong>Includes all course IDs</strong> — even if they do <strong>not</strong> have a matching department.</p></li><li><p><strong>Does not include any department IDs</strong> that are <strong>not tied to a course</strong>.</p></li></ol><p>Query evaluation:</p><p><strong>Option 1:</strong></p><pre class=\"prettyprint linenums\">SELECT c.course_id, \n       d.department_id\nFROM course_details c\nLEFT OUTER JOIN department_details d ON c.department_id = d.department_id;\n</pre><ul><li><p><strong>LEFT JOIN</strong> ensures:</p><ul><li><p>All <strong>courses</strong> are shown</p></li><li><p>If no matching department, department_id is <code>NULL</code> </p></li></ul></li><li><p>Fully meets the requirement</p></li></ul><p><strong>Option 2:</strong></p><pre class=\"prettyprint linenums\">SELECT c.course_id, \n       CASE WHEN d.department_id IS NOT NULL THEN d.department_id ELSE NULL END AS department_id\nFROM course_details c\nLEFT OUTER JOIN department_details d ON c.department_id = d.department_id;\n</pre><ul><li><p>Functionally <strong>same as Option 1</strong>, just uses a verbose <code>CASE</code> instead of directly showing <code>d.department_id</code></p></li><li><p>Also <strong>correct</strong>, but <strong>not preferred</strong> due to redundancy</p></li></ul><p><strong>Option 3:</strong></p><pre class=\"prettyprint linenums\">SELECT \n    c.course_id, \n    c.course_name, \n    d.department_id\nFROM \n    course_details c\nRIGHT OUTER JOIN \n    department_details d \nON \n    c.department_id = d.department_id;\n</pre><ul><li><p><strong>RIGHT JOIN</strong> on departments → shows <strong>departments even with no courses</strong> </p></li><li><p>Violates requirement 2</p></li></ul><p><strong>Option 4:</strong></p><pre class=\"prettyprint linenums\">SELECT course_id, department_id\nFROM department_details d  \nRIGHT OUTER JOIN course_details c  \nUSING (department_id);\n</pre><ul><li><p><strong>RIGHT JOIN</strong> from departments to courses = same effect as LEFT JOIN from courses</p></li><li><p>Shows all courses, with department_id if available</p></li><li><p>Also satisfies both requirements</p></li></ul><p><strong>Option 5:</strong></p><pre class=\"prettyprint linenums\">SELECT c.course_id, d.department_id  \nFROM course_details c  \nRIGHT OUTER JOIN .department_details d  \nON (c.depatrment_id=d.department_id)\n</pre><ul><li><p>Syntax error: stray dot before <code>department_details</code></p></li><li><p>Typo in <code>c.depatrment_id</code></p></li></ul><p><strong>Option 6:</strong></p><pre class=\"prettyprint linenums\">SELECT c.course_id, d.department_id  \nFROM course_details c  \nFULL OUTER JOIN department_details d  \nON (c.department_id=d.department_id)\n</pre><ul><li><p><strong>FULL OUTER JOIN</strong> includes:</p><ul><li><p>Courses with and without departments</p></li><li><p>Departments with no courses</p></li></ul></li><li><p>Violates the second condition</p></li></ul><p><br></p><p><strong>Oracle JOINS</strong></p><p>Oracle <code>JOINS</code> are used to retrieve data from multiple tables. An Oracle <code>JOIN</code> is performed whenever two or more tables are joined in a SQL statement.</p><p><strong>There are 4 different types of Oracle joins:</strong></p><p>Oracle <code>INNER JOIN</code> (or sometimes called simple join)</p><p>Oracle <code>LEFT OUTER JOIN</code> (or sometimes called <code>LEFT JOIN</code>)</p><p>Oracle <code>RIGHT OUTER JOIN</code> (or sometimes called <code>RIGHT JOIN</code>)</p><p>Oracle <code>FULL OUTER JOIN</code> (or sometimes called <code>FULL JOIN</code>)</p><p><br></p><p><strong>INNER JOIN (simple join)</strong></p><p>Chances are, you've already written a statement that uses an Oracle <code>INNER JOIN</code>. It is the most common type of join. Oracle<code>INNER JOIN</code> return all rows from multiple tables where the join condition is met.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INNER JOIN</code> in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1 \nINNER JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>INNER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-35-43-24928132deb29a86ae282a2d5d4b4e6d.png\"></p><p>The Oracle <code>INNER JOIN</code> would return the records where <em>table1</em> and <em>table2</em> intersect.</p><p><br></p><p><strong>LEFT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>LEFT OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p>Syntax</p><p>The syntax for the Oracle <code>LEFT OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nLEFT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>LEFT OUTER JOIN</code> keywords are replaced with LEFT JOIN.</p><p>Visual Illustration</p><p>In this visual diagram, the Oracle <code>LEFT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-17-2ee387b09bb38b1b8dc835df5f025fa0.png\"></p><p>The Oracle <code>LEFT OUTER JOIN</code> would return the all records from <em>table1</em> and only those records from <em>table2</em> that intersect with <em>table1</em>.</p><p><br></p><p><strong>RIGHT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>RIGHT OUTER JOIN</code>. This type of join returns all rows from the RIGHT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>RIGHT OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nRIGHT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>RIGHT OUTER JOIN</code> keywords are replaced with RIGHT JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>RIGHT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-48-1112abda363494f4f4674610d4a5828b.png\"></p><p>The Oracle <code>RIGHT OUTER JOIN</code> would return the all records from <em>table2</em> and only those records from <em>table1</em> that intersect with <em>table2</em>.</p><p><br></p><p><strong>FULL OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>FULL OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table and RIGHT-hand table with nulls in place where the join condition is not met.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>FULL OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nFULL [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>FULL OUTER JOIN</code> keywords are replaced with FULL JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>FULL OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-37-23-693a8eb7a6e48912a42bf894a4d6ab7e.png\"></p><p>The Oracle <code>FULL OUTER JOIN</code> would return the all records from both <em>table1</em> and <em>table2</em>.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT c.course_id, \n       d.department_id\nFROM course_details c\nLEFT OUTER JOIN department_details d ON c.department_id = d.department_id;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT c.course_id, \n       CASE WHEN d.department_id IS NOT NULL THEN d.department_id ELSE NULL END AS department_id\nFROM course_details c\nLEFT OUTER JOIN department_details d ON c.department_id = d.department_id;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT \n    c.course_id, \n    c.course_name, \n    d.department_id\nFROM \n    course_details c\nRIGHT OUTER JOIN \n    department_details d \nON \n    c.department_id = d.department_id;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT course_id, department_id\nFROM department_details d  \nRIGHT OUTER JOIN course_details c  \nUSING (department_id);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT c.course_id, d.department_id  \nFROM course_details c  \nRIGHT OUTER JOIN .department_details d  \nON (c.depatrment_id=d.department_id)\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT c.course_id, d.department_id  \nFROM course_details c  \nFULL OUTER JOIN department_details d  \nON (c.department_id=d.department_id)\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "",
            "question_plain": "View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS.Exhibit 1:CREATE TABLE DEPARTMENT_DETAILS(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ndepartment_name VARCHAR2(50),\nhod VARCHAR2(50),\n);\nExhibit 2:CREATE TABLE course_details(\ncourse_id NUMBER PRIMARY KEY,\ncourse_name VARCHAR2(50),\ndepartment_id NUMBER REFERENCES department_details (department_id)\n);Required: Generate a report that shows all course IDs irrespective of whether they have corresponding department IDs or not but no department IDs if they do not have any courses.&nbsp; Required: Generate a report that shows the following:All course IDs irrespective of whether they have corresponding department IDs or notDo not have department IDs listed if they have no courses.&nbsp; Identify the best SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919377,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding GLOBAL TEMPORARY TABLES. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Global Temporary Table ( GTT) - key facts](https://facedba.blogspot.com/2017/06/global-temporary-table-gtt-key-facts.html)",
                    "[Oracle / PLSQL: Global Temporary tables](https://www.techonthenet.com/oracle/tables/global_temp.php)"
                ],
                "feedbacks": [
                    "Temporary tables can have triggers associated with them, allowing for additional functionality and automation when working with temporary data. This feature enhances the flexibility and usability of global temporary tables in Oracle Database SQL.",
                    "Views can indeed be created against temporary tables, providing a way to simplify complex queries, improve data organization, and enhance data access efficiency. This capability allows for better data management and query optimization in Oracle Database SQL.",
                    "All undo associated with Data Manipulation Language (DML) operations against a Global Temporary Table (GTT) is indeed written to the normal undo tablespace. This ensures data consistency and integrity in Oracle Database SQL, making GTTs a reliable and secure option for temporary data storage.",
                    "The data in a Global Temporary Table (GTT) is not written to the temporary tablespace. Instead, GTTs store data in memory or in the temporary tablespace for the duration of a session, providing a temporary and efficient data storage solution in Oracle Database SQL.",
                    "Indexes can be created on temporary tables in Oracle Database SQL, contrary to the statement provided. Indexes help improve query performance and data retrieval speed, making them a valuable addition to temporary tables when working with large datasets or complex queries.",
                    "Each column in a Global Temporary Table (GTT) should indeed be defined as either NULL or NOT NULL. If this value is left blank, the database assumes NOT NULL as the default, ensuring data integrity and consistency in Oracle Database SQL. This requirement helps maintain data quality and accuracy when working with temporary data in GTTs."
                ],
                "explanation": "<p>Correct Options:</p><p><strong>1. Temporary tables can have triggers associated with them.</strong></p><ul><li><p>You <strong>can create triggers</strong> on GLOBAL TEMPORARY TABLES.</p></li><li><p>For example: <strong>row-level triggers</strong> can be used to log changes during a session or transaction.</p></li></ul><p><strong>2. Views can be created against temporary tables.</strong></p><ul><li><p>You <strong>can create views</strong> based on GTTs.</p></li><li><p>However, such views are typically only useful within a session or transaction, depending on the GTT's behaviour.</p></li></ul><p><strong>3. All undo associated with DML against a GTT is written to the normal undo tablespace.</strong></p><ul><li><p>Although <strong>GTT data</strong> is session- or transaction-specific, <strong>undo for DML operations</strong> (like inserts/updates/deletes) is <strong>still written to the regular undo tablespace</strong>.</p></li><li><p>This is necessary for <strong>read consistency and rollback</strong>.</p></li></ul><p>Incorrect Options:</p><ul><li><p><strong>The data in a GLOBAL TEMPORARY TABLE is not written to the temporary tablespace.</strong></p><ul><li><p>The <strong>data</strong> in a GTT <strong>is</strong> stored in the <strong>temporary tablespace</strong>, not the permanent one.</p></li></ul></li></ul><ul><li><p><strong>Indexes cannot be created on temporary tables.</strong></p><ul><li><p>You <strong>can create indexes</strong> on GTTs.</p></li><li><p>These can be either <strong>explicit</strong> (created manually) or <strong>automatically created</strong> when constraints are defined.</p></li></ul></li></ul><ul><li><p><strong> Each column should either be defined as NULL or NOT NULL. If this value is left blank, the database assumes NOT NULL as the default.</strong></p><ul><li><p>In Oracle, <strong>the default is NULL</strong> when no NULL/NOT NULL is specified.</p></li><li><p>So, this statement is <strong>incorrect</strong></p></li></ul></li></ul><p><br></p><p><strong>GLOBAL TEMPORARY TABLES</strong> in Oracle are tables that are created distinct within the Oracle sessions.</p><p><strong>Syntax</strong></p><p>The syntax for Oracle <strong>CREATE GLOBAL TEMPORARY TABLE</strong> is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE GLOBAL TEMPORARY TABLE table_name\n( column1 datatype [ NULL | NOT NULL ],\n  column2 datatype [ NULL | NOT NULL ],\n  ...\n  column_n datatype [ NULL | NOT NULL ]\n);</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table_name - The name of the global temporary table that you wish to create. </p><p>column1, column2, ... column_n - The columns that you wish to create in the global temporary table. Each column must have a datatype. The column should either be defined as <code>NULL</code> or <code>NOT NULL</code> and if this value is left blank, the database assumes <code>NULL</code> as the default.</p><p><strong>Features:</strong></p><p>The data in a Global Temporary Table (GTT) is written to the temporary tablespace, which is not directly protected by redo, so using a GTT improves performance by <strong>reducing redo generation</strong>. Unfortunately, prior to Oracle 12c, <em>all undo associated with DML against a GTT is written to the normal undo tablespace</em>, which is itself <strong>protected by redo</strong>. As a result, using a GTT reduces the amount of redo generation, but does not eliminate it. Another why of describing this is, using a GTT removes direct redo generation, but not indirect redo generation cause by undo.</p><p> 1. GTTs use space in your <strong>temporary tablespace</strong>. Regular tables use space in their assigned tablespace.</p><p> 2. GTTs never have to be truncated, the <strong>data automatically goes away</strong> when your session ends (or you commit). Regular tables persist until you delete/truncate.</p><p> 3. GTTs allow you to see only the data your session has put in. Regular tables allow you to see other people's data that they put in (Assuming you're not using FGAC).</p><p> 4. <strong>Regular tables get fragmented</strong>/oversized over time because your report is 100 rows and the next guy's report is 10000000 rows which may lead to lots of empty blocks being scanned. GTTs are effectively truncated when you logout/commit.</p><p> 5. Regular tables have stats calculated in order to help the optimizer (which may be good or bad). GTTs don't have stats calculated unless they are specifically set.</p><p> 6. GTTs don't persist very well. This makes it harder for stateless or pooled connections to \"build\" with one connection and then \"Query\" with another connection. </p><p> 7. You do understand that even a GTT will generate GOBS of redo when you use <code>UPDATE</code> and <code>DELETE</code> on it (generates MINIMAL with <code>INSERT</code>). You can pass a GTT to child function or procedure from parent call.</p><p> 8. No <code>REDO</code> is generated for the GTT, however<strong> </strong><code>UNDO</code><strong> is generated for the GTT</strong> and <code>REDO</code> for the <code>UNDO</code> *must* be generated</p><p> 9. Since <code>INSERT</code> and <code>SELECT</code> generates minimal <code>UNDO</code> (and consequently minimal <code>REDO</code>), GTT will be best suited when most of your operations against GTT are either <code>INSERT</code> and <code>SELECT</code>.</p><p> 10. Since <code>UPDATE</code> and <code>DELETE</code> generate the most amount of <code>UNDO</code> (and consequently most <code>REDO</code> to protect the UNDO), using GTT for these DML operations will almost generate the same amount of <code>REDO</code> as for a normal table. </p><p> 11. An <code>UPDATE</code> against a GTT will generate 1/2 of <code>REDO</code> as it generated for normal table (since REDO for the <code>UNDO</code> is logged)</p><p> 12. A <code>DELETE</code> against a GTT will generate same amount of <code>REDO</code> as it generated for normal table (since <code>UNDO</code> for <code>DELETE</code> is more) and the <code>REDO</code> for the <code>UNDO</code> is logged.</p><p> 13. Although the data in a GTT is written to the temporary tablespace, the associated undo is still written to the normal undo tablespace, which is itself protected by redo, so using a GTT does not reduce undo and the redo associated with protecting the undo tablespace.</p><p> 14. If the <code>TRUNCATE</code> statement is issued against a temporary table, <strong>only the session specific data is truncated</strong>. There is no affect on the data of other sessions.</p><p> 15. <strong>Indexes can be created</strong> on temporary tables. The content of the index and the scope of the index is the same as the database session. Index stats is managed by Oracle it self.</p><p> 16. <strong>Views can be created</strong> against temporary tables and combinations of temporary and permanent tables.</p><p> 17. Temporary tables can have triggers associated with them.</p><p> 18. <strong>Export and Import utilities can be used</strong> to transfer the table definitions, but no data rows are processed.</p>",
                "answers": [
                    "<p>Temporary tables can have triggers associated with them.</p>",
                    "<p>Views can be created against temporary tables.</p>",
                    "<p>All undo associated with DML against a GTT is written to the normal undo tablespace.</p>",
                    "<p>The data in a GLOBAL TEMPORARY TABLE is not written to the temporary tablespace.</p>",
                    "<p>Indexes cannot be created on temporary tables.</p>",
                    "<p>Each column should either be defined as NULL or NOT NULL. If this value is left blank, the database assumes NOT NULL as the default.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "Global Temporary tables",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding GLOBAL TEMPORARY TABLES. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919379,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the command to create the BOOKS table. </p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE books(\nbook_id CHAR(6) PRIMARY KEY,\ntitle VARCHAR2(100) NOT&nbsp;NULL,\npublisher_id VARCHAR2(4)\nauthor_id VARCHAR2(50)\n);</pre><p><br></p><p><strong>Given:</strong> The BOOK_ID value 101 does not exist in the table.&nbsp; </p><p>The following SQL statement has now been executed.</p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">INSERT&nbsp;INTO&nbsp;books(BOOK_ID, TITLE, AUTHOR_ID)\nVALUES\n('101', 'LEARNING SQL', 'TONY STARK');\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[INSERT statement](https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj40774.html)"
                ],
                "feedbacks": [
                    "The INSERT statement will execute successfully and insert a new row into the BOOKS table with a blank entry in the PUBLISHER_ID field. Since the column allows NULL values and no value is provided in the INSERT statement, it will default to a blank entry.",
                    "This choice is incorrect because the INSERT statement will execute successfully even without explicitly specifying NULL in the INSERT statement. The column allows NULL values by default, so not providing a value will default to NULL.",
                    "This choice is incorrect because the INSERT statement will execute successfully without explicitly adding the PUBLISHER_ID column name to the columns list. If a column is not specified in the INSERT statement, it will default to NULL or the default value specified for that column.",
                    "This choice is incorrect because the INSERT statement will execute successfully even if the PUBLISHER_ID column name is not added to the columns list. As long as the column allows NULL values and no value is provided, it will default to NULL."
                ],
                "explanation": "<p><strong>Correct Answer:&nbsp; </strong>It executes successfully and the row is inserted with a blank entry PUBLISHER_ID field.</p><p><br></p><p>Let's break this down step by step to determine <strong>the correct result of executing the given </strong><code><strong>INSERT</strong></code><strong> statement</strong>.</p><p><strong>Exhibit 1: BOOKS Table Definition</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE books(\n  book_id CHAR(6) PRIMARY KEY,\n  title VARCHAR2(100) NOT NULL,\n  publisher_id VARCHAR2(4),\n  author_id VARCHAR2(50)\n);\n</pre><p><br></p><p><strong>Exhibit 2: INSERT Statement</strong></p><pre class=\"prettyprint linenums\">INSERT INTO books(BOOK_ID, TITLE, AUTHOR_ID)\nVALUES ('101', 'LEARNING SQL', 'TONY STARK');\n</pre><p><strong>Analysis:</strong></p><ul><li><p>The <code>INSERT</code> statement <strong>specifies only three columns</strong>:<br><code>BOOK_ID</code>, <code>TITLE</code>, and <code>AUTHOR_ID</code>.</p></li><li><p>The <code><strong>PUBLISHER_ID</strong></code><strong> column is omitted</strong> in the insert list.</p></li><li><p>Is this a problem? <strong>No</strong>, <strong>because:</strong></p><ul><li><p><code>PUBLISHER_ID</code> is <strong>nullable</strong> (there’s <strong>no </strong><code><strong>NOT NULL</strong></code><strong> constraint</strong> on it).</p></li><li><p>In Oracle, if a column is omitted in an <code>INSERT</code>, and it is <strong>nullable</strong>, it will automatically get a <strong>NULL</strong> value.</p></li><li><p>Therefore, Oracle will insert <code>NULL</code> into <code>PUBLISHER_ID</code> by default.</p></li></ul></li></ul><p><strong>Conclusion: The statement executes successfully</strong>, and a new row is inserted with <code>PUBLISHER_ID</code> set to <code><strong>NULL</strong></code> (i.e., a blank entry).</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_22-19-37-f26f74368ec6537166470eeebc380751.png\"></p><p><br></p><p>Why the other options are incorrect:</p><ul><li><p><strong>\"It executes successfully only if NULL is explicitly specified in the INSERT statement.\"</strong> → <strong>Incorrect</strong></p><ul><li><p>NULL is the default value for columns that are not explicitly assigned a value.</p></li></ul></li><li><p><strong>\"It executes successfully only if the PUBLISHER_ID column name is added to the columns list in the INSERT statement.\"</strong> → <strong>Incorrect</strong></p><ul><li><p>The column does not require explicit inclusion unless a specific value is provided.</p></li></ul></li><li><p><strong>\"It executes successfully only if the PUBLISHER_ID column name is added to the columns list and NULL is explicitly specified in the INSERT statement.\"</strong> → <strong>Incorrect</strong></p></li></ul><ul><li><p>Explicitly specifying NULL is <strong>not required</strong>, as it is the default behaviour.</p><p><br></p></li></ul><p>The Oracle <strong>INSERT statement</strong> is used to insert a single record or multiple records into a table in Oracle.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>INSERT</code> statement when inserting a single record using the <code>VALUES</code> keyword is:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO table\n(column1, column2, ... column_n )\nVALUES\n(expression1, expression2, ... expression_n );</pre><p><br></p><p>Or the syntax for the Oracle <code>INSERT</code> statement when inserting multiple records using a <code>SELECT</code> statement is:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO table\n(column1, column2, ... column_n )\nSELECT expression1, expression2, ... expression_n\nFROM source_table\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table - The table to insert the records into. </p><p>column1, column2, ... column_n - The columns in the <em>table</em> to insert values. </p><p>expression1, expression2, ... expression_n - The values to assign to the columns in the table. So <em>column1</em> would be assigned the value of <em>expression1</em>, <em>column2</em> would be assigned the value of <em>expression2</em>, and so on. </p><p>source_table - The source table when inserting data from another table. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be inserted.</p><p><strong>Note</strong></p><p>When inserting records into a table using the Oracle <code>INSERT</code> statement, you must provide a value for every <code>NOT NULL</code> column.</p><p>You can omit a column from the Oracle <code>INSERT</code> statement if the column allows <code>NULL</code> values.</p><p><br></p><p>The Oracle <strong>INSERT ALL statement</strong> is used to add multiple rows with a single <code>INSERT</code> statement. The rows can be inserted into one table or multiple tables using only one SQL command.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INSERT ALL</code> statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT ALL\n  INTO mytable (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO mytable (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\n  INTO mytable (column1, column2, column_n) VALUES (expr1, expr2, expr_n)\nSELECT * FROM dual;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>mytable - The table to insert the records into. </p><p>column1, column2, column_n - The columns in the <em>table</em> to insert values. </p><p>expr1, expr2, ... expr_n - The values to assign to the columns in the table.</p>",
                "answers": [
                    "<p>It executes successfully and the row is inserted with a blank entry PUBLISHER_ID field.</p>",
                    "<p>It executes successfully only if NULL is explicitly specified in the INSERT statement.</p>",
                    "<p>It executes successfully only if the PUBLISHER_ID column name is added to the columns list in the INSERT statement.</p>",
                    "<p>It executes successfully only if the PUBLISHER_ID column name is added to the columns list and NULL is explicitly specified in the INSERT statement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "INSERT",
            "question_plain": "View and examine the command to create the BOOKS table. Exhibit 1:CREATE TABLE books(\nbook_id CHAR(6) PRIMARY KEY,\ntitle VARCHAR2(100) NOT&nbsp;NULL,\npublisher_id VARCHAR2(4)\nauthor_id VARCHAR2(50)\n);Given: The BOOK_ID value 101 does not exist in the table.&nbsp; The following SQL statement has now been executed.Exhibit 2:INSERT&nbsp;INTO&nbsp;books(BOOK_ID, TITLE, AUTHOR_ID)\nVALUES\n('101', 'LEARNING SQL', 'TONY STARK');\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919485,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the Oracle COUNT function. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle COUNT Function](https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/)"
                ],
                "feedbacks": [
                    "The Oracle COUNT() function is indeed classified as an aggregate function, which means it operates on a set of values and returns a single value as a result.",
                    "The Oracle COUNT(*) function includes NULL values in the count, meaning it counts all rows, regardless of whether they contain NULL values or not.",
                    "The COUNT(DISTINCT expression) function in Oracle returns the number of unique and non-null items in a group, excluding any duplicate values.",
                    "<p>The Oracle COUNT(ALL expression)...excludes the number of non-null (excludes NOT the not-null but the null, which makes the selection incorrect)</p>",
                    "It is possible to combine the COUNT() function with the HAVING and GROUP BY clauses in Oracle SQL. Using these clauses together allows for more complex and specific data analysis, rather than causing a conflict or error."
                ],
                "explanation": "<p>Correct options:</p><ol><li><p><strong>The Oracle COUNT() function is classified as an aggregate function</strong> – It is used to return the number of items in a group.</p><ol><li><p><code>COUNT()</code> is an <strong>aggregate function</strong> that returns the number of rows in a group.</p></li><li><p>It can be used with or without <code>GROUP BY</code>.</p></li></ol></li><li><p><strong>The Oracle COUNT(*) function does not ignore NULL values</strong> – Since <code>COUNT(*)</code> counts rows rather than specific column values, it includes NULLs.</p><ol><li><p><code>COUNT(*)</code> <strong>counts all rows</strong>, <strong>including rows where all columns are NULL</strong>.</p></li><li><p>It <strong>does not ignore</strong> NULLs because it counts rows, not values.</p></li></ol></li><li><p><strong>COUNT(DISTINCT expression) function returns the number of unique excluding null items in a group</strong> – It eliminates duplicates and ignores NULL values.</p><ol><li><p><code>COUNT(DISTINCT column)</code> <strong>counts only unique, non-NULL</strong> values.</p></li></ol></li></ol><p>Why the others are incorrect:</p><ul><li><p><strong>The Oracle COUNT(ALL expression) evaluates the expression and excludes the number of non-null items in a group, but returns non-null duplicate values</strong> → <strong>Incorrect</strong></p><ul><li><p><code>COUNT(ALL expression)</code> counts <strong>all non-null values</strong>, including duplicates, but does <strong>not exclude non-null items</strong>.</p></li></ul></li><li><p><strong>You cannot combine the COUNT() function with the HAVING and GROUP BY clauses as they will create a conflict and produce an error</strong> → <strong>Incorrect</strong></p><ul><li><p><code>COUNT()</code> is commonly used with <code>HAVING</code> and <code>GROUP BY</code> to filter grouped results.</p></li><li><p>Example:</p><ul><li><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(*) \nFROM employees \nGROUP BY department_id \nHAVING COUNT(*) &gt; 10;\n</pre></li></ul></li></ul></li></ul><p><br></p><p>The <strong>Oracle COUNT() function</strong> is an <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate function</a> that returns the number of items in a group.</p><p>The syntax of the <code>COUNT()</code> function is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">COUNT( [ALL | DISTINCT | * ] expression)</pre><p><br></p><p>The <code>COUNT()</code> function accepts a clause which can be either <code>ALL</code>, <code>DISTINCT</code>, or <code>*</code>:</p><p><code>COUNT(*)</code> function returns the number of items in a group, including <code>NULL</code> and duplicate values.</p><p><code>COUNT(DISTINCT expression)</code> function returns the number of unique and non-null items in a group.</p><p><code>COUNT(ALL expression)</code> evaluates the expression and returns the number of non-null items in a group, including duplicate values.</p><p>If you don’t explicitly specify <code>DISTINCT</code> or <code>ALL</code>, the <code>COUNT()</code> function uses the <code>ALL</code> by default.</p><p>Note that, unlike other <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>, the <code>COUNT(*)</code> function does not ignore <code>NULL</code> values.</p><p><br></p><p>You can combine the <code>COUNT()</code> function with the a <code>HAVING</code>, <code>GROUP BY</code> and <code>ORDER BY</code> clauses as shown.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    column_1,\n    COUNT( column_2)\nFROM\n    table\nGROUP BY\n    column_1\nHAVING\n    COUNT( column_1)&gt; 1\nORDER BY\n    column_1;</pre><p><br></p><p><br></p><p>The statement about the Oracle COUNT(ALL expression) function is incorrect. The COUNT(ALL expression) function evaluates the expression and includes all values, including duplicates and <strong>NULL </strong>values, in the count.</p><p>No, <code><strong>COUNT(expression)</strong></code><strong> or </strong><code><strong>COUNT(ALL expression)</strong></code> counts all <strong>non-NULL</strong> values (including duplicates).</p><p><br></p><p>Example:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/q_and_a/2025-01-15_11-20-53-d17e8a028a3fc71371661e205c7c5599.png\"></p><p><br></p><p> </p><p>but</p><p><br></p><p><br></p><p> <img src=\"https://img-c.udemycdn.com/redactor/raw/q_and_a/2025-01-15_11-20-53-eeefbd30e66340c58359595e2b505041.png\"></p>",
                "answers": [
                    "<p>The Oracle COUNT() function is classified as an aggregate function.</p>",
                    "<p>The Oracle COUNT(*) function does not ignore NULL values.</p>",
                    "<p>COUNT(DISTINCT expression) function returns the number of unique excluding null items in a group.</p>",
                    "<p>The Oracle COUNT(ALL expression) evaluates the expression and excludes the number of non-null items in a group, but returns non-null duplicate values.</p>",
                    "<p>You cannot combine the COUNT() function with the a HAVING and GROUP BY clauses as they will create a conflict and produce an error.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "COUNT",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the Oracle COUNT function. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919381,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(30)\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBER</pre><p><br></p><p><strong>Required: </strong></p><ul><li><p>For customers whose income level has a value, you want to display the first name and due amount as 5% of their credit limit. </p></li><li><p>Customers who have no amount due should not be displayed.&nbsp; </p></li></ul><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL query correctly selects the first name and due amount (5% of credit limit) for customers whose income level is not null and have a credit limit greater than 0. It filters out customers with no amount due as required.",
                    "This SQL query incorrectly uses the inequality operator for comparing NULL values in the WHERE clause, which will not return the desired results. Additionally, the due_amount column is not present in the table, so the query will not execute successfully.",
                    "This SQL query correctly selects the first name and due amount (5% of credit limit) for customers whose income level is not null. However, it incorrectly checks for due_amount to be not null, which is not a valid column in the table.",
                    "This SQL query incorrectly uses the inequality operator for comparing NULL values in the WHERE clause, which will not return the desired results. Additionally, it checks for cust_credit_level instead of cust_credit_limit, which is incorrect.",
                    "This SQL query incorrectly uses the inequality operator for comparing NULL values in the WHERE clause, which will not return the desired results. Additionally, it checks for cust_income_level and due_amount to be not equal to NULL, which is not the correct way to handle null values in SQL."
                ],
                "explanation": "<p>Let's breakdown what is required:</p><ul><li><p><strong>Display:</strong></p><ul><li><p><code>CUST_FIRST_NAME</code></p></li><li><p><strong>Due Amount</strong> = 5% of <code>CUST_CREDIT_LIMIT</code></p></li></ul></li><li><p><strong>Conditions:</strong></p><ol><li><p><strong>Only include customers where </strong><code><strong>CUST_INCOME_LEVEL</strong></code><strong> is NOT NULL</strong></p></li><li><p><strong>Exclude customers where the calculated due amount is NULL or 0</strong></p></li></ol></li></ul><p><strong>Assumptions:</strong></p><ul><li><p>If <code>CUST_CREDIT_LIMIT</code> is NULL or 0, then <strong>5% of it is NULL or 0</strong>, and <strong>such rows should be excluded</strong>.</p></li></ul><p>Correct query:</p><pre class=\"prettyprint linenums\">SELECT \n    CUST_FIRST_NAME, \n    CUST_CREDIT_LIMIT * 0.05 AS DUE_AMOUNT\nFROM \n    CUSTOMERS\nWHERE \n    CUST_INCOME_LEVEL IS NOT NULL\n    AND CUST_CREDIT_LIMIT IS NOT NULL\n    AND CUST_CREDIT_LIMIT * 0.05 &gt; 0;\n</pre><p><br></p><ul><li><p><code>CUST_INCOME_LEVEL IS NOT NULL</code> → ensures income level exists</p></li><li><p><code>CUST_CREDIT_LIMIT IS NOT NULL</code> → avoids NULL calculation</p></li><li><p><code>CUST_CREDIT_LIMIT * 0.05 &gt; 0</code> → filters out zero or NULL due amounts</p></li></ul><p><br></p><p>Incorrect options:</p><pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level != NULL \nAND due_amount != NULL;\n</pre><ul><li><p><code>!= NULL</code> is invalid SQL — should be <code>IS NOT NULL</code></p></li><li><p>You <strong>cannot use </strong><code><strong>due_amount</strong></code><strong> in the </strong><code><strong>WHERE</strong></code><strong> clause</strong> directly since it's an alias defined in <code>SELECT</code></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level IS NOT NULL \nAND due_amount IS NOT NULL;\n</pre><ul><li><p>Same issue: <code>due_amount</code> alias <strong>not allowed</strong> in <code>WHERE</code> clause</p></li><li><p>You must repeat the expression (<code>cust_credit_limit * .05</code>) in <code>WHERE</code></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level != NULL \nAND cust_credit_level != NULL;\n</pre><ul><li><p><code>!= NULL</code> is invalid — must use <code>IS NOT NULL</code></p></li><li><p>Typo: <code>cust_credit_level</code> (should be <code>cust_credit_limit</code>)</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level &lt;&gt; NULL \nAND due_amount &lt;&gt; NULL;\n</pre><ul><li><p>Again, <code>&lt;&gt; NULL</code> is invalid syntax — should be <code>IS NOT NULL</code></p></li><li><p>Can't use <code>due_amount</code> in <code>WHERE</code> (not yet computed)</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * 0.05 AS due_amount\nFROM customers\nWHERE cust_income_level IS NOT NULL \nAND cust_credit_limit IS NOT NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level != NULL \nAND due_amount != NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level IS NOT NULL \nAND due_amount IS NOT NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level != NULL \nAND cust_credit_level != NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, \n       cust_credit_limit * .05 AS DUE_AMOUNT \nFROM customers \nWHERE cust_income_level &lt;&gt; NULL \nAND due_amount &lt;&gt; NULL;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the description of the CUSTOMERS table.Table: CUSTOMERSName                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(30)\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBERRequired: For customers whose income level has a value, you want to display the first name and due amount as 5% of their credit limit. Customers who have no amount due should not be displayed.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919383,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the EMP table as well as the exhibit.</p><p><strong>Table: EMP</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nEMPNO                   NOT NULL          NUMBER(4)\nFIRST_NAME                                VARCHAR(20)\nLAST_NAME                                 VARCHAR2\nSALARY                                    NUMBER(10,2)\nDEPNO                                     NUMBER(2)\n</pre><p><br></p><p><strong>Given: </strong>EMP is not partitioned and not an index-organized table</p><p>Evaluate this SQL statement.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nDROP COLUMN first_name;\n</pre><p><br></p><p>Identify the statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ALTER TABLE Statement](https://www.techonthenet.com/oracle/tables/alter_table.php)"
                ],
                "feedbacks": [
                    "<p>As long as at least one column remains in the table after dropping the FIRST_NAME column, the operation will be successful. Dropping a column does not require all columns to be present in the table.</p>",
                    "<p>The CASCADE option is used to drop all dependent objects when dropping a column. However, in the case of a column that is part of a composite PRIMARY KEY, it cannot be dropped even with the CASCADE option, as it would violate the integrity of the primary key constraint.</p>",
                    "The presence of data in the FIRST_NAME column does not affect the ability to drop the column. As long as the column is not part of a primary key or other constraint that would prevent its removal, it can be dropped regardless of the data it contains.",
                    "The SET UNUSED option marks the column as unused, but does not physically remove it from the table. It can be rolled back to restore the column. However, this option is not relevant to the scenario described in the SQL statement, which involves dropping the column entirely."
                ],
                "explanation": "<p>The <strong>true statement</strong> regarding the execution of <code>ALTER TABLE emp DROP COLUMN first_name;</code> is:</p><p><strong>\"The FIRST_NAME column would be dropped provided at least one column remains in the table.\"</strong></p><p>Explanation:</p><ul><li><p>In <strong>Oracle</strong>, a column can be dropped using <code>ALTER TABLE ... DROP COLUMN</code>, as long as <strong>at least one column remains in the table</strong>.</p></li><li><p>The <strong>CASCADE option</strong> is <strong>not required</strong> unless the column is part of a <strong>primary key</strong> or has dependencies.</p></li><li><p>The column <strong>does not need to be empty</strong> to be dropped.</p></li><li><p>If you want the ability to <strong>roll back</strong> the column removal, you should use <code>SET UNUSED</code> instead of <code>DROP COLUMN</code>. Once a column is dropped, it <strong>cannot be recovered</strong>.</p></li></ul><p>Incorrect options:</p><p><strong>\"The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is added to the SQL statement.\"</strong></p><ul><li><p><strong>Misleading and irrelevant here</strong></p></li><li><p>In general, <strong>dropping a column that's part of a primary key</strong> requires extra care and may need to drop the constraint first.</p></li><li><p>Also, <code>CASCADE</code> is used in <code>DROP TABLE</code>, not in <code>ALTER TABLE DROP COLUMN</code>.</p></li><li><p>In this case, <code>FIRST_NAME</code> is <strong>not part of a primary key</strong> anyway.</p></li></ul><p><strong>\"The FIRST_NAME column would be dropped provided it does not contain any data.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Oracle does <strong>not</strong> require the column to be empty before dropping it.</p></li><li><p>The column can have data and still be dropped.</p></li></ul><p><strong>\"The drop of the FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the SQL statement.\"</strong></p><ul><li><p><strong>Incorrect</strong></p></li><li><p><code>SET UNUSED</code> marks the column as unusable (invisible to queries) but doesn't make the operation <strong>automatically rollback-able</strong>.</p></li><li><p>Once <code>DROP COLUMN</code> or <code>SET UNUSED</code> is committed, it <strong>cannot be rolled back</strong>.</p></li></ul><p><br></p><p>The Oracle <code>ALTER TABLE</code> statement is used to add, modify, or drop/delete columns in a table. The Oracle <code>ALTER TABLE</code> statement is also used to <code>RENAME</code> a table.</p><p>To <strong>DROP A COLUMN</strong> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  DROP COLUMN column_name;</pre><p><br></p><p>To <strong>ADD A COLUMN</strong> in a table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name column_definition;</pre><p><br></p><p>To <strong>ADD MULTIPLE COLUMNS</strong> to an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD (column_1 column_definition,\n       column_2 column_definition,\n       ...\n       column_n column_definition);</pre><p><br></p><p>To <strong>MODIFY A COLUMN</strong> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  MODIFY column_name column_type;</pre><p><br></p><p>To <strong>MODIFY MULTIPLE COLUMNS</strong> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  MODIFY (column_1 column_type,\n          column_2 column_type,\n          ...\n          column_n column_type);</pre><p><br></p><p>To <strong>RENAME A COLUMN</strong> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  RENAME COLUMN old_name TO new_name;</pre><p><br></p><p>To <strong>RENAME A TABLE</strong>, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  RENAME TO new_table_name;</pre>",
                "answers": [
                    "<p>The FIRST_NAME column would be dropped provided at least one column remains in the table.</p>",
                    "<p>The FIRST_NAME column can be dropped even if it is part of a composite PRIMARY KEY provided the CASCADE option is added to the SQL statement.</p>",
                    "<p>The FIRST_NAME column would be dropped provided it does not contain any data.</p>",
                    "<p>The drop of the FIRST_NAME column can be rolled back provided the SET UNUSED option is added to the SQL statement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ALTER TABLE",
            "question_plain": "View and examine the structure of the EMP table as well as the exhibit.Table: EMPName                    Null??            Type\nEMPNO                   NOT NULL          NUMBER(4)\nFIRST_NAME                                VARCHAR(20)\nLAST_NAME                                 VARCHAR2\nSALARY                                    NUMBER(10,2)\nDEPNO                                     NUMBER(2)\nGiven: EMP is not partitioned and not an index-organized tableEvaluate this SQL statement.Exhibit 1:ALTER TABLE emp\nDROP COLUMN first_name;\nIdentify the statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919385,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The following query has been executed. </p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE), 'MON'), 'fmonth dd \"is the first Monday of \" fmonth rrrr')\nFROM dual;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query uses the NEXT_DAY function with the 'MONDAY' parameter to find the next occurrence of Monday after the current date. This means it will return the date for the first Monday of the next month, making Choice A correct.",
                    "<p>The query does not involve any logic to find the last Monday of the current month.</p>",
                    "<p>The query is valid and will return a result.</p>",
                    "<p>The query does not contain any syntax errors or logical issues, so it will not generate an error.</p>"
                ],
                "explanation": "<p>The query returns a <strong>formatted string</strong> that identifies the <strong>first Monday of the next month</strong>, expressed in a full-text format.</p><p>How it works:</p><ol><li><p><code>LAST_DAY(SYSDATE)</code> gets the <strong>last day of the current month</strong>.</p></li><li><p><code>NEXT_DAY(..., 'MON')</code> finds the <strong>first Monday after that</strong>, which is the <strong>first Monday of the next month</strong>.</p></li><li><p><code>TO_CHAR(..., 'fmonth dd \"is the first Monday of \" fmonth rrrr')</code> formats the result like:<br><strong>\"July 01 is the first Monday of July 2025\"</strong> (assuming SYSDATE is in June 2025 and July 1st is a Monday).</p></li></ol><p>The actual output will vary depending on the current date, but the structure will always follow that pattern.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-22_14-30-51-b2566d3932603131a532a465e31335aa.png\"></p><p>Executed on 2020-04-22</p>",
                "answers": [
                    "<p>It returns the date for the first Monday of the next month.</p>",
                    "<p>It returns the date for the last Monday of the current month.</p>",
                    "<p>It executes successfully but does not return any result.</p>",
                    "<p>It generates an error.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Given: The following query has been executed. Exhibit 1:SELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE), 'MON'), 'fmonth dd \"is the first Monday of \" fmonth rrrr')\nFROM dual;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919387,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES table.</p><p><strong>Table: EMPLOYEES</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\n</pre><p><br></p><p><strong>Given: </strong> There is a parent/child relationship between EMPLOYEE_ID and MANAGER_ID.</p><p><strong>Required: </strong></p><ul><li><p>Display the name, joining date, and manager for all employees. </p></li><li><p>Newly hired employees are yet to be assigned a department or a manager;&nbsp; 'No Manager' should be displayed in the MANAGER column. </p></li></ul><p>Identify the SQL query which would give you the required output. </p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query uses an inner join between the EMPLOYEES table and itself, which will only return rows where there is a match between the employee and their manager. This will exclude newly hired employees who have not been assigned a manager yet. Additionally, the NVL function is used to display 'No Manager' for those employees without a manager.",
                    "This query uses a LEFT OUTER JOIN between the EMPLOYEES table and itself, ensuring that all rows from the left table (employees) are returned, even if there is no match in the right table (managers). This allows for the display of newly hired employees who have not been assigned a manager yet, with 'No Manager' shown in the Manager column.",
                    "This query uses a RIGHT OUTER JOIN, which is not suitable for this scenario as it will return all rows from the right table (employees) even if there is no match in the left table (managers). This would not accurately display the required information for all employees.",
                    "This query attempts to use a NATURAL JOIN, which joins tables based on columns with the same name. However, in this case, it is not appropriate as it does not allow for the specific join condition needed to link employees to their managers based on the EMPLOYEE_ID and MANAGER_ID columns.",
                    "<p>This query uses a LEFT OUTER JOIN between the EMPLOYEES table and itself, ensuring that all rows from the left table (employees) are returned, even if there is no match in the right table (managers). This allows for the display of newly hired employees who have not been assigned a manager yet, with 'No Manager' shown in the Manager column.</p><pre class=\"prettyprint linenums\">SELECT e.last_name EMP_LAST_NAME, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager  \nFROM employees e  \nLEFT OUTER JOIN employees m \nON (e.manager_id = m.employee_id);\n</pre>"
                ],
                "explanation": "<p>The key here is:</p><ul><li><p><strong>You want to list <em>all</em> employees</strong>, including newly hired ones.</p></li><li><p>Some may <strong>not yet have a manager</strong>, so you need to show “No Manager” in that case.</p></li></ul><p>Given that, a <strong>LEFT OUTER JOIN</strong> from <code>employees</code> to itself (joining manager data) is the best choice. It keeps all rows from the main employees table (even if there's no matching manager), and replaces nulls with <code>'No Manager'</code>.</p><p><strong>Correct answer:</strong></p><pre class=\"prettyprint linenums\">SELECT e.last_name EMP_LAST_NAME, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager  \nFROM employees e  \nLEFT OUTER JOIN employees m \nON (e.manager_id = m.employee_id);\n</pre><ul><li><p><strong>LEFT OUTER JOIN</strong> ensures <strong>all employees</strong> are included, even those <strong>without a manager</strong> (i.e., <code>MANAGER_ID IS NULL</code>).</p></li><li><p><code>NVL(m.last_name, 'No Manager')</code> replaces any <code>NULL</code> manager names with <code>'No Manager'</code>, exactly as required.</p></li><li><p>It correctly displays the employee's <strong>last name</strong>, <strong>hire date</strong>, and <strong>manager's last name</strong> (or 'No Manager').</p></li></ul><p>Why the others are incorrect:</p><p><strong>INNER JOIN:</strong></p><pre class=\"prettyprint linenums\">SELECT e.last_name, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e  \nJOIN employees m \nON (e.manager_id = m.employee_id);\n</pre><ul><li><p>Excludes employees with no manager (<code>MANAGER_ID IS NULL</code>) — <strong>violates requirement</strong> to show all employees.</p></li></ul><p><strong>RIGHT OUTER JOIN:</strong></p><pre class=\"prettyprint linenums\">SELECT e.last_name, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e  \nRIGHT OUTER JOIN employees m \nON (e.manager_id = m.employee_id);\n</pre><ul><li><p>Shows all <strong>managers</strong>, not all <strong>employees</strong> — wrong direction for the join.</p></li><li><p>Will <strong>exclude employees without managers</strong> — again, violates requirement.</p></li></ul><p><strong>NATURAL JOIN (with ON clause):</strong></p><pre class=\"prettyprint linenums\">SELECT e.last_name EMP_LAST_NAME, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e  \nNATURAL JOIN employees m \nON (e.manager_id = m.employee_id);\n</pre><ul><li><p><strong>Invalid syntax</strong>: <code>NATURAL JOIN</code> does <strong>not allow</strong> an <code>ON</code> clause.</p></li><li><p>Even without syntax error, <code>NATURAL JOIN</code> is inappropriate here — it joins tables using <strong>columns with the same name</strong>, which can cause unintended results.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT e.last_name, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e&nbsp; \nJOIN employees m \nON (e.manager_id = m.employee_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT e.last_name EMP_LAST_NAME, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager  \nFROM employees e  \nLEFT OUTER JOIN employees m \nON (e.manager_id = m.employee_id);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT e.last_name, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e&nbsp; \nRIGHT OUTER JOIN employees m \nON (e.manager_id = m.employee_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT e.last_name EMP_LAST_NAME, \n       e.hire_date, \n       NVL(m.last_name, 'No Manager') Manager \nFROM employees e&nbsp; \nNATURAL JOIN employees m \nON (e.manager_id = m.employee_id);</pre>",
                    "<p>None of the listed queries meets the specified requirements.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the structure of the EMPLOYEES table.Table: EMPLOYEESName                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\nGiven:  There is a parent/child relationship between EMPLOYEE_ID and MANAGER_ID.Required: Display the name, joining date, and manager for all employees. Newly hired employees are yet to be assigned a department or a manager;&nbsp; 'No Manager' should be displayed in the MANAGER column. Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919389,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in the EMPLOYEES table. </p><p><strong>Table: EMPLOYEES </strong></p><pre class=\"prettyprint linenums\"> ENAME                      HIREDATE                         SAL                     COMM\n SMITH                     17-DEC-19                         800                   \n ALLEN                     20-FEB-19                        1600                      300\n  WARD                     22-FEB-19                        1250                      500\n JONES                     02-APR-18                        2975\nMARTIN                     28-SEP-17                        1250                     1400\n BLAKE                     01-MAY-16                        2850   \n</pre><p><br></p><p><strong>Required: </strong>Generate a report showing the base salary paid to each employee to date. </p><p>Identify the best SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL query correctly calculates the base salary paid to each employee to date by calculating the number of years since the hire date, multiplying it by the salary, and rounding the result. It also includes the employee name and hire date in the output.",
                    "This SQL query has syntax errors and incorrect calculations. It does not correctly calculate the base salary paid to each employee to date. The calculation of the number of years since the hire date is incorrect, and there are missing concatenation operators in the SELECT statement.",
                    "This SQL query includes an incorrect calculation by adding the commission (comm) to the salary calculation, which is not required for the base salary paid to each employee to date. The concatenation of employee name and hire date is also missing necessary spaces and punctuation marks in the output.",
                    "This SQL query has incorrect syntax and calculation errors. The calculation of the base salary paid to each employee to date is incorrect due to the incorrect placement of functions and operators. The concatenation of employee name and hire date is missing necessary spaces and punctuation marks in the output.",
                    "<p>This SQL query correctly calculates the base salary paid to each employee to date by calculating the number of years since the hire date, multiplying it by the salary, and rounding the result. It also includes the employee name and hire date in the output.</p><pre class=\"prettyprint linenums\">SELECT ename || ' joined on ' || hiredate&nbsp; || ', the base salary paid is ' ||\nTO_CHAR(ROUND(TRUNC(SYSDATE - hiredate) / 365 * sal)) \"SALARY TO DATE\"\nFROM employees;\n</pre>"
                ],
                "explanation": "<p><strong>Requirement</strong>: Generate a report <strong>showing the base salary paid to each employee to date</strong>.</p><ul><li><p><strong>\"Base salary\"</strong>: This means <strong>only </strong><code><strong>SAL</strong></code>, not including commission (<code>COMM</code>).</p></li><li><p><strong>\"To date\"</strong>: The amount paid from <code>HIREDATE</code> to today, assuming an annual salary.</p></li></ul><p>We need to calculate the approximate <strong>total salary paid to each employee</strong> since their hire date:</p><p>(Years of service) × SAL where years = <code>(SYSDATE - HIREDATE) / 365</code></p><p><strong>Correct Query</strong>:</p><pre class=\"prettyprint linenums\">SELECT ename || ' joined on ' || hiredate || ', the base salary paid is ' ||\nTO_CHAR(ROUND(TRUNC(SYSDATE - hiredate) / 365 * sal)) \"SALARY TO DATE\"\nFROM employees;\n</pre><ul><li><p>Correct calculation: <code>(SYSDATE - HIREDATE) / 365 * SAL</code></p></li><li><p>Uses <code>TRUNC(SYSDATE - hiredate)</code> to eliminate the fractional day before dividing.</p></li><li><p>Rounds the result.</p></li><li><p>Uses <code>TO_CHAR()</code> to format the number as a string for display.</p></li><li><p>Correctly <strong>excludes </strong><code><strong>COMM</strong></code>, as required.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2023-06-08_19-43-06-34a221685ce3a2deab189307f88d441f.png\"></p><p><br></p><p><strong><em>Note: </em></strong><em>The question is only asking for the base salary. If it would have asked for all compensation or salary plus commissions, this would be a different scenario.</em></p><p><br></p><p>Incorrect Queries:</p><p><strong>Syntax Error</strong>:</p><pre class=\"prettyprint linenums\">SELECT ename || ' joined on ' || hiredate ', the base salary paid is ' \nTO_CHAR ROUND((ROUND(SYSDATE) - TRUNC(hiredate)) / 365 * sal) \"SALARY TO DATE\"\nFROM employees;\n</pre><ul><li><p>Missing <code>||</code> between strings.</p></li><li><p><code>TO_CHAR ROUND(...)</code> is invalid syntax — should be <code>TO_CHAR(ROUND(...))</code>.</p></li></ul><p><strong>Includes COMM (Not required)</strong>:</p><pre class=\"prettyprint linenums\">SELECT ename || 'joined on' || hiredate || ', the base salary paid is '\nTO_CHAR (ROUND(SYSDATE - hiredate) / 365 * sal + comm) \"SALARY TO DATE\"\nFROM employees;\n</pre><ul><li><p>Incorrect because it <strong>adds commission</strong> (<code>+ comm</code>), which is not part of <strong>base salary</strong>.</p></li></ul><p><strong>Includes COMM and minor formatting issue</strong>:</p><pre class=\"prettyprint linenums\">SELECT ename || 'joined on' || hiredate || ', the base salary paid is ' ||\nTO_CHAR (ROUND(ROUND(SYSDATE - hiredate) / 365 * sal + comm)) \"SALARY TO DATE\"\nFROM employees;\n</pre><ul><li><p>Still includes <code>comm</code>, violating the \"base salary only\" requirement.</p></li><li><p>Properly formatted, but still logically incorrect.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT ename || ' joined on ' || hiredate&nbsp; || ', the base salary paid is ' ||\nTO_CHAR(ROUND(TRUNC(SYSDATE - hiredate) / 365 * sal)) \"SALARY TO DATE\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename || ' joined on ' || hiredate&nbsp; ', the base salary paid is ' \nTO_CHAR ROUND((ROUND(SYSDATE) - TRUNC(hiredate)) / 365 * sal) \"SALARY TO DATE\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename || 'joined on' || hiredate || ', the base salary paid is '\nTO_CHAR (ROUND(SYSDATE - hiredate) / 365 * sal + comm) \"SALARY TO DATE\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename || 'joined on' || hiredate || ', the base salary paid is ' ||\nTO_CHAR (ROUND(ROUND(SYSDATE - hiredate) / 365 * sal + comm)) \"SALARY TO DATE\"\nFROM employees;\n</pre>",
                    "<p>None of the listed queries meets the specified requirements.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the data in the EMPLOYEES table. Table: EMPLOYEES  ENAME                      HIREDATE                         SAL                     COMM\n SMITH                     17-DEC-19                         800                   \n ALLEN                     20-FEB-19                        1600                      300\n  WARD                     22-FEB-19                        1250                      500\n JONES                     02-APR-18                        2975\nMARTIN                     28-SEP-17                        1250                     1400\n BLAKE                     01-MAY-16                        2850   \nRequired: Generate a report showing the base salary paid to each employee to date. Identify the best SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919391,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structures of the EMPLOYEES and DEPARTMENTS tables. </p><p><strong>Table: EMPLOYEES </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\n</pre><p><br></p><p><strong>Table: DEPARTMENTS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nDEPARTMENT_ID           NOT NULL          NUMBER(4)\nDEPARTMENT_NAME         NOT NULL          VARCHAR2(30)\nMANAGER_ID                                NUMBER(6)\nLOCATION_ID                               NUMBER(4)</pre><p><br></p><p><strong>Required:</strong> Update EMPLOYEES table as follows: </p><ul><li><p>Update only those employees who work in Toronto or Seattle (locations 2900 and 2700). </p></li><li><p>Set department_id for these employees to the department_id corresponding to London (location_id 2100). </p></li><li><p>Set the employees' salary in location_id 2100 to 1.1 times the average salary of their department. </p></li><li><p>Set the employees' commission in location_id 2100 to 1.5 times the average commission of their department.&nbsp; </p></li><li><p>Those employees previous with department_id 2100 prior to the update are not modified.</p></li></ul><p>The following command has been executed.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">UPDATE employees\nSET department_id = (SELECT department_id \n                     FROM departments \n                     WHERE location_id = 2100)\nWHERE department_id IN (SELECT department_id \n                        FROM departments \n                        WHERE location_id IN (2900, 2700));\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice is incorrect because multiple columns can be specified together in an UPDATE statement. It is valid to update multiple columns in a single UPDATE statement in Oracle SQL.",
                    "This choice is incorrect because a sub-query can have a join condition in an UPDATE statement in Oracle SQL. It is possible to use sub-queries with join conditions to update specific rows in a table based on certain criteria.",
                    "This choice is incorrect because the UPDATE statement in the exhibit does not fully meet the required criteria specified in the question. It may execute successfully, but it does not update the employees' salary and commission as per the given conditions.",
                    "This choice is correct because the UPDATE statement in the exhibit may execute successfully, but it does not give the desired update. It does not set the employees' salary and commission in location_id 2100 to 1.1 times the average salary of their department and 1.5 times the average commission of their department, respectively."
                ],
                "explanation": "<p>Correct answer: This <code>UPDATE</code> statement executes successfully but does not give the desired update.</p><pre class=\"prettyprint linenums\">UPDATE employees\nSET department_id = (SELECT department_id \n                     FROM departments \n                     WHERE location_id = 2100)\nWHERE department_id IN (SELECT department_id \n                        FROM departments \n                        WHERE location_id IN (2900, 2700));\n</pre><p><br></p><p><strong>Executes successfully</strong> because:</p><ul><li><p>The subqueries are scalar and syntactically valid.</p></li><li><p>It only attempts to update the <code>department_id</code>—no multi-column updates or joins.</p></li></ul><p><strong>But it does <em>not</em> give the desired update</strong>, because:</p><ul><li><p>It <strong>only</strong> changes the <code>department_id</code>—there’s no logic to update <code>salary</code> or <code>commission_pct</code>.</p></li><li><p>It does <strong>not exclude</strong> employees who were already in department 2100 before the update.</p></li><li><p>It assumes <strong>only one</strong> department exists for <code>location_id = 2100</code>. If there are multiple, the subquery could raise an error at runtime.</p></li></ul>\n<img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-06-14_18-13-49-0970533764ca36030b02c21feca12337.png\"><p><br></p><p><strong>Corrected Working SQL Query</strong></p><p>Here’s a version using a <strong>common table expression (CTE)</strong> and scalar subqueries to break it into clear parts:</p><pre class=\"prettyprint linenums\">-- First, retrieve the department_id for London\nWITH london_dept AS (\n  SELECT department_id\n  FROM departments\n  WHERE location_id = 2100\n),\ntoronto_seattle_emps AS (\n  SELECT e.employee_id\n  FROM employees e\n  JOIN departments d ON e.department_id = d.department_id\n  WHERE d.location_id IN (2700, 2900)\n)\nUPDATE employees\nSET department_id = (SELECT department_id FROM london_dept),\n    salary = (SELECT ROUND(1.1 * AVG(salary)) \n              FROM employees \n              WHERE department_id = (SELECT department_id FROM london_dept)),\n    commission_pct = (SELECT ROUND(1.5 * NVL(AVG(commission_pct), 0), 2)\n                      FROM employees \n                      WHERE department_id = (SELECT department_id FROM london_dept))\nWHERE employee_id IN (SELECT employee_id FROM toronto_seattle_emps)\n  AND department_id != (SELECT department_id FROM london_dept);\n</pre><p><br></p><p><strong>What the query does:</strong></p><ol><li><p><code><strong>WITH london_dept AS (...)</strong></code><br>Retrieves the <code>department_id</code> of <strong>London</strong> (<code>location_id = 2100</code>).<br>Correct.</p></li><li><p><code><strong>WITH toronto_seattle_emps AS (...)</strong></code><br>Finds employees in <strong>Toronto or Seattle</strong> by joining <code>employees</code> and <code>departments</code> on <code>department_id</code>.<br>Correct filtering based on <code>location_id IN (2700, 2900)</code>.</p></li><li><p><code><strong>UPDATE employees SET ...</strong></code></p><ul><li><p><code><strong>department_id</strong></code> is set to <strong>London’s department_id</strong> </p></li><li><p><code><strong>salary</strong></code> is set to <code>1.1 × AVG(salary)</code> of London department </p></li><li><p><code><strong>commission_pct</strong></code> is set to <code>1.5 × AVG(commission_pct)</code> of London department </p><ul><li><p><code>NVL</code> ensures NULL values in commission are treated as 0. </p></li></ul></li></ul></li><li><p><code><strong>WHERE employee_id IN (...) AND department_id != (London)</strong></code><br>Ensures:</p><ul><li><p>Only Toronto/Seattle employees are updated.</p></li><li><p>Existing London employees are excluded. </p></li></ul></li></ol><p><strong>Is this valid syntax?</strong></p><ul><li><p>Multiple columns are being updated with <strong>independent scalar subqueries</strong> — this is <strong>valid</strong>.</p></li><li><p>Using <code><strong>WITH</strong></code><strong> clause</strong> to prepare intermediate results — <strong>also valid</strong>.</p></li><li><p><strong>No invalid joins or multi-row subqueries</strong> — everything resolves to a single value.</p></li></ul>",
                "answers": [
                    "<p>It generates an error because multiple columns (SALARY, COMMISSION) cannot be specified together in an UPDATE statement.</p>",
                    "<p>It generates an error because a sub-query cannot have a join condition in a UPDATE statement.</p>",
                    "<p>It executes successfully and gives the desired update.</p>",
                    "<p>It executes successfully but does not give the desired update.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structures of the EMPLOYEES and DEPARTMENTS tables. Table: EMPLOYEES Name                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\nTable: DEPARTMENTS Name                    Null??            Type\nDEPARTMENT_ID           NOT NULL          NUMBER(4)\nDEPARTMENT_NAME         NOT NULL          VARCHAR2(30)\nMANAGER_ID                                NUMBER(6)\nLOCATION_ID                               NUMBER(4)Required: Update EMPLOYEES table as follows: Update only those employees who work in Toronto or Seattle (locations 2900 and 2700). Set department_id for these employees to the department_id corresponding to London (location_id 2100). Set the employees' salary in location_id 2100 to 1.1 times the average salary of their department. Set the employees' commission in location_id 2100 to 1.5 times the average commission of their department.&nbsp; Those employees previous with department_id 2100 prior to the update are not modified.The following command has been executed.Exhibit 1:UPDATE employees\nSET department_id = (SELECT department_id \n                     FROM departments \n                     WHERE location_id = 2100)\nWHERE department_id IN (SELECT department_id \n                        FROM departments \n                        WHERE location_id IN (2900, 2700));\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919393,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements regarding the WHERE and HAVING clauses in a SELECT statement. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: WHERE Clause](https://www.techonthenet.com/oracle/where.php)",
                    "[Oracle / PLSQL: HAVING Clause](https://www.techonthenet.com/oracle/having.php)"
                ],
                "feedbacks": [
                    "The WHERE and HAVING clauses can be used in the same statement regardless of whether they are applied to the same or different columns in the table. The WHERE clause filters rows based on a specified condition, while the HAVING clause filters groups based on a specified condition after the data has been grouped.",
                    "The aggregate functions and columns used in the HAVING clause do not necessarily need to be specified in the SELECT list of the query. The HAVING clause is used to filter groups based on aggregate conditions, and it can reference aggregate functions without explicitly including them in the SELECT list.",
                    "The WHERE clause is used to filter rows based on a specified condition before any grouping is done. It does not have the capability to exclude rows after dividing them into groups, as that functionality is specifically handled by the HAVING clause.",
                    "The HAVING clause can indeed be used with aggregate functions in subqueries. This allows for more complex filtering conditions to be applied to grouped data, enabling the use of aggregate functions to filter groups based on specific criteria.",
                    "The WHERE clause is used to exclude rows before any grouping is done, making it suitable for filtering individual rows based on specific conditions. It does not have the capability to exclude rows after dividing them into groups, as that functionality is specifically handled by the HAVING clause."
                ],
                "explanation": "<p>Correct statements:</p><ol><li><p><strong>The WHERE clause can be used to exclude rows before dividing them into groups.</strong></p><ul><li><p><strong>True:</strong> WHERE filters rows <strong>before</strong> GROUP BY is applied.</p></li></ul></li><li><p><strong>The HAVING clause can be used with aggregate functions in subqueries.</strong></p><ul><li><p><strong>True:</strong> HAVING filters groups <strong>after</strong> aggregation and can use aggregate functions, including in subqueries.</p></li></ul></li></ol><p>Why the others are false:</p><ul><li><p><strong>The WHERE clause can be used to exclude rows after dividing them into groups.</strong></p><ul><li><p><strong>False:</strong> WHERE filters rows <em>before</em> grouping, not after.</p></li></ul></li><li><p><strong>The aggregate functions and columns used in the HAVING clause must be specified in the SELECT list of the query.</strong></p><ul><li><p><strong>False:</strong> HAVING can reference aggregate functions or columns not necessarily in SELECT list.</p></li></ul></li><li><p><strong>The WHERE and HAVING clauses can be used in the same statement only if they are applied to different columns in the table.</strong></p><ul><li><p><strong>False:</strong> They can apply to same or different columns; the key is that WHERE filters rows first, HAVING filters groups after aggregation.</p></li></ul></li></ul><p><br></p><p>The Oracle <code>HAVING</code> clause is used in combination with the<a href=\"https://www.techonthenet.com/oracle/group_by.php\"> GROUP BY clause</a> to restrict the groups of returned rows to only those whose the condition is <code>TRUE</code>.</p><p><em>√&nbsp; The HAVING clause can be used with aggregate functions in subqueries.</em></p><p><br></p><p><strong>Syntax</strong></p><p>The syntax for the <code>HAVING</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n\nHAVING having_condition;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause. </p><p>aggregate_function - It can be a function such as <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\">SUM</a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\">COUNT</a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\">MIN</a>, <a href=\"https://www.techonthenet.com/oracle/functions/max.php\">MAX</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/avg.php\">AVG</a> functions. </p><p>aggregate_expression - This is the column or expression that the <em>aggregate_function</em> will be used against. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - These are the conditions for the records to be selected. </p><p>having_condition - This is a further condition applied only to the aggregated results to restrict the groups of returned rows. Only those groups whose condition evaluates to TRUE will be included in the result set.</p><p><br></p><p><br></p><p>The Oracle <code>WHERE</code> clause is used to filter the results from a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement.</p><p><em>√&nbsp; The WHERE clause can be used to exclude rows before dividing them into groups.</em></p><p><br></p><p><strong>Syntax</strong></p><p>The syntax for the <code>WHERE</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">WHERE conditions;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>conditions - The conditions that must be met for records to be selected.</p>",
                "answers": [
                    "<p>The WHERE and HAVING clauses can be used in the same statement only if they are applied to different columns in the table.</p>",
                    "<p>The aggregate functions and columns used in the HAVING clause must be specified in the SELECT list of the query.</p>",
                    "<p>The WHERE clause can be used to exclude rows after dividing them into groups.</p>",
                    "<p>The HAVING clause can be used with aggregate functions in subqueries.</p>",
                    "<p>The WHERE clause can be used to exclude rows before dividing them into groups.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify two true statements regarding the WHERE and HAVING clauses in a SELECT statement. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919395,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PROGRAMS table.</p><p><strong>Table: PROGRAMS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nPROG_ID                 NOT NULL          NUMBER(3)\nPROG_COST                                 NUMBER(8,2)\nSTART_DATE              NOT NULL          DATE\nEND_DATE                                  DATE</pre><p><br></p><p>Identify two SQL statements which would execute successfully. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: NVL Function](https://www.techonthenet.com/oracle/functions/nvl.php)",
                    "[Oracle / PLSQL: TO_DATE Function](https://www.techonthenet.com/oracle/functions/to_date.php)"
                ],
                "feedbacks": [
                    "<p>The SQL statement is incorrect because there is a missing comma between the function ADD_MONTHS(END_DATE,1) and SYSDATE. The correct syntax should be SELECT NVL(ADD_MONTHS(END_DATE,1), SYSDATE) FROM programs;.</p>",
                    "<p>The SQL statement is correct because it uses the TO_DATE function to convert the date values in the END_DATE column to a valid date format. The NVL function is used to handle any NULL values in the END_DATE column.</p>",
                    "<p>The SQL statement is incorrect because there is a syntax error in the MONTHS_BETWEEN function. The correct syntax should be SELECT NVL(MONTHS_BETWEEN(start_date, end_date),'Ongoing') FROM programs;.</p>",
                    "<p>The SQL statement is correct because it uses the TO_CHAR function to convert the result of the MONTHS_BETWEEN function to a character data type. The NVL function is used to handle any NULL values in the start_date or end_date columns.</p>"
                ],
                "explanation": "<p>Correct options:</p><pre class=\"prettyprint linenums\">SELECT TO_DATE(NVL(END_DATE, SYSDATE)) \nFROM programs;\n</pre><ul><li><p><code>NVL(END_DATE, SYSDATE)</code> returns a <strong>DATE</strong> (either <code>END_DATE</code> or <code>SYSDATE</code>).</p></li><li><p><code>TO_DATE()</code> function <strong>expects a string input</strong>, not a date.</p></li><li><p>However, Oracle is <strong>lenient</strong> in some cases and might accept <code>TO_DATE</code> with a DATE input without error, essentially treating it as a no-op.</p></li><li><p><strong>So this is syntactically valid</strong>, but the <code>TO_DATE()</code> here is <strong>redundant and unnecessary</strong> since the argument is already a DATE.</p></li><li><p>It <strong>will execute successfully</strong> but it’s better practice to avoid redundant conversions.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(MONTHS_BETWEEN(start_date,end_date)),'Ongoing') \nFROM programs;</pre><ul><li><p><code>MONTHS_BETWEEN(start_date, end_date)</code> returns a NUMBER (can be NULL if <code>end_date</code> is NULL).</p></li><li><p><code>TO_CHAR</code> converts number to string.</p></li><li><p><code>NVL(..., 'Ongoing')</code> replaces NULL with <code>'Ongoing'</code>.</p></li><li><p>This is syntactically correct.</p></li><li><p><strong> This statement will execute successfully.</strong></p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2022-08-17_11-50-23-82de1d234be3033d6175818e050aa4f8.png\"></p><p><br></p><p>Incorrect options:</p><pre class=\"prettyprint linenums\">SELECT NVL(MONTHS_BETWEEN(start_date - end_date), 'Ongoing') \nFROM programs;\n</pre><ul><li><p><code>MONTHS_BETWEEN</code> expects two DATE arguments, but here <code>start_date - end_date</code> results in a NUMBER (difference in days).</p></li><li><p>So <code>MONTHS_BETWEEN(start_date - end_date)</code> is invalid because it receives one argument which is a NUMBER, not two DATEs.</p></li><li><p><strong> This statement will NOT execute successfully.</strong></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT NVL(ADD_MONTHS(END_DATE, 1) SYSDATE) \nFROM programs;\n</pre><ul><li><p>This syntax is invalid:</p><ul><li><p><code>NVL</code> requires <strong>two arguments</strong> separated by a comma.</p></li><li><p>There is a missing comma between <code>ADD_MONTHS(END_DATE, 1)</code> and <code>SYSDATE</code>.</p></li><li><p><strong> This statement will NOT execute successfully.</strong></p></li></ul></li></ul><p><br></p><p><strong>The Oracle/PLSQL NVL function </strong>lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. replace_with The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL</code> function returns a substitute value.</p><p><br></p><p><br></p><p><strong>The Oracle/PLSQL TO_DATE function</strong> converts a string to a date.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TO_DATE</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">TO_DATE( string1 [, format_mask] [, nls_language] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string that will be converted to a date. </p><p>format_mask Optional. - This is the format that will be used to convert <em>string1</em> to a date.</p><p><strong>Returns</strong></p><p>The <code>TO_DATE</code> function returns a date value.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT NVL(ADD_MONTHS(END_DATE,1)SYSDATE) \nFROM programs;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_DATE(NVL(END_DATE,SYSDATE)) \nFROM programs;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(MONTHS_BETWEEN(start_date - end_date),'Ongoing') \nFROM programs;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(MONTHS_BETWEEN(start_date,end_date)),'Ongoing') \nFROM programs;</pre>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the PROGRAMS table.Table: PROGRAMS Name                    Null??            Type\nPROG_ID                 NOT NULL          NUMBER(3)\nPROG_COST                                 NUMBER(8,2)\nSTART_DATE              NOT NULL          DATE\nEND_DATE                                  DATEIdentify two SQL statements which would execute successfully. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919397,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Examine this SQL statement.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">DELETE FROM employees e\nWHERE EXISTS (\n    SELECT 'dummy'\n    FROM emp_history\n    WHERE employee_id = e.employee_id\n);\n</pre><p><br></p><p>The subquery is successfully<strong> </strong>executed, and if the condition in the exists is satisfied then the DELETE statement is executed.</p><p>Identify true statements regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Correlated Subquery](https://www.oracletutorial.com/oracle-basics/oracle-correlated-subquery/)",
                    "[Oracle EXISTS Operator](https://www.oracletutorial.com/oracle-basics/oracle-exists/)",
                    "[Oracle / PLSQL: DELETE Statement](https://www.techonthenet.com/oracle/delete.php)"
                ],
                "feedbacks": [
                    "The subquery in the EXISTS clause references the outer table's column (e.employee_id), making it a correlated subquery that is evaluated for each row in the outer query.",
                    "The DELETE statement processes one row at a time, executing the subquery for each row that meets the condition specified in the EXISTS clause before deleting the corresponding row from the employees table.",
                    "The DELETE statement will execute successfully even if the subquery in the EXISTS clause returns multiple rows. As long as at least one row is returned, the condition is considered satisfied for the DELETE operation to proceed.",
                    "The subquery in the EXISTS clause is executed for every row in the employees table. It checks for the existence of a matching row in the emp_history table for each employee_id in the employees table.",
                    "Not all existing rows in the EMPLOYEES table will be deleted. Only the rows that have a matching employee_id in the emp_history table will be deleted based on the condition specified in the EXISTS clause."
                ],
                "explanation": "<p>Let's review each option for true/false statements:</p><ol><li><p><strong>The subquery is a correlated subquery</strong> – <strong>True</strong><br>The subquery references <code>e.employee_id</code> from the outer query, making it correlated since it depends on each row in <code>employees</code>.</p></li><li><p><strong>The DELETE statement executes successfully even if the subquery selects multiple rows</strong> – <strong>True</strong><br>The <code>EXISTS</code> clause does not depend on how many rows are returned; it only checks if <em>any</em> rows match the condition.</p></li><li><p><strong>The subquery is executed for every row in the employees table</strong> – <strong>True</strong><br>Since the subquery is correlated, it runs once per row in <code>employees</code> to determine if <code>EXISTS</code> is satisfied.</p></li><li><p><strong>The deletion occurs row by row after each subquery execution</strong> – <strong>True</strong><br>Since the subquery checks per row and deletes qualifying rows individually, the process occurs row by row.</p></li><li><p><strong>All existing rows in the EMPLOYEES table are always deleted</strong> – <strong>False</strong><br>Only rows where the <code>EXISTS</code> condition is satisfied (meaning there is a matching <code>employee_id</code> in <code>emp_history</code>) will be deleted—not all rows.</p></li></ol><p><br></p><p><strong>The Oracle DELETE statement</strong> is used to delete a single record or multiple records from a table in Oracle.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DELETE</code> statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM table\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table - The table that you wish to delete records from. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be deleted. If no conditions are provided, then all records from the table will be deleted.</p><p><strong>Note</strong></p><p>You do not need to list fields in the Oracle <code>DELETE</code> statement since you are deleting the entire row from the table.</p><p>You may wish to delete records in one table based on values in another table. Since you can't list more than one table in the Oracle FROM clause when you are performing a delete, you can use the <a href=\"https://www.techonthenet.com/oracle/exists.php\">Oracle EXISTS clause</a>.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM suppliers\nWHERE EXISTS\n  ( SELECT customers.customer_name\n    FROM customers\n    WHERE customers.customer_id = suppliers.supplier_id\n    AND customer_id &gt; 25 );</pre><p><br></p><p>This Oracle <code>DELETE</code> example would delete all records in the <em>suppliers</em> table where there is a record in the <em>customers</em> table whose customer_id is greater than 25, and the <em>customer_id</em> matches the <em>supplier_id</em>.</p><p><br></p><p><strong>A typical Subquery</strong> is a <code>SELECT</code> statement that is included or nested within another SQL statement, which can be another <code>SELECT</code> or an <code>INSERT</code>, <code>UPDATE </code>or <code>DELETE</code>. Subqueries are always enclosed within parentheses.</p><p>In most cases, subqueries are executed prior to the execution of the main statement where they are nested in, with the exception of correlated subqueries. </p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM table_A\nWHERE column_X IN\n  (\n    SELECT column_X\n    FROM table_B\n  );</pre><p><br></p><p><strong>Correlated Subqueries</strong> reference one or more columns from the outer or main statement (which can be a <code>SELECT</code>, UPDATE or DELETE). So, since they are related to the main query, they cannot be executed alone prior to executing the main statement. Instead, they are executed once for each candidate row that can possibly be returned or affected by the main statement.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM customers c\nWHERE 100 &lt;\n(\nSELECT COUNT ( * )\nFROM orders\nWHERE customer_id = c.customer_id\n);</pre><p><a href=\"http://sql.standout-dev.com/2015/10/subqueries-oracle-sql/\">http://sql.standout-dev.com/2015/10/subqueries-oracle-sql/</a></p><p><br></p><p><strong>The Oracle WHERE</strong> clause is used to filter the results from a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>WHERE</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">WHERE conditions;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>conditions - The conditions that must be met for records to be selected.</p><p><a href=\"https://www.techonthenet.com/oracle/where.php\">https://www.techonthenet.com/oracle/where.php</a></p>",
                "answers": [
                    "<p>The subquery is a correlated subquery.</p>",
                    "<p><strong> </strong>The deletion occurs row by row after each subquery execution.</p>",
                    "<p>The DELETE statement executes successfully even if the subquery selects multiple rows.</p>",
                    "<p>The subquery is executed for every row in the employees table.</p>",
                    "<p>All existing rows in the EMPLOYEES table are always deleted.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d",
                "b"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Examine this SQL statement.Exhibit 1:DELETE FROM employees e\nWHERE EXISTS (\n    SELECT 'dummy'\n    FROM emp_history\n    WHERE employee_id = e.employee_id\n);\nThe subquery is successfully executed, and if the condition in the exists is satisfied then the DELETE statement is executed.Identify true statements regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919399,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong></p><ul><li><p>You do not own the the objects</p></li><li><p>You do not have the DROP ANY TABLE system privilege</p></li><li><p>You do not have the EXECUTE ANY PROCEDURE system privilege</p></li><li><p>Referenced tables are not in your schema</p></li></ul><p>Identify the actions can you perform only with system privileges. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Privilege hierarchy](https://docs.oracle.com/cd/E11882_01/timesten.112/e21642/privileges.htm#TTSQL343)",
                    "[Truncate table in another schema without drop any table privilege](https://community.oracle.com/tech/developers/discussion/2150646/truncate-table-in-another-schema-without-drop-any-table-privilege)"
                ],
                "feedbacks": [
                    "Querying any table in a database requires system privileges as it involves accessing data from tables that are not in your schema. Without system privileges, you would not be able to query tables that you do not own.",
                    "Logging into a database is a system-level operation that requires system privileges. Without the necessary system privileges, you would not be able to access the database at all.",
                    "Accessing flat files via a database stored in an operating system directory does not require system privileges. This operation is related to file system access rather than database system privileges.",
                    "Executing a procedure in another schema requires object-level privileges rather than system privileges. System privileges are not needed to execute procedures in different schemas.",
                    "Using the WITH GRANT OPTION clause allows a user to grant the same privileges they have been granted to other users. It is a privilege granted at the object level, not a system privilege.",
                    "Truncating a table in another schema requires object-level privileges on that specific table, not system privileges. System privileges are not needed to truncate tables in different schemas."
                ],
                "explanation": "<p><strong>Correct options:</strong></p><ol><li><p><strong>Query any table in a database</strong> – <strong>Requires system privilege</strong><br>Accessing tables outside your schema generally requires the <code>SELECT ANY TABLE</code> system privilege.</p></li><li><p><strong>Log into a database</strong> – <strong>Does not require system privilege</strong><br>Logging into a database simply requires a valid user account with authentication privileges.</p></li></ol><p>Incorrect options</p><ul><li><p><strong>Access flat files via a database, which are stored in an operating system directory</strong> – <strong>Requires system privilege</strong><br>Accessing external files typically requires the <code>READ ANY FILE</code> or <code>ADMINISTER DATABASE TRIGGER</code> system privilege.</p></li><li><p><strong>Execute a procedure in another schema</strong> – <strong>Requires system privilege</strong><br>Since you lack <code>EXECUTE ANY PROCEDURE</code>, executing another schema’s procedure would require explicit privileges or system-level access.</p></li><li><p><strong>Use the WITH GRANT OPTION clause</strong> – <strong>Does not require system privilege</strong><br>The <code>WITH GRANT OPTION</code> can be used if you already have privileges granted to you with that option.</p></li><li><p><strong>Truncate a table in another schema</strong> – <strong>Requires system privilege</strong><br>Truncating a table outside your schema would typically require the <code>ALTER ANY TABLE</code> or <code>DROP ANY TABLE</code> system privileges.</p></li></ul><p>When multiple users can access database objects, authorization can be controlled to these objects with privileges. Every object has an owner. Privileges control if a user can modify an object owned by another user. Privileges are granted or revoked either by the instance administrator, a user with the <code>ADMIN</code> privilege or, for privileges to a certain object, by the owner of the object.</p><p><strong>A System Privilege</strong> is the right to perform a particular action or to perform an action on any object of a particular type. Objects include tables, views, materialized views, synonyms, indexes, sequences, cache groups, replication schemes and PL/SQL functions, procedures and packages. Only the instance administrator or a user with <code>ADMIN</code> privilege can grant or revoke system privileges.</p><p>The system privileges can be passed <code>WITH ADMIN OPTION</code>.</p><p><br></p><p>An <strong>Object Privilege</strong> is the right to perform a particular action on an object or to access another user's object. Objects include tables, views, materialized views, indexes, synonyms, sequences, cache groups, replication schemes and PL/SQL functions, procedures and packages.</p><p>An object's owner has all <strong>Object Privileges</strong> for that object, and those privileges cannot be revoked. The object's owner can grant object privileges for that object to other database users. A user with <code>ADMIN</code> privilege can grant and revoke object privileges from users who do not own the objects on which the privileges are granted.</p><p>Some privileges confer other privileges. For example, <code>ADMIN</code> privilege confers all other privileges.</p><p>All users of the database have the <code>PUBLIC</code> role. In a newly created TimesTen database, by default <code>PUBLIC</code> has <code>SELECT</code> and <code>EXECUTE</code> privileges on various system tables and views and PL/SQL functions, procedures and packages. Privileges that are granted to <code>PUBLIC</code> as part of database creation cannot be revoked.</p><p>The object privileges can be passed <code>WITH GRANT OPTION</code>.</p><p><br></p><p><strong>TRUNCATE TABLE</strong></p><p><code>TRUNCATE TABLE</code> command requires user to have \"drop any table\" permission.</p><p><code>TRUNCATE ANY TABLE</code> is a system privilege.</p>",
                "answers": [
                    "<p>Query any table in a database.</p>",
                    "<p>Log into a database.</p>",
                    "<p>Access flat files via a database, which are stored in an operating system directory.</p>",
                    "<p>Execute a procedure in another schema.</p>",
                    "<p>Use the WITH GRANT OPTION clause.</p>",
                    "<p>Truncate a table in another schema.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "System Privileges",
            "question_plain": "View and examine the following available responses.Given: You do not own the the objectsYou do not have the DROP ANY TABLE system privilegeYou do not have the EXECUTE ANY PROCEDURE system privilegeReferenced tables are not in your schemaIdentify the actions can you perform only with system privileges. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919401,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the INTERSECT operator.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: INTERSECT Operator](https://www.techonthenet.com/oracle/intersect.php)"
                ],
                "feedbacks": [
                    "The INTERSECT operator does not require the names of columns in all SELECT statements to be identical. It only compares the result sets of the SELECT statements and returns rows that appear in both result sets.",
                    "The INTERSECT operator does not ignore NULL values. It includes NULL values in the comparison and returns rows that match in all SELECT statements, including NULL values.",
                    "Reversing the order of the intersected tables does not alter the result when using the INTERSECT operator. The operator compares the result sets of the SELECT statements, not the order of the tables.",
                    "The correct statement regarding the INTERSECT operator is that the number of columns and data types must be identical for all SELECT statements in the query. This ensures that the comparison can be made accurately between the result sets of the SELECT statements."
                ],
                "explanation": "<p>Correct option:</p><ul><li><p><strong>The number of columns and data types must be identical for all SELECT statements in the query</strong> – <strong>True</strong><br>When using <code>INTERSECT</code>, the queries must return the same number of columns, and each corresponding column must have compatible data types.</p></li></ul><p><code>INTERSECT</code> returns only the rows that occur in both queries' result sets, sorting them and removing duplicates. The columns in the queries that make up a compound query can have different names, but the output result set will use the names of the columns in the first query.</p><p><br></p><p>Incorrect options:</p><ul><li><p><strong>Reversing the order of the intersected tables alters the result</strong> – <strong>False</strong><br>The <code>INTERSECT</code> operator is <strong>commutative</strong>, meaning the result remains unchanged regardless of the order of the queries.</p></li><li><p><strong>It ignores NULLs</strong> – <strong>False</strong><br>The <code>INTERSECT</code> operator <strong>includes</strong> <code>NULL</code> values in comparisons. If a <code>NULL</code> exists in both result sets at the same position with identical values (or both are <code>NULL</code>), it will be included in the final output.</p></li><li><p><strong>The names of columns in all SELECT statements must be identical</strong> – <strong>False</strong><br>Column names do not need to match, only the number of columns and their data types must be compatible.</p></li></ul><p><br></p><p><strong>The Oracle INTERSECT</strong> operator is used to return the results of 2 or more <code>SELECT</code> statements. However, it only returns the rows selected by all queries or data sets. If a record exists in one query and not in the other, it will be omitted from the <code>INTERSECT</code> results.</p><p><br></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-23_19-27-48-628754d4fc13e3277b5d9abd1dbac8e2.png\"></p><p><br></p><p><strong>Explanation:</strong> The <code>INTERSECT</code> query will return the records in the blue shaded area. These are the records that exist in both Table1 and Table2.</p><p>Each SELECT statement within the <code>INTERSECT</code> must have the same number of fields in the result sets with similar data types.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INTERSECT</code> operator in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nINTERSECT\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The columns or calculations that you wish to retrieve. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p><p><strong>Note</strong></p><p>There must be same number of expressions in both <code>SELECT</code> statements and have similar data types.</p>",
                "answers": [
                    "<p>The names of columns in all SELECT statements must be identical.</p>",
                    "<p>It ignores NULLs.</p>",
                    "<p>Reversing the order of the intersected tables alters the result.</p>",
                    "<p>The number of columns and data types must be identical for all SELECT statements in the query.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "INTERSECT",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the INTERSECT operator.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919403,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS table. </p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-32-02-3cd3aa4b3e3b446474620dca6ba71af1.png\"><p><br></p><p>Identify two tasks which would require subqueries. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Subqueries](https://www.techonthenet.com/oracle/subqueries.php)"
                ],
                "feedbacks": [
                    "This task requires a subquery to calculate the average PROD_LIST_PRICE of all products and compare it with the PROD_MIN_PRICE of each product. Additionally, the condition for orderable status also involves filtering based on another column, making it suitable for a subquery.",
                    "This task involves filtering products based on supplier ID and product status, both of which are separate conditions. Using a subquery can help in retrieving the total number of products that meet both criteria.",
                    "To compare the PROD_LIST_PRICE of each product with the average PROD_LIST_PRICE of all products, a subquery is needed to calculate the average value. This comparison requires a subquery to fetch the average value for comparison.",
                    "This task involves filtering suppliers based on the PROD_LIST_PRICE of products, which does not require a subquery. The condition can be directly applied to the main query without the need for a subquery.",
                    "This task requires finding the lowest PROD_LIST_PRICE for each product status, which can be achieved using a GROUP BY clause in SQL. It does not necessarily require a subquery to accomplish this task."
                ],
                "explanation": "<p>Correct options:</p><ul><li><p><strong>Show the number of products whose PROD_LIST_PRICE is higher than the average PROD_LIST_PRICE.</strong></p><ul><li><p>To determine if a product’s <code>PROD_LIST_PRICE</code> is <strong>higher than the average</strong>, a subquery is needed to compute the average value.</p></li></ul></li></ul><pre class=\"prettyprint linenums\">SELECT supplier_id\nFROM products\nWHERE prod_list_price &gt; (\n    SELECT AVG(prod_list_price)\n    FROM products);</pre><p><br></p><ul><li><p><strong>Generate a list of all products where the PROD_MIN_PRICE is higher than the average PROD_LIST_PRICE of all products, and has an orderable status.</strong></p><ul><li><p>This task requires calculating the <strong>average</strong> <code>PROD_LIST_PRICE</code>, which involves an aggregate function.</p></li><li><p>Since the comparison involves every product's <code>PROD_MIN_PRICE</code>, a subquery is needed to compute the average.</p></li></ul></li></ul><pre class=\"prettyprint linenums\">SELECT prod_id\nFROM products\nWHERE prod_status = ‘orderable’\nHAVING MIN(prod_list_price) &gt; (\n    SELECT AVG(prod_list_price)\n    FROM products)\nGROUP by prod_id;</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-23_20-30-04-d5be31b27dc92d1140b08fd3b5446c83.png\"></p><p><br></p><p>Incorrect options:</p><ul><li><p><strong>Render the total number of products supplied by supplier 102 and have product status as 'OBSOLETE'</strong> – <strong>Does not require a subquery</strong></p><ul><li><p>This task involves filtering and aggregating data, which can be done with a <code>COUNT()</code> and <code>WHERE</code> clause.</p></li></ul></li><li><p><strong>Generate a list of suppliers where the PROD_LIST_PRICE is less than 1000</strong> – <strong>Does not require a subquery</strong></p><ul><li><p>Filtering on <code>PROD_LIST_PRICE &lt; 1000</code> can be done with a simple <code>WHERE</code> clause.</p></li></ul></li><li><p><strong>Show the lowest PROD_LIST_PRICE for each product status</strong> – <strong>Does not require a subquery</strong></p><ul><li><p>Using <code>GROUP BY product_status</code> with <code>MIN(PROD_LIST_PRICE)</code> can achieve this without a subquery.</p></li></ul></li></ul><p><br></p><p><strong>In Oracle, a subquery is a query within a query</strong>. You can create subqueries within your SQL statements. These subqueries can reside in the <code>WHERE</code> clause, the <code>FROM</code> clause, or the <code>SELECT</code> clause.</p><p><strong>WHERE clause</strong></p><p>Most often, the subquery will be found in the <code>WHERE</code> clause. These subqueries are also called nested subqueries.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \nFROM all_tables tabs\nWHERE tabs.table_name IN (SELECT cols.table_name\n                          FROM all_tab_columns cols\n                          WHERE cols.column_name = 'SUPPLIER_ID');</pre><p><br></p><p><strong>Limitation:</strong> Oracle allows up to 255 levels of subqueries in the <code>WHERE</code> clause.</p><p><strong>FROM clause</strong></p><p>A subquery can also be found in the <code>FROM</code> clause. These are called <strong>inline views</strong>.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT suppliers.name, subquery1.total_amt\nFROM suppliers,\n (SELECT supplier_id, SUM(orders.amount) AS total_amt\n  FROM orders\n  GROUP BY supplier_id) subquery1\nWHERE subquery1.supplier_id = suppliers.supplier_id;</pre><p><br></p><p>In this example, we've created a subquery in the <code>FROM</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT supplier_id, SUM(orders.amount) AS total_amt\n FROM orders\n GROUP BY supplier_id) subquery1</pre><p><br></p><p>This subquery has been aliased with the name <em>subquery1</em>. This will be the name used to reference this subquery or any of its fields.</p><p><strong>Limitations</strong></p><p>Oracle allows an unlimited number of subqueries in the FROM clause.</p><p><strong>SELECT clause</strong></p><p>A subquery can also be found in the <code>SELECT</code> clause.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT tbls.owner, tbls.table_name,\n  (SELECT COUNT(column_name) AS total_columns\n   FROM all_tab_columns cols\n   WHERE cols.owner = tbls.owner\n   AND cols.table_name = tbls.table_name) subquery2\nFROM all_tables tbls;</pre><p><br></p><p>In this example, we've created a subquery in the <code>SELECT</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT COUNT(column_name) AS total_columns\n FROM all_tab_columns cols\n WHERE cols.owner = tbls.owner\n AND cols.table_name = tbls.table_name) subquery2</pre><p><br></p><p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p><p>The trick to placing a subquery in the select clause is that the subquery must return a single value. This is why an aggregate function such as <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\">SUM function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\">COUNT function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\">MIN function</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/max.php\">MAX function</a> is commonly used in the subquery.</p>",
                "answers": [
                    "<p>Generate a list of all products where the PROD_MIN_PRICE is higher than the average PROD_LIST_PRICE of all products, and has an orderable status.</p>",
                    "<p>Render the total number of products supplied by supplier 102 and have product status as 'OBSOLETE'</p>",
                    "<p>Show the number of products whose PROD_LIST_PRICE is higher than the average PROD_LIST_PRICE.</p>",
                    "<p>Generate a list of suppliers where the PROD_LIST_PRICE is less than 1000.</p>",
                    "<p>Show the lowest PROD_LIST_PRICE for each product status.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the structure of the PRODUCTS table. Identify two tasks which would require subqueries. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919405,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of ORDERS and ORDER_ITEMS tables.&nbsp; </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-34-46-8e9c38438a0687f256e16e9401fdc760.png\"></p><p><br></p><p><strong>Given:</strong> ORDER_ID is the primary key in the ORDERS table and the foreign key of the ORDER_ITEMS table, whose constraint is defined with the ON DELETE CASCADE option. </p><p>Identify the DELETE statement which would execute successfully.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DELETE Statement](https://www.techonthenet.com/oracle/delete.php)",
                    "[DELETE](https://docs.oracle.com/search/?q=DELETE&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)",
                    "[Oracle DELETE](https://www.oracletutorial.com/oracle-basics/oracle-delete/)"
                ],
                "feedbacks": [
                    "<p>This DELETE statement correctly specifies the table name 'orders' and includes a condition to delete records where the order_total is less than 1000. Since the DELETE operation is only performed on the ORDERS table, it will execute successfully without any syntax errors.</p>",
                    "This DELETE statement uses a subquery in the WHERE clause to select order_id from the ORDER_ITEMS table. However, the syntax is incorrect as it does not specify how the ORDERS table should be linked to the subquery result, making it invalid for deleting records from the ORDERS table.",
                    "<p>This DELETE statement incorrectly specifies 'order_id' after the DELETE keyword, which is not valid syntax for deleting records from a table in SQL. Additionally, the WHERE clause does not include the correct table name and condition for deleting records based on the order_total column, making this statement invalid for successful execution.</p>",
                    "<p>This DELETE statement attempts to delete records from both the ORDERS and ORDER_ITEMS tables using aliases 'o' and 'i'. However, the syntax is incorrect as it does not specify the join condition between the two tables, which is necessary when deleting records from multiple tables.</p>"
                ],
                "explanation": "<p>Correct option:</p><p><code><strong>DELETE orders WHERE order_total &lt; 1000;</strong></code></p><ul><li><p><strong>Valid syntax</strong> for deleting from a single table.</p></li><li><p>Will <strong>successfully delete</strong> orders with <code>order_total &lt; 1000</code>.</p></li><li><p>Because of <strong>ON DELETE CASCADE</strong>, matching rows in <code>ORDER_ITEMS</code> will also be deleted automatically.</p></li><li><p> <strong>This DELETE will execute successfully.</strong></p></li></ul><p>Both syntax for DELETE as shown below are valid:</p><pre class=\"prettyprint linenums\">DELETE FROM orders \nWHERE order_total &lt; 1000;</pre><p><br></p><p>and</p><pre class=\"prettyprint linenums\">DELETE orders \nWHERE order_total &lt; 1000;</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-23_22-34-30-b1ebf61324a609085959d9d540019325.png\"></p><p><br></p><p>Incorrect options:</p><p><code><strong>DELETE orders.o, order_items.i WHERE o.order_id = i.order_id;</strong></code></p><ul><li><p><strong>Invalid syntax</strong> in Oracle.</p></li><li><p>Oracle <strong>does not support multi-table deletes</strong> in this format — this is more typical of <strong>MySQL</strong>.</p></li><li><p>In Oracle, to delete from multiple tables, you must issue separate DELETEs or rely on <code>ON DELETE CASCADE</code>.</p></li></ul><p><strong> </strong><code><strong>DELETE FROM orders WHERE (SELECT order_id FROM order_items);</strong></code></p><ul><li><p>Invalid <code>WHERE</code> clause — it compares a scalar (a single value) to a <strong>subquery returning multiple rows</strong>, and the syntax is incorrect.</p></li><li><p>Even if corrected, this is not the correct form for a DELETE.</p></li></ul><p><code><strong>DELETE order_id FROM orders WHERE order_total &lt; 1000;</strong></code></p><ul><li><p><strong>Invalid DELETE syntax</strong> in Oracle.</p></li><li><p>You cannot delete just a column like <code>order_id</code> — DELETE always removes entire rows.</p></li><li><p>This syntax is not supported in Oracle SQL.</p></li></ul><p><br></p><p><strong>The Oracle DELETE statement</strong> is used to delete a single record or multiple records from a table in Oracle.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DELETE</code> statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">DELETE FROM table\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table - The table that you wish to delete records from. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be deleted. If no conditions are provided, then all records from the table will be deleted.</p><p><strong><em>Note: </em></strong><em>You do not need to list fields in the Oracle </em><code><em>DELETE</em></code><em> statement since you are deleting the entire row from the table.</em></p><p><br></p><p><br></p><p>The key to the question is the comments about the foreign key in the Order Items table and that the Delete Cascade option is enabled.</p><p>For you to delete rows from a table, the table must be in your own schema or you must have the <code>DELETE</code> object privilege on the table.</p><p>For you to delete rows from an updatable materialized view, the materialized view must be in your own schema or you must have the <code>DELETE</code> object privilege on the materialized view.</p><p>For you to delete rows from the base table of a view, the owner of the schema containing the view must have the <code>DELETE</code> object privilege on the base table. Also, if the view is in a schema other than your own, then you must have the <code>DELETE</code> object privilege on the view.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">DELETE orders \nWHERE order_total &lt; 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE FROM orders \nWHERE (SELECT order_id FROM order_items);</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE order_id \nFROM orders \nWHERE order_total &lt; 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">DELETE orders.o, order_items.i\nWHERE o.order_id = i.order_id;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "DELETE",
            "question_plain": "View and examine the structure of ORDERS and ORDER_ITEMS tables.&nbsp; Given: ORDER_ID is the primary key in the ORDERS table and the foreign key of the ORDER_ITEMS table, whose constraint is defined with the ON DELETE CASCADE option. Identify the DELETE statement which would execute successfully.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919407,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the data in the CUST_NAME column of the CUSTOMERS table.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CUST_NAME\nLex De Haan\nRenske Ladwig\nJose Manuel Urman\nJason Mallin\n</pre><p><br></p><p><strong>Required:</strong> Extract only those customer names that have three names and display the * symbol in place of the first name as follows.</p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">CUST_NAME\n*** De Haan\n**** Manuel Urman\n</pre><p><br></p><p>Identify the SQL queries which would give you the required output. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: LPAD Function](https://www.techonthenet.com/oracle/functions/lpad.php)",
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)",
                    "[Oracle / PLSQL: INSTR Function](https://www.techonthenet.com/oracle/functions/instr.php)"
                ],
                "feedbacks": [
                    "This query correctly uses the LPAD function to add '*' symbols in place of the first name for customer names with three parts. It uses the INSTR function to find the position of the second space in the name, ensuring that only names with three parts are selected.",
                    "<p>This query correctly uses the LPAD function and the INSTR function to identify customer names with three parts and replace the first name with '*' symbols. The difference is in the use of the negative index in the INSTR function to find the second space in the name.</p>",
                    "This query has an error in the syntax of the INSTR function, missing a comma between the 'cust_name' column and the space character. This would result in a syntax error and incorrect output. Additionally, the calculation for the length of the substring is incorrect, which would not produce the desired result.",
                    "This query also has a syntax error in the INSTR function, missing a comma between the 'cust_name' column and the space character. This would result in a syntax error and incorrect output. Additionally, the calculation for the length of the substring is incorrect, which would not produce the desired result."
                ],
                "explanation": "<p>Valid options:</p><pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR(cust_name, ' ')),LENGTH(cust_name),'*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,2)&lt;&gt;0;\n</pre><ul><li><p><code>INSTR(cust_name, ' ', 1, 2)</code> finds the <strong>position of the second space</strong>.</p></li><li><p>The <code>SUBSTR(... INSTR(...))</code> starts from the first space onward.</p></li><li><p><code>LPAD(..., LENGTH(cust_name), '*')</code> pads the result with asterisks on the left to the original length.</p></li><li><p>This works perfectly.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR(cust_name, ' ')),LENGTH(cust_name),'*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',-1,2)&lt;&gt;0;\n</pre><ul><li><p>Oracle treats negative <code>start_position</code> in <code>INSTR</code> a bit differently:<br><code>INSTR(cust_name, ' ', -1, 2)</code> means <strong>searching backward from the end</strong> to find the second space.</p></li><li><p>This still correctly identifies names with <strong>two spaces</strong>, i.e., three-name customers.</p></li><li><p>Works as expected, though less commonly used.</p></li></ul><p><br></p><p>Invalid options:</p><pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR (cust_name ' ')),LENGTH(cust_name) - INSTR(cust_name, ' '), '*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,-2)&lt;&gt;0;</pre><p>Invalid or ineffective syntax:</p><ul><li><p>Negative values in the 4th argument (<code>occurrence</code>) don't behave as expected.</p><p><br></p></li></ul><pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR (cust_name ' ')),LENGTH(cust_name) - INSTR(cust_name, ' '), '*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,2)&lt;&gt;0;</pre><p><br></p><ul><li><p>Calculates the wrong padding length, depending on how many characters are in the first name.</p></li></ul><p><br></p><p>To solve this problem, we need to:</p><ol><li><p><strong>Filter customers with three names</strong> — i.e., two spaces in the <code>cust_name</code>.</p></li><li><p><strong>Mask the first name</strong> — by replacing it with asterisks (<code>*</code>) and preserving the rest of the name.</p></li></ol><p>From your question, the correct queries should:</p><ul><li><p>Use <code>INSTR(cust_name, ' ', 1, 2) &lt;&gt; 0</code> in the <code>WHERE</code> clause to ensure <strong>two spaces</strong> exist.</p></li><li><p>Use <code>SUBSTR</code> and <code>LPAD</code> to extract everything after the first space, then pad it with <code>*</code> to the original name's length.</p></li></ul><p><br></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-23_22-49-17-8351e789f28e7542aca0014349ece6d5.png\"></p><p><br></p><p><strong>The Oracle/PLSQL LPAD function</strong> pads the left-side of a string with a specific set of characters (when <em>string1</em> is not null).</p><p><strong>Syntax</strong></p><p>The syntax for the <code>LPAD</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">LPAD( string1, padded_length [, pad_string] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to pad characters to (the left-hand side). </p><p>padded_length - The number of characters to return. If the <em>padded_length</em> is smaller than the original string, the <code>LPAD</code> function will truncate the string to the size of <em>padded_length</em>. </p><p>pad_string Optional. - This is the string that will be padded to the left-hand side of <em>string1</em>. If this parameter is omitted, the <code>LPAD</code> function will pad spaces to the left-side of <em>string1</em>.</p><p><strong>Returns</strong></p><p>The <code>LPAD</code> function returns a string value.</p><p><br></p><p><br></p><p><strong>The Oracle/PLSQL SUBSTR functions </strong>allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The source string. </p><p>start_position - The starting position for extraction. The first position in the string is always 1. </p><p>length Optional. - It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a NULL value.</p><p><strong>Note</strong></p><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p><p><br></p><p><strong>The Oracle/PLSQL INSTR</strong> function returns the location of a substring in a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">INSTR( string, substring [, start_position [, th_appearance ] ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The string to search. <em>string</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. </p><p>substring - The substring to search for in <em>string</em>. <em>substring</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. </p><p>start_position Optional. - The position in <em>string</em> where the search will start. If omitted, it defaults to 1. The first position in the string is 1. If the <em>start_position</em> is negative, the <code>INSTR</code> function counts back <em>start_position</em> number of characters from the end of <em>string</em> and then searches towards the beginning of <em>string</em>. nth_appearance Optional. The nth appearance of <em>substring</em>. If omitted, it defaults to 1.</p><p><strong>Returns</strong></p><p>The <code>INSTR</code> function returns a numeric value. The first position in the string is 1.<br>If <em>substring</em> is not found in <em>string</em>, then the <code>INSTR</code> function will return 0.</p><p><br></p><p><br></p><p><strong>The syntax for the LENGTH</strong> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">LENGTH( string1 )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 The string to return the length for.</p><p><strong>Returns</strong></p><p>The <code>LENGTH</code> function returns a numeric value.<br>If <em>string1</em> is <code>NULL</code>, then the <code>LENGTH</code> function will return <code>NULL</code>.</p><p><br></p><pre class=\"prettyprint linenums\">LENGTH(NULL)\nResult: NULL\n\nLENGTH('')\nResult: NULL\n\nLENGTH(' ')\nResult: 1\n\nLENGTH('England')\nResult: 7\n\nLENGTH('England ')\nResult: 8</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR(cust_name, ' ')),LENGTH(cust_name),'*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,2)&lt;&gt;0;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR(cust_name, ' ')),LENGTH(cust_name),'*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',-1,2)&lt;&gt;0;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR (cust_name ' ')),LENGTH(cust_name) - INSTR(cust_name, ' '), '*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,-2)&lt;&gt;0;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LPAD(SUBSTR(cust_name, INSTR (cust_name ' ')),LENGTH(cust_name) - INSTR(cust_name, ' '), '*') \"CUST NAME\" \nFROM customers \nWHERE INSTR(cust_name, ' ',1,2)&lt;&gt;0;</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SUBSTR",
            "question_plain": "View and examine the data in the CUST_NAME column of the CUSTOMERS table.Exhibit: 1CUST_NAME\nLex De Haan\nRenske Ladwig\nJose Manuel Urman\nJason Mallin\nRequired: Extract only those customer names that have three names and display the * symbol in place of the first name as follows.Exhibit: 2CUST_NAME\n*** De Haan\n**** Manuel Urman\nIdentify the SQL queries which would give you the required output. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919409,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about views. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: VIEW](https://www.techonthenet.com/oracle/views.php)",
                    "[Oracle / PLSQL: Check Constraints](https://www.techonthenet.com/oracle/check.php)",
                    "[How to create view in oracle](https://techgoeasy.com/oracle-views/)"
                ],
                "feedbacks": [
                    "A view in Oracle Database does not consume any storage space as it is a virtual table that does not store data physically. It simply provides a way to present data from one or more tables in a structured format without duplicating the data.",
                    "In Oracle Database, a normal or regular view cannot be indexed directly. However, materialized views can be indexed to improve query performance by storing the results of the view in a physical table.",
                    "In Oracle Database, it is possible to modify the definition of a view without dropping it by using the CREATE OR REPLACE VIEW statement. This allows for changes to the view's query or structure without affecting any dependent objects.",
                    "In Oracle Database, tables referenced in the defining query of a view do not need to exist at the time of view creation. However, the view will become invalid if any referenced tables are dropped or altered, and it will need to be recompiled."
                ],
                "explanation": "<p>True options:</p><ol><li><p><strong>A view causes no storage space consumption</strong> – <strong>True</strong></p><ul><li><p>Regular views do not store data; they act as saved queries retrieving data dynamically from base tables. However, <strong>materialized views</strong> do consume storage since they store query results.</p></li></ul></li><li><p><strong>It is possible to modify the definition of a VIEW without dropping it using a CREATE OR REPLACE VIEW statement</strong> – <strong>True</strong></p><ul><li><p>The <code>CREATE OR REPLACE VIEW</code> statement allows updating a view’s definition without the need to drop and recreate it.</p></li></ul></li></ol><p>False options:</p><ul><li><p><strong>A normal or regular VIEW can be indexed</strong> – <strong>False</strong></p><ul><li><p>Views <strong>cannot</strong> be indexed directly since they do not store data. Indexing applies only to underlying base tables.</p></li></ul></li><li><p><strong>Tables in the defining query of a VIEW must always exist in order to create the VIEW</strong> – <strong>False</strong></p><ul><li><p>In Oracle SQL, using the <strong>FORCE</strong> option when creating a view allows its definition to be stored even if referenced base tables do not exist at the time.</p></li></ul></li></ul><p><br></p><p><strong>An Oracle VIEW</strong>, in essence, is a virtual table that does not physically exist. Rather, it is created by a query <a href=\"https://www.techonthenet.com/oracle/joins.php\">joining one or more tables</a>.</p><p><strong>Create VIEW</strong></p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE VIEW</code> Statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE VIEW view_name AS\n  SELECT columns\n  FROM tables\n  [WHERE conditions];</pre><p><br></p><p>view_name - The name of the Oracle <code>VIEW</code> that you wish to create. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be included in the <code>VIEW</code>.</p><p>Example</p><p>Here is an example of <strong>how to use the Oracle CREATE VIEW:</strong></p><p><br></p><pre class=\"prettyprint linenums\">CREATE VIEW sup_orders AS\n  SELECT suppliers.supplier_id, orders.quantity, orders.price\n  FROM suppliers\n  INNER JOIN orders\n  ON suppliers.supplier_id = orders.supplier_id\n  WHERE suppliers.supplier_name = 'Microsoft';</pre><p><br></p><p>This Oracle <code>CREATE VIEW</code> example would create a virtual table based on the result set of the SELECT statement. You can now query the Oracle <code>VIEW</code> as follows:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM sup_orders;</pre><p><br></p><p><strong>Update VIEW</strong></p><p>You can modify the definition of an Oracle VIEW without dropping it by using the Oracle CREATE OR REPLACE VIEW Statement.</p><p><strong>Syntax</strong></p><p>The syntax for the CREATE OR REPLACE VIEW Statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW view_name AS\n  SELECT columns\n  FROM table\n  WHERE conditions;</pre><p><br></p><p>view_name&nbsp; -The name of the Oracle VIEW that you wish to create or replace.</p><p><br></p><p>A <strong>CHECK constraint</strong> allows you to specify a condition on each row in a table.</p><p>Note</p><p>A <code>CHECK</code> constraint can NOT be defined on a <a href=\"https://www.techonthenet.com/oracle/views.php\">SQL View</a>.</p><p>The <code>CHECK</code> constraint defined on a table must refer to only columns in that table. It can not refer to columns in other tables.</p><p>A <code>CHECK</code> constraint can NOT include a <a href=\"https://www.techonthenet.com/oracle/subqueries.php\">SQL Subquery</a>.</p><p>A <code>CHECK</code> constraint can be defined in either a <a href=\"https://www.techonthenet.com/oracle/tables/create_table.php\">SQL CREATE TABLE statement</a> or a <a href=\"https://www.techonthenet.com/oracle/tables/alter_table.php\">SQL ALTER TABLE statement</a>.</p><p><strong>Using a CREATE TABLE statement</strong></p><p>The syntax for creating a check constraint using a <code>CREATE TABLE</code> statement in Oracle is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE table_name\n(\n  column1 datatype null/not null,\n  column2 datatype null/not null,\n\n  ...\n\n  CONSTRAINT constraint_name CHECK (column_name condition) [DISABLE]\n\n);</pre><p><br></p><p>The <code>DISABLE</code> keyword is optional. If you create a check constraint using the <code>DISABLE</code> keyword, the constraint will be created, but the condition will not be enforced.</p><p>The <code>WITH CHECK OPTION</code> clause can be given for an updatable view to prevent inserts to rows for which the <code>WHERE</code> clause in the <code><em>select_statement</em></code> is not true. It also prevents updates to rows for which the <code>WHERE</code> clause is true but the update would cause it to be not true (in other words, it prevents visible rows from being updated to nonvisible rows).</p><p>In a <code>WITH CHECK OPTION</code> clause for an updatable view, the <code>LOCAL</code> and <code>CASCADED</code> keywords determine the scope of check testing when the view is defined in terms of another view. When neither keyword is given, the default is <code>CASCADED</code>. The <code>LOCAL</code> keyword restricts the <code>CHECK OPTION</code> only to the view being defined. <code>CASCADED</code> causes the checks for underlying views to be evaluated as well.</p><p>Views do not contain any data – it is just a stored query in the database that can be executed when called. All the data it shows comes from the base tables. One can think of a view as a virtual table or mapping of data from one or more</p><p>-A view takes up no storage space other than for the definition of the view in the data dictionary.</p><p>Views <strong>cannot</strong> have indexes associated as per Oracle SQL Standards.</p><p>An exception to needing a table to create a view is when Force is used. Force forces the creation of a View even when the View will be invalid. Views can be indexed if they are materialized view. This makes the statement T<em>ables in the defining query of a VIEW must always exist in order to create the VIEW</em> <strong>False </strong>and the statement <em>VIEW can be indexed</em> <strong>True</strong>. That said, a normal or regular view cannot be indexed.</p><p><a href=\"https://docs.oracle.com/database/121/CCAPP/GUID-B66D7E02-D602-4B2A-89FA-B5A496702611.htm#CCAPP9037\">https://docs.oracle.com/database/121/CCAPP/GUID-B66D7E02-D602-4B2A-89FA-B5A496702611.htm#CCAPP9037</a></p><p><br></p><p><br></p><pre class=\"prettyprint linenums\">CREATE FORCE&nbsp;VIEW for_view AS \nSELECT ttt \nFROM emp;</pre><p><br></p><p>Warning: View created with compilation errors.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \nFROM for_view;</pre><p><br></p><p>ERROR at line 1:</p><p>ORA-04063: view \"USER.FOR_VIEW\" has errors</p><p><br></p><p><strong>Types of Indexes for Materialized Views</strong></p><p>The two most common operations on a materialized view are query execution and fast refresh, and each operation has different performance requirements:</p><ul><li><p>Query execution might need to access any subset of the materialized view key columns, and might need to join and aggregate over a subset of those columns. Consequently, for best performance, create a single-column bitmap index on each materialized view key column.</p></li><li><p>In the case of materialized views containing only joins using fast refresh, create indexes on the columns that contain the rowids to improve the performance of the refresh operation.</p></li><li><p>If a materialized view using aggregates is fast refreshable, then an index appropriate for the fast refresh procedure is created unless <code>USING NO INDEX</code> is specified in the <code>CREATE MATERIALIZED VIEW</code> statement.</p></li></ul><p><a href=\"https://docs.oracle.com/cd/E29633_01/CDMOG/GUID-8D4FCC4B-39FF-464C-844E-7AD7E87190D3.htm\">https://docs.oracle.com/cd/E29633_01/CDMOG/GUID-8D4FCC4B-39FF-464C-844E-7AD7E87190D3.htm</a></p>",
                "answers": [
                    "<p>A view causes no storage space consumption.</p>",
                    "<p>A normal or regular VIEW can be indexed.</p>",
                    "<p>It is possible to modify the definition of a VIEW without dropping it using a CREATE OR REPLACE VIEW Statement.</p>",
                    "<p>Tables in the defining query of a VIEW must always exist in order to create the VIEW.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "VIEW",
            "question_plain": "View and examine the following available responses.Identify the true statements about views. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919411,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>The following commands have been executed.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">DEFINE hiredate = '01-APR-2011'\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE hire_date &gt; '&amp;hiredate'\nAND manager_id &gt; &amp;mgr_id;\n</pre><p><br></p><p>Identify the substitution variable you would be prompted for the input.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[The DEFINE and UNDEFINE Commands](https://www.oreilly.com/library/view/oracle-sqlplus-the/1565925785/ch04s06.html)",
                    "[SQL*Plus Command Reference](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqpug/SQL-Plus-command-reference.html)",
                    "[Literals, Substitution Variables and Bind Variables](https://oracle-base.com/articles/misc/literals-substitution-variables-and-bind-variables)"
                ],
                "feedbacks": [
                    "<p>Only 'mgr_id' is a substitution variable in the commands provided in the exhibits. Therefore, the user would be prompted for input for this variable.</p>",
                    "Both 'hiredate' and 'mgr_id' are not substitution variables in the commands provided in the exhibits. Therefore, the user would not be prompted for input for these variables.",
                    "Only 'hiredate' is not a substitution variable in the commands provided in the exhibits. Therefore, the user would not be prompted for input for this variable.",
                    "<p>None of the commands in the exhibits require any input from the user, so there are no substitution variables to prompt for input.</p>"
                ],
                "explanation": "<p>Correct option:</p><p><strong>Only 'mgr_id'</strong></p><p>Because:</p><ul><li><p><code>hiredate</code> is predefined using <code>DEFINE</code>.</p></li><li><p><code>mgr_id</code> is not defined, so you'll be <strong>prompted</strong> for that only.</p></li></ul><p>In Exhibit 2, the SQL statement uses substitution variables. The <code>&amp;hiredate</code> and <code>&amp;mgr_id</code> variables indicate that the user will be prompted to provide input before executing the query.</p><p>Now, looking at Exhibit 1, the <code>DEFINE</code> statement assigns a value to the <code>hiredate</code> variable. Since <code>hiredate</code> has already been defined, the user will <strong>not</strong> be prompted to enter its value. However, the <code>mgr_id</code> variable has no predefined value, meaning the user <strong>will</strong> be prompted for its input.</p><p>So, the correct answer is: <strong>Only 'mgr_id'</strong>.</p><p><br></p><p>Let's analyze what's happening in this scenario with substitution variables in Oracle SQL*Plus or SQL Developer:</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">DEFINE hiredate = '01-APR-2011'\n</pre><ul><li><p>This command defines a <strong>substitution variable</strong> called <code>hiredate</code> with a fixed value.</p></li><li><p>So, when <code>&amp;hiredate</code> is referenced later, Oracle will <strong>not prompt</strong> for input — it uses the defined value.</p></li></ul><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE hire_date &gt; '&amp;hiredate'\nAND manager_id &gt; &amp;mgr_id;\n</pre><ul><li><p><code>&amp;hiredate</code> is <strong>already defined</strong> → Oracle will use <code>'01-APR-2011'</code> silently.</p></li><li><p><code>&amp;mgr_id</code> is <strong>not defined</strong> → Oracle <strong>will prompt</strong> the user to enter a value.</p><p><br></p></li></ul><p>The <code>DEFINE</code>and <code>UNDEFINE</code> commands allow you to explicitly create and delete user variables. <code>DEFINE</code> creates a variable and assigns it an initial value. <code>DEFINE</code> also lets you list all currently defined user variables with their values. The <code>UNDEFINE</code> command allows you to delete a user variable so it can no longer be referenced.</p><p><br></p><p><strong>DEFINE</strong></p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">DEFINE [variable] | [variable = text]</pre><p><br></p><p>Specifies a user or predefined variable and assigns a <code>CHAR</code> value to it, or lists the value and variable type of a single variable or all variables.</p><p><strong>Terms</strong></p><p>variable - Represents the user or predefined variable whose value you wish to assign or list.</p><p>text - Represents the <code>CHAR</code> value you wish to assign to variable. Enclose text in single quotes if it contains punctuation or blanks.</p><p>variable = text - Defines (names) a substitution variable and assigns it a CHAR value.</p><p>Enter <code>DEFINE</code> followed by variable to list the value and type of variable. Enter <code>DEFINE</code> with no clauses to list the values and types of all substitution variables.</p><p><br></p><p><strong>UNDEFINE</strong></p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">UNDEFINE variable ...</pre><p><br></p><p>variable - Represents the name of the substitution variable you want to delete.</p><p>Deletes one or more substitution variables that you defined either explicitly (with the <code>DEFINE</code> command) or implicitly (with an argument to the <code>START</code> command).</p><p><strong>Substitution Variables</strong> are a feature of the SQL*Plus tool. They have nothing to do with the way SQL is processed by the database server. When a substitution variable is used in a statement, SQL*Plus requests an input value and rewrites the statement to include it.</p><p>Substitution variables act as global placeholders for information that changes regularly. For example, you could set the current month member to the substitution variable <code>CurMnth</code> so that when the month changes, you need not update the month value manually in the form or the report script. You create and assign values to substitution variables within the application. These substitution variables are then available in the application when you select members for a form.</p><p><a href=\"https://docs.oracle.com/en/cloud/saas/planning-budgeting-cloud/pfusa/about_substitution_variables.html\">https://docs.oracle.com/en/cloud/saas/planning-budgeting-cloud/pfusa/about_substitution_variables.html</a></p>",
                "answers": [
                    "<p>Only 'mgr_id'</p>",
                    "<p>Both the substitution variables ''hiredate' and 'mgr_id'.</p>",
                    "<p>Only hiredate'</p>",
                    "<p>None, because no input required</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "DEFINE",
            "question_plain": "View and examine the following available responses.The following commands have been executed.Exhibit 1:DEFINE hiredate = '01-APR-2011'\nExhibit 2:SELECT employee_id, first_name, salary\nFROM employees\nWHERE hire_date &gt; '&amp;hiredate'\nAND manager_id &gt; &amp;mgr_id;\nIdentify the substitution variable you would be prompted for the input.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919413,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about Oracle synonyms. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Synonyms](https://www.techonthenet.com/oracle/synonyms.php)",
                    "[The Complete Guide to Oracle Synonyms](https://www.databasestar.com/oracle-synonym/)",
                    "[Reasons to Use Packages](https://docs.oracle.com/database/121/LNPLS/packages.htm#LNPLS00902)"
                ],
                "feedbacks": [
                    "<p>This statement is true. A synonym has an object number associated with it. This object number is used internally by Oracle to reference the object that the synonym points to.</p>",
                    "This statement is true. Private synonym names do not need to be unique within the database. Each user can have their own private synonym with the same name, as they are specific to the user's schema.",
                    "This statement is incorrect. Only users with the CREATE PUBLIC SYNONYM privilege can create public synonyms. Public synonyms are accessible to all users in the database.",
                    "<p>A synonym can be created on an object within a package.</p><p>If you have a package <code>MY_PACKAGE</code> with a procedure <code>MY_PROCEDURE</code>, you can create a synonym for it:\n<code>CREATE SYNONYM MY_SYNONYM FOR MY_PACKAGE.MY_PROCEDURE;</code></p><p>Now, instead of referencing <code>MY_PACKAGE.MY_PROCEDURE</code>, I can simply use <code>MY_SYNONYM</code> to call the procedure.</p>",
                    "<p>A synonym can have a synonym. Synonyms are aliases for table, view, sequence, procedure, or other objects, but they cannot be chained together to create synonym chains.</p>"
                ],
                "explanation": "<p>True statements:</p><p><strong>1.</strong> <em>\"Private synonym names do not need to be unique in the database.\"</em></p><ul><li><p>Private synonyms are <strong>owned by individual users</strong> and are only visible in that user's schema.</p></li><li><p>Therefore, <strong>different users can create private synonyms with the same name</strong> — they don’t need to be globally unique.</p></li></ul><p><strong>2.</strong> <em>\"A synonym has an object number.\"</em></p><ul><li><p>Every object in Oracle — including synonyms — is stored in the data dictionary and has a corresponding <strong>object ID</strong> (<code>OBJECT_ID</code>).</p></li><li><p>You can see this in the <code>ALL_OBJECTS</code> or <code>DBA_OBJECTS</code> views.</p></li></ul><p>False statements:</p><ul><li><p><em>\"A synonym cannot have a synonym.\"</em></p><ul><li><p>A synonym <strong>can point to another synonym</strong>, although this is generally discouraged due to potential resolution complexity.</p></li></ul></li><li><p><em>A synonym cannot be created on an object in a package.\"</em></p><ul><li><p>You <strong>can</strong> create a synonym for a <strong>package or its objects</strong>, like procedures/functions within it.</p><ul><li><p>Example:</p><pre class=\"prettyprint linenums\">CREATE SYNONYM my_proc FOR hr.my_package.my_procedure;\n</pre></li></ul></li></ul></li><li><p><em>\"Any user can create a PUBLIC synonym.\"</em></p><ul><li><p>Only users with the <code><strong>CREATE PUBLIC SYNONYM</strong></code> privilege (typically <code>DBA</code>s) can create public synonyms.</p></li><li><p>Regular users <strong>cannot</strong> do this unless explicitly granted the privilege.</p></li></ul><p><br></p></li></ul><p>A <strong>Synonym</strong> is an alternative name for objects such as tables, views, sequences, stored procedures, and other database objects.</p><p>You generally use synonyms when you are granting access to an object from another schema and you don't want the users to have to worry about knowing which schema owns the object.</p><p><strong>Create Synonym (or Replace)</strong></p><p>You may wish to create a synonym so that users do not have to prefix the table name with the schema name when using the table in a query.</p><p><strong>Syntax</strong></p><p>The syntax to create a <code>SYNONYM</code> in Oracle is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE [OR REPLACE] [PUBLIC] SYNONYM [schema .] synonym_name\n  FOR [schema .] object_name [@ dblink];</pre><p><br></p><p><code>OR REPLACE</code> - Allows you to recreate the synonym (if it already exists) without having to issue a <code>DROP</code> synonym command. </p><p><code>PUBLIC</code> - It means that the synonym is a public synonym and is accessible to all users. Remember though that the user must first have the appropriate privileges to the object to use the synonym. </p><p>schema - The appropriate schema. If this phrase is omitted, Oracle assumes that you are referring to your own schema. </p><p>object_name - The name of the object for which you are creating the synonym. It can be one of the following: table view sequence stored procedure function package materialized view java class schema object user-defined object synonym</p><p><br></p><p><strong>Oracle Public and Private Synonyms</strong></p><p>There are two types of synonyms that can be created on an Oracle database: public and private.</p><p>A <strong>public</strong> synonym can be accessed by any user on the database. The user who creates the synonym it does not own it – it’s owned by the <code>PUBLIC</code> user group.</p><p>A <strong>private</strong> synonym can only be accessed by the person who created the synonym. This user is also the owner. The synonym name must be unique within the schema.</p><p>A synonym can be created on the following types of objects:</p><p>• table</p><p>• view</p><p>• <a href=\"https://www.databasestar.com/sql-stored-procedures/\">stored procedure</a></p><p>• function</p><p>• package</p><p>• <a href=\"https://www.databasestar.com/oracle-sequence/\">sequence</a></p><p>• materialised view</p><p>• synonym</p><p>• java class schema object</p><p>• user-defined object</p><p>A package is a schema object that groups logically related PL/SQL types, variables, constants, subprograms, cursors, and exceptions. A package is compiled and stored in the database, where many applications can share its contents.</p><p>Here is the basic syntax of creating a new synonym:</p><pre class=\"prettyprint linenums\">CREATE [OR REPLACE] [PUBLIC] SYNONYM schema.synonym_name\nFOR schema.object;</pre><p><br></p><p>If you skip the schema, Oracle will create the synonym in your own schema.</p><p>As per Oracle Documentation, it cannot create a synonym for a object contained ‘inside’ a package. Although a synonym could be created on a package. Reference Material: Oracle Database 21C SQL language Reference- Page 1694.</p><p>Synonyms are objects, so they have an object number.</p><p><a href=\"https://stackoverflow.com/questions/58565216/have-view-object-number-in-oracle\">https://stackoverflow.com/questions/58565216/have-view-object-number-in-oracle</a></p>",
                "answers": [
                    "<p>A synonym has an object number.</p>",
                    "<p>Private synonym names do not need to be unique in the database.</p>",
                    "<p>Any user can create a PUBLIC synonym.</p>",
                    "<p>A synonym cannot be created on an object in a package.</p>",
                    "<p>A synonym cannot have a synonym.</p>"
                ]
            },
            "correct_response": [
                "b",
                "a"
            ],
            "section": "Synonyms",
            "question_plain": "View and examine the following available responses.Identify the true statements about Oracle synonyms. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919415,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements are about views in an Oracle Database. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: VIEW](https://www.techonthenet.com/oracle/views.php)",
                    "[CREATE VIEW](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CREATE-VIEW.html)",
                    "[DROP VIEW](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/DROP-VIEW.html)"
                ],
                "feedbacks": [
                    "<p>Views in Oracle Database can join tables from different schemas as long as the necessary privileges are granted to the user creating the view. This allows for flexibility in querying data from multiple sources.</p>",
                    "<p><code>FORCE</code> allows the creation of a view regardless of the existence of the tables.</p><p>It does not bypass privilege requirements. The necessary privileges on the base tables must be granted, or the view will remain invalid.</p>",
                    "<p>A SELECT statement can contain a WHERE clause when querying a view, even if the view itself contains a WHERE clause in its defining query. This allows for further filtering of data retrieved from the view based on specific criteria.</p><p><br></p>",
                    "<p><br></p><p>Using the FORCE option allows the creation of a view even if the user creating the view does not have the necessary privileges on the underlying base tables. This can be useful in certain scenarios where the view needs to be created for specific purposes.</p>",
                    "<p>When rows are inserted into a table through a view, the data is directly inserted into the underlying table. This means that even if the view is dropped, the data inserted through the view will still be retained in the table.</p>",
                    "Views in Oracle Database do have an object number assigned to them. This object number is used internally by the database to uniquely identify and manage the view object within the database system."
                ],
                "explanation": "<p>Here are the three true statements about views in an Oracle Database:</p><ol><li><p><strong>Rows inserted into a table using a view are retained in the table if the view is dropped.</strong> A view is merely a stored SQL query that provides a logical representation of data from one or more underlying tables. When you insert rows through an updatable view, the data is physically stored in the base tables. Dropping the view removes only its definition from the database schema and does not affect the data in the underlying tables.</p></li><li><p><strong>Views have no segment.</strong> In an Oracle database, a segment is a storage object that consumes space, such as a table or an index. Standard views are simply definitions of queries and do not store data themselves. Therefore, they do not have a data segment allocated to them. It's important to distinguish standard views from materialized views, which do store data and consequently have segments.</p></li><li><p><strong>FORCE may be used to create a view regardless of whether the base tables of the view has privileges on them.</strong> The <code>CREATE FORCE VIEW</code> statement allows for the creation of a view even if the underlying base tables do not exist at the time of creation or if the creator does not have the necessary privileges on them. The resulting view will be in an \"invalid\" state and cannot be queried until the base tables are created and the required privileges are granted. This is particularly useful in development environments and for deploying applications where the order of object creation might vary.</p></li></ol><p>Incorrect options:</p><ul><li><p>\"Views can join tables only if they belong to the same schema.\"</p></li></ul><p>This statement is <strong>incorrect</strong>.</p><p>A powerful feature of views is their ability to create a simplified, logical representation of data that may be spread across different schemas. As long as the user creating the view has the necessary <code>SELECT</code> (or other) privileges on the tables in the other schemas, they can be joined together.</p><p>To do this, you simply prefix the table name with its schema name in the <code>CREATE VIEW</code> statement.</p><p><strong>Example:</strong></p><p>Imagine you have two schemas:</p><ul><li><p><code>HR_DATA</code> with an <code>employees</code> table.</p></li><li><p><code>FINANCE_DATA</code> with a <code>salaries</code> table.</p></li></ul><p>You can create a view in the <code>HR_DATA</code> schema that joins these two tables:</p><pre class=\"prettyprint linenums\">CREATE VIEW employee_salary_view AS\nSELECT\n    e.employee_id,\n    e.first_name,\n    e.last_name,\n    s.salary_amount\nFROM\n    employees e\nJOIN\n    FINANCE_DATA.salaries s ON e.employee_id = s.employee_id;\n</pre><p><br></p><p>In this example, the user in <code>HR_DATA</code> who is creating the view must have been granted <code>SELECT</code> permission on the <code>FINANCE_DATA.salaries</code> table.</p><p><br></p><ul><li><p>\"Views have no object number.\"</p></li></ul><p>This statement is also <strong>incorrect</strong>.</p><p>In an Oracle Database, every object that is created—including tables, indexes, sequences, procedures, and <strong>views</strong>—is assigned a unique identifier called an <code>OBJECT_ID</code> (or <code>OBJECT_NUMBER</code>). This number is stored in the database's data dictionary and is used internally by Oracle to manage and track the object.</p><p>You can easily verify this by querying the data dictionary views, such as <code>USER_OBJECTS</code>, <code>ALL_OBJECTS</code>, or <code>DBA_OBJECTS</code>.</p><p><strong>Example Query:</strong></p><p>If you run the following query, you will see a list of all views in your schema, each with its own unique <code>OBJECT_ID</code>.\nSELECT\n&nbsp; &nbsp; object_name,\n&nbsp; &nbsp; object_type,\n&nbsp; &nbsp; object_id\nFROM\n&nbsp; &nbsp; USER_OBJECTS\nWHERE\n&nbsp; &nbsp; object_type = 'VIEW';\n</p><p>The existence of an <code>OBJECT_ID</code> for each view proves that they do, in fact, have an object number.</p><p><br></p><p><strong>An Oracle VIEW</strong>, in essence, is a virtual table that does not physically exist. Rather, it is created by a query <a href=\"https://www.techonthenet.com/oracle/joins.php\">joining one or more tables</a>.</p><p><strong>Create VIEW</strong></p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE VIEW</code> Statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE VIEW view_name AS\n  SELECT columns\n  FROM tables\n  [WHERE conditions];</pre><p><br></p><p>view_name - The name of the Oracle <code>VIEW</code> that you wish to create. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be included in the <code>VIEW</code>.</p><p><br></p><p><strong>Update VIEW</strong></p><p>You can modify the definition of an Oracle <code>VIEW</code> without dropping it by using the Oracle CREATE OR REPLACE VIEW Statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE OR REPLACE VIEW</code> Statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW view_name AS\n  SELECT columns\n  FROM table\n  WHERE conditions;</pre><p><br></p><p>view_name - The name of the Oracle <code>VIEW</code> that you wish to create or replace.</p><p><br></p><p><strong>DROP VIEW </strong></p><p>Once an Oracle <code>VIEW</code> has been created, you can drop it with the Oracle <code>DROP VIEW</code> Statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DROP VIEW</code> Statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">DROP VIEW view_name;</pre><p><br></p><p>view_name - The name of the view that you wish to drop.</p><p><br></p><p><strong>Schemas</strong></p><p>To create a view in your own schema, you must have the <code>CREATE VIEW</code> system privilege. To create a view in another user's schema, you must have the <code>CREATE ANY VIEW</code> system privilege.</p><p>To create a subview, you must have the <code>UNDER ANY VIEW</code> system privilege or the <code>UNDER</code> object privilege on the superview.</p><p>The owner of the schema containing the view must have the privileges necessary to either select, insert, update, or delete rows from all the tables or views on which the view is based. The owner must be granted these privileges directly, rather than through a role.</p><p>To use the basic constructor method of an object type when creating an object view, one of the following must be true:</p><p>• The object type must belong to the same schema as the view to be created.</p><p>• You must have the <code>EXECUTE ANY TYPE</code> system privileges.</p><p>• You must have the <code>EXECUTE</code> object privilege on that object type.</p><p>You can create a view joining tables from different schema as long as you have select access on both tables or use the <code>FORCE</code> option.</p><p><br></p><p><strong>FORCE</strong></p><p>Specify <code>FORCE</code> if you want to create the view regardless of whether the base tables of the view or the referenced object types exist or the owner of the schema containing the view has privileges on them. These conditions must be true before any <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements can be issued against the view.</p><p>View can be created with non existent table if we use 'create force view' </p><p>If the view definition contains any constraints, <code>CREATE VIEW ... FORCE</code> will fail if the base table does not exist or the referenced object type does not exist. <code>CREATE VIEW ... FORCE</code> will also fail if the view definition names a constraint that does not exist.</p><p>Use the <code>DROP VIEW</code> statement to remove a view or an object view from the database. You can change the definition of a view by dropping and re-creating it.</p><p><br></p><p><strong>Using VIEWS in Queries</strong></p><p>Views can be queried in the same manner as tables.</p><p>With some restrictions, rows can be inserted into, updated in, or deleted from a base table using a view.</p><p>Data inserted through view, as with an actual table, will not be deleted if the view (or table) used to do the insert is deleted.</p><p><strong>Restrictions on DML operations</strong> for views use the following criteria in the order listed:</p><p>• If a view is defined by a query that contains <code>SET</code> or <code>DISTINCT</code> operators, a <code>GROUP BY</code> clause, or a group function, then rows cannot be inserted into, updated in, or deleted from the base tables using the view.</p><p>• If a view is defined with <code>WITH CHECK OPTION</code> , a row cannot be inserted into, or updated in, the base table (using the view), if the view cannot select the row from the base table.</p><p>• If a <code>NOT NULL</code> column that does not have a <code>DEFAULT</code> clause is omitted from the view, then a row cannot be inserted into the base table using the view.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28310/views001.htm#ADMIN11781\">https://docs.oracle.com/cd/B28359_01/server.111/b28310/views001.htm#ADMIN11781</a></p><p><br></p><p>Views and synonyms are objects, so they have an object number, but a view does not consume physical space in the database, so it does not have a segment.</p><p><a href=\"https://stackoverflow.com/questions/58565216/have-view-object-number-in-oracle\">https://stackoverflow.com/questions/58565216/have-view-object-number-in-oracle</a></p>",
                "answers": [
                    "<p>Views have no segment.</p>",
                    "<p><code>FORCE</code> may be used to create a view regardless of whether the base tables of the view has privileges on them.</p>",
                    "<p>Rows inserted into a table using a view are retained in the table if the view is dropped.</p>",
                    "<p>Views can join tables only if they belong to the same schema.</p>",
                    "<p>Views have no object number.</p>",
                    "<p>A SELECT statement cannot contain a WHERE clause when querying a view containing a WHERE clause in its defining query.</p>"
                ]
            },
            "correct_response": [
                "b",
                "a",
                "c"
            ],
            "section": "VIEW",
            "question_plain": "View and examine the following available responses.Identify the true statements are about views in an Oracle Database. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919353,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL query and exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT constraints_name, constraints_type, search_condition, r_constraint_name, delete_rule, status,\nFROM user_constraints\nWHERE table_name = 'ORDERS';\n</pre><p><br></p><p><strong>Given: </strong>Below is the output of the above SQL query.</p><p><strong>Exhibit: 2</strong></p>\n<img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question/2025-06-16_15-22-35-92cd52f49130a68954a17c96ac6d02f2.png\"><p><br></p><p>Identify true statements about the output. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[DBA_SUPPLEMENTAL_LOGGING](https://docs.oracle.com/search/?q=Supplemental%2520Logging&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)",
                    "[ALL_CONSTRAINTS](https://docs.oracle.com/search/?q=ALL_CONSTRAINTS&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)"
                ],
                "feedbacks": [
                    "The DELETE_RULE column in the output indicates the desired state of related rows in the child table when the corresponding row is deleted from the parent table. This information is crucial for maintaining data integrity and enforcing referential constraints between tables.",
                    "<p>In the second column of the output, 'C' indicates a check constraint. Check constraints are used to enforce specific conditions on the data stored in a table, ensuring data consistency and validity.</p>",
                    "<p>The STATUS column does not indicate whether the table is currently in use in the output. It is more likely to provide information about the status of the constraint itself, such as whether it is enabled or disabled.</p>",
                    "<p>The R_CONSTRAINT_NAME column does not contain an alternative name for the constraint in the output. It typically represents the name of the referential constraint between the parent and child tables, rather than an alternative name.</p>"
                ],
                "explanation": "<p>True statements:</p><p><strong>1.</strong> <em>\"The DELETE_RULE column indicates the desired state of related rows in the child table when the corresponding row is deleted from the parent table.\"</em></p><ul><li><p><code>DELETE_RULE</code> describes what happens when a referenced (parent) row is deleted:</p><ul><li><p><code>CASCADE</code>: child rows are also deleted.</p></li><li><p><code>SET NULL</code>: child foreign key values are set to NULL.</p></li></ul></li><li><p>This column is meaningful <strong>only for referential integrity constraints (type 'R')</strong>.</p><p><br></p></li></ul><p><strong>2.</strong> <em>\"In the second column, 'C' indicates a check constraint.\"</em></p><ul><li><p>In the <code>CONSTRAINT_TYPE</code> column:</p><ul><li><p><code>'C'</code> stands for <strong>Check constraint</strong>.</p></li><li><p><code>'P'</code> = Primary key.</p></li><li><p><code>'R'</code> = Referential integrity (foreign key).</p></li></ul></li><li><p>So values like <code>ORDER_DATE_NN</code>, <code>ORDER_MODE_LOV</code>, etc. marked with <code>'C'</code> are check constraints.</p></li></ul><p>False statements:</p><ul><li><p><em>\"The STATUS column indicates whether the table is currently in use.\"</em></p></li><li><p>The <code>STATUS</code> column indicates whether the <strong>constraint is enabled or disabled</strong>, <strong>not</strong> whether the table is in use.</p></li><li><p><code>'ENABLED'</code> = the constraint is active and enforced.</p></li></ul><p><em>\"The R_CONSTRAINT_NAME column contains an alternative name for the constraint.\"</em></p><ul><li><p><code>R_CONSTRAINT_NAME</code> refers to the <strong>primary or unique constraint</strong> in the <strong>parent table</strong> that the foreign key (referential constraint) points to.</p></li><li><p>It is <strong>not</strong> an alias or alternate name.</p></li></ul><p><br></p><p><strong>Oracle allows three different DELETE_RULE definitions</strong></p><p>• <code>ON DELETE CASCADE</code> (when a referenced parent table row is removed all the child are removed automatically)</p><p>• The <code>ON DELETE SET NULL</code> action allows data that references the parent key to be deleted, but not updated. When referenced data in the parent key is deleted, all rows in the child table that depend on those parent key values have their foreign keys set to null.</p><p>• <code>ON DELETE NO ACTION</code> (which is the default) prevents deleting a parent when there are children</p><p>√&nbsp; The DELETE_RULE column indicates the desired state of related rows in the child table when the corresponding row is deleted from the parent table.</p><p><br></p><p><strong>Constraint Types</strong></p><p>Oracle constraints are critical to the scalability, flexibility and integrity of your database data. Constraints apply specific rules to data, ensuring the data conforms to the requirements defined. There are a number of different kinds of constraints that you will be concerned with as a DBA. These are:</p><p><code>C</code> - Check constraint on a table</p><p>Check constraints validate that values in a given column meet a specific criteria. For example, you could create a check constraint on a varchar2 column so it only can contain the values T or F for example.</p><p><em>√&nbsp; In the second column, 'C' indicates a check constraint.</em></p><p><br></p><p><code>P</code> - Primary key</p><p>Primary key constraints define a column or series of columns that uniquely identify a given row in a table. Defining a primary key on a table is optional and you can only define a single primary key on a table. A primary key constraint can consist of one or many columns (up to 32). Any column that is defined as a primary key column is automatically set with a NOT NULL status.</p><p><a href=\"http://dba-oracle.com/concepts/constraints_foreign_key_unique_not_null.htm\">http://dba-oracle.com/concepts/constraints_foreign_key_unique_not_null.htm</a></p><p><code>U</code> - Unique key</p><p>Unique constraints are like alternative primary key constraints. A unique constraint defines a column, or series of columns, that must be unique in value. You can have a number of unique constraints defined and the columns can have NULL values in them, unlike a column that belongs to a primary key constraint.</p><p><a href=\"http://dba-oracle.com/concepts/constraints_foreign_key_unique_not_null.htm\">http://dba-oracle.com/concepts/constraints_foreign_key_unique_not_null.htm</a></p><p><code>R</code> - Referential integrity</p><p>A referential integrity rule is a rule defined on a key (a column or set of columns) in one table that guarantees that the values in that key match the values in a key in a related table (the referenced value).</p><p>Referential integrity also includes the rules that dictate what types of data manipulation are allowed on referenced values and how these actions affect dependent values.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14220/data_int.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14220/data_int.htm</a></p><p><code>V</code> - With check option, on a view</p><p>The <code>WITH CHECK OPTION</code> clause is used for an <a href=\"https://www.oracletutorial.com/oracle-view/oracle-updatable-view/\">updatable view</a> to prohibits the changes to the view that would produce rows which are not included in the defining query.</p><p><a href=\"https://www.oracletutorial.com/oracle-view/oracle-with-check-option/\">https://www.oracletutorial.com/oracle-view/oracle-with-check-option/</a></p><p><code>O</code> - With read only, on a view</p><p>The <code>WITH READ ONLY</code> clause prevents the underlying tables from changes through the view.</p><p><a href=\"https://www.oracletutorial.com/oracle-view/oracle-create-view/\">https://www.oracletutorial.com/oracle-view/oracle-create-view/</a></p><p><code>H</code> - Hash expression</p><p><code>ORA_HASH</code> is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample.</p><p><a href=\"https://docs.oracle.com/cd/B12037_01/server.101/b10759/functions097.htm\">https://docs.oracle.com/cd/B12037_01/server.101/b10759/functions097.htm</a></p><p><code>F</code> - Constraint that involves a REF column</p><p>A constraint on a user-defined <code>REF</code> column, the system creates the constraint on the attributes that make up the REF column. Therefore, the column names displayed in this view are the attribute names, with the <code>REF</code> column name as a prefix.</p><p><code>\"REF_name\".\"attribute\"</code></p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_1042.htm#REFRN20045\">https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_1042.htm#REFRN20045</a></p><p><code>S</code> - Supplemental logging</p><p>Redo log files are generally used for instance recovery and media recovery. The data needed for such operations is automatically recorded in the redo log files. However, a redo-based application may require that additional columns be logged in the redo log files. The process of logging these additional columns is called supplemental logging.</p><p>By default, Oracle Database does not provide any supplemental logging, which means that by default LogMiner is not usable. Therefore, you must enable at least minimal supplemental logging before generating log files which will be analyzed by LogMiner.</p><p><br></p><p>✗&nbsp; The R_CONSTRAINT_NAME column contains an alternative name for the constraint.</p><p>The r_constraint_name stores the primary key name</p><p><a href=\"https://community.oracle.com/thread/516922\">https://community.oracle.com/thread/516922</a></p><p><br></p><p>✗&nbsp; The STATUS column indicates whether the table is currently in use.</p><p>The STATUS column refers to whether the non-partitioned index is enabled or not.</p><p><a href=\"https://community.oracle.com/thread/463349\">https://community.oracle.com/thread/463349</a></p>",
                "answers": [
                    "<p>The DELETE_RULE column indicates the desired state of related rows in the child table when the corresponding row is deleted from the parent table.</p>",
                    "<p>In the second column, 'C' indicates a check constraint.</p>",
                    "<p>The STATUS column indicates whether the table is currently in use.</p>",
                    "<p>The R_CONSTRAINT_NAME column contains an alternative name for the constraint.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following SQL query and exhibit.Exhibit: 1SELECT constraints_name, constraints_type, search_condition, r_constraint_name, delete_rule, status,\nFROM user_constraints\nWHERE table_name = 'ORDERS';\nGiven: Below is the output of the above SQL query.Exhibit: 2\nIdentify true statements about the output. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919355,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE orders (\n  order_no NUMBER(2) CONSTRAINT ord_pk PRIMARY KEY,\n  ord_date DATE CHECK (ord_date &lt;= SYSDATE),\n  cust_id NUMBER(4)\n);\n\nCREATE TABLE ord_items (\n  ord_no NUMBER(2),\n  item_no NUMBER(3),\n  qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n  CONSTRAINT DATE CHECK (ord_date &lt;= SYSDATE),\n  CONSTRAINT it_pk PRIMARY KEY (ord_no, item_no),\n  CONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (order_no)\n);\n</pre><p>&nbsp; </p><p><strong>Given: </strong>The above command fails when executed. </p><p>Identify the reason for the failed execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle SYSDATE Function](https://www.oracletutorial.com/oracle-date-functions/oracle-sysdate/)",
                    "[Oracle Check Constraint](https://www.oracletutorial.com/oracle-basics/oracle-check-constraint/)"
                ],
                "feedbacks": [
                    "The SYSDATE function is not allowed in a CHECK constraint because the value of SYSDATE changes every time the constraint is evaluated, making it unsuitable for defining a static condition.",
                    "The BETWEEN clause can be used in a CHECK constraint to define a range of values that a column can hold. However, in this specific case, the issue is not related to the use of the BETWEEN clause.",
                    "The CHECK constraint can be applied to columns with the DATE data type to enforce specific conditions on the values stored in those columns. Therefore, the failure of the execution is not due to the data type of the columns.",
                    "The error in the execution is not related to the composite primary key constraint on ORD_NO and ITEM_NO. The issue lies in the usage of the SYSDATE function in the CHECK constraint, not in the primary key definition."
                ],
                "explanation": "<p>Correct option:<strong> SYSDATE cannot be used with the CHECK constraint.</strong></p><p>The <strong>CHECK</strong> constraint in Oracle <strong>cannot</strong> reference functions like <code>SYSDATE</code> because it must be evaluated at the time of insertion or update using fixed column values. Since <code>SYSDATE</code> is dynamic and constantly changing, it cannot be enforced as a constraint in this way.</p><p>If you need to impose a restriction involving <code>SYSDATE</code>, consider using:</p><ul><li><p><strong>Triggers</strong>: You can write a <code>BEFORE INSERT</code> or <code>BEFORE UPDATE</code> trigger to enforce the condition.</p></li><li><p><strong>Default Values</strong>: Use <code>DEFAULT SYSDATE</code> for timestamp columns where needed.</p></li><li><p><strong>Computed Expressions</strong>: Instead of a constraint, check conditions within queries or application logic.</p><p><br></p></li></ul><p>Oracle’s <code><strong>CHECK</strong></code><strong> constraints</strong> must be <strong>deterministic</strong>, meaning they must evaluate to the <strong>same result for the same input</strong>, every time.</p><ul><li><p><code>SYSDATE</code> is <strong>non-deterministic</strong> — it changes constantly.</p></li><li><p>As a result, you <strong>cannot use </strong><code><strong>SYSDATE</strong></code><strong> (or </strong><code><strong>CURRENT_DATE</strong></code><strong>, etc.) in a CHECK constraint</strong>.</p></li></ul><p><strong>Example – Invalid:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE test_dates (\n  hire_date DATE CHECK (hire_date &gt;= SYSDATE)  -- invalid\n);\n</pre><p>This will throw an <strong>ORA-02436: date or system variable wrongly specified in CHECK constraint</strong>.</p><p><strong>Alternative Approaches:</strong></p><ul><li><p>Use a <strong>trigger</strong> to validate SYSDATE-based conditions using a <code>BEFORE INSERT OR UPDATE</code> trigger:</p></li></ul><pre class=\"prettyprint linenums\">CREATE OR REPLACE TRIGGER trg_ord_date_check\nBEFORE INSERT OR UPDATE ON orders\nFOR EACH ROW\nBEGIN\n  IF :NEW.ord_date &gt; SYSDATE THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Order date cannot be in the future.');\n  END IF;\nEND;</pre><p>What This Trigger Does:</p><ul><li><p>Runs <strong>before</strong> any insert or update on the <code>orders</code> table.</p></li><li><p>Checks if the new <code>ord_date</code> is <strong>greater than the current system date</strong>.</p></li><li><p>If so, it raises an error and prevents the operation.</p></li></ul><p><strong>The Oracle SYSDATE </strong>function returns the current date and time of the Operating System (OS) where the Oracle Database installed.</p><p><strong>Syntax</strong></p><p>Since the <code>SYSDATE</code> function does not require any argument, you can call it without specifying the parentheses:</p><pre class=\"prettyprint linenums\">SYSDATE&lt;/code&gt;</pre><p><strong>Return value</strong></p><p>The <code>SYSDATE</code> function returns the current date and time value whose type is <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-date/\"><code>DATE</code></a>.</p><p>The format of the returned date time value depends on the value of the <code>NLS_DATE_FORMAT</code> parameter.</p><p><strong>Remarks</strong></p><p>The Oracle <code>SYSDATE</code> function cannot be used in the condition of a <code>CHECK</code> constraint.</p>",
                "answers": [
                    "<p>SYSDATE cannot be used with the CHECK constraint.</p>",
                    "<p>The BETWEEN clause cannot be used for the CHECK constraint.</p>",
                    "<p>The CHECK constraint cannot be placed on columns having the DATE data type.</p>",
                    "<p>ORD_NO and ITEM_NO cannot be used as a composite primary key because ORD_NO is also the FOREIGN KEY.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1CREATE TABLE orders (\n  order_no NUMBER(2) CONSTRAINT ord_pk PRIMARY KEY,\n  ord_date DATE CHECK (ord_date &lt;= SYSDATE),\n  cust_id NUMBER(4)\n);\n\nCREATE TABLE ord_items (\n  ord_no NUMBER(2),\n  item_no NUMBER(3),\n  qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n  CONSTRAINT DATE CHECK (ord_date &lt;= SYSDATE),\n  CONSTRAINT it_pk PRIMARY KEY (ord_no, item_no),\n  CONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (order_no)\n);\n&nbsp; Given: The above command fails when executed. Identify the reason for the failed execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919357,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about transactions. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Structure of a Transaction](https://docs.oracle.com/database/121/CNCPT/transact.htm#CNCPT038)"
                ],
                "feedbacks": [
                    "<p>This statement is correct. The database automatically issues an implicit COMMIT statement before and after every DDL statement. This ensures that the changes made by the DDL statement are permanent and cannot be rolled back.</p>",
                    "This statement is correct. Each DDL statement executed forms a single transaction. DDL statements are used to define or modify the structure of database objects such as tables, indexes, and views.",
                    "This statement is incorrect. A transaction involving DDL statements typically ends with a COMMIT statement to make the changes permanent. DDL statements are used to define the structure of database objects, not to manipulate data.",
                    "This statement is incorrect. A transaction typically consists of either DDL or DML statements, not a combination of both. DDL statements are used to define the structure of database objects, while DML statements are used to manipulate data.",
                    "<p>This statement is incorrect. A transaction consists of one or more DML statements, not DDL statements. DML statements are used to manipulate data in the database, while DDL statements are used to define the structure of the database objects.</p>"
                ],
                "explanation": "<p>True statements:</p><ol><li><p><strong>Each Data Definition Language (DDL) statement executed forms a single transaction.</strong></p><ul><li><p>DDL statements (such as <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>) are <strong>auto-committed</strong>, meaning each execution is treated as an independent transaction.</p></li></ul></li><li><p><strong>The database issues an implicit COMMIT statement before and after every DDL statement.</strong></p><ul><li><p>Oracle automatically commits changes before and after executing a DDL statement, ensuring that structural modifications are immediately permanent.</p></li></ul></li></ol><p>Untrue or inaccurate statements:</p><ul><li><p><strong>A set of Data Manipulation Language (DML) statements executed in a sequence ending with a SAVEPOINT forms a single transaction.</strong></p><ul><li><p>Incorrect. A transaction continues beyond a <code>SAVEPOINT</code> until explicitly committed or rolled back.</p></li></ul></li><li><p><strong>A set of DDL statements executed in a sequence ending with a COMMIT forms a single transaction.</strong></p><ul><li><p>Incorrect. Each DDL statement is auto-committed individually, so they do not form a single transaction.</p></li></ul></li><li><p><strong>A combination of DDL and DML statements executed in a sequence ending with a COMMIT forms a single transaction.</strong></p><ul><li><p>Incorrect. DDL statements are auto-committed, meaning they cannot be grouped into a transaction with DML statements.</p></li></ul></li></ul><p><br></p><p><strong>End of a Transaction</strong></p><p>A transaction can end under different circumstances.</p><p>• A transaction ends when any of the following actions occurs:</p><p>• A user issues a <code>COMMIT</code> or <code>ROLLBACK</code> statement without a <code>SAVEPOINT</code> clause.</p><p>• In a <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-0680EB2C-ADF4-431A-A259-FB2227E5AA93\">commit</a>, a user explicitly or implicitly requested that the changes in the transaction be made permanent. Changes made by the transaction are permanent and visible to other users only after a transaction commits. The transaction shown in \"<a href=\"https://docs.oracle.com/database/121/CNCPT/transact.htm#GUID-A049FE81-8B67-4386-B599-9CDD7E6B6C59\" title=\"To illustrate the concept of a transaction, consider a banking database.\">Sample Transaction: Account Debit and Credit</a>\" ends with a commit.</p><p>• A user runs a DDL command such as <code>CREATE</code>, <code>DROP</code>, <code>RENAME</code>, or <code>ALTER</code>.</p><p>• The database issues an implicit <code>COMMIT</code> statement before and after every DDL statement. If the current transaction contains DML statements, then Oracle Database first commits the transaction and then runs and commits the DDL statement as a new, single-statement transaction.</p><p>• A user exits normally from most Oracle Database utilities and tools, causing the current transaction to be implicitly committed. The commit behavior when a user disconnects is application-dependent and configurable.</p>",
                "answers": [
                    "<p> The database issues an implicit COMMIT statement before and after every DDL statement. </p>",
                    "<p>Each Data Definition Language (DDL) statement executed forms a single transaction.</p>",
                    "<p>A set of DDL statements executed in a sequence ending with a COMMIT forms a single transaction.</p>",
                    "<p>A combination of DDL and DML statements executed in a sequence ending with a COMMIT forms a single transaction.</p>",
                    "<p>A set of Data Manipulation Language (DML) statements executed in a sequence ending with a SAVEPOINT forms a single transaction.</p>"
                ]
            },
            "correct_response": [
                "b",
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about transactions. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919359,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the details of PRODUCT_INFORMATION table as well as the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-03-25_00-00-42-5a16a32efe8aa33c4164d03b70de123d.png\"></p><p><br></p><p><strong>Required: </strong>Display PRODUCT_NAME from the table where the CATEGORY_ID column has values 12 or 13, and the SUPPLIER_ID column has the value 102088.&nbsp; &nbsp;</p><p>The following SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_name\nFROM product_information\nWHERE (category_id = 12 AND category_id = 13)&nbsp;AND supplier_id = 102088;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>If there are no rows in the PRODUCT_INFORMATION table that meet the specified conditions (CATEGORY_ID values of 12 or 13 and SUPPLIER_ID value of 102088), the query would execute without errors but return no rows in the output. This outcome is possible if there are no matching records in the table based on the given criteria.</p>",
                    "The WHERE clause condition does not necessarily need to be enclosed within parentheses in SQL queries. While it can be a good practice for readability, it is not a requirement for the query to execute.",
                    "The SQL statement provided meets the requirements specified in the question by filtering the rows based on the values in the CATEGORY_ID and SUPPLIER_ID columns. Therefore, the query would execute successfully and display the desired result if matching rows exist in the table.",
                    "<p>Using the same column in both sides of the AND logical operator is a valid condition in SQL queries. It is not a syntax error and does not prevent the query from executing.</p>"
                ],
                "explanation": "<p>The condition <code>category_id = 12 AND category_id = 13</code> is <strong>logically impossible</strong>, so it should be <strong>OR</strong> instead of <strong>AND</strong> to correctly filter the data.</p><p>The query would execute successfully but no rows are returned.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-24_20-25-59-32be3967c8e884b7b5bb0f2fb8bb92e3.png\"></p><p><br></p><p>Here’s the corrected query:</p><pre class=\"prettyprint linenums\">SELECT product_name  \nFROM product_information  \nWHERE (category_id = 12 OR category_id = 13)  \nAND supplier_id = 102088;\n</pre><p><br></p><p>This ensures that the query retrieves rows where <code>category_id</code> is <strong>either</strong> 12 <strong>or</strong> 13, while still filtering for <code>supplier_id = 102088</code>.</p>",
                "answers": [
                    "<p>It would execute but the output would return no rows.</p>",
                    "<p>It would not execute because the entire WHERE clause condition is not enclosed within the parentheses.</p>",
                    "<p>It would execute and the output would display the desired result.</p>",
                    "<p>It would not execute because the same column has been used in both sides of the AND logical operator to form the condition.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the details of PRODUCT_INFORMATION table as well as the exhibit.Required: Display PRODUCT_NAME from the table where the CATEGORY_ID column has values 12 or 13, and the SUPPLIER_ID column has the value 102088.&nbsp; &nbsp;The following SQL statement has been executed.Exhibit: 1SELECT product_name\nFROM product_information\nWHERE (category_id = 12 AND category_id = 13)&nbsp;AND supplier_id = 102088;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919417,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibits.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE emp(\n  emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\n  ename VARCHAR2(15),\n  salary NUMBER (8,2),\n  mgr_no NUMBER(2)\n);\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp ADD CONSTRAINT emp_mgr_fk\nFOREIGN KEY (mgr_no)\nREFERENCES emp(emp_no)\nON DELETE SET NULL;\n</pre><p><br></p><p><strong>Exhibit 3:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk\nCASCADE;\n</pre><p><br></p><p><strong>Exhibit 4:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\n</pre><p><br></p><p><strong>Given: </strong> All SQL statements which execute successfully. </p><p>Identify the true statements regarding the result. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SET CONSTRAINT[S]](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/SET-CONSTRAINTS.html)",
                    "[Oracle / PLSQL: Enable a foreign key](https://www.techonthenet.com/oracle/foreign_keys/enable.php)",
                    "[Immediate and deferred constraints](https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:671629032835)"
                ],
                "feedbacks": [
                    "The foreign key constraint will be disabled as indicated by the \"DISABLE NOVALIDATE\" clause in Exhibit 3. This means that the constraint will not be enforced for existing data but will be enabled for future data.",
                    "<p>The primary key constraint will be enabled and IMMEDIATE, as shown in Exhibit 4 with the \"ENABLE NOVALIDATE\" clause. This means that the primary key constraint will be enforced immediately for both existing and future data.</p>",
                    "The foreign key constraint will be enabled and DEFERRED is not a true statement. The foreign key constraint in Exhibit 3 is explicitly disabled with the \"DISABLE NOVALIDATE\" clause, so it cannot be enabled and deferred.",
                    "The foreign key constraint will be enabled and IMMEDIATE is not accurate. The foreign key constraint in Exhibit 3 is disabled with the \"DISABLE NOVALIDATE\" clause, so it cannot be enabled and immediate.",
                    "<p>The primary key constraint will be enabled and IMMEDIATE as shown in Exhibit 4 with the \"ENABLE NOVALIDATE\" clause. This means that the primary key constraint will be enforced immediately for both existing and future data.</p>"
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p><strong>The foreign key constraint will be disabled.</strong><br>True — it was disabled via <code>CASCADE</code> and not re-enabled.</p></li><li><p><strong>The primary key constraint will be enabled and IMMEDIATE.</strong><br>True — default behaviour on re-enabling a constraint is <strong>IMMEDIATE</strong>.</p></li></ol><p>Let's break down the SQL exhibits and analyze what happens to the constraints step-by-step:</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE emp(\n  emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\n  ename VARCHAR2(15),\n  salary NUMBER (8,2),\n  mgr_no NUMBER(2)\n);\n</pre><ul><li><p>This creates a table <code>emp</code> with a <strong>primary key</strong> constraint on <code>emp_no</code>.</p></li></ul><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp ADD CONSTRAINT emp_mgr_fk\nFOREIGN KEY (mgr_no)\nREFERENCES emp(emp_no)\nON DELETE SET NULL;\n</pre><ul><li><p>Adds a <strong>foreign key</strong> <code>emp_mgr_fk</code> on <code>mgr_no</code>, referencing <code>emp_no</code> in the same table (self-reference).</p></li><li><p><code>ON DELETE SET NULL</code> means if a manager is deleted, employees managed by them will have <code>mgr_no</code> set to NULL.</p></li></ul><p><strong>Exhibit 3:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk\nCASCADE;\n</pre><ul><li><p>Disables the <strong>primary key</strong> constraint and <strong>cascades</strong> the disable to all dependent constraints — including <code>emp_mgr_fk</code>.</p></li></ul><p><strong>Exhibit 4:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\n</pre><ul><li><p>Re-enables the <strong>primary key</strong> constraint.</p></li></ul><p><strong>However</strong>, <strong>re-enabling the primary key constraint does NOT automatically re-enable the foreign key constraint</strong>. The foreign key remains <strong>disabled</strong> unless explicitly re-enabled.</p><p>Constraint Deferral Behaviour:</p><ul><li><p>By default, when you enable a constraint using <code>ENABLE CONSTRAINT</code>, it is enabled in <strong>IMMEDIATE</strong> mode (not deferred).</p></li><li><p>There's no mention of deferrable options or <code>SET CONSTRAINTS</code> clauses in the SQL shown.</p></li></ul><p><strong>Incorrect Options:</strong></p><ul><li><p><strong>The primary key constraint will be enabled and DEFERRED.</strong><br>False — would require <code>DEFERRABLE INITIALLY DEFERRED</code>, which isn’t present.</p></li><li><p><strong>The foreign key constraint will be enabled and IMMEDIATE/DEFERRED.</strong><br>False — it's still <strong>disabled</strong> after the steps shown.</p></li></ul><p><br></p><p><strong>SET CONSTRAINTS</strong></p><p>Only <code>DEFERRABLE</code> constraints can be <code>DEFERRED</code>. By default constraints are created enabled, not deferrable, immedate, and validated no matter when they're created. <code>DEFERRABLE</code> must be set when the constraint is created</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE t_emp(  \n    empno NUMBER(2) CONSTRAINT t_emp_pk PRIMARY KEY DEFERRABLE,  \n    mgrno NUMBER(2) CONSTRAINT t_emp_fk REFERENCES t_emp DEFERRABLE);</pre><p><br></p><p><strong>IMMEDIATE</strong></p><p>Specify <code>IMMEDIATE</code> to cause the specified constraints to be checked immediately on execution of each constrained DML statement. Oracle Database first checks any constraints that were deferred earlier in the transaction and then continues immediately checking constraints of any further statements in that transaction, as long as all the checked constraints are consistent and no other <code>SET</code> <code>CONSTRAINTS</code> statement is issued. If any constraint fails the check, then an error is signaled. At that point, a <code>COMMIT</code> statement causes the whole transaction to undo.</p><p>Making constraints immediate at the end of a transaction is a way of checking whether <code>COMMIT</code> can succeed. You can avoid unexpected rollbacks by setting constraints to <code>IMMEDIATE</code> as the last statement in a transaction. If any constraint fails the check, you can then correct the error before committing the transaction.</p><p><strong>DEFERRED</strong></p><p>Specify <code>DEFERRED</code> to indicate that the conditions specified by the deferrable constraint are checked when the transaction is committed.</p><p><br></p><p><br></p><p><strong>Enable Foreign Key / Primary Key</strong></p><p>You can enable the foreign key using the <code>ALTER TABLE</code> statement.</p><p><strong>Syntax</strong></p><p>The syntax for enabling a foreign key in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\nENABLE CONSTRAINT constraint_name;</pre><p><br></p><p>None of the constraints in question are set to <code>DEFERRABLE</code>, so when the the primary key constraint its (unique) index (<code>EMP_EMP_NO_PK</code>) <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/18/admin/managing-schema-objects.html#GUID-90ACCD15-C65D-4595-9887-CC7588824E71\">is dropped</a> when it is set to DISABLE .</p><p>The foreign key constraint that references it is also disabled (<code>CASCADE</code>). </p><p>When it is set to <code>ENABLE</code> again the index is re-created; the foreign key constraint remains disabled.</p><p>A constraint that's <code>DEFERRABLE</code> though uses a non-unique index instead of a unique index (because it has to record changes that may violate the unique constraint while constraint checking is being deferred). In this case the index isn't dropped when the constraint is disabled because it can continue to be updated with what could be constraint-violating changes.</p><p><code>ALTER TABLE</code> is DDL, so pending transactions are committed before it starts and after it succeeds [<a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/COMMIT.htm\">ref</a>].</p><p><br></p><p><strong>What's the difference?</strong></p><p>The main <strong>difference between an immediate and deferred constraint</strong> is quite simple: an immediate constraint is validated after each statement, a deferred constraint is validated upon commit (or upon setting all constraints to immediate).</p><p>The <code>DEFERRABLE</code> and <code>NOT DEFERRABLE</code> parameters indicate whether or not, in subsequent transactions, constraint checking can be deferred until the end of the transaction using the <code>SET CONSTRAINT(S)</code> statement. If you omit this clause, then the default is <code>NOT DEFERRABLE</code>.</p><p>Specify <code>NOT DEFERRABLE</code> to indicate that in subsequent transactions you cannot use the <code>SET CONSTRAINT(S)</code> clause to defer checking of this constraint until the transaction is committed. The checking of a <code>NOT DEFERRABLE</code> constraint can never be deferred to the end of the transaction. </p><p>Specify <code>DEFERRABLE</code> to indicate that in subsequent transactions you can use the <code>SET CONSTRAINT(S)</code> clause to defer checking of this constraint until after the transaction is committed. This setting in effect lets you disable the constraint temporarily while making changes to the database that might violate the constraint until all the changes are complete. </p><p>You cannot alter a constraint's deferrability. That is, whether you specify either of these parameters, or make the constraint <code>NOT DEFERRABLE</code> implicitly by specifying neither of them, you cannot specify this clause in an <code>ALTER TABLE</code> statement. You must drop the constraint and re-create it.</p>",
                "answers": [
                    "<p>The foreign key constraint will be disabled.</p>",
                    "<p>The primary key constraint will be enabled and IMMEDIATE.</p>",
                    "<p>The foreign key constraint will be enabled and DEFERRED.</p>",
                    "<p>The foreign key constraint will be enabled and IMMEDIATE.</p>",
                    "<p>The primary key constraint will be enabled and DEFERRED.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following SQL exhibits.Exhibit 1:CREATE TABLE emp(\n  emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\n  ename VARCHAR2(15),\n  salary NUMBER (8,2),\n  mgr_no NUMBER(2)\n);\nExhibit 2:ALTER TABLE emp ADD CONSTRAINT emp_mgr_fk\nFOREIGN KEY (mgr_no)\nREFERENCES emp(emp_no)\nON DELETE SET NULL;\nExhibit 3:ALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk\nCASCADE;\nExhibit 4:ALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\nGiven:  All SQL statements which execute successfully. Identify the true statements regarding the result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919419,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The following command has been executed successfully.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE&nbsp;products;\n</pre><p><br></p><p>Identify the true statements regarding the result. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DROP TABLE Statement](https://www.techonthenet.com/oracle/tables/drop_table.php)",
                    "[DROP TABLE](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/DROP-TABLE.html)"
                ],
                "feedbacks": [
                    "When a table is dropped, all existing views and synonyms that refer to the table are invalidated but retained. This means that any queries or references to the dropped table will result in an error until the views and synonyms are updated or recreated.",
                    "Dropping a table does not automatically commit any uncommitted transactions in the session. Transactions must be explicitly committed or rolled back by the user. Therefore, the statement that any uncommitted transaction in the session is committed is incorrect.",
                    "<p>Use the <code>DROP TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely. Unless you specify the <code>PURGE</code> clause, the <code>DROP TABLE</code> statement does not result in space being released back to the tablespace for use by other objects, and the space continues to count toward the user's space quota.</p>",
                    "When a table is dropped, all the table's indexes, if any exist, are also dropped along with the table. Indexes are dependent on the table they are created on, so dropping the table will invalidate and remove any associated indexes.",
                    "Dropping a table deletes the table data, but the table structure itself is deleted as well. The statement that the table structure is retained is incorrect, as dropping a table removes both the data and the structure from the database."
                ],
                "explanation": "<p> Correct options:</p><ul><li><p><strong>All existing views and synonyms that refer to the table are invalidated but retained.</strong></p></li><li><p><strong>Any uncommitted transaction in the session is committed.</strong></p></li><li><p><strong>The statement will move the table and all its data from the database entirely.</strong></p></li></ul><p><br></p><p>Let's analyze what happens when the following SQL command is executed:</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">DROP TABLE products;\n</pre><p>This command <strong>removes the table </strong><code><strong>products</strong></code> from the database completely, including its data, structure, indexes, and constraints.</p><p>Now, evaluate the options one by one:</p><p><strong>1. All existing views and synonyms that refer to the table are invalidated but retained.</strong></p><ul><li><p>When you drop a table:</p><ul><li><p>Any <strong>views</strong> or <strong>synonyms</strong> that depend on it become <strong>invalid</strong>, but they are <strong>not dropped</strong> — they remain in the database.</p></li><li><p>The next time you try to use the view, it fails unless the underlying table is recreated or the view is corrected.</p></li></ul></li></ul><p><strong>2. Any uncommitted transaction in the session is committed.</strong></p><ul><li><p>A <code>DROP TABLE</code> is a <strong>DDL</strong> (Data Definition Language) statement.</p></li><li><p>DDL statements in Oracle <strong>implicitly commit</strong> the current transaction — both <strong>before and after</strong> the DDL operation.</p></li></ul><p><strong>3. The statement will move the table and all its data from the database entirely.</strong></p><ul><li><p>The <code>DROP TABLE</code> command <strong>completely removes</strong> the table from the database — structure, data, indexes, constraints, triggers, etc.</p></li><li><p>There is <strong>no residual structure or data</strong> after this unless <code>PURGE</code> is omitted and the table goes to the recycle bin (if enabled).</p></li></ul><p>Incorrect options:</p><p><strong>All the table's indexes, if any exist, are invalidated but retained.</strong></p><ul><li><p>All indexes <strong>on the table</strong> are <strong>dropped</strong> along with the table. They are <strong>not retained or invalidated</strong> — they are permanently removed.</p></li></ul><p><strong>Table data is deleted but the table structure is retained.</strong></p><ul><li><p>That's what the <code>TRUNCATE TABLE</code> command does.</p></li><li><p><code>DROP TABLE</code> deletes <strong>both the data and the structure</strong>.</p></li></ul><p><br></p><p>The Oracle <strong>DROP TABLE statement</strong> allows you to remove or delete a table from the Oracle database.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>DROP TABLE</code> statement is:</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE [schema_name].table_name\n[ CASCADE CONSTRAINTS ]\n[ PURGE ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>schema_name - The name of the schema that owns the table. </p><p>table_name - The name of the table to remove from the Oracle database. </p><p>CASCADE CONSTRAINTS Optional. - If specified, all referential integrity constraints will be dropped as well. </p><p>PURGE Optional. - If specified, the table and its dependent objects will be purged from the recycle bin and you will not be able to recover the table. If not specified, the table and its dependent objects are placed in the recycle bin and can be recovered later, if needed.</p><p><strong>Note</strong></p><p>If there are referential integrity constraints on <em>table_name</em> and you do not specify the <em>CASCADE CONSTRAINTS</em> option, the DROP TABLE statement will return an error and Oracle will not drop the table.</p><p><br></p><p>Use the <code>DROP TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely.</p><p>Unless you specify the <code>PURGE</code> clause, the <code>DROP</code> <code>TABLE</code> statement does not result in space being released back to the tablespace for use by other objects, and the space continues to count toward the user's space quota.</p><p>For an external table, this statement removes only the table metadata in the database. It has no affect on the actual data, which resides outside of the database.</p><p>When you drop a table that is part of a cluster, the table is moved to the recycle bin. However, if you subsequently drop the cluster, then the table is purged from the recycle bin and can no longer be recovered with a <code>FLASHBACK</code> <code>TABLE</code> operation.</p><p>Dropping a table invalidates dependent objects and removes object privileges on the table. If you want to re-create the table, then you must regrant object privileges on the table, re-create the indexes, integrity constraints, and triggers for the table, and respecify its storage parameters. Truncating has none of these effects. Therefore, removing rows with the <code>TRUNCATE</code> statement can be more efficient than dropping and re-creating a table.</p><p><br></p><p><strong>Implicit Commit</strong></p><p>The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/commit.html\" title=\"13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax\"><code>COMMIT</code></a> before executing the statement.</p><p><strong>Data definition language (DDL) statements that define or modify database objects.</strong> <code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Syntax\"><code>ALTER EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-procedure.html\" title=\"13.1.5&nbsp;ALTER PROCEDURE Syntax\"><code>ALTER PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-server.html\" title=\"13.1.6&nbsp;ALTER SERVER Syntax\"><code>ALTER SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-table.html\" title=\"13.1.7&nbsp;ALTER TABLE Syntax\"><code>ALTER TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-database.html\" title=\"13.1.10&nbsp;CREATE DATABASE Syntax\"><code>CREATE DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-event.html\" title=\"13.1.11&nbsp;CREATE EVENT Syntax\"><code>CREATE EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-index.html\" title=\"13.1.13&nbsp;CREATE INDEX Syntax\"><code>CREATE INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-procedure.html\" title=\"13.1.15&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax\"><code>CREATE PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-server.html\" title=\"13.1.16&nbsp;CREATE SERVER Syntax\"><code>CREATE SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-table.html\" title=\"13.1.17&nbsp;CREATE TABLE Syntax\"><code>CREATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-database.html\" title=\"13.1.21&nbsp;DROP DATABASE Syntax\"><code>DROP DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-event.html\" title=\"13.1.22&nbsp;DROP EVENT Syntax\"><code>DROP EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-index.html\" title=\"13.1.24&nbsp;DROP INDEX Syntax\"><code>DROP INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-procedure.html\" title=\"13.1.26&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax\"><code>DROP PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-server.html\" title=\"13.1.27&nbsp;DROP SERVER Syntax\"><code>DROP SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-table.html\" title=\"13.1.28&nbsp;DROP TABLE Syntax\"><code>DROP TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/rename-table.html\" title=\"13.1.33&nbsp;RENAME TABLE Syntax\"><code>RENAME TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/truncate-table.html\" title=\"13.1.34&nbsp;TRUNCATE TABLE Syntax\"><code>TRUNCATE TABLE</code></a>.</p>",
                "answers": [
                    "<p>All existing views and synonyms that refer to the table are invalidated but retained.</p>",
                    "<p>Any uncommitted transaction in the session is committed.</p>",
                    "<p>The statement will move the table and all its data from the database entirely.</p>",
                    "<p>All the table's indexes if any exist, are invalidated but retained.</p>",
                    "<p>Table data is deleted but the table structure is retained.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "DROP TABLE",
            "question_plain": "View and examine the following available responses.Given: The following command has been executed successfully.Exhibit: 1 DROP&nbsp;TABLE&nbsp;products;\nIdentify the true statements regarding the result. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919421,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The EMPLOYEES table has 1000 rows and employees are working in the company for more than 10 years. </p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1&nbsp; &nbsp;</strong></p><pre class=\"prettyprint linenums\">UPDATE employees\nSET commission_pct = NVL(commission_pct,0.01)\nWHERE&nbsp;TRUNC(hire_date) &lt; TRUNC(SYSDATE - (365*2));\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: UPDATE Statement](https://www.techonthenet.com/oracle/update.php)",
                    "[Oracle / PLSQL: NVL Function](https://www.techonthenet.com/oracle/functions/nvl.php)",
                    "[Oracle / PLSQL: TRUNC Function (with dates)](https://www.techonthenet.com/oracle/functions/trunc_date.php)"
                ],
                "feedbacks": [
                    "<p>The SQL statement successfully executes and updates the records of employees who have been working in the company for more than 2 years. This is because the WHERE clause filters the records based on the condition provided, which specifies employees working for more than 10 years. Therefore, the query correctly updates the records of employees who meet this criteria.</p>",
                    "<p>This choice is incorrect because the SQL statement updates the records of employees who have been working in the company for more than 2 years, not less than 2 years. The condition in the WHERE clause specifies employees working for more than 10 years, so the query updates records for employees meeting this criterion, not those working for less than 2 years.</p>",
                    "<p>The SQL statement does not use the NVL function with the UPDATE command, so it does not violate any syntax rules related to the NVL function. Therefore, there is no error in using the NVL function in this context, and the statement can execute successfully without any issues.</p>",
                    "<p>The SQL statement provided in the exhibit does not contain any syntax errors that would cause it to fail during execution. The UPDATE command and the WHERE clause are used correctly, and there are no apparent syntax issues that would result in a syntax error. Therefore, the statement can be executed successfully without encountering any syntax errors.</p>",
                    "<p>This SQL statement uses the UPDATE command to modify records in the EMPLOYEES table based on a condition. Since the condition specifies that employees working for more than 10 years should be updated, and the statement executes successfully, it indicates that the query runs without errors but does not update any rows because the condition is not met.</p>"
                ],
                "explanation": "<p>Correct option: <strong>It executes successfully and updates the records of those employees who have been working in the company for more than 2 years.</strong></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-25_12-04-52-331c65bdb3a9a814e897fea2a68d322d.png\"></p><p><br></p><p>Let's analyze the given SQL statement carefully:</p><pre class=\"prettyprint linenums\">UPDATE employees\nSET commission_pct = NVL(commission_pct, 0.01)\nWHERE TRUNC(hire_date) &lt; TRUNC(SYSDATE - (365*2));\n</pre><p><strong>Key points:</strong></p><ol><li><p><strong>NVL Function</strong>:</p><ul><li><p><code>NVL(commission_pct, 0.01)</code> is valid.</p></li><li><p>This means if <code>commission_pct</code> is NULL, it will be set to <code>0.01</code>; otherwise, it remains unchanged.</p></li><li><p>No syntax error with using <code>NVL</code> in <code>UPDATE</code>.</p></li></ul></li><li><p><strong>WHERE Clause</strong>:</p><ul><li><p><code>TRUNC(hire_date) &lt; TRUNC(SYSDATE - (365*2))</code> means we are updating only those employees hired more than <strong>2 years</strong> ago.</p></li></ul></li><li><p><strong>Given Information</strong>:</p><ul><li><p>All 1000 employees have been in the company for <strong>more than 10 years</strong>.</p></li><li><p>Therefore, all satisfy the <code>WHERE</code> condition.</p></li></ul></li></ol><p><strong>Final Evaluation:</strong></p><ul><li><p>The statement <strong>executes successfully</strong>.</p></li><li><p>It <strong>updates</strong> all employees who have been in the company for more than 2 years (which is everyone in this case).</p></li><li><p>It sets <code>commission_pct = 0.01</code> <strong>only for those whose </strong><code><strong>commission_pct</strong></code><strong> is currently NULL</strong>.</p></li></ul><p><br></p><p><strong>The Oracle UPDATE statement</strong> is used to update existing records in a table in an Oracle database. There are 2 syntaxes for an update query in Oracle depending on whether you are performing a traditional update or updating one table with data from another table.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>UPDATE</code> statement when updating one table in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE table\nSET column1 = expression1,\n    column2 = expression2,\n    ...\n    column_n = expression_n\n[WHERE conditions];</pre><p><br></p><p>OR</p><p>The syntax for the Oracle <code>UPDATE</code> statement when updating one table with data from another table is:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE table1\nSET column1 = (SELECT expression1\n               FROM table2\n               WHERE conditions)\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>column1, column2, ... column_n - The columns that you wish to update. </p><p>expression1, expression2, ... expression_n - The new values to assign to the <em>column1</em>, <em>column2</em>, ... column_n. So <em>column1</em> would be assigned the value of <em>expression1</em>, <em>column2</em> would be assigned the value of <em>expression2</em>, and so on. </p><p>WHERE conditions Optional. - The conditions that must be met for the update to execute. If no conditions are provided, then all records in the table will be updated.</p><p><br></p><p><br></p><p><strong>The Oracle/PLSQL NVL function</strong> lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the NVL function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. </p><p>replace_with - The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The NVL function returns a substitute value.</p><p><br></p><p><br></p><p><strong>The Oracle/PLSQL TRUNC function</strong> returns a date truncated to a specific unit of measure.</p><p><strong>Syntax </strong>(with dates)</p><p>The syntax for the <code>TRUNC</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">TRUNC ( date [, format ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>date - The date to truncate. </p><p>format Optional. - The unit of measure to apply for truncating. If the <em>format</em> parameter is omitted, the TRUNC function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off.</p><p>The <code>TRUNC</code> function (as it applies to dates) returns a date value.</p>",
                "answers": [
                    "<p>It executes successfully and updates the records of those employees who have been working in the company for more than 2 years.</p>",
                    "<p>It executes successfully and updates the records of those employees who have been working in the company for less than 2 years.</p>",
                    "<p>It gives an error because NVL function cannot be used with UPDATE.</p>",
                    "<p>It gives a syntax error.</p>",
                    "<p>It executes successfully but no rows updated.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "UPDATE",
            "question_plain": "View and examine the following available responses.Given: The EMPLOYEES table has 1000 rows and employees are working in the company for more than 10 years. Evaluate the following SQL statement.Exhibit: 1&nbsp; &nbsp;UPDATE employees\nSET commission_pct = NVL(commission_pct,0.01)\nWHERE&nbsp;TRUNC(hire_date) &lt; TRUNC(SYSDATE - (365*2));\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919423,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS tables.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE department_details(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\nhod VARCHAR2(50)\n);\n</pre><p><br></p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE course_details(\ncourse_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ncourse_name CARCHAR2(50),\ndepartment_id NUMBER REFERENCES department_details (department_id)\n);\n</pre><p><br></p><p><strong>Required: </strong>Generate a list of all department IDs that do not exist in the COURSE_DETAILS table. </p><p><strong>Given: </strong>The following SQL statement has been executed.</p><pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id\nFROM department_details d\nINNER&nbsp;JOIN course_details c\nON (d.department_id = c.department_id);\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>The query may execute successfully, but display an incorrect list of department IDs that do not exist in the COURSE_DETAILS table. This could happen if there is a mistake in the ON clause condition or if the query logic is flawed, resulting in inaccurate results being displayed.</p>",
                    "The query may execute successfully and display the required list of department IDs that do not exist in the COURSE_DETAILS table. This outcome is possible if the query is correctly structured and the ON clause condition is valid.",
                    "<p>The query may fail because the ON clause condition is not valid. If the condition used in the ON clause does not correctly match the relationship between the DEPARTMENT_DETAILS and COURSE_DETAILS tables, the query may not be able to execute successfully and could result in a failure.</p>",
                    "<p>The join type used in the query may not be incorrect, as the query could still execute successfully even if the join type is not the most optimal for the given scenario. The failure of the query is not necessarily due to the join type used.</p>"
                ],
                "explanation": "<p>The query will <strong>execute successfully but display an incorrect list</strong> because the <strong>INNER JOIN</strong> only returns department IDs that exist in both <code>department_details</code> and <code>course_details</code>. It does not show departments that have no corresponding courses.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-25_12-49-12-fd41a96e61c04d78c1c2d4ff907f0495.png\"></p><p><br></p><p>The query executes successfully but it produces an intersect of the courses in common to both lists, not a list of all department IDs that do not exist in the COURSE_DETAILS table.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-25_13-01-32-2008d178724607bfaff916d5c40cfc92.png\"></p><p><br></p><p>The \"no data found\" indicates that it did execute successfully however nothing was returned, ∴ an incorrect list.</p><p><br></p><p>Correct Approach:</p><p>To find <strong>department IDs that do not exist in the </strong><code><strong>course_details</strong></code><strong> table</strong>, you should use a <strong>LEFT JOIN</strong> and filter out matching records:</p><pre class=\"prettyprint linenums\">SELECT d.department_id\nFROM department_details d\nLEFT JOIN course_details c ON d.department_id = c.department_id\nWHERE c.department_id IS NULL;\n</pre><p><br></p><p>Explanation:</p><ul><li><p><strong>LEFT JOIN</strong> ensures all department IDs from <code>department_details</code> appear, even if they have no match in <code>course_details</code>.</p></li><li><p>Filtering with <code>WHERE c.department_id IS NULL</code> isolates department records <strong>without</strong> a linked course.</p></li></ul><p><br></p><p>Another valid query to fulfil the required is below:</p><pre class=\"prettyprint linenums\">SELECT d.department_id \nFROM department_details d \nLEFT OUTER JOIN course_details c \nON d.department_id = c.department_id\nWHERE c.course_id IS NULL;\n</pre><p><br></p><p>Explanation:\n</p><ul><li><p>LEFT OUTER JOIN ensures that all departments are included, even if they have no courses. </p></li><li><p>WHERE c.course_id IS NULL filters out departments that do have courses, leaving only those that do not exist in course_details. </p></li></ul>",
                "answers": [
                    "<p>It executes successfully but displays an incorrect list.</p>",
                    "<p>It executes successfully and displays the required list.</p>",
                    "<p>It fails because the ON clause condition is not valid.</p>",
                    "<p>It fails because the join type used is incorrect.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS tables.Exhibit: 1CREATE TABLE department_details(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\nhod VARCHAR2(50)\n);\nExhibit: 2CREATE TABLE course_details(\ncourse_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ncourse_name CARCHAR2(50),\ndepartment_id NUMBER REFERENCES department_details (department_id)\n);\nRequired: Generate a list of all department IDs that do not exist in the COURSE_DETAILS table. Given: The following SQL statement has been executed.SELECT d.department_id, c.course_id\nFROM department_details d\nINNER&nbsp;JOIN course_details c\nON (d.department_id = c.department_id);\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919425,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statements regarding sequences in a single instance Oracle database. (Choose three.) </p>",
                "relatedLectureIds": [],
                "links": [
                    "[CREATE SEQUENCE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CREATE-SEQUENCE.html)",
                    "[Managing Views, Sequences, and Synonyms](https://docs.oracle.com/search/?q=Managing%2520Sequences&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)",
                    "[Duplicate Values in a Sequence](https://nareshnaruka.blogspot.com/2011/10/duplicate-values-in-sequence.html)"
                ],
                "feedbacks": [
                    "A sequence can issue duplicate values if it is not set up properly or if there are issues with the incrementing logic. This can lead to data integrity problems in the database.",
                    "If a sequence's cached values are not yet allocated and the instance shuts down, those unallocated values will be lost. This can result in unexpected behavior when the database is restarted.",
                    "Sequences can have gaps in the generated values due to various reasons such as rollbacks, transaction failures, or caching settings. These gaps are a normal occurrence in sequences and do not affect their functionality.",
                    "Two or more tables can have keys generated from the same sequence. Sequences are independent objects in the database and can be used to generate unique values for multiple tables without any issues.",
                    "A sequence can be dropped by a user with the necessary privileges, not just a DBA. However, dropping a sequence should be done carefully as it can impact any tables or applications relying on that sequence for generating unique values."
                ],
                "explanation": "<p>Correct statements:</p><ol><li><p><strong>A sequence's unallocated cached values are lost if the instance shuts down</strong> – Cached sequence values are stored in memory, and if the database shuts down, any unused cached values are lost.</p></li><li><p><strong>Sequences can have gaps</strong> – Gaps can occur due to rollbacks, instance failures, or sequences being incremented by multiple sessions.</p></li><li><p><strong>A sequence can issue duplicate values</strong> – This can happen if the sequence is <strong>cycled</strong> or manually reset.</p></li></ol><p>Incorrect Statements:</p><ul><li><p><strong>\"Two or more tables cannot have keys generated from the same sequence\"</strong> → This is incorrect because sequences are independent of tables, and multiple tables can use the same sequence for key generation.</p></li><li><p><strong>\"A sequence can only be dropped by a DBA\"</strong> → This is incorrect because any user with the appropriate privileges (<code>DROP SEQUENCE</code>) can drop a sequence.</p></li></ul><p><br></p><p><strong>Sequences are database objects</strong> from which multiple users can generate unique integers. The sequence generator generates sequential numbers, which can help to generate unique primary keys automatically, and to coordinate keys across multiple rows or tables.</p><p>Without sequences, sequential values can only be produced programmatically. A new primary key value can be obtained by selecting the most recently produced value and incrementing it. This method requires a lock during the transaction and causes multiple users to wait for the next value of the primary key; this waiting is known as serialization. If developers have such constructs in applications, then you should encourage the developers to replace them with access to sequences. Sequences eliminate serialization and improve the concurrency of an application.</p><p>Sequence numbers are generated independently of tables, so the same sequence can be used for one or for multiple tables.</p><p>To <strong>Create a Sequence</strong> in your schema, you must have the <code>CREATE SEQUENCE</code> system privilege. To create a sequence in another user's schema, you must have the <code>CREATE ANY SEQUENCE</code> privilege.</p><p>The <code>CACHE</code> clause preallocates a set of sequence numbers and keeps them in memory so that sequence numbers can be accessed faster. When the last of the sequence numbers in the cache has been used, the database reads another set of numbers into the cache.</p><p>The database might skip sequence numbers if you choose to cache a set of sequence numbers. For example, when an instance abnormally shuts down (for example, when an instance failure occurs or a <code>SHUTDOWN ABORT</code> statement is issued), sequence numbers that have been cached but not used are lost. Also, sequence numbers that have been used but not saved are lost as well. The database might also skip cached sequence numbers after an export and import.</p><p><br></p><p><strong>Duplicate Values in a Sequence</strong></p><p>When and how duplicate values are generated<br>1. Values can be duplicate if the <code>CYCLE</code> clause is used at the time of creating sequence, what it means when the high value is reached, it shall start from min-value resulting in duplicate values<br>2. The problem is that someone either accidentally used a different sequence to generate a few primary keys<br>3. Somehow have set some primary key manually, or<br>4. Copied rows from other environment without changing the primary key or updating the sequence.<br><br>The above scenario the case fits in case 1.<br><br>Now the action plan to fix<br>1.extract the definition from dba_sequences<br>2.Take the invalid object count(why becoz dependents objects in db will be invalid need to compile them later)<br>3.Create the sequence with nocycle clause<br>4.compile invalids<br></p><p>Noteworthy:<br>1. The current value of Sequence is not stored in dba_sequences whereas its stored in v$_sequences.nextvalue. DBA_Sequences store the cache values so it doesn't reflect the correct value of sequence.</p><p><br></p><pre class=\"prettyprint linenums\">Query\nSQL&gt; select demo.nextval from dual;\nNEXTVAL\n----------\n2</pre><p><br>=&gt;Current Value of sequence is 2 <br>Querying value from dba_sequences</p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; select sequence_owner,sequence_name,last_number\n2 from dba_sequences where sequence_name='DEMO';\nSEQUENCE_OWNER SEQUENCE_NAME LAST_NUMBER\n------------------------------ ------------------------------ -----------\nSYS DEMO 21</pre><p><br>&gt;SEE the value of last_number.<br>Exact value can be retrieved</p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; select sequence_owner,sequence_name,nextvalue\n2 from v$_sequences where sequence_name='DEMO';\nSEQUENCE_OWNER SEQUENCE_NAME NEXTVALUE\n-------------------- -------------------- ----------\nSYS DEMO 2</pre><p><br>2. Difference in sequence cant be avoided because of instance failure, transaction failure, rollback.<br>Example lets do instance failure and verify </p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; select sequence_owner,sequence_name,last_number\n2 from dba_sequences where sequence_name='DEMO';\nSEQUENCE_OWNER SEQUENCE_NAME LAST_NUMBER\n-------------------- -------------------- -----------\nSYS DEMO 21</pre><pre class=\"prettyprint linenums\">SQL&gt; select demo.nextval from dual;\nNEXTVAL\n----------\n3</pre><pre class=\"prettyprint linenums\">SQL&gt; shut abort\nORACLE instance shut down.\n\nSQL&gt; startup\nORACLE instance started.\n\nTotal System Global Area 564957184 bytes\nFixed Size 1384956 bytes\nVariable Size 201330180 bytes\nDatabase Buffers 356515840 bytes\nRedo Buffers 5726208 bytes\nDatabase mounted.\nDatabase opened.</pre><pre class=\"prettyprint linenums\">SQL&gt; select demo.nextval from dual;\nNEXTVAL\n----------\n21</pre><p><br></p><p>Per asktom → three things can't be avoided<br>1. Taxes<br>2. Death<br>3. Gap in sequences.<br>Hence beware of Gaps and if you need strictly in order then use some other logic as well.</p><p><br></p><p><strong>Generating Sequence Numbers for Multiple Tables</strong></p><p>Because a unique sequence number is generated for each logical input record, rather than for each table insert, the same sequence number can be used when inserting data into multiple tables. This is frequently useful.</p><p>Sometimes, however, you might want to generate different sequence numbers for each <code>INTO</code> <code>TABLE</code> clause. For example, your data format might define three logical records in every input record. In that case, you can use three <code>INTO</code> <code>TABLE</code> clauses, each of which inserts a different part of the record into the same table. When you use <code>SEQUENCE(MAX)</code>, SQL*Loader will use the maximum from each table, which can lead to inconsistencies in sequence numbers.</p><p>To generate sequence numbers for these records, you must generate unique numbers for each of the three inserts. Use the number of table-inserts per record as the sequence increment, and start the sequence numbers for each insert with successive numbers.</p><p><em>✗ Two or more tables cannot have keys generated from the same sequence.</em></p><p><a href=\"https://docs.oracle.com/database/121/SUTIL/GUID-8B1B4DB0-19AE-4404-9930-1CE5AF1477E1.htm#SUTIL1245\">https://docs.oracle.com/database/121/SUTIL/GUID-8B1B4DB0-19AE-4404-9930-1CE5AF1477E1.htm#SUTIL1245</a></p><p>You can drop any sequence in your schema. To drop a sequence in another schema, you must have the <code>DROP ANY SEQUENCE</code> system privilege.</p><p><em>✗ A sequence can only be dropped by a DBA.</em></p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9001.htm#SQLRF01804\">https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9001.htm#SQLRF01804</a></p>",
                "answers": [
                    "<p>A sequence can issue duplicate values.</p>",
                    "<p>A sequence's unallocated cached values are lost if the instance shuts down.</p>",
                    "<p>Sequences can have gaps.</p>",
                    "<p>Two or more tables cannot have keys generated from the same sequence.</p>",
                    "<p>A sequence can only be dropped by a DBA.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "Sequences",
            "question_plain": "View and examine the following available responses.Identify the statements regarding sequences in a single instance Oracle database. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919427,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT cust_id, cust_last_name \"Last Name\"\nFROM&nbsp;customers\nWHERE country_id = 10\nUNION\nSELECT cust_id CUST_NO, cust_last_name\nFROM&nbsp;customers\nWHERE country_id = 30;\n</pre><p><br></p><p>Identify the order by clauses which could complete the query successfully. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ORDER BY Clause](https://www.techonthenet.com/oracle/order_by.php)",
                    "[Oracle / PLSQL: UNION Operator](https://www.techonthenet.com/oracle/union.php)"
                ],
                "feedbacks": [
                    "<p>This choice is correct because \"Last Name\" is a valid column name in the query, so it can be used in the ORDER BY clause to successfully complete the query.</p>",
                    "This choice is correct because using the column positions (2, 1) in the ORDER BY clause is valid and will successfully complete the query.",
                    "This choice is correct because using the column position (2) and the column name \"cust_id\" in the ORDER BY clause is valid and will successfully complete the query.",
                    "<p>This choice is incorrect because \"CUST NO\" is not a valid column name in the query, so it cannot be used in the ORDER BY clause.</p>",
                    "<p>This choice is incorrect because \"CUST_NO\" is not a valid column in the query, so it cannot be used in the ORDER BY clause.</p>"
                ],
                "explanation": "<p>Correct Options:</p><ol><li><p><strong>ORDER BY \"Last Name\";</strong> – Since <code>\"Last Name\"</code> is an alias for <code>cust_last_name</code> in the first <code>SELECT</code> statement, it can be used for ordering.</p></li><li><p><strong>ORDER BY 2, 1;</strong> – This refers to ordering by the <strong>second column</strong> (<code>cust_last_name</code>) and then the <strong>first column</strong> (<code>cust_id</code>).</p></li><li><p><strong>ORDER BY 2, cust_id;</strong> – This orders by the <strong>second column</strong> (<code>cust_last_name</code>) and then explicitly by <code>cust_id</code>.</p></li></ol><p>Invalid ORDER BY clauses:</p><ul><li><p><strong>ORDER BY \"CUST NO\";</strong> – <code>\"CUST NO\"</code> is an alias used in the second <code>SELECT</code> statement, but aliases from individual <code>SELECT</code> statements are not recognized in a <code>UNION</code> query.</p></li><li><p><strong>ORDER BY CUST_NO;</strong> – <code>CUST_NO</code> is an alias in the second <code>SELECT</code>, but the final result set does not recognize individual aliases from separate queries.</p></li></ul><p><br></p><p><strong>The Oracle ORDER BY</strong> clause is used to sort the records in your result set. The <code>ORDER BY</code> clause can only be used in <code>SELECT</code> statements.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>ORDER BY</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expressions\nFROM tables\n[WHERE conditions]\nORDER BY expression [ ASC | DESC ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the <code>sle</code> clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected. </p><p><code>ASC</code> Optional. - It sorts the result set in ascending order by <em>expression</em> (default, if no modifier is provider). </p><p><code>DESC</code> Optional. - It sorts the result set in descending order by <em>expression</em>.</p><p><strong>Note</strong></p><p>If the <code>ASC</code> or <code>DESC</code> modifier is not provided in the <code>ORDER BY</code> clause, the results will be sorted by <em>expression</em> in ascending order (which is equivalent to <code>ORDER BY <em>expression</em> ASC</code>.</p><p><br></p><p>The Oracle <code>UNION</code> operator is used to combine the result sets of 2 or more Oracle <code>SELECT</code> statements. It removes duplicate rows between the various <code>SELECT</code> statements.</p><p>Each <code>SELECT</code> statement within the <code>UNION</code> operator must have the same number of fields in the result sets with similar data types.</p><p><strong>Syntax</strong></p><p>The syntax for the UNION operator in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nUNION\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, expression_n - The columns or calculations that you wish to retrieve. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p><p><strong>Note</strong></p><p>There must be same number of expressions in both <code>SELECT</code> statements.</p><p><em>✗&nbsp; ORDER BY CUST_NO;</em></p><p><em>✗&nbsp; ORDER BY \"CUST NO\";</em></p>",
                "answers": [
                    "<p><code>ORDER BY \"Last Name\";</code> </p>",
                    "<p><code>ORDER BY 2, 1;</code> </p>",
                    "<p><code>ORDER BY 2, cust_id;</code> </p>",
                    "<p><code>ORDER BY \"CUST NO\";</code> </p>",
                    "<p><code>ORDER BY CUST_NO;</code> </p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "a"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT cust_id, cust_last_name \"Last Name\"\nFROM&nbsp;customers\nWHERE country_id = 10\nUNION\nSELECT cust_id CUST_NO, cust_last_name\nFROM&nbsp;customers\nWHERE country_id = 30;\nIdentify the order by clauses which could complete the query successfully. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919429,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the DESCRIBE command. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[DBMS_DESCRIBE](https://docs.oracle.com/search/?q=%25C2%25A0DESCRIBE&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)",
                    "[Alphabetic List of SQLcl Commands](https://docs.oracle.com/database/sql-developer-4.2/SQCQR/toc.htm#SQCQR-GUID-6736ADCE-ABD9-49B8-91E5-7973221DC434)",
                    "[SQL*Plus Command Reference](https://docs.oracle.com/cd/B10501_01/server.920/a90842/ch13.htm)"
                ],
                "feedbacks": [
                    "The DESCRIBE command can indeed be used to display the structure of an existing view in Oracle Database SQL. It provides information about the columns, data types, and constraints of the view.",
                    "The DESCRIBE command is a versatile tool that can be used from both SQL*Plus and SQL Developer environments. It allows users to quickly view the structure of tables, views, and other objects in the database.",
                    "<p>The DESCRIBE command is capable of displaying the NOT NULL constraint for columns that have that constraint. It helps users quickly identify which columns in a table do not allow NULL values.</p>",
                    "The DESCRIBE command is not limited to SQL Developer; it can also be used from SQL*Plus. Both tools offer the functionality to describe the structure of database objects using the DESCRIBE command.",
                    "The DESCRIBE command does not display all constraints defined for each column. It mainly focuses on presenting the column names, data types, and any constraints like NOT NULL, but it does not list all constraints.",
                    "<p>The DESCRIBE command does display the PRIMARY KEY constraint for columns. </p>",
                    "The DESCRIBE command is not exclusive to SQL*Plus; it can also be used in SQL Developer. Both tools offer the functionality to describe the structure of database objects using the DESCRIBE command."
                ],
                "explanation": "<p>Correct statements:</p><ol><li><p><strong>It can be used to display the structure of an existing view</strong> – The <code>DESCRIBE</code> command works for both tables and views, showing column details.</p></li><li><p><strong>It can be used from SQL*Plus and SQL Developer</strong> – The command is available in both tools for querying metadata.</p></li><li><p><strong>It displays the NOT NULL constraint for any columns that have that constraint</strong> – The output includes information about whether a column allows <code>NULL</code> values.</p></li></ol><p>Incorrect Statements:</p><ul><li><p><strong>\"It can be used only from SQL Developer\"</strong> → Incorrect, as it is also available in SQL*Plus.</p></li><li><p><strong>\"It displays all constraints that are defined for each column\"</strong> → Incorrect, because <code>DESCRIBE</code> does not show all constraints like <code>PRIMARY KEY</code> or <code>FOREIGN KEY</code>.</p></li><li><p><strong>\"It does not display the PRIMARY KEY constraint for any column or columns that have that constraint\"</strong> → Correct, because <code>DESCRIBE</code> does not explicitly show <code>PRIMARY KEY</code> constraints.</p></li><li><p><strong>\"It can be used only from SQL*Plus\"</strong> → Incorrect, as it is also available in SQL Developer.</p></li></ul><p><br></p><p><strong>DESCRIBE</strong></p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">DESCRIBE [schema.]object[@db_link]</pre><p><br></p><p>Lists the column definitions for the specified table, view or synonym, or the specifications for the specified function or procedure.</p><p><strong>Terms</strong></p><p>schema - Represents the schema where the object resides. If you omit schema, SQL*Plus assumes you own object.</p><p>object - Represents the table, view, type, procedure, function, package or synonym you wish to describe.</p><p>@db_link - Consists of the database link name corresponding to the database where object exists.</p><p><strong>Usage</strong></p><p>The description for tables, views, types and synonyms contains the following information:</p><p>• each column's name</p><p>• whether or not null values are allowed (<code>NULL</code> or <code>NOT NULL</code>) for each column</p><p>• datatype of columns, for example, <code>CHAR</code>, <code>DATE</code>, <code>LONG</code>, <code>LONGRAW</code>, <code>NUMBER</code>, <code>RAW</code>, <code>ROWID</code>, <code>VARCHAR2</code> <code>(VARCHAR)</code>, or <code>XMLType</code></p><p>• precision of columns (and scale, if any, for a numeric column)</p><p><br></p><p>When you do a <code>DESCRIBE</code>, <code>VARCHAR2</code> columns are returned with a type of <code>VARCHAR2</code>.</p><p>The <code>DESCRIBE</code> command enables you to describe objects recursively to the depth level set in the <code>SET DESCRIBE</code> command. You can also display the line number and indentation of the attribute or column name when an object contains multiple object types. For more information, see the <code>SET</code> command.</p><p>To control the width of the data displayed, use the <code>SET LINESIZE</code> command.</p><p>Columns output for the <code>DESCRIBE</code> command are typically allocated a proportion of the linesize currently specified. Decreasing or increasing the linesize with the <code>SET LINESIZE</code> command usually makes each column proportionally smaller or larger. This may give unexpected text wrapping in your display. For more information, see the <code>SET</code> command.</p><p><br></p><p><strong>The description for functions and procedures contains the following information:</strong></p><p>• the type of PL/SQL object (function or procedure)</p><p>• the name of the function or procedure</p><p>• the type of value returned (for functions)</p><p>• the argument names, types, whether input or output, and default values, if any</p><p>• the ENCRYPT keyword to indicate whether or not data in a column is encrypted</p><p><br></p><p><strong>SQL*Plus Command Reference</strong></p><p><strong>SQLcl Commands</strong></p><p>excerpt</p><p><br></p><pre class=\"prettyprint linenums\">DESC[RIBE] {[schema.]object[@connect_identifier]}</pre><p><br></p><p>Using the <a href=\"https://apex.oracle.com/\">apex.oracle.com/</a>, Describe does display the <code>PRIMARY KEY</code> constraint for any column or columns that have that constraint.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/q_and_a/2025-01-10_18-46-05-30c637d2a257dfb03e93eee74012ce33.png\"></p>",
                "answers": [
                    "<p>It can be used to display the structure of an existing view.</p>",
                    "<p>It can be used from SQL*Plus and SQL Developer.</p>",
                    "<p>It displays the NOT NULL constraint for any columns that have that constraint.</p>",
                    "<p>It can be used only from SQL Developer.</p>",
                    "<p>It displays all constraints that are defined for each column.</p>",
                    "<p>It does not display the PRIMARY KEY constraint for any column or columns that have that constraint.</p>",
                    "<p>It can be used only from SQL*Plus.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the DESCRIBE command. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919431,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS table.</p><p><strong>Table: PRODUCTS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nPRODUCT_ID              NOT NULL          NUMBER(2)\nPRODUCT_NAME                              VARCHAR(10)\nUNIT_PRICE                                NUMBER(3)\nSURCHARGE                                 VARCHAR2(2)\nEXPIRY_DATE                               DATE\nDELIVERY_DATE                             DATE</pre><p><br></p><p>Identify the valid query expressions. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[TO_NUMBER](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/TO_NUMBER.html)",
                    "[SELECT](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html)"
                ],
                "feedbacks": [
                    "This query selects the product_id, unit_price, and surcharge columns from the PRODUCTS table. It calculates the subtotal by adding the unit_price and surcharge, then calculates a 10% discount and finally calculates the total price after the discount. The TO_NUMBER function is used to convert the surcharge to a number for mathematical operations.",
                    "This query selects the product_id, product_name, and delivery_date columns from the PRODUCTS table. It calculates the number of days before delivery by subtracting the current date (SYSDATE) from the delivery_date using the TRUNC function to remove the time portion.",
                    "This query attempts to calculate the number of days before delivery by subtracting the 'today' value from the delivery_date column. However, 'today' is not a valid function or value in Oracle SQL, so this query will result in an error.",
                    "This query selects the product_id, unit_price, and surcharge columns from the PRODUCTS table. It attempts to calculate the subtotal, 10% discount, and total price, but it uses incorrect syntax for arithmetic operations and string literals. The calculations are not valid and will result in errors.",
                    "This query selects the product_id, unit_price, and surcharge columns from the PRODUCTS table. It attempts to calculate a new surcharge by multiplying the surcharge by 1.1 and then calculates the increase in surcharge. However, the syntax used for calculations is incorrect, and this query will result in errors."
                ],
                "explanation": "<p><strong>The two valid query expressions are:</strong></p><ol><li><p><br></p></li></ol><pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       (unit_price + TO_NUMBER(surcharge)) Subtotal,\n       ((unit_price + TO_NUMBER(surcharge)) * 0.1) \"10% Discount\",\n       ((unit_price + TO_NUMBER(surcharge)) - ((unit_price + TO_NUMBER(surcharge)) * 0.1)) Total\nFROM products;\n</pre><ol><li><p><br></p></li></ol><pre class=\"prettyprint linenums\">SELECT product_id, product_name, delivery_date,\n       delivery_date - (TRUNC(SYSDATE)) \"Days before delivery\"\nFROM products;\n</pre><p><br></p><p>Let’s evaluate <strong>each SQL query</strong> based on the updated structure of the <code>PRODUCTS</code> table and Oracle SQL rules.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       (unit_price + TO_NUMBER(surcharge)) Subtotal,\n       ((unit_price + TO_NUMBER(surcharge)) * 0.1) \"10% Discount\",\n       ((unit_price + TO_NUMBER(surcharge)) - ((unit_price + TO_NUMBER(surcharge)) * 0.1)) Total\nFROM products;\n</pre><ul><li><p><strong>Valid</strong>:</p><ul><li><p><code>surcharge</code> is <code>VARCHAR2</code>, so converting it using <code>TO_NUMBER()</code> is correct.</p></li><li><p>Arithmetic is valid.</p></li><li><p>Aliases are properly used.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id, product_name, delivery_date,\n       delivery_date - (TRUNC(SYSDATE)) \"Days before delivery\"\nFROM products;\n</pre><ul><li><p><strong>Valid</strong>:</p><ul><li><p>Subtracting two dates returns the number of days.</p></li><li><p><code>SYSDATE</code> is a valid built-in function.</p></li><li><p>No data type conflicts.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id, product_name, delivery_date,\n       delivery_date - today \"Days before delivery\"\nFROM products;\n</pre><ul><li><p><strong>Invalid</strong>:</p><ul><li><p><code>today</code> is not a valid Oracle SQL keyword.</p></li><li><p>Should be <code>SYSDATE</code>.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       (unit_price + surcharge) 'Subtotal',\n       'Subtotal' * .1 \"10% Discount\",\n       - 'Subtotal' - '10% Discount' = 'Total'\nFROM products;\n</pre><ul><li><p><strong>Invalid</strong>:</p><ul><li><p>Uses <strong>string literals</strong> like <code>'Subtotal'</code> instead of column aliases.</p></li><li><p>Arithmetic on string literals is invalid.</p></li><li><p>Multiple syntax and logic errors.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       surcharge * 1.1 New_Surcharge,\n       (New_Surcharge - surcharge) Increase\nFROM products;\n</pre><ul><li><p><strong>Invalid</strong>:</p><ul><li><p><code>surcharge</code> is <code>VARCHAR2</code> → cannot multiply with 1.1 without explicit conversion.</p></li><li><p>Alias <code>New_Surcharge</code> cannot be reused in the <strong>same SELECT clause</strong>.</p></li></ul></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       (unit_price + TO_NUMBER(surcharge)) Subtotal,\n       ((unit_price + TO_NUMBER(surcharge)) * 0.1) \"10% Discount\",\n       ((unit_price + TO_NUMBER(surcharge)) - ((unit_price + TO_NUMBER(surcharge)) * 0.1)) Total\nFROM products;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT product_id, product_name, delivery_date,\n       delivery_date - (TRUNC(SYSDATE)) \"Days before delivery\"\nFROM products;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT product_id, product_name, delivery_date,\n       delivery_date - today \"Days before delivery\"\nFROM products;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       (unit_price + surcharge) 'Subtotal',\n       'Subtotal' * .1 \"10% Discount\",\n       - 'Subtotal' - '10% Discount' = 'Total'\nFROM products;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT product_id, unit_price, surcharge,\n       surcharge * 1.1 New_Surcharge,\n       (New_Surcharge - surcharge) Increase\nFROM products;\n</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the PRODUCTS table.Table: PRODUCTS Name                    Null??            Type\nPRODUCT_ID              NOT NULL          NUMBER(2)\nPRODUCT_NAME                              VARCHAR(10)\nUNIT_PRICE                                NUMBER(3)\nSURCHARGE                                 VARCHAR2(2)\nEXPIRY_DATE                               DATE\nDELIVERY_DATE                             DATEIdentify the valid query expressions. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919433,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding single row subqueries. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Subqueries](https://www.techonthenet.com/oracle/subqueries.php)"
                ],
                "feedbacks": [
                    "<p>Single row subqueries can be used with the having clause to filter the results of a grouped query based on the result of the subquery. This allows for more specific filtering conditions on grouped data.</p>",
                    "<p>A SQL statement may have multiple single row subquery blocks. This means that multiple subqueries can be used within the same SQL statement to retrieve different single values for comparison or filtering.</p>",
                    "Single row subqueries can be used in the where clause to filter the results based on the result of the subquery. This allows for more complex filtering conditions in the SQL statement.",
                    "<p>Single row subqueries must be placed on the left side of the comparison operator or condition. This is because the subquery is used to return a single value that can be compared to other values in the SQL statement.</p>",
                    "Single row subqueries must be placed on the right side of the comparison operator or condition. This is because the subquery is used to return a single value that can be compared to other values in the SQL statement.",
                    "<p>Single row subqueries must return a row to prevent errors in the SQL statement. If the subquery does not return a row, it can lead to errors such as \"no data found\" or \"single-row subquery returns more than one row.\"</p>"
                ],
                "explanation": "<p>Correct statements:</p><ul><li><p>\"They can be used with the having clause.\"</p><p>This is TRUE. Subqueries (including single-row subqueries) can be used in the HAVING clause to filter groups based on a condition that involves the subquery's result.</p></li><li><p>\"A SQL statement may have multiple single row subquery blocks.\"</p><p>This is TRUE. A single SQL statement can incorporate multiple single-row subqueries in different parts of the query (e.g., in the WHERE, HAVING, or SELECT clauses).</p></li><li><p>\"They can be used in the where clause.\"</p><p>This is TRUE. This is one of the most common uses of single-row subqueries – to filter rows based on a condition determined by the subquery's result.</p></li></ul><p>Incorrect statements:</p><ul><li><p>\"They must be placed on the left side of the comparison operator or condition.\"</p><p>This is FALSE. Single-row subqueries can be placed on either side of a comparison operator (e.g., WHERE column = (SELECT ...) or WHERE (SELECT ...) = column). The important thing is that the subquery returns a single value that can be compared.</p></li><li><p>\"They must be placed on the right side of the comparison operator or condition.\"</p><p>This is FALSE. As explained above, they can be on either side.</p></li><li><p>\"They must return a row to prevent errors in the SQL statement.\"</p><p>This is FALSE. If a single-row subquery returns no rows, the result of the subquery is considered NULL. Depending on the comparison operator, this might lead to no rows being returned by the outer query, but it doesn't necessarily cause a syntax error in the SQL statement itself. For example, WHERE column = (SELECT ...) where the subquery returns no rows would resolve to WHERE column = NULL, which typically evaluates to unknown and thus filters out all rows, but it's not an error.</p></li></ul><p><br></p><p><strong>Oracle Subquery</strong></p><p>A subquery is a SQL <code>SELECT</code> statement that is contained within another <code>SELECT</code> statement. Subqueries can appear in various parts of a query, including the <code>SELECT</code> clause, the <code>FROM</code> clause, the <code>WHERE</code> clause and the <code>HAVING</code> clause. The innermost query is evaluated prior to queries that contain it. Performance problems can result if an \"expensive\" query is nested as an inner query.</p><p><em>√&nbsp; They can be used with the having clause.</em></p><p>Typically, you can use a subquery anywhere that you use an expression.</p><p><strong>Oracle evaluates the whole query above in two steps:</strong></p><p>• First, execute the subquery.</p><p>• Second, use the result of the subquery in the outer query.</p><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS such as MySQL and PostgreSQL use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p><p><em>√&nbsp; They can be used in the where clause.</em></p><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p><p><em>√&nbsp; A SQL statement may have multiple single row subquery blocks.</em></p><p><strong>Advantages of Oracle subqueries</strong></p><p>These are the main advantages of subqueries:</p><p>• Provide an alternative way to query data that would require complex <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">joins</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\">unions</a>.</p><p>• Make the complex queries more readable.</p><p>• Allow a complex query to be structured in a way that it is possible to isolate each part.</p>",
                "answers": [
                    "<p>They can be used with the having clause.</p>",
                    "<p>A SQL statement may have multiple single row subquery blocks.</p>",
                    "<p>They can be used in the where clause.</p>",
                    "<p>They must be placed on the left side of the comparison operator or condition.</p>",
                    "<p>They must be placed on the right side of the comparison operator or condition.</p>",
                    "<p>They must return a row to prevent errors in the SQL statement.</p>"
                ]
            },
            "correct_response": [
                "c",
                "a",
                "b"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding single row subqueries. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919435,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">INSERT ALL\n  WHEN order_total &lt; 10000 THEN\n    INTO small_orders\n  WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n    INTO medium_orders\n  WHEN order_total &gt; 20000 THEN\n    INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;\n</pre><p><br></p><p>Identify the true statement regarding the evaluation of rows returned by the subquery in the INSERT statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle SQL Language Reference – INSERT ALL](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/INSERT.html)",
                    "[Using WHEN in the CASE statement](http://psoug.org/definition/WHEN.htm)"
                ],
                "feedbacks": [
                    "In the provided SQL exhibit, the rows returned by the subquery in the INSERT statement are evaluated by all three WHEN clauses, regardless of the results of the evaluation of any other WHEN clause. This means that each row will be checked against all three conditions specified in the WHEN clauses.",
                    "The statement that the rows are evaluated by the first WHEN clause, and if the condition is true, then the row would not be evaluated by the subsequent WHEN clauses, is incorrect. In the SQL exhibit, all three WHEN clauses are evaluated for each row returned by the subquery, regardless of the result of the evaluation of any other WHEN clause.",
                    "The statement that the rows are evaluated by the first WHEN clause, and if the condition is false, then the row would be evaluated by the subsequent WHEN clauses, is incorrect. In the provided SQL exhibit, all three WHEN clauses are evaluated for each row returned by the subquery, regardless of the outcome of the evaluation of any other WHEN clause.",
                    "The assertion that the INSERT statement would give an error because the ELSE clause is not present for support in case none of the WHEN clauses are true is not applicable in this context. The absence of an ELSE clause does not necessarily result in an error, as the INSERT statement can still be executed based on the conditions specified in the WHEN clauses."
                ],
                "explanation": "<p>Correct option: <strong>They are evaluated by all the three WHEN clauses regardless of the results of the evaluation of any other WHEN clause.</strong></p><p><strong>Breakdown of the Query</strong></p><p><strong>1. INSERT ALL</strong></p><ul><li><p>This is an Oracle-specific syntax used to <strong>insert rows into multiple tables</strong> based on conditions.</p></li><li><p>It's often referred to as <strong>conditional multitable insert</strong>.</p></li><li><p>It’s different from a regular <code>INSERT INTO</code> because it can <strong>conditionally insert into different tables</strong> using <code>WHEN ... THEN</code>.</p></li></ul><p><strong>2. WHEN ... THEN INTO ...</strong></p><p>These clauses define the <strong>conditions</strong> that determine <strong>which table</strong> the row should be inserted into.</p><ul><li><p><code>WHEN order_total &lt; 10000 THEN INTO small_orders</code><br>→ If the <code>order_total</code> is <strong>less than 10,000</strong>, insert the row into the <code>small_orders</code> table.</p></li><li><p><code>WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN INTO medium_orders</code><br>→ If the <code>order_total</code> is <strong>between 10,001 and 19,999</strong>, insert it into <code>medium_orders</code>.</p></li><li><p><code>WHEN order_total &gt; 20000 THEN INTO large_orders</code><br>→ If the <code>order_total</code> is <strong>greater than 20,000</strong>, insert into <code>large_orders</code>.</p></li></ul><p> <strong>Note</strong>: There’s no <code>ELSE</code> clause, so if a row doesn’t match any condition, it is <strong>not inserted anywhere</strong>.</p><p><strong>3. SELECT ... FROM orders</strong></p><ul><li><p>This part is a <strong>subquery</strong> that retrieves the rows to evaluate against the <code>WHEN</code> conditions.</p></li><li><p>It selects:</p><ul><li><p><code>order_id</code></p></li><li><p><code>order_total</code></p></li><li><p><code>customer_id</code></p></li></ul></li><li><p>These are the <strong>columns that will be inserted</strong> into the matching table(s), depending on the <code>WHEN</code> clauses.</p></li></ul><p>The SQL statement in <strong>Exhibit 1</strong> uses Oracle's <code><strong>INSERT ALL</strong></code> syntax with <strong>conditional </strong><code><strong>WHEN</strong></code><strong> clauses</strong>, which is used for <strong>conditional multitable inserts</strong>.</p><p><strong>How Conditional INSERT ALL Works in Oracle:</strong></p><ul><li><p><strong>Each row</strong> returned by the <code>SELECT</code> is <strong>evaluated independently</strong> against <strong>each </strong><code><strong>WHEN</strong></code><strong> condition</strong>.</p></li><li><p>The evaluation is <strong>not exclusive</strong> (i.e., it's not like <code>IF...ELSE IF...ELSE</code> logic).</p></li><li><p>A row may match <strong>multiple </strong><code><strong>WHEN</strong></code><strong> conditions</strong> (if allowed by the logic).</p></li><li><p>Oracle evaluates <strong>all </strong><code><strong>WHEN</strong></code><strong> clauses independently</strong>, and <strong>multiple inserts</strong> can happen <strong>for the same row</strong> if multiple conditions are true.</p></li></ul><p><strong>Why the Others Are Incorrect:</strong></p><ul><li><p><strong>\"Evaluated by the first WHEN clause only\"</strong> →&nbsp; False: Oracle doesn't stop after the first match.</p></li><li><p><strong>\"Else clause is required\"</strong> →&nbsp; False: The <code>ELSE</code> clause is <strong>optional</strong>; if no <code>WHEN</code> matches, the row is just <strong>not inserted</strong>.</p></li><li><p><strong>\"Evaluated only if the first fails\"</strong> →&nbsp; Also incorrect because all <code>WHEN</code> clauses are always considered.</p></li></ul><p>From Oracle Docs: “All <code>WHEN</code> clauses are evaluated for each row returned by the subquery. If more than one <code>WHEN</code> condition evaluates to true, then multiple INTO clauses can be executed for the same row.”</p><p><br><strong>The Oracle WHEN</strong> keyword is used in two ways. One use is in the <code>CASE</code> statement to pick among given values. The other use of <code>WHEN</code> is in a conditional <a href=\"http://psoug.org/definition/INSERT.htm\" title=\"View INSERT information\">INSERT</a> statement.<br><br><strong>Using WHEN in the CASE statement</strong><br>The <code>CASE</code> statement operates like a series of IF statements, only using the key word <code>WHEN</code>.<br><br><strong>Example Usage:</strong><br>An example of <code>WHEN</code> used in a <code>CASE</code> statement that reports a temperature range:</p><p><br></p><pre class=\"prettyprint linenums\">CASE\nWHEN n_temperature = 10 THEN v_status := 'very low';\nWHEN n_temperature &lt; 20 THEN v_status := 'low';\nWHEN n_temperature = 50 THEN v_status := 'medium';\nWHEN n_temperature &gt; 80 THEN v_status := 'high';\nELSE v_status := 'very high';\nEND CASE;</pre><p><br></p><p><strong>Using WHEN in a conditional </strong><a href=\"http://psoug.org/definition/INSERT.htm\" title=\"View INSERT information\"><strong>INSERT</strong></a><strong> statement</strong></p><p>There are two modes for conditional insert: <strong>ALL</strong> and <strong>FIRST</strong>.</p><p>If you specify <code>ALL</code>, the default value, then the database evaluates each <code>WHEN</code> clause regardless of the results of the evaluation of any other <code>WHEN</code> clause. For each <code>WHEN</code> clause whose condition evaluates to true, the database executes the corresponding <code>INTO</code> clause list.</p><p><em>√&nbsp; They are evaluated by all the three WHEN clauses regardless of the results of the evaluation of any other WHEN clause.</em></p><p><br></p><p>If you specify <code>FIRST</code>, then the database evaluates each <code>WHEN</code> clause in the order in which it appears in the statement. For the first <code>WHEN</code> clause that evaluates to true, the database executes the corresponding <code>INTO</code> clause and skips subsequent <code>WHEN</code> clauses for the given row. </p><p><strong>Example Usage:</strong></p><p><br></p><pre class=\"prettyprint linenums\">INSERT\nWHEN MOD(deptno,2)=0 THEN\nINTO even_employees (empno, ename)\nVALUES (empno, ename)\n\nWHEN MOD(deptno,2)=1 THEN\nINTO uneven_employees (empno, ename)\nVALUES (empno, ename)\n\nELSE\nINTO unknow_employees (empno, ename)\nVALUES (empno, ename)\nSELECT empno, ename, deptno FROM emp;</pre>",
                "answers": [
                    "<p>They are evaluated by all the three WHEN clauses regardless of the results of the evaluation of any other WHEN clause.</p>",
                    "<p>They are evaluated by the first WHEN clause. If the condition is true, then the row would not be evaluated by the subsequent WHEN clauses.</p>",
                    "<p>They are evaluated by the first WHEN clause. If the condition is false, then the row would be evaluated by the subsequent WHEN clauses.</p>",
                    "<p>The insert statement would give an error because the ELSE clause is not present for support in case none of WHEN clauses are true.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "INSERT",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1INSERT ALL\n  WHEN order_total &lt; 10000 THEN\n    INTO small_orders\n  WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n    INTO medium_orders\n  WHEN order_total &gt; 20000 THEN\n    INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;\nIdentify the true statement regarding the evaluation of rows returned by the subquery in the INSERT statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919437,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in the PROMOTIONS table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-12_22-17-53-c5c4f26e621d56256152f4f6737d3d4b.png\"></p><p><br></p><p><strong>Required: </strong>Produce a report that provides the name, cost, and start date of all promos in the POST category that were launched before January 1, 2019.&nbsp; </p><p><strong>Given:&nbsp; </strong>PROMO_BEGIN_DATE is stored in the date format mm/dd/rrrr</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query correctly selects the promo_name, promo_cost, and promo_begin_date columns from the promotions table. It filters the results to only include promos in the POST category and those that have a promo_begin_date before January 1, 2019. The TO_DATE function is used to convert the date format to match the comparison date format.",
                    "This query incorrectly uses the LIKE operator with wildcard characters that are not valid in this context. It also compares the promo_begin_date directly to a date string without proper conversion, which may lead to incorrect results. The comparison for the promo_category is also incorrect as it uses an asterisk instead of single quotes.",
                    "This query incorrectly uses the LIKE operator with underscore characters that are not suitable for this scenario. It also compares the promo_begin_date directly to a date string without proper conversion, which may lead to incorrect results. The comparison for the promo_cost is also incorrect as it uses an incorrect pattern matching.",
                    "This query incorrectly uses the = operator for comparing the promo_category, which should be done with the LIKE operator. The comparison for the promo_begin_date is also incorrect as it compares directly to a date string without proper conversion. Additionally, the promo_category value is enclosed in dollar signs, which is not standard SQL syntax."
                ],
                "explanation": "<p>Let's analyze each SQL query based on the requirement:</p><p><strong>Requirement Summary</strong></p><ul><li><p><strong>Table</strong>: <code>PROMOTIONS</code></p></li><li><p><strong>Return columns</strong>: <code>promo_name</code>, <code>promo_cost</code>, <code>promo_begin_date</code></p></li><li><p><strong>Conditions</strong>:</p><ul><li><p><code>promo_category</code> = <code>'POST'</code> (case-insensitive)</p></li><li><p><code>promo_begin_date</code> &lt; January 1, 2019</p></li></ul></li><li><p><strong>Date format</strong>: Stored in <code>mm/dd/yyyy</code> (<code>mm/dd/rrrr</code> in Oracle terms)</p></li></ul><p><strong>Correct Query:</strong></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date\nFROM promotions\nWHERE UPPER(promo_category) = 'POST'\nAND promo_begin_date &lt; TO_DATE('01/01/2019', 'MM/DD/YYYY');\n</pre><p>Why it is correct:</p><ul><li><p><code>UPPER(promo_category) = 'POST'</code> ensures <strong>case-insensitive</strong> match.</p></li><li><p><code>TO_DATE('01/01/2019', 'MM/DD/YYYY')</code> properly converts the string to a <strong>DATE</strong> type for accurate comparison.</p></li><li><p>Matches all requirements perfectly.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions \nWHERE promo_category LIKE '*P*'  \nAND promo_begin_date &lt; '1-JANUARY-19';\n</pre><p>Issues:</p><ul><li><p><code>*P*</code> is <strong>not valid</strong> SQL syntax in Oracle (<code>*</code> is not a wildcard; use <code>%</code>).</p></li><li><p><code>'1-JANUARY-19'</code> is a string, and without explicit <code>TO_DATE</code>, it <strong>relies on implicit conversion</strong>, which is risky and may fail.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions \nWHERE promo_cost LIKE '_post_'  \nAND promo_begin_date &lt; '01/01/2019';\n</pre><p>Issues:</p><ul><li><p><code>promo_cost</code> is a <strong>numeric</strong> column. Using <code>LIKE</code> on numeric types is <strong>invalid</strong>.</p></li><li><p><code>_post_</code> is intended for string pattern matching but used on the wrong column.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions\nWHERE promo_category = '$post$'  \nAND promo_begin_date &lt; '01-01-19';\n</pre><p>Issues:</p><ul><li><p><code>$post$</code> is not standard Oracle syntax unless that's the literal value (unlikely).</p></li><li><p><code>'01-01-19'</code> again is a string, which <strong>may cause implicit conversion issues</strong>.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date\nFROM promotions\nWHERE UPPER(promo_category) = 'POST'\nAND promo_begin_date &lt; TO_DATE('01/01/2019', 'MM/DD/YYYY');\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions \nWHERE promo_category&nbsp; LIKE '*P*'&nbsp; \nAND promo_begin_date &lt; '1-JANUARY-19';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions \nWHERE promo_cost&nbsp; LIKE '_post_'&nbsp; \nAND promo_begin_date &lt; '01/01/2019';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT promo_name, promo_cost, promo_begin_date \nFROM promotions\nWHERE promo_category = '$post$'&nbsp; \nAND promo_begin_date &lt; '01-01-19';\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the data in the PROMOTIONS table. Required: Produce a report that provides the name, cost, and start date of all promos in the POST category that were launched before January 1, 2019.&nbsp; Given:&nbsp; PROMO_BEGIN_DATE is stored in the date format mm/dd/rrrrIdentify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919439,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding dropping columns from a table. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Marking Columns Unused](https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables006.htm#ADMIN11660:~:text=Unused%2520columns%2520are%2520also%2520removed%2520from%2520the%2520target%2520table%2520whenever%2520an%2520explicit%2520drop%2520of%2520any%2520particular%2520column%2520or%2520columns%2520of%2520the%2520table%2520is%2520issued.)",
                    "[Oracle / PLSQL: ALTER TABLE Statement](https://www.techonthenet.com/oracle/tables/alter_table.php)",
                    "[Dropping Columns](https://oracle-base.com/articles/8i/dropping-columns)"
                ],
                "feedbacks": [
                    "The ALTER TABLE command in Oracle Database SQL allows for the dropping of multiple columns simultaneously, making it a convenient and efficient way to remove unwanted columns from a table.",
                    "If a column is referenced by another column in any other table, it cannot be dropped to maintain data integrity and prevent potential issues with foreign key constraints. This restriction ensures that data relationships are not broken.",
                    "Contrary to the statement, a column can be dropped even if it contains data. However, dropping a column with data will result in the loss of that data, so it is essential to carefully consider the implications before proceeding with the drop operation.",
                    "When a column is set as unused in Oracle Database SQL, it is not automatically dropped from the table upon the next commit action. The column remains in the table structure but is marked as unused, allowing for potential recovery if needed.",
                    "In Oracle Database SQL, a column does not need to be set as unused before it can be dropped from a table. The DROP COLUMN command can be used directly to remove a column from a table without the need to mark it as unused first.",
                    "Dropping a column from a table will not automatically cause other columns in the same table that do not contain data to be dropped. Only the explicitly identified column being dropped will be removed from the table structure."
                ],
                "explanation": "<p>Correct statements:</p><ol><li><p><strong>Multiple columns can be dropped simultaneously using the ALTER TABLE command.</strong></p></li><li><p><strong>A column that is referenced by another column in any other table cannot be dropped.</strong></p></li></ol><p><br></p><p>Let's analyze the available responses in the context of <strong>dropping columns from a table in Oracle SQL</strong>.</p><p>Correct Statements:</p><p><strong>1. Multiple columns can be dropped simultaneously using the ALTER TABLE command.</strong></p><ul><li><p><strong>True.</strong></p></li><li><p>Syntax:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP (column1, column2);\n</pre></li><li><p>Oracle allows <strong>dropping multiple columns at once</strong> by listing them inside parentheses.</p></li></ul><p><strong>2. A column that is referenced by another column in any other table cannot be dropped.</strong></p><ul><li><p><strong>True.</strong></p></li><li><p>If a column is part of a <strong>foreign key relationship</strong>, it <strong>cannot be dropped directly</strong>.</p></li><li><p>You must <strong>first drop the constraint</strong> or use <code>CASCADE CONSTRAINTS</code>.</p></li></ul><p>Incorrect Statements:</p><p>A column can be removed only if it contains no data.</p><ul><li><p><strong>False.</strong></p></li><li><p>Columns <strong>can be dropped regardless of whether they contain data</strong> or not.</p></li><li><p>The <code>DROP COLUMN</code> command removes the column and its data.</p></li></ul><p>A column that is set as unused is implicitly dropped from a table upon the following commit action.</p><ul><li><p><strong>False.</strong></p></li><li><p>Marking a column as <strong>UNUSED</strong> does <strong>not drop it on COMMIT</strong>.</p></li><li><p>You must explicitly drop it later using:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP UNUSED COLUMNS;\n</pre></li></ul><p>A column must be set as unused before it is dropped from a table.</p><ul><li><p><strong>False.</strong></p></li><li><p>You can drop a column <strong>directly</strong> using <code>ALTER TABLE DROP COLUMN</code>.</p></li><li><p>Setting a column as <strong>UNUSED</strong> is optional, typically used for <strong>performance</strong> reasons in large tables.</p></li></ul><p>Dropping a column from a table will not cause the columns in that table that do not contain data to be dropped while an explicitly identified column is being dropped.</p><ul><li><p><strong>Poorly worded and misleading.</strong></p></li><li><p>Oracle <strong>only drops the column(s)</strong> you explicitly specify.</p></li><li><p>The presence or absence of data in other columns <strong>has no impact</strong>.</p></li></ul><p><br></p><p><strong>The Oracle ALTER TABLE statemen</strong>t is used to add, modify, or drop/delete columns in a table. The Oracle <code>ALTER TABLE</code> statement is also used to rename a table.</p><p><strong>Drop columns in table</strong></p><p><strong>Syntax</strong></p><p>To <code>DROP A COLUMN</code> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  DROP COLUMN column_name;</pre><p><br></p><p>To <code>DROP MULTIPLE COLUMNS</code> in an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name \n  DROP (column_name1, column_name2);</pre><p><br></p><p>When you drop a column, there is no affect on columns which have no data. </p><p><br></p><p><strong>Marking Columns Unused</strong></p><p>If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the <code>ALTER TABLE...SET UNUSED</code> statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.</p><p>To mark the <code>hiredate</code> and <code>mgr</code> columns as unused, execute the following statement:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE hr.admin_emp SET UNUSED (hiredate, mgr);</pre><p><br></p><p>You can later remove columns that are marked as unused by issuing an <code>ALTER TABLE...DROP UNUSED COLUMNS</code> statement. Unused columns are also removed from the target table whenever an explicit drop of any particular column or columns of the table is issued.</p>",
                "answers": [
                    "<p>Multiple columns can be dropped simultaneously using the ALTER TABLE command.</p>",
                    "<p>A column that is referenced by another column in any other table cannot be dropped.</p>",
                    "<p>A column can be removed only if it contains no data.</p>",
                    "<p>A column that is set as unused is implicitly dropped from a table upon the following commit action.</p>",
                    "<p>A column must be set as unused before it is dropped from a table.</p>",
                    "<p>Dropping a column from a table will not cause the columns in that table that do not contain data to be dropped while an explicitly identified column is being dropped.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "ALTER",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding dropping columns from a table. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919441,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the situations where a transaction completes. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Distributed Transactions](https://docs.oracle.com/en/database/oracle/oracle-database/23/jjdbc/transaction-management.html)",
                    "[What Are The DML, DDL, and TCL Commands in SQL?](https://www.databasestar.com/dml-ddl-tcl-commands/)"
                ],
                "feedbacks": [
                    "<p>The transaction's completion depends on whether the block contains explicit <code>COMMIT</code> or <code>ROLLBACK</code> statements.</p>",
                    "When a DELETE statement is executed, it is considered a data manipulation language (DML) operation that modifies data in a table. The transaction completes when the DELETE operation is successfully executed, and the changes are committed to the database.",
                    "When a ROLLBACK command is executed, it is used to undo all changes made in the current transaction and restore the database to its state before the transaction began. The transaction completes when the ROLLBACK command is executed, and the changes are reverted.",
                    "When a data definition language (DDL) statement is executed, it is used to define, modify, or drop database objects such as tables, views, or indexes. The transaction completes when the DDL statement is successfully executed, and the changes are committed to the database.",
                    "When a TRUNCATE statement is executed after the pending transaction, it is used to remove all rows from a table quickly and efficiently. The transaction completes when the TRUNCATE statement is executed, and the table is truncated, removing all data without generating undo logs."
                ],
                "explanation": "<p>The three situations where a transaction <strong>completes</strong> are:</p><ol><li><p><strong>When a ROLLBACK command is executed</strong> – This ends the current transaction and undoes any changes made during it.</p></li><li><p><strong>When a data definition language (DDL) statement is executed</strong> – DDL statements like <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code> trigger an implicit commit before and after execution, completing the transaction.</p></li><li><p><strong>When a TRUNCATE statement is executed after the pending transaction</strong> – <code>TRUNCATE</code> is a DDL operation and also causes an implicit commit, completing the transaction.</p></li></ol><p>The other two options don’t necessarily complete a transaction:</p><ul><li><p>A <strong>PL/SQL anonymous block</strong> may contain transactional statements, but it doesn’t automatically commit or rollback unless explicitly coded to do so.</p></li><li><p>A <strong>DELETE statement</strong> is a DML operation and doesn’t complete a transaction unless followed by a <code>COMMIT</code> or <code>ROLLBACK</code>.</p></li></ul><p><br></p><p><strong>Transaction Management</strong></p><p>A transaction is a logical unit of work that contains one or more SQL statements. A transaction is an atomic unit. The effects of all the SQL statements in a transaction can be either all committed (applied to the database) or all rolled back (undone from the database).</p><p>A transaction begins with the first executable SQL statement. A transaction ends when it is committed or rolled back, either explicitly with a <code>COMMIT</code> or <code>ROLLBACK</code> statement or implicitly when a DDL statement is issued.</p><p><strong>Statement Execution and Transaction Control</strong></p><p>A SQL statement that runs successfully is different from a committed transaction. Executing successfully means that a single statement was:</p><p>• Parsed</p><p>• Found to be a valid SQL construction</p><p>• Run without error as an atomic unit. For example, all rows of a multirow update are changed.</p><p>However, until the transaction that contains the statement is committed, the transaction can be rolled back, and all of the changes of the statement can be undone. A statement, rather than a transaction, runs successfully.</p><p>Committing means that a user has explicitly or implicitly requested that the changes in the transaction be made permanent. </p><p>• An <strong>explicit request</strong> occurs when the user issues a <code>COMMIT</code> statement. </p><p>• An <strong>implicit request</strong> occurs after normal termination of an application or completion of a data definition language (DDL) operation. </p><p>The changes made by the SQL statement(s) of a transaction become permanent and visible to other users only after that transaction commits. Queries that are issued after the transaction commits will see the committed changes.</p><p><strong>The Data Definition Language (DDL) commands in Oracle SQL include:</strong></p><p><code>CREATE</code>: creates objects in the database, such as as tables, views, and functions. </p><p><code>ALTER</code>: changes or alters objects in the database, such as tables and views. Note: this includes all <code>ALTER</code> statements except <code>ALTER SESSION</code> and <code>ALTER SYSTEM</code>. </p><p><code>DROP</code>: drops, or deletes, objects in the database. </p><p><code>TRUNCATE</code>: removes all data from a table. </p><p><code>RENAME</code>: changes the name of an object in the database.</p><p><code>COMMENT</code>: adds comments for an object to the data dictionary.</p><p><code>GRANT</code>: give privileges to a user or role in the database.</p><p><code>REVOKE</code>: remove certain privileges from a user or role in the database.</p><p><code>ANALYZE</code>: analyses information on a table, index, or cluster.</p><p><code>AUDIT</code>: Track the occurrence of SQL statements in user sessions or on specific schema objects.</p><p><code>NOAUDIT</code>: Disables auditing set up by the AUDIT command.</p><p><code>ASSOCIATE STATISTICS</code>: Associate a statistics type with columns, functions, and other objects.</p><p><code>DISASSOCIATE STATISTICS</code>: Remove the statistics association set up by <code>ASSOCIATE STATISTICS</code>.</p><p><code>FLASHBACK</code>: Restore an earlier version of a table.</p><p><code>PURGE</code>: Remove a table or index from the recycle bin.</p><p>DDL commands cannot be rolled back, as they include a <code>COMMIT</code> as part of their execution.</p><p><strong>Explicit Transaction Control</strong>:</p><p>A transaction is completed if the PL/SQL block contains a <code>COMMIT</code> or <code>ROLLBACK</code> statement.</p><p>Example:</p><pre class=\"prettyprint linenums\">sqlCode kopierenBEGIN    INSERT INTO employees VALUES (1, 'John');    COMMIT; -- Transaction completes hereEND;</pre><p><br></p><p><strong>No Transaction Control</strong>:</p><p>If the block doesn't contain <code>COMMIT</code> or <code>ROLLBACK</code>, the transaction remains open until the session explicitly commits or rolls back the changes.</p><p>Example:</p><pre class=\"prettyprint linenums\">sqlCode kopierenBEGIN    INSERT INTO employees VALUES (2, 'Jane');    -- No COMMIT or ROLLBACK, so the transaction is still pendingEND;</pre><p><br></p><p><strong>Exceptions</strong>:</p><p>If an exception occurs and is not handled, the transaction is not committed and may be implicitly rolled back, depending on the database.</p>",
                "answers": [
                    "<p>When a PL/SQL anonymous block is executed</p>",
                    "<p>When a DELETE statement is executed</p>",
                    "<p>When a ROLLBACK command is executed</p>",
                    "<p>When a data definition language (DDL) statement is executed</p>",
                    "<p>When a TRUNCATE statement is executed after the pending transaction</p>"
                ]
            },
            "correct_response": [
                "c",
                "d",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the situations where a transaction completes. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919443,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the WITH GRANT OPTION clause. (Choose three)&nbsp; &nbsp;</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Managing User Privileges and Roles](https://docs.oracle.com/cd/A97630_01/server.920/a96521/privs.htm)",
                    "[WITH GRANT OPTION keywords](https://www.ibm.com/support/knowledgecenter/en/SSGU8G_12.1.0/com.ibm.sqls.doc/ids_sqs_0125.htm)"
                ],
                "feedbacks": [
                    "The statement is incorrect. The grantee does not need the GRANT ANY OBJECT PRIVILEGE system privilege to use the WITH GRANT OPTION clause. This clause allows the grantee to pass on the privileges they have been granted to other users.",
                    "The statement is incorrect. The grantee can use the WITH GRANT OPTION clause to pass on privileges to PUBLIC if they choose to do so. This allows for broader access to the granted privileges.",
                    "The statement is correct. If you revoke a privilege that was granted using the WITH GRANT OPTION clause, you also revoke the ability of the grantee to pass on that privilege to other users. This severs the chain of privileges.",
                    "The statement is correct. The grantee can use the WITH GRANT OPTION clause to pass on the privileges they have been granted to other users in the database. This allows for the delegation of privileges to different users as needed.",
                    "The statement is correct. The grantee can grant object privileges to other users in the database, but they can only include the WITH GRANT OPTION clause if they have the GRANT ANY OBJECT PRIVILEGE system privilege. This privilege is required to delegate the ability to pass on privileges to other users."
                ],
                "explanation": "<p>Here are the <strong>three true statements</strong> regarding the <code>WITH GRANT OPTION</code> clause:</p><ol><li><p><strong>If you revoke from user the privilege that you granted using the WITH GRANT OPTION keyword, you sever the chain of privileges.</strong><br>– This is true. Revoking a privilege granted with <code>WITH GRANT OPTION</code> causes a cascading revoke, removing that privilege from any users the grantee had passed it on to.</p></li><li><p><strong>It can be used to pass on privileges to other users by the grantee.</strong><br>– Correct. This is the primary purpose of the clause: it allows the grantee to grant the same privilege to others.</p></li><li><p><strong>It cannot be used to pass on privileges to PUBLIC by the grantee.</strong><br>– Also true. The grantee can grant privileges to specific users or roles, but not to the <code>PUBLIC</code> group unless they have broader administrative rights.</p></li></ol><p>The other two statements are <strong>false</strong>:</p><ul><li><p>The grantee <strong>does not need</strong> the <code>GRANT ANY OBJECT PRIVILEGE</code> system privilege to use <code>WITH GRANT OPTION</code>; they only need to have received the privilege with that option themselves.</p></li><li><p>Similarly, the grantee <strong>can</strong> include <code>WITH GRANT OPTION</code> when passing on a privilege, but only if they were granted it with that option in the first place.</p></li></ul><p><br></p><p><strong>Granting Object Privileges</strong></p><p>You also use the <code>GRANT</code> statement to grant object privileges to roles and users. To grant an object privilege, you must fulfill one of the following conditions:</p><p>You own the object specified.</p><p>You possess the <code>GRANT ANY OBJECT PRIVILEGE</code> system privilege that enables you to grant and revoke privileges on behalf of the object owner.</p><p>The <code>WITH GRANT OPTION</code> clause was specified when you were granted the object privilege by its owner.</p><p><strong>Specifying the GRANT OPTION</strong></p><p>Specify WITH GRANT OPTION to enable the grantee to grant the object privileges to other users and roles. The user whose schema contains an object is automatically granted all associated object privileges with the <code>GRANT OPTION</code>. This special privilege allows the grantee several expanded privileges:</p><p><strong>The grantee can grant the object privilege to any users in the database, with or without the </strong><code><strong>GRANT OPTION</strong></code><strong>, or to any role in the database.</strong></p><p>If both of the following are true, the grantee can create views on the table and grant the corresponding privileges on the views to any user or role in the database. The grantee receives object privileges for the table with the <code>GRANT OPTION</code>. The grantee has the <code>CREATE VIEW</code> or <code>CREATE ANY VIEW</code> system privilege.</p><p>The <code>GRANT OPTION</code> is not valid when granting an object privilege to a role. Oracle prevents the propagation of object privileges through roles so that grantees of a role cannot propagate object privileges received by means of roles.</p><p><strong>The WITH GRANT OPTION</strong> keywords convey the privilege or role to a user with the right to grant the same privileges or role to other users.</p><p>You create a chain of privileges that begins with you and extends to user as well as to whomever user subsequently conveys the right to grant privileges. If you include WITH GRANT OPTION, you can no longer control the dissemination of privileges.</p><p>The following example grants the Alter and Select privileges to user on the an object (sequence or system), with the ability to grant those privileges to others:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT ALL ON object TO user WITH GRANT OPTION;</pre><p><br></p><p>If you revoke from user the privilege that you granted using the <code>WITH GRANT OPTION</code> keyword, you sever the chain of privileges. </p><p>That is, when you revoke privileges from user, you automatically revoke the privileges of all users who received privileges from user or from the chain that user created (unless user, or the users who received privileges from user, were granted the same set of privileges by someone else).</p>",
                "answers": [
                    "<p>The grantee must have the GRANT ANY OBJECT PRIVILEGE system privilege to use this option.</p>",
                    "<p>It cannot be used to pass on privileges to PUBLIC by the grantee.</p>",
                    "<p>If you revoke from user the privilege that you granted using the WITH GRANT OPTION keyword, you sever the chain of privileges. </p>",
                    "<p>It can be used to pass on privileges to other users by the grantee.</p>",
                    "<p>The grantee can grant the object privilege to any user in the database, but cannot include WITH GRANT OPTION unless they have the GRANT ANY OBJECT PRIVILEGE system privilege.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d",
                "e"
            ],
            "section": "WITH GRANT",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the WITH GRANT OPTION clause. (Choose three)&nbsp; &nbsp;",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919445,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of CUSTOMERS table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-30-31-d89e878da49629b455f0ccb5541bc09d.png\"></p><p><br></p><p><strong>Required:</strong></p><ul><li><p>Using the CUSTOMERS table, generate a report that shows an increase in the credit limit by 15% for all customers. </p></li><li><p>Customers whose credit limit has not been entered should have the message \"N/A\" displayed.&nbsp; </p></li></ul><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: NVL Function](https://www.techonthenet.com/oracle/functions/nvl.php)",
                    "[Oracle / PLSQL: TO_CHAR Function](https://www.techonthenet.com/oracle/functions/to_char.php)"
                ],
                "feedbacks": [
                    "This query correctly selects the customer ID, last name, city, current credit limit, and calculates the new credit limit by increasing it by 15%. It uses the NVL function to display \"N/A\" for customers without a credit limit entered.",
                    "This query incorrectly applies the NVL function before calculating the new credit limit, which results in an incorrect output. The placement of the NVL function should be after calculating the new credit limit to display \"N/A\" for customers without a credit limit entered.",
                    "This query incorrectly multiplies the credit limit by 0.15 instead of 1.15, resulting in a decrease in the credit limit instead of an increase. It also places the NVL function in the wrong position, affecting the display of \"N/A\" for customers without a credit limit entered.",
                    "This query incorrectly places the NVL function outside of the TO_CHAR function, resulting in an error in the syntax. Additionally, it does not correctly calculate the new credit limit by increasing it by 15%.",
                    "This query incorrectly multiplies the credit limit by 0.15 instead of 1.15, resulting in a decrease in the credit limit instead of an increase. It also places the NVL function in the wrong position, affecting the display of \"N/A\" for customers without a credit limit entered."
                ],
                "explanation": "<p><strong>Correct SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\",\n       NVL(TO_CHAR(cust_credit_limit * 1.15), 'N/A') \"NEW CREDIT\"\nFROM customers;\n</pre><p>This query:</p><ul><li><p>Correctly increases credit by 15%,</p></li><li><p>Uses <code>TO_CHAR()</code> to convert the numeric value to a string,</p></li><li><p>Applies <code>NVL()</code> to return <code>\"N/A\"</code> if <code>cust_credit_limit</code> is null.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-26_13-09-51-8ea86c1cff36674a2e940f700d608c08.png\"></p><p><br></p><p>To solve this, let’s break down the <strong>requirement</strong> and examine the <strong>correct SQL query</strong>:</p><p><strong>Requirements:</strong></p><ol><li><p><strong>Display customer ID, last name, city, current credit limit.</strong></p></li><li><p><strong>Increase the credit limit by 15%</strong> — so multiply by <strong>1.15</strong>.</p></li><li><p><strong>If credit limit is null</strong>, show <code>\"N/A\"</code> instead of a number.</p></li></ol><p><strong>Best Way to Handle This in SQL:</strong></p><ul><li><p>Use <code>NVL()</code> to handle <code>NULL</code> values in <code>cust_credit_limit</code>.</p></li><li><p>Multiply <code>cust_credit_limit * 1.15</code> <strong>only when it is not null</strong>.</p></li><li><p>Use <code>TO_CHAR()</code> to convert the numeric result into a character string so that <code>'N/A'</code> (a string) is compatible.</p><p><br></p></li></ul><p><strong>Why the Other Options Are Incorrect:</strong></p><ul><li><pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", \n       TO_CHAR(NVL(cust_credit_limit * 1.15),'N/A') \"NEW CREDIT\" \nFROM customers;</pre><p><br>Invalid: <code>NVL(cust_credit_limit * 1.15, 'N/A')</code> tries to mix number and string types before converting.</p></li><li><pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", \n       NVL(TO_CHAR(cust_credit_limit * .15),'N/A') \"NEW CREDIT\" \nFROM customers;</pre><p><br>Wrong calculation – this gives the <strong>increase amount</strong>, not the <strong>new total</strong> credit limit.</p></li><li><pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", NVL(cust_credit_limit * .15),'N/A' \"NEW CREDIT\" \nFROM customers;</pre><p><br>Wrong calculation – this gives the <strong>increase amount</strong>, not the <strong>new total</strong> credit limit.</p></li><li><pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", NVL(cust_credit_limit * 1.15),'N/A' \"NEW CREDIT\" \nFROM customers;</pre><p><br>Type mismatch – you're trying to substitute a <strong>string </strong><code><strong>'N/A'</strong></code> in place of a <strong>number</strong>, which will raise an error.</p></li></ul><p><br></p><p><strong>The Oracle/PLSQL NVL function </strong>lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. replace_with The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL</code> function returns a substitute value.</p><p><br></p><p><strong>The Oracle/PLSQL TO_CHAR function</strong> converts a number or date to a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TO_CHAR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">TO_CHAR( value [, format_mask] [, nls_language] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>value A number or date that will be converted to a string. format_mask Optional. This is the format that will be used to convert <em>value</em> to a string. nls_language Optional. This is the nls language used to convert <em>value</em> to a string.</p><p><strong>Returns</strong></p><p>The <code>TO_CHAR</code> function returns a string value.</p><p><br></p><p>It is necessary to convert the numbers to text characters in order to do the substitution of the <code>NULL</code> value in cust_credit_limit to insert the text as required. Before it is converted, the math calculation must be done. The required asks to show an increased percentage to the current credit value, which in this case is done by 1.15x the value of the current credit limit. </p><p>The math needs to be done first, and then the conversion to text, then the substitution for <code>NULL</code> values.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\",\n       NVL(TO_CHAR(cust_credit_limit * 1.15), 'N/A') \"NEW CREDIT\"\nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", \n       TO_CHAR(NVL(cust_credit_limit * 1.15),'N/A') \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", \n       NVL(TO_CHAR(cust_credit_limit * .15),'N/A') \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", NVL(cust_credit_limit * 1.15),'N/A' \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_id,\n       cust_last_name,\n       cust_city,\n       cust_credit_limit \"CURRENT CREDIT\", NVL(cust_credit_limit * .15),'N/A' \"NEW CREDIT\" \nFROM customers;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "NVL",
            "question_plain": "View and examine the structure of CUSTOMERS table. Required:Using the CUSTOMERS table, generate a report that shows an increase in the credit limit by 15% for all customers. Customers whose credit limit has not been entered should have the message \"N/A\" displayed.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919447,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statements which indicate the end of a transaction. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Structure of a Transaction](https://docs.oracle.com/cd/E11882_01/server.112/e40540/transact.htm#CNCPT038)"
                ],
                "feedbacks": [
                    "After a CREATE statement is issued, it marks the end of a transaction as the transaction is completed with the creation of the specified object in the database.",
                    "After a SAVEPOINT is issued, it does not indicate the end of a transaction. SAVEPOINT is used to set a point within a transaction to which you can later roll back.",
                    "After a SELECT statement is issued, it does not indicate the end of a transaction. SELECT statements are used to retrieve data from the database and do not affect the transaction's state.",
                    "After a ROLLBACK is issued, it marks the end of a transaction by undoing any changes made within the transaction and returning the database to its state before the transaction began.",
                    "After a COMMIT is issued, it marks the end of a transaction by making all changes within the transaction permanent in the database. It signifies the successful completion of the transaction."
                ],
                "explanation": "<p>The <strong>three statements that indicate the end of a transaction</strong> are:</p><ol><li><p><strong>After a CREATE statement is issued</strong> – <code>CREATE</code> is a DDL (Data Definition Language) command, and DDL statements implicitly commit any current transaction and end it.</p></li><li><p><strong>After a ROLLBACK is issued</strong> – This explicitly ends the current transaction and undoes all changes made during it.</p></li><li><p><strong>After a COMMIT is issued</strong> – This also explicitly ends the current transaction, making all changes permanent.</p></li></ol><p>The other two do <strong>not</strong> end a transaction:</p><ul><li><p><strong>SAVEPOINT</strong> sets a marker within a transaction but does not end it.</p></li><li><p><strong>SELECT</strong> simply retrieves data and doesn’t affect transaction boundaries unless explicitly wrapped in a transaction block.</p></li></ul><p><br></p><p><strong>End of a Transaction</strong></p><p>A transaction ends when any of the following actions occurs:</p><p>•&nbsp; A user issues a <code>COMMIT</code> or <code>ROLLBACK</code> statement without a <code>SAVEPOINT</code> clause.</p><p><em>√ After a COMMIT is issued.</em></p><p><em>√&nbsp; After a ROLLBACK is issued.</em></p><p><br></p><p>In a commit, a user explicitly or implicitly requested that the changes in the transaction be made permanent. Changes made by the transaction are permanent and visible to other users only after a transaction commits. The transaction shown in <a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e40540/transact.htm#i974\">Figure 10-1</a> ends with a commit.</p><p>•&nbsp; A user runs a DDL command such as <code>CREATE</code>, <code>DROP</code>, <code>RENAME</code>, or <code>ALTER</code>.</p><p><em>√&nbsp; After a CREATE statement is issued.</em></p><p><br></p><p>•&nbsp; The database issues an implicit <code>COMMIT</code> statement before and after every DDL statement. If the current transaction contains DML statements, then Oracle Database first commits the transaction and then runs and commits the DDL statement as a new, single-statement transaction.</p><p>•&nbsp; A user exits normally from most Oracle Database utilities and tools, causing the current transaction to be implicitly committed. The commit behavior when a user disconnects is application-dependent and configurable.</p><p><strong>Note:</strong></p><p>Applications should always explicitly commit or undo transactions before program termination.</p><p>A client process terminates abnormally, causing the transaction to be implicitly rolled back using metadata stored in the transaction table and the undo segment.</p><p>After one transaction ends, the next executable SQL statement automatically starts the following transaction.</p>",
                "answers": [
                    "<p>After a CREATE statement is issued.</p>",
                    "<p>After a SAVEPOINT is issued.</p>",
                    "<p>After a SELECT statement is issued.</p>",
                    "<p>After a ROLLBACK is issued.</p>",
                    "<p>After a COMMIT is issued.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the statements which indicate the end of a transaction. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919449,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario: </strong>You notice a performance change in your production Oracle 12c database. You want to know which change caused this performance difference.&nbsp; </p><p>Identify the method or feature should you use.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Comparing Database Performance Over Time](https://docs.oracle.com/en/database/oracle/oracle-database/23/tgdba/comparing-database-performance-time.html)"
                ],
                "feedbacks": [
                    "Comparing Period ADDM report is not the most suitable method for identifying the specific change that caused a performance difference in the Oracle database. ADDM (Automatic Database Diagnostic Monitor) focuses on analyzing performance issues and providing recommendations, but it may not pinpoint the exact change that led to the performance difference.",
                    "AWR (Automatic Workload Repository) Compare Period report is the correct choice for identifying the specific change that caused a performance difference in the Oracle database. The AWR report allows you to compare two different time periods and analyze the performance metrics to pinpoint the root cause of the performance change.",
                    "Active Session History (ASH) report provides information about the current and recent activity in the database, focusing on active sessions and their performance characteristics. While ASH can be useful for real-time monitoring and analysis, it may not be the most effective method for identifying the specific change that caused a performance difference in the past.",
                    "Taking a new snapshot and comparing it with a preserved snapshot is a valid method for analyzing performance changes in the Oracle database. However, this method may not provide as detailed and comprehensive analysis as the AWR Compare Period report, which is specifically designed for comparing performance metrics over different time periods."
                ],
                "explanation": "<p>The most suitable method to identify <strong>what caused a performance difference</strong> in your Oracle 12c production database is the <strong>Compare Period ADDM report</strong>.</p><p>Here’s why:</p><ul><li><p><strong>Compare Period ADDM report</strong> is specifically designed to analyze and compare performance across two different time periods. It highlights changes in workload, configuration, and resource usage, helping you pinpoint the root cause of performance shifts.</p></li><li><p><strong>AWR Compare Period report</strong> also compares performance metrics between two periods, but it’s more data-driven and less diagnostic—it doesn’t provide actionable recommendations like ADDM does.</p></li><li><p><strong>ASH report</strong> gives detailed session-level activity, which is great for real-time or short-term analysis, but not ideal for comparing historical performance changes.</p></li><li><p><strong>Taking a new snapshot and comparing it with a preserved snapshot</strong> is a manual approach and lacks the analytical depth of the Compare Period ADDM.</p></li></ul><p>So, for a clear, guided diagnosis of what changed and why performance dipped, <strong>Compare Period ADDM</strong> is your best bet.</p><p><br></p><p><strong>Automatic Workload Repository Compare Periods Reports</strong></p><p>Performance degradation of the database occurs when your database was performing optimally in the past, but has over time gradually degraded to a point where it becomes noticeable to the users. AWR Compare Periods report enables you to compare database performance over time.</p><p>An AWR report shows AWR data during a period in time between two snapshots (or two points in time). An AWR Compare Periods report, on the other hand, shows the difference between two periods in time (or two AWR reports, which equates to four snapshots). Using AWR Compare Periods reports helps you to identify detailed performance attributes and configuration settings that differ between two time periods.</p><p><em>√&nbsp; AWR Compare Period report.</em></p><p><br></p><p>For example, assume that a batch workload runs daily during a maintenance window between 10:00 p.m. and midnight is showing poor performance and is now completing at 2 a.m instead. You can generate an AWR Compare Periods report for the time period from 10:00 p.m. to midnight on a day when performance was good, and another report for the time period from 10:00 a.m. to 2 a.m. on a day when performance was poor. You can then compare these reports to identify configuration settings, workload profile, and statistics that differ between these two time periods. Based on those differences, you can more easily diagnose the cause of the performance degradation.</p><p>The two time periods selected in an AWR Compare Periods report can be of different durations because the report normalizes the statistics by the amount of time spent on the database for each time period, and presents statistical data ordered by the largest difference between the time periods.</p>",
                "answers": [
                    "<p>Compare Period ADDM report.</p>",
                    "<p>AWR Compare Period report.</p>",
                    "<p>Active Session History (ASH) report.</p>",
                    "<p>Taking a new snapshot and comparing it with a preserved snapshot.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Reference",
            "question_plain": "Scenario: You notice a performance change in your production Oracle 12c database. You want to know which change caused this performance difference.&nbsp; Identify the method or feature should you use.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919451,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in the CUST_NAME column of the CUSTOMERS table.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CUST_NAME\nRenske Ladwig\nJason Mallin\nSamuel McCain\nAllan MCEwen\nIrene Mikkilineni\nJulia Nayer</pre><p><br></p><p><strong>Required: </strong>List the values of CUST_NAME where the last name begins with either Mc or MC.&nbsp; </p><p>Identify the WHERE clause which gives the required result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: INITCAP Function](https://www.techonthenet.com/oracle/functions/initcap.php)",
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)",
                    "[Oracle / PLSQL: INSTR Function](https://www.techonthenet.com/oracle/functions/instr.php)"
                ],
                "feedbacks": [
                    "This WHERE clause does not correctly identify the last name that begins with either 'Mc' or 'MC'. The SUBSTR function is not used properly to extract the last name, and the comparison with 'Mc%' is incorrect.",
                    "This WHERE clause uses the INITCAP function to capitalize the first letter of each word in the string, but it does not correctly identify the last name that begins with either 'Mc' or 'MC'. The comparison with 'MC%' and 'Mc%' is not valid.",
                    "This WHERE clause correctly identifies the last name that begins with either 'Mc' or 'MC'. It extracts the last name using SUBSTR and INSTR functions, converts it to uppercase, and compares it with 'MC%' in uppercase to cover both cases.",
                    "This WHERE clause incorrectly combines the conditions for 'Mc%' and 'MC%' using the OR operator. It does not correctly identify the last name that begins with either 'Mc' or 'MC'.",
                    "This WHERE clause attempts to extract the last name using SUBSTR and INSTR functions, converts it to uppercase, and compares it with 'MC%' in uppercase. However, the extraction of the last name is not done correctly, leading to inaccurate results."
                ],
                "explanation": "<p>The correct <code>WHERE</code> clause that gives the required result—<strong>listing customers whose last name begins with either \"Mc\" or \"MC\"</strong>—is:</p><pre class=\"prettyprint linenums\">WHERE UPPER(SUBSTR(cust_name, INSTR(cust_name, ' ') + 1)) LIKE 'MC%'\n</pre><p>Here’s why this works:</p><ul><li><p><code>INSTR(cust_name, ' ') + 1</code> locates the position just after the space, which marks the start of the last name.</p></li><li><p><code>SUBSTR(...)</code> extracts the last name.</p></li><li><p><code>UPPER(...)</code> ensures case-insensitive comparison.</p></li><li><p><code>LIKE 'MC%'</code> matches any last name starting with \"Mc\" or \"MC\", regardless of case.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-26_16-58-47-0dfc71aad68e11521620e9841af96e1b.png\"></p><p><br></p><p>The other options either use incorrect syntax (like <code>INSTR(cust_name, '')</code>, which returns 1 and doesn’t help isolate the last name) or improperly structure the <code>LIKE</code> condition.</p><p><br></p><p><strong>The Oracle/PLSQL INITCAP</strong> function sets the first character in each word to uppercase and the rest to lowercase.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INITCAP</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">INITCAP( string1 )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string argument whose first character in each word will be converted to uppercase and all remaining characters converted to lowercase.</p><p><strong>Returns</strong></p><p>The <code>INITCAP</code> function returns a string value.</p><p><br></p><p><strong>The Oracle/PLSQL SUBSTR</strong> functions allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The source string. </p><p>start_position - The starting position for extraction. The first position in the string is always 1. </p><p>length Optional. - It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a <code>NULL</code> value.</p><p>Note</p><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p><p><br></p><p><strong>The Oracle/PLSQL INSTR</strong> function returns the location of a substring in a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INSTR</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">INSTR( string, substring [, start_position [, th_appearance ] ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The string to search. <em>string</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. </p><p>substring - The substring to search for in <em>string</em>. <em>substring</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. </p><p>start_position Optional. - The position in <em>string</em> where the search will start. If omitted, it defaults to 1. The first position in the string is 1. If the <em>start_position</em> is negative, the <code>INSTR</code> function counts back <em>start_position</em> number of characters from the end of <em>string</em> and then searches towards the beginning of <em>string</em>. </p><p>nth_appearance Optional. - The nth appearance of <em>substring</em>. If omitted, it defaults to 1.</p><p><strong>Returns</strong></p><p>The <code>INSTR</code> function returns a numeric value. The first position in the string is 1.<br>If <em>substring</em> is not found in <em>string</em>, then the <code>INSTR</code> function will return 0.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE SUBSTR (cust_name, INSTR (cust_name, '') +1) LIKE 'Mc%'\n </pre>",
                    "<pre class=\"prettyprint linenums\">WHERE INITCAP(SUBSTR(cust_name, INSTR(cust_name, '')+1)) IN ('MC%', 'Mc%) \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE UPPER(SUBSTR(cust_name, INSTR(cust_name, ' ') + 1)) LIKE 'MC%' \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE SUBSTR(cust_name, INSTR (cust_name, '') +1) LIKE 'Mc%' OR 'MC%' \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE SUBSTR(cust_name, INSTR(cust_name, ' ')+1) LIKE UPPER ('MC%') \n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "INITCAP",
            "question_plain": "View and examine the data in the CUST_NAME column of the CUSTOMERS table.Exhibit: 1CUST_NAME\nRenske Ladwig\nJason Mallin\nSamuel McCain\nAllan MCEwen\nIrene Mikkilineni\nJulia NayerRequired: List the values of CUST_NAME where the last name begins with either Mc or MC.&nbsp; Identify the WHERE clause which gives the required result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919453,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE products;\n</pre><p><br></p><p><strong>Given: </strong>The command has been executed.</p><p>Identify the true statements regarding the implication of this command. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DROP TABLE Statement](https://www.techonthenet.com/oracle/tables/drop_table.php)",
                    "[DROP TABLE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/DROP-TABLE.html)"
                ],
                "feedbacks": [
                    "<p>Use the <code>DROP TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely.</p>",
                    "<p>The <code>DROP&nbsp;TABLE</code> implicitly ends any transaction active in the current session, as if you had done a <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/commit.html\" rel=\"noopener noreferrer\" target=\"_blank\" title=\"13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax\"><code>COMMIT</code></a> before executing the statement.</p>",
                    "<p>This statement is incorrect because when a table is dropped, all data in the table is deleted, but the table structure itself remains intact. The table structure, including indexes, columns, constraints, and triggers, is not affected by the drop operation.</p>",
                    "<p>Dropping a table invalidates dependent objects and removes object privileges on the table. All views and synonyms will remain.</p>",
                    "<p>This statement is incorrect because when a table is dropped, all data in the table is deleted, but the table structure itself remains intact. The table structure, including indexes, columns, constraints, and triggers, is not affected by the drop operation.</p>"
                ],
                "explanation": "<p>Here are the <strong>three true statements</strong> regarding the implications of executing <code>DROP TABLE products;</code>:</p><ol><li><p><strong>All data along with the table structure is deleted</strong><br>– Correct. The <code>DROP TABLE</code> command removes both the data and the table definition from the database.</p></li><li><p><strong>A pending transaction in the session is committed</strong><br>– True. DDL statements like <code>DROP TABLE</code> cause an implicit commit, which finalizes any pending transactions before and after the statement.</p></li><li><p><strong>All views and synonyms on the table remain but they are invalidated</strong><br>– Also true. Dependent objects like views and synonyms are not dropped, but they become invalid and unusable until corrected or recompiled.</p></li></ol><p>The following are <strong>not true</strong>:</p><ul><li><p><strong>All indexes on the table remain but they are invalidated</strong> – False. Indexes are part of the table structure and are dropped along with the table.</p></li><li><p><strong>All data in the table is deleted but the table structure remains</strong> – False. That would describe a <code>TRUNCATE</code> or <code>DELETE</code>, not a <code>DROP</code>.</p></li></ul><p><br></p><p><strong>The Oracle DROP TABLE statement</strong> allows you to remove or delete a table from the Oracle database.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>DROP TABLE</code> statement is:</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE [schema_name].table_name\n[ CASCADE CONSTRAINTS ]\n[ PURGE ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>schema_name - The name of the schema that owns the table. </p><p>table_name - The name of the table to remove from the Oracle database. </p><p>CASCADE CONSTRAINTS Optional. - If specified, all referential integrity constraints will be dropped as well. </p><p>PURGE Optional. - If specified, the table and its dependent objects will be purged from the recycle bin and you will not be able to recover the table. If not specified, the table and its dependent objects are placed in the recycle bin and can be recovered later, if needed.</p><p><strong>Note: </strong>If there are referential integrity constraints on <em>table_name</em> and you do not specify the <em>CASCADE CONSTRAINTS</em> option, the <code>DROP TABLE </code> statement will return an error and Oracle will not drop the table.</p><p>Use the <code>DROP TABLE</code> statement to move a table or object table to the recycle bin or to remove the table and all its data from the database entirely.</p><p><em>√&nbsp; All data along with the table structure is deleted.</em></p><p><strong>Caution:</strong></p><p> Unless you specify the <code>PURGE</code> clause, the <code>DROP TABLE</code> statement does not result in space being released back to the tablespace for use by other objects, and the space continues to count toward the user's space quota.</p><p>For an external table, this statement removes only the table metadata in the database. It has no affect on the actual data, which resides outside of the database.</p><p>When you drop a table that is part of a cluster, the table is moved to the recycle bin. However, if you subsequently drop the cluster, the table is purged from the recycle bin and can no longer be recovered with a <code>FLASHBACK TABLE</code> operation.</p><p>Dropping a table invalidates dependent objects and removes object privileges on the table. If you want to re-create the table, then you must regrant object privileges on the table, re-create the indexes, integrity constraints, and triggers for the table, and respecify its storage parameters. Truncating has none of these effects. Therefore, removing rows with the <code>TRUNCATE</code> statement can be more efficient than dropping and re-creating a table.</p><p><em>√&nbsp;&nbsp; All views and synonyms on the table remain but they are invalidated.</em></p><p><strong>Implicit Commit</strong></p><p>The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/commit.html\" title=\"13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax\"><code>COMMIT</code></a> before executing the statement.</p><p><strong>Data definition language (DDL) statements that define or modify database objects.</strong> <code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Syntax\"><code>ALTER EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-procedure.html\" title=\"13.1.5&nbsp;ALTER PROCEDURE Syntax\"><code>ALTER PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-server.html\" title=\"13.1.6&nbsp;ALTER SERVER Syntax\"><code>ALTER SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-table.html\" title=\"13.1.7&nbsp;ALTER TABLE Syntax\"><code>ALTER TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-database.html\" title=\"13.1.10&nbsp;CREATE DATABASE Syntax\"><code>CREATE DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-event.html\" title=\"13.1.11&nbsp;CREATE EVENT Syntax\"><code>CREATE EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-index.html\" title=\"13.1.13&nbsp;CREATE INDEX Syntax\"><code>CREATE INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-procedure.html\" title=\"13.1.15&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax\"><code>CREATE PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-server.html\" title=\"13.1.16&nbsp;CREATE SERVER Syntax\"><code>CREATE SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-table.html\" title=\"13.1.17&nbsp;CREATE TABLE Syntax\"><code>CREATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-database.html\" title=\"13.1.21&nbsp;DROP DATABASE Syntax\"><code>DROP DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-event.html\" title=\"13.1.22&nbsp;DROP EVENT Syntax\"><code>DROP EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-index.html\" title=\"13.1.24&nbsp;DROP INDEX Syntax\"><code>DROP INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-procedure.html\" title=\"13.1.26&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax\"><code>DROP PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-server.html\" title=\"13.1.27&nbsp;DROP SERVER Syntax\"><code>DROP SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-table.html\" title=\"13.1.28&nbsp;DROP TABLE Syntax\"><code>DROP TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/rename-table.html\" title=\"13.1.33&nbsp;RENAME TABLE Syntax\"><code>RENAME TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/truncate-table.html\" title=\"13.1.34&nbsp;TRUNCATE TABLE Syntax\"><code>TRUNCATE TABLE</code></a>.</p><p><em>√&nbsp; A pending transaction in the session is committed.</em></p>",
                "answers": [
                    "<p>All data along with the table structure is deleted.</p>",
                    "<p>A pending transaction in the session is committed.</p>",
                    "<p>All indexes on the table remain but they are invalidated.</p>",
                    "<p>All views and synonyms on the table remain but they are invalidated.</p>",
                    "<p>All data in the table is deleted but the table structure remains.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "d"
            ],
            "section": "DROP TABLE",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1DROP&nbsp;TABLE products;\nGiven: The command has been executed.Identify the true statements regarding the implication of this command. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919455,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_name || 'it's not available for order'\nFROM product_information\nWHERE&nbsp;product_status = 'obsolete';</pre><p><br></p><p><strong>Given: </strong>The following error has been generated by executing the above query.</p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">ERROR\nORA-01756: quoted string not properly terminated</pre><p><br></p><p>Which of the following is the proper action to be taken?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Alternative Quoting Mechanism (''Q'') for String Literals](https://livesql.oracle.com/apex/livesql/file/content_CIREYU9EA54EOKQ7LAMZKRF6P.html)"
                ],
                "feedbacks": [
                    "Removing the single quotation marks enclosing the character literal string in the SELECT clause would result in a syntax error as the single quotation marks are necessary to denote a character literal in SQL.",
                    "Using the escape character to negate the single quotation mark within the literal character string in the SELECT clause may not be the best approach as it can make the query more complex and error-prone. It is not a standard practice in SQL.",
                    "Enclosing the character literal string in the SELECT clause within double quotation marks is not the correct action to take as double quotation marks are typically used for identifiers in SQL, not for character literals. Using double quotation marks in this context would not resolve the issue.",
                    "Using the Oracle (q) operator and delimiter to allow the use of a single quotation mark within the literal character string in the SELECT clause is the proper action to take in this scenario. The (q) operator allows for the inclusion of single quotation marks within a character literal without causing syntax errors."
                ],
                "explanation": "<p>The correct action to resolve the <strong>ORA-01756: quoted string not properly terminated</strong> error is: <strong>Use the Oracle (q) operator and delimiter to allow the use of a single quotation mark within the literal character string in the SELECT clause.</strong></p><p>Here’s why:<br>The issue arises because the string <code>'it's not available for order'</code> contains an <strong>unescaped single quote</strong> in <code>it's</code>, which prematurely ends the string. Oracle interprets that as the end of the literal, causing a syntax error.</p><p>To fix it, you can use the <code><strong>q</strong></code><strong> operator</strong>, which allows you to define your own delimiters for string literals. For example:</p><pre class=\"prettyprint linenums\">SELECT product_name || q'[it's not available for order]'\nFROM product_information\nWHERE product_status = 'obsolete';\n</pre><p><br></p><p>This way, Oracle treats everything between <code>[ ]</code> as a single string, including the <code>'</code> in <code>it's</code>.</p><p><br></p><p><strong>Alternative Quoting Mechanism (''Q'') for String Literals</strong></p><p>Oracle Database offers the ability, in both SQL and PL/SQL, to specify our own user-defined delimiters for string literals. </p><p>Here's how it works: you prefix your literal with the letter \"q\". Then you type a single quote, followed by your starting delimiter for the literal. Then you type your literal string without having to double up on your single quote characters. When you have typed in your full literal, terminate it with your ending delimiter, followed by a single quote. In other words, you will follow this general format: q'[your string here]' where \"[\" represents (and certainly could be used for) the starting delimiter, and \"]\" represents the ending delimiter. </p><p>Oracle automatically recognizes \"paired\" delimiters, such as [], {}, (), and &lt;&gt;. </p><p>If you want to use some other character as your start delimiter and it doesn't have a \"natural\" partner for termination, you must use the same character for start and end delimiters. </p><p>Finally, if you choose a character for a delimiter and it appears in your string immediately before a single quotation mark, Oracle will be unhappy and raise an error.</p><p><br></p><p><strong>Traditional \"Doubling-Up\" of Single Quotes</strong></p><p><br></p><pre class=\"prettyprint linenums\">BEGIN  \n   DBMS_OUTPUT.put_line ('That''s a really funny ''joke''.');  \nEND; \n</pre><p>That's a really funny 'joke'.</p><p><br></p><p><strong>Using Paired Symbols</strong></p><pre class=\"prettyprint linenums\">BEGIN  \n    DBMS_OUTPUT.PUT_LINE (  \n       q'[What's a quote among friends?]');  \nEND; \n</pre><p>What's a quote among friends?</p><p><br></p><p><strong>Replacement for Single Quote</strong></p><pre class=\"prettyprint linenums\">BEGIN  \n    DBMS_OUTPUT.PUT_LINE (  \n       q'!What's a quote among friends?!');  \nEND; \n</pre><p>What's a quote among friends?</p>",
                "answers": [
                    "<p>Remove the single quotation marks enclosing the character literal string in the SELECT clause</p>",
                    "<p>Use the escape character to negate the single quotation mark within the literal character string in the SELECT clause</p>",
                    "<p>Enclose the character literal string in the SELECT clause within double quotation marks</p>",
                    "<p>Use the Oracle (q) operator and delimiter to allow the use of a single quotation mark within the literal character string in the SELECT clause</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT product_name || 'it's not available for order'\nFROM product_information\nWHERE&nbsp;product_status = 'obsolete';Given: The following error has been generated by executing the above query.Exhibit: 2ERROR\nORA-01756: quoted string not properly terminatedWhich of the following is the proper action to be taken?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919457,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS tables.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE department_details(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ndepartment_name VARCHAR2(50),\nhod VARCHAR2(50)\n);\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">CREATE&nbsp;TABLE&nbsp;course_details(\ncourse_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ncourse_name VARCHAR2(50),\ndepartment_id VARCHAR2(50),\ndepartment_id NUMBER&nbsp;REFERENCES department_details(department_id));\n</pre><p><br></p><p><strong>Required:</strong> Generate a list of all department IDs along with any course IDs that may have been assigned to them.&nbsp; </p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Joins](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Joins.html)"
                ],
                "feedbacks": [
                    "This query uses a RIGHT OUTER JOIN, which will return all records from the course_details table and the matching records from the department_details table. However, the requirement is to list all department IDs along with any course IDs assigned to them, so a LEFT OUTER JOIN should be used instead.",
                    "This query correctly uses a LEFT OUTER JOIN, which will return all records from the department_details table and the matching records from the course_details table. This is the appropriate join type to use in this scenario to list all department IDs along with any course IDs assigned to them.",
                    "This query uses a LEFT OUTER JOIN, but the tables are joined in the opposite order compared to the requirement. The department_details table should be on the left side of the join to list all department IDs along with any course IDs assigned to them.",
                    "This query uses a RIGHT OUTER JOIN, which will return all records from the course_details table and the matching records from the department_details table. However, the requirement is to list all department IDs along with any course IDs assigned to them, so a LEFT OUTER JOIN should be used instead."
                ],
                "explanation": "<p>The correct SQL query to generate a list of <strong>all department IDs</strong> along with any <strong>associated course IDs</strong>—even if a department has no courses—is:</p><pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id \nFROM department_details d \nLEFT OUTER JOIN course_details c \nON (d.department_id = c.department_id);\n</pre><p>Here’s why this works:</p><ul><li><p>A <strong>LEFT OUTER JOIN</strong> ensures all rows from the <code>department_details</code> table are included, even if there’s no matching <code>course_details</code> row.</p></li><li><p>This satisfies the requirement to list <strong>all departments</strong>, regardless of whether they have courses assigned.</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-26_19-17-19-132f9553a9f3efd4138becf8ca66ff98.png\"></p><p><br></p><p>The other options either reverse the join direction or use a <code>RIGHT OUTER JOIN</code>, which would prioritize courses over departments—not what we want here.</p><p><br></p><p>Oracle <code>JOINS</code> are used to retrieve data from multiple tables. An Oracle <code>JOIN</code> is performed whenever two or more tables are joined in a SQL statement.</p><p><strong>There are 4 different types of Oracle joins:</strong></p><p>Oracle <code>INNER JOIN</code> (or sometimes called simple join)</p><p>Oracle <code>LEFT OUTER JOIN</code> (or sometimes called <code>LEFT JOIN</code>)</p><p>Oracle <code>RIGHT OUTER JOIN</code> (or sometimes called <code>RIGHT JOIN</code>)</p><p>Oracle <code>FULL OUTER JOIN</code> (or sometimes called <code>FULL JOIN</code>)</p><p><br></p><p>The below query is correct because we want all department_id's located in department_details, with only the course_id's that correspond in course_details.&nbsp; To do this, the RIGHT or LEFT on the OUTER JOIN is needed to be pointing to the department_details table that is either on the right or left side of the outer join. </p><p><br></p><pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id \nFROM department_details d \nLEFT OUTER JOIN course_details c \nON (d.department_id=c. department_id); </pre><p><br></p><p>This query has a <code>LEFT OUTER JOIN</code> with department_details on the left side of the join clause.</p><p><br></p><p><strong>LEFT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>LEFT OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table specified in the <code>ON</code> condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p>Syntax</p><p>The syntax for the Oracle <code>LEFT OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nLEFT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>LEFT OUTER JOIN</code> keywords are replaced with LEFT JOIN.</p><p>Visual Illustration</p><p>In this visual diagram, the Oracle <code>LEFT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-17-2ee387b09bb38b1b8dc835df5f025fa0.png\"></p><p>The Oracle <code>LEFT OUTER JOIN</code> would return the all records from <em>table1</em> and only those records from <em>table2</em> that intersect with <em>table1</em>.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id&nbsp; \nFROM department_details d&nbsp; \nRIGHT OUTER JOIN course_details c&nbsp; \nON (d.department_id=c.department_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id \nFROM department_details d \nLEFT OUTER JOIN course_details c \nON (d.department_id = c.department_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id&nbsp; \nFROM course_details c&nbsp; \nLEFT OUTER JOIN department_details d&nbsp; \nON (c.department_id=d.department_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_id, c.course_id&nbsp; \nFROM department_details d&nbsp; \nRIGHT OUTER JOIN course_details c&nbsp; \nON (c.department_id=d.department_id);</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the commands used to create DEPARTMENT_DETAILS and COURSE_DETAILS tables.Exhibit 1:CREATE TABLE department_details(\ndepartment_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ndepartment_name VARCHAR2(50),\nhod VARCHAR2(50)\n);\nExhibit 2:CREATE&nbsp;TABLE&nbsp;course_details(\ncourse_id NUMBER&nbsp;PRIMARY&nbsp;KEY,\ncourse_name VARCHAR2(50),\ndepartment_id VARCHAR2(50),\ndepartment_id NUMBER&nbsp;REFERENCES department_details(department_id));\nRequired: Generate a list of all department IDs along with any course IDs that may have been assigned to them.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919459,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding a self join. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Self Join](https://www.oracletutorial.com/oracle-basics/oracle-self-join/)",
                    "[What is Self Join in Oracle?](https://www.w3resource.com/oracle/joins/oracle-self-join.php)"
                ],
                "feedbacks": [
                    "A self join can be a left outer join, where all the rows from the left table are included in the result set, along with matching rows from the right table if any.",
                    "A self join does not have to be a full outer join. It can be any type of join, including inner join, left outer join, right outer join, or cross join.",
                    "A self join can be an inner join, where only the rows with matching values in the join key column are included in the result set.",
                    "A self join does not have to be an equijoin, where the join condition involves equality between columns. It can involve any type of join condition, such as inequality or range conditions.",
                    "The join key column in a self join does not necessarily have to have an index. While an index can improve performance, it is not a requirement for a self join to function correctly."
                ],
                "explanation": "<p>The two <strong>true statements</strong> regarding a self join are:</p><ol><li><p><strong>It can be a left outer join</strong> – Absolutely. A self join is just a regular join where a table is joined to itself. You can use any type of join—<strong>inner</strong>, <strong>left outer</strong>, or even <strong>right/full outer</strong>—depending on what you're trying to retrieve.</p></li><li><p><strong>It can be an inner join</strong> – Also true. In fact, inner self joins are quite common when comparing rows within the same table based on some condition (like finding employees who report to the same manager).</p></li></ol><p>The other options are <strong>not necessarily true</strong>:</p><ul><li><p>A self join <strong>does not have to be</strong> a full outer join—it depends on the use case.</p></li><li><p>It <strong>does not have to be</strong> an equijoin; you can use other conditions like inequalities.</p></li><li><p>The join key <strong>does not require</strong> an index, although having one can improve performance.</p></li></ul><p><br></p><p><strong>Oracle Self Join</strong></p><p>A self join is a join that joins a table with itself. A self join is useful for comparing rows within a table or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\">querying</a> hierarchical data.</p><p>A self join uses other <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-joins/\">joins</a> such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">inner join</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-left-join/\">left join</a>. In addition, it uses the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-alias/\">table alias</a> to assign the table different names in the same query.</p><p><em>√&nbsp; It can be an inner join.</em></p><p><strong>Note: </strong> Referencing the same table more than once in a query without using <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-alias/\">table aliases</a> cause an error.</p><p>• To join a table itself means that each row of the table is combined with itself and with every other row of the table.</p><p>• The table appears twice in the FROM clause and is followed by table aliases that qualify column names in the join condition.</p><p>• The self join can be viewed as a join of two copies of the same table. The table is not actually copied, but SQL performs the command as though it were.</p><p>• To perform a self join, Oracle Database combines and returns rows of the table that satisfy the join condition (index).</p><p><strong>Syntax:</strong></p><p><br></p><pre class=\"prettyprint linenums\">SELECT a.column_name, b.column_name... \nFROM table1 a, table1 b \nWHERE a.common_filed = b.common_field;</pre><p><br></p><p><em>√&nbsp; It can be a left outer join.</em></p>",
                "answers": [
                    "<p>It can be a left outer join.</p>",
                    "<p>It must be a full outer join.</p>",
                    "<p>It can be an inner join.</p>",
                    "<p>It must be an equijoin.</p>",
                    "<p>The join key column must have an index.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding a self join. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919487,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CUST_NAME\nRenske Ladwig\nJason Mallin\nSamuel McCain\nAllan MCEwen\nIrene Mikkilineni\nJulia Nayer</pre><p><br></p><p><strong>Required: </strong></p><ol><li><p>Add new columns to the table with the names ADDRESS, CITY, PROVINCE_STATE, COUNTRY_CODE, and TELEPHONE. </p></li><li><p>Each column is to be text with the ability to hold up to 30 characters, except COUNTRY_CODE and TELEPHONE which is to be a number which should hold up to 3 and 12 respectively. </p></li><li><p>The TELEPHONE field must be the primary key.</p></li></ol><p><strong>Given:</strong> The CUST_NAME is the only column in this table which has the above data in the table. The below query has been run and failed.</p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">ALTER&nbsp;TABLE&nbsp;customers\nADD (\naddress VARCHAR2(30),\ncity VARCHAR2(30),\nprovince_state VARCHAR2(30),\ncountry_code NUMBER(3),\ntelephone NUMBER(12),\nCONSTRAINT telephone_pk PRIMARY&nbsp;KEY(telephone)\n);\n</pre><p><br></p><p>Identify the reason the SQL query fails.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ALTER TABLE Statement](https://www.techonthenet.com/oracle/tables/alter_table.php)"
                ],
                "feedbacks": [
                    "The syntax of the ALTER TABLE statement is correct for adding new columns to an existing table. The issue lies elsewhere in the query.",
                    "It is possible to add columns to an existing table in Oracle using the ALTER TABLE statement. This is not the reason for the query failure.",
                    "The correct syntax for adding columns to an existing table in Oracle is ALTER TABLE, not MODIFY TABLE. However, this is not the reason for the query failure.",
                    "Constraints can be added to a table after it has been created in Oracle. This is not the reason for the query failure.",
                    "The table being empty or not does not impact the ability to add new columns to an existing table in Oracle. This is not the reason for the query failure.",
                    "The query fails because the TELEPHONE field is defined as the primary key (CONSTRAINT telephone_pk PRIMARY KEY(telephone)), but it is not marked as mandatory (NOT NULL). In Oracle, a primary key column must also be marked as NOT NULL."
                ],
                "explanation": "<p>The most likely reason the SQL query fails is: <strong>The table must be empty to add mandatory (NOT NULL) column.</strong></p><p>Here's why:</p><ul><li><p><strong>No </strong><code><strong>NOT NULL</strong></code><strong> specified, but Primary Keys are implicitly </strong><code><strong>NOT NULL</strong></code><strong>:</strong> While the <code>ALTER TABLE</code> statement doesn't explicitly include <code>NOT NULL</code> for the new columns, the <code>TELEPHONE</code> column is being designated as a <code>PRIMARY KEY</code>. A fundamental rule for primary keys in SQL is that they cannot contain <code>NULL</code> values.</p></li><li><p><strong>Existing data in </strong><code><strong>CUST_NAME</strong></code><strong>:</strong> The problem statement clearly indicates that the <code>CUSTOMERS</code> table already contains data in the <code>CUST_NAME</code> column.</p></li><li><p><strong>Adding a non-nullable column to a non-empty table:</strong> When you add a new column that implicitly or explicitly has a <code>NOT NULL</code> constraint to a table that already contains rows, the database doesn't know what values to put into this new, non-nullable column for the existing rows. This causes the <code>ALTER TABLE</code> statement to fail.</p></li></ul><p>Let's look at why the other options are less likely or incorrect:</p><ul><li><p><strong>The syntax of the ALTER TABLE statement is incorrect.</strong> The syntax used in Exhibit 2 for <code>ALTER TABLE</code> and <code>ADD</code> is generally correct for adding multiple columns and a constraint in Oracle (which <code>VARCHAR2</code> and <code>NUMBER</code> types suggest).</p></li><li><p><strong>You cannot add columns to an existing table.</strong> This is false. <code>ALTER TABLE ADD COLUMN</code> (or <code>ADD</code> in Oracle) is a standard SQL command to add columns to an existing table.</p></li><li><p><strong>The syntax should be MODIFY TABLE, not ALTER TABLE.</strong> While <code>MODIFY</code> is used in <code>ALTER TABLE</code> to change existing columns, <code>ADD</code> is the correct keyword for adding new ones. <code>MODIFY TABLE</code> as a standalone statement is not standard SQL.</p></li><li><p><strong>Constraints cannot be added after a table has been created.</strong> This is false. Constraints, including primary keys, can be added to an existing table using <code>ALTER TABLE ADD CONSTRAINT</code>.</p></li><li><p><strong>The table must be empty to add columns.</strong> This is too broad. You <em>can</em> add nullable columns to a non-empty table. The issue arises specifically when adding non-nullable columns (like a primary key) to a non-empty table without providing default values.</p></li></ul><p><strong>The Oracle ALTER TABLE </strong>statement is used to add, modify, or drop/delete columns in a table. The Oracle ALTER TABLE statement is also used to rename a table.</p><p><strong>Add column in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD COLUMN</code> in a table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name column_definition;</pre><p><br></p><p><strong>Add multiple columns in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD MULTIPLE COLUMNS</code> to an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD (column_1 column_definition,\n       column_2 column_definition,\n       ...\n       column_n column_definition);</pre>",
                "answers": [
                    "<p>The syntax of the ALTER TABLE statement is incorrect.</p>",
                    "<p>You cannot add columns to an existing table.</p>",
                    "<p>The syntax should be MODIFY TABLE, not ALTER TABLE.</p>",
                    "<p>Constraints cannot be added after a table has been created.</p>",
                    "<p>The table must be empty to add columns.</p>",
                    "<p>The table must be empty to add mandatory (NOT NULL) column.</p>"
                ]
            },
            "correct_response": [
                "f"
            ],
            "section": "ALTER",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Exhibit: 1CUST_NAME\nRenske Ladwig\nJason Mallin\nSamuel McCain\nAllan MCEwen\nIrene Mikkilineni\nJulia NayerRequired: Add new columns to the table with the names ADDRESS, CITY, PROVINCE_STATE, COUNTRY_CODE, and TELEPHONE. Each column is to be text with the ability to hold up to 30 characters, except COUNTRY_CODE and TELEPHONE which is to be a number which should hold up to 3 and 12 respectively. The TELEPHONE field must be the primary key.Given: The CUST_NAME is the only column in this table which has the above data in the table. The below query has been run and failed.Exhibit: 2ALTER&nbsp;TABLE&nbsp;customers\nADD (\naddress VARCHAR2(30),\ncity VARCHAR2(30),\nprovince_state VARCHAR2(30),\ncountry_code NUMBER(3),\ntelephone NUMBER(12),\nCONSTRAINT telephone_pk PRIMARY&nbsp;KEY(telephone)\n);\nIdentify the reason the SQL query fails.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919489,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and review the following available responses.</p><p>Identify the true statements regarding the removal of columns from a table. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Dropping Columns](https://oracle-base.com/articles/8i/dropping-columns)"
                ],
                "feedbacks": [
                    "Setting a column as unused or dropping it are both valid actions to remove a column from queries. Setting a column as unused will keep the column metadata but exclude it from queries, while dropping a column will permanently remove it from the table structure.",
                    "<p>Dropping a column from a table will cause all unused columns in that table to be dropped at the same time.</p>",
                    "When a column is marked as unused, it will not be visible in queries, and it will also not be visible to other users. Marking a column as unused effectively hides it from all interactions with the table.",
                    "The correct syntax to physically drop a column from a table in Oracle Database SQL is:\nALTER TABLE table_name DROP COLUMN column_name;\nUsing the correct syntax is crucial to successfully removing a column from a table.",
                    "In Oracle Database SQL, a logical delete and a physical delete are not the same thing. A logical delete typically involves marking a record as deleted without physically removing it from the table, while a physical delete actually removes the record from the table. These are distinct actions with different implications for data management."
                ],
                "explanation": "<p>The two <strong>true statements</strong> regarding the removal of columns from a table are:</p><ol><li><p><strong>It is possible to set a column as unused or drop it. Both actions will remove the column from queries.</strong><br>– Correct. In Oracle, marking a column as <code>UNUSED</code> makes it invisible to queries and applications, and it can later be physically dropped using <code>DROP UNUSED COLUMNS</code>.</p></li><li><p><strong>Dropping a column from a table will cause all columns marked as UNUSED in that table to be dropped at the same time.</strong><br>– Also true. When you issue <code>ALTER TABLE ... DROP UNUSED COLUMNS</code>, Oracle removes <em>all</em> columns previously marked as unused in that table in one go.</p></li></ol><p>The other statements are <strong>not true</strong>:</p><ul><li><p>A column marked as <code>UNUSED</code> is <strong>not visible</strong> in queries at all—not even to the user who marked it.</p></li><li><p>The syntax <code>DROP COLUMN column_name FROM table_name;</code> is incorrect. The correct Oracle syntax is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP COLUMN column_name;\n</pre></li><li><p>A <strong>logical delete</strong> (like setting a column as unused) and a <strong>physical delete</strong> (like dropping the column) are <strong>not the same</strong>—the former is reversible until physically dropped.</p></li></ul><p><strong>Dropping Columns</strong></p><p>Oracle 8i introduced the ability to drop a column from a table. Prior to this it was necessary to drop the entire table and rebuild it. Now you can mark a column as unused (logical delete) or delete it completely (physical delete).</p><p>√&nbsp; It is possible to set a column as unused or drop it. Both actions will remove the column from queries.</p><p><br></p><p><strong>Logical Delete</strong></p><p>On large tables the process of physically removing a column can be very time and resource consuming. For this reason you may decide to logically delete it.</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name SET UNUSED (column_name);\nALTER TABLE table_name SET UNUSED (column_name1, column_name2);</pre><p><br></p><p>Once this is done the columns will no longer be visible to the user. If at a later date you have time to physically delete the columns this can be done using the following.</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP UNUSED COLUMNS;</pre><p><br></p><p>On large tables you can reduce the amount of undo logs accumulated by using the <code>CHECKPOINT</code> option which forces a checkpoint after the specified number of rows have been processed.</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP UNUSED COLUMNS CHECKPOINT 250;</pre><p><br></p><p>The <code>DBA_UNUSED_COL_TABS</code> view can be used to view the number of unused columns per table.</p><p><br></p><p><strong>Physical Delete</strong></p><p>To physically drop a column you can use one of the following syntaxes, depending on whether you wish to drop a single or multiple columns.</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name DROP COLUMN column_name;\nALTER TABLE table_name DROP (column_name1, column_name2);</pre><p><br></p><p>Dropping a column from a table will cause all unused columns in that table to be dropped at the same time.</p><p><em>√&nbsp; Dropping a column from a table will cause all unused columns in that table to be dropped at the same time.</em></p>",
                "answers": [
                    "<p>It is possible to set<em> </em>a column as unused or drop it. Both actions will remove the column from queries.</p>",
                    "<p>Dropping a column from a table will cause all columns marked as <code>UNUSED</code> in that table to be dropped at the same time.</p>",
                    "<p>Once a column is marked as unused, it will still show in a query but will no longer be visible to other users.</p>",
                    "<p>To physically drop a column you can use the following syntax.</p><pre class=\"prettyprint linenums\">DROP COLUMN column_name FROM table_name;</pre>",
                    "<p>A logical delete physical delete are the same thing.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "ALTER",
            "question_plain": "View and review the following available responses.Identify the true statements regarding the removal of columns from a table. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919461,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in the PRODUCTS table. </p><p><strong>Table: PRODUCTS </strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-12_22-07-12-6fbf7aad7f6d3eb33f4b57ecd7689b39.png\"></p><p><br></p><p><strong>Required:</strong> Display product names from the PRODUCTS table that belong to the 'Software/other' category with minimum prices as either $2000 or $4000 and with no unit of measure.&nbsp; </p><p><strong>Given: </strong>The following query has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT prod_name, prod_category, prod_min_price\nFROM&nbsp;products\nWHERE&nbsp;prod_category LIKE'%Other%' \n  AND&nbsp;(prod_min_price = 2000 OR prod_min_price = 4000)\n  AND&nbsp;prod_unit_of_measure &lt;&gt; ' ';</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: IS NULL Condition](https://www.techonthenet.com/oracle/isnull.php)"
                ],
                "feedbacks": [
                    "The query execution is successful, but it may return an incorrect result due to the conditions specified for the product names, minimum prices, and unit of measure. The query may not accurately filter the data based on the given criteria.",
                    "This choice is incorrect as the query may not return the required result. The conditions specified for the product names, minimum prices, and unit of measure may not accurately filter the data as per the given requirements.",
                    "The query may generate an error because the condition specified for the PROD_UNIT_OF_MEASURE column is not valid. If the unit of measure condition is not correctly defined or does not match the data in the table, an error may occur during query execution.",
                    "The query may generate an error because the condition specified for the PROD_CATEGORY column is not valid. If the category condition is not correctly defined or does not match the data in the table, an error may occur during query execution."
                ],
                "explanation": "<p>The correct answer is: <strong>It executes successfully but returns the incorrect result.</strong></p><p>Here’s why:</p><ul><li><p>The query uses <code>LIKE '%Other%'</code>, which will match any category containing \"Other\" (e.g., \"Software/Other\"), so that part is fine.</p></li><li><p>The price condition <code>(prod_min_price = 2000 OR prod_min_price = 4000)</code> is also valid.</p></li><li><p>The issue lies in this part: <code>prod_unit_of_measure &lt;&gt; ' '</code>. This condition checks for values that are <strong>not a single space</strong>, but it <strong>does not correctly identify rows where the unit of measure is missing</strong> (i.e., <code>NULL</code>).</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-27_21-36-20-c003d614fbb970662edaf2c0e3b4bf4a.png\"></p><p>In SQL, comparisons with <code>NULL</code> using <code>&lt;&gt;</code> or <code>=</code> always return unknown (i.e., false), so rows with <code>NULL</code> in <code>prod_unit_of_measure</code> will be <strong>excluded</strong>, even though the requirement is to find products with <strong>no unit of measure</strong>.</p><p>To fix it, you’d want something like:</p><pre class=\"prettyprint linenums\">... AND (prod_unit_of_measure IS NULL OR TRIM(prod_unit_of_measure) = '')\n</pre><p>That way, you catch both <code>NULL</code> and blank values.</p><p><br></p><p>Here’s the corrected SQL query that meets all the requirements:</p><pre class=\"prettyprint linenums\">SELECT prod_name, prod_category, prod_min_price\nFROM products\nWHERE prod_category = 'Software/other'\n  AND prod_min_price IN (2000, 4000)\n  AND (prod_unit_of_measure IS NULL OR TRIM(prod_unit_of_measure) = '');\n</pre><p>Why this works:</p><ul><li><p><code><strong>prod_category = 'Software/other'</strong></code> ensures you're only pulling from the exact category.</p></li><li><p><code><strong>prod_min_price IN (2000, 4000)</strong></code> simplifies the price filter.</p></li><li><p><code><strong>prod_unit_of_measure IS NULL OR TRIM(...) = ''</strong></code> captures both missing and blank unit values.</p></li></ul><p><br></p><p><strong>The Oracle IS NULL</strong> condition is used to test for a NULL value. You can use the Oracle IS NULL condition in either a SQL statement or in a block of PLSQL code.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>IS&nbsp;NULL</code> condition in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">expression IS NULL</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - The value to test whether it is a null value.</p><p><strong>Note</strong></p><p>If <em>expression</em> is a NULL value, the condition evaluates to TRUE.</p><p>If <em>expression</em> is not a NULL value, the condition evaluates to FALSE.</p>",
                "answers": [
                    "<p>It executes successfully but returns the incorrect result.</p>",
                    "<p>It executes successfully and returns the required result.</p>",
                    "<p>It generates an error because the condition specified for PROD_UNIT_OF_MEASURE is not valid.</p>",
                    "<p>It generates an error because the condition specified for the PROD_CATEGORY column is not valid.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the data in the PRODUCTS table. Table: PRODUCTS Required: Display product names from the PRODUCTS table that belong to the 'Software/other' category with minimum prices as either $2000 or $4000 and with no unit of measure.&nbsp; Given: The following query has been executed.Exhibit: 1SELECT prod_name, prod_category, prod_min_price\nFROM&nbsp;products\nWHERE&nbsp;prod_category LIKE'%Other%' \n  AND&nbsp;(prod_min_price = 2000 OR prod_min_price = 4000)\n  AND&nbsp;prod_unit_of_measure &lt;&gt; ' ';Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919463,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given:</strong> There are employees who receive more salary than employee with employee number 6.</p><p><strong>Required:</strong> Create a report which will display the name ( first name and last name ) for those employees who receive more salary than the employee with employee number 6.</p><p>View and examine the following available responses. Identify the SQL queries which would give you the required output. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: WHERE Clause](https://www.techonthenet.com/oracle/where.php)",
                    "[Oracle / PLSQL: IN Condition](https://www.techonthenet.com/oracle/in.php)"
                ],
                "feedbacks": [
                    "This query correctly retrieves the first name and last name of employees who receive a salary greater than the employee with employee number 6 by using a subquery to compare the salary values.",
                    "<p>This query correctly retrieves the first name and last name of employees who receive a salary greater than the employee with employee number 6 by using a subquery with the IN operator to compare the salary values.</p>",
                    "This query has a syntax error as the IN operator is used incorrectly in the subquery. It should be used with a list of values, not with a single value like in this case.",
                    "This query has a syntax error as the SELECT statement within the subquery is missing the FROM clause. It should specify the table from which to select the salary value.",
                    "This query has a syntax error as the IN operator is used incorrectly in the subquery. It should be used with a list of values, not with a single value like in this case. Additionally, the parentheses around the value 6 are unnecessary."
                ],
                "explanation": "<p>The two <strong>correct SQL queries</strong> that will return the required output are:</p><ol><li><pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees \nWHERE salary &gt; \n  (SELECT salary  \n   FROM employees \n   WHERE employee_id = 6);\n</pre></li><li><pre class=\"prettyprint linenums\">SELECT first_name, last_name\nFROM employees\nWHERE salary &gt; (\n    SELECT salary\n    FROM employees\n    WHERE employee_id IN (6)\n);\n</pre></li></ol><p>Why these work:</p><ul><li><p>Both use a <strong>subquery</strong> to retrieve the salary of the employee with <code>employee_id = 6</code>.</p></li><li><p>The outer query then compares each employee’s salary to that value.</p></li><li><p><code>employee_id IN (6)</code> is functionally equivalent to <code>= 6</code> in this context, though <code>IN</code> is more flexible for multiple values.</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-27_22-26-28-43dca51a0d0e5ef51c86fffdf45ce037.png\"></p><p><br></p><p>Why the others fail:</p><ul><li><p><code>employee_id = IN (6)</code> is <strong>invalid syntax</strong>.</p></li><li><p><code>SELECT salary WHERE employee_id = 6</code> is missing the <code>FROM</code> clause — also invalid.</p></li><li><p><code>employee_id = (6)</code> is syntactically incorrect unless used in a specific context with a subquery.</p></li></ul><p><br></p><p><strong>The Oracle WHERE</strong> clause is used to filter the results from a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>WHERE</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">WHERE conditions;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>conditions - The conditions that must be met for records to be selected.</p><p><strong>The Oracle IN condition</strong> is used to help reduce the need to use multiple <a href=\"https://www.techonthenet.com/oracle/or.php\">OR conditions</a> in a SELECT, INSERT, UPDATE, or DELETE statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>IN</code> condition in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">expression IN (value1, value2, ... value_n);</pre><p><br></p><p>OR</p><p><br></p><pre class=\"prettyprint linenums\">expression IN (subquery);</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - The value to test. </p><p>value1, value2, ... value_n - The values to test against <em>expression</em>. subquery This is a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT statement</a> whose result set will be tested against <em>expression</em>. If any of these values matches <em>expression</em>, then the IN condition will evaluate to true.</p><p><strong>Note</strong></p><p>The Oracle IN condition will return the records where <em>expression</em> is <em>value1</em>, <em>value2</em>..., or <em>value_n</em>.</p><p>The Oracle IN condition is also called the Oracle IN operator.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees \nWHERE salary &gt; \n  (SELECT salary  \n   FROM employees \n   WHERE employee_id = 6);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name\nFROM employees\nWHERE salary &gt; (\n    SELECT salary\n    FROM employees\n    WHERE employee_id IN (6)\n);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name\nFROM employees\nWHERE salary &gt; (\n&nbsp; &nbsp; SELECT salary\n&nbsp; &nbsp; FROM employees\n&nbsp; &nbsp; WHERE employee_id = IN (6)\n);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees \nWHERE salary &gt; ( \n&nbsp; &nbsp; &nbsp;SELECT salary&nbsp; \n&nbsp; &nbsp; &nbsp;WHERE employee_id = 6\n);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, last_name \nFROM employees \nWHERE salary &gt; ( \n&nbsp; &nbsp; &nbsp;SELECT salary&nbsp; \n&nbsp; &nbsp; &nbsp;WHERE employee_id = (6)\n);</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following scenario.Given: There are employees who receive more salary than employee with employee number 6.Required: Create a report which will display the name ( first name and last name ) for those employees who receive more salary than the employee with employee number 6.View and examine the following available responses. Identify the SQL queries which would give you the required output. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919465,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following data listing for a table STUDENTS:.</p><p><strong>Table: STUDENTS</strong></p><pre class=\"prettyprint linenums\">ROWNUM         ID              NAME                 SCORE\n1              1               JONES\n2              2               SMITH                20\n3\n4              3                                    15\n5              4               SIMPSON              25</pre><p><br></p><p><strong>Given:</strong></p><ul><li><p>ROWNUM is a pseudocolumn.</p></li><li><p>Row 3 is completely NULL. </p></li><li><p>The SCORE for JONES is NULL.&nbsp; </p></li></ul><p>Examine the following SELECT statement.&nbsp; &nbsp; </p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT COUNT(*), AVG(SCORE)\nFROM students;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: COUNT Function](https://www.techonthenet.com/oracle/functions/count.php)",
                    "[Oracle / PLSQL: AVG Function](https://www.techonthenet.com/oracle/functions/avg.php)"
                ],
                "feedbacks": [
                    "The query uses ROWNUM to assign a unique row number to each row in the result set. Since row 3 is completely NULL, it will not be included in the result set. Therefore, the query will return the row numbers 3 and 15.",
                    "The query excludes the row that is completely NULL (row 3) and displays the row number and score for the remaining rows. Therefore, the query will return the row numbers 5 and 20.",
                    "The query excludes the row that is completely NULL (row 3) but includes the row with a NULL score for JONES. Therefore, the query will return the row numbers 3 and 20.",
                    "The query does not have any syntax errors or logical issues that would cause it to return an error. It may exclude rows with NULL values, but it will still execute successfully.",
                    "The query uses ROWNUM to assign a unique row number to each row in the result set. Since row 3 is completely NULL, it will not be included in the result set. Therefore, the query will return the row numbers 4 and 15.",
                    "The query uses ROWNUM to assign a unique row number to each row in the result set. Since row 3 is completely NULL, it will not be included in the result set. Therefore, the query will return the row numbers 2 and 12.5."
                ],
                "explanation": "<p>The correct result of the query execution is: <strong>5,20</strong></p><p>Here’s why:</p><ul><li><p><code>COUNT(*)</code> counts <strong>all rows</strong>, including those with <code>NULL</code> values in any column — so it returns <strong>5</strong>.</p></li><li><p>Even though row 3 is completely <code>NULL</code>, the <code>COUNT</code> function will count it as a valid row when using the asterisk feature. </p></li><li><p><code>AVG</code> will ignore <code>NULL</code> values when computing averages.</p></li><li><p><code>AVG(SCORE)</code> calculates the average of <strong>non-NULL</strong> values in the <code>SCORE</code> column. The non-null scores are: 20, 15, and 25.<br>So, <strong>(20 + 15 + 25) / 3 = 60 / 3 = 20</strong></p></li></ul><p>Therefore, the query returns: <code><strong>5,20</strong></code></p><p><br></p><p><strong>The Oracle/PLSQL COUNT</strong> function returns the count of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>COUNT</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>COUNT</code> function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the <code>COUNT</code> function and must be included in the <code>GROUP BY</code> clause at the end of the SQL statement. </p><p>aggregate_expression - This is the column or expression whose non-null values will be counted. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The COUNT function returns a numeric value.</p><p>The Oracle/PLSQL AVG function returns the average value of an expression.</p><p>Syntax</p><p>The syntax for the AVG function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT AVG(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the AVG function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       AVG(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the <code>AVG</code> function and must be included in the <code>GROUP BY</code> clause at the end of the SQL statement. aggregate_expression This is the column or expression that will be averaged. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>AVG</code> function returns a numeric value.</p><p>Even though row 3 is completely <code>NULL</code>, the <code>COUNT</code> function will count it as a valid row when using the asterisk feature. </p><p><code>AVG</code> will ignore <code>NULL</code> values when computing averages.</p><p><em>√&nbsp; 5,20</em></p>",
                "answers": [
                    "<p>3,15</p>",
                    "<p>5,20</p>",
                    "<p>3,20</p>",
                    "<p>The query would return an error.</p>",
                    "<p>4,15</p>",
                    "<p>2,12.5</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following data listing for a table STUDENTS:.Table: STUDENTSROWNUM         ID              NAME                 SCORE\n1              1               JONES\n2              2               SMITH                20\n3\n4              3                                    15\n5              4               SIMPSON              25Given:ROWNUM is a pseudocolumn.Row 3 is completely NULL. The SCORE for JONES is NULL.&nbsp; Examine the following SELECT statement.&nbsp; &nbsp; Exhibit 1:SELECT COUNT(*), AVG(SCORE)\nFROM students;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919467,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required: </strong></p><ul><li><p>Using the CUSTOMERS table, you need to generate a report that shows 50% of each credit amount in each income level. </p></li><li><p>The report should NOT show any repeated credit amounts in each income level.&nbsp; </p></li></ul><p>Identify the best SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DISTINCT Clause](https://www.techonthenet.com/oracle/distinct.php)"
                ],
                "feedbacks": [
                    "This query selects distinct income levels from the CUSTOMERS table and calculates 50% of each credit limit without showing any repeated credit amounts. It meets the requirements of the scenario by providing unique credit amounts for each income level.",
                    "This query concatenates the income level and 50% of the credit limit, but it does not ensure that the credit amounts are unique within each income level. It does not meet the requirement of the scenario to avoid repeated credit amounts.",
                    "Using two DISTINCT keywords in the same SELECT statement is not valid SQL syntax. The DISTINCT keyword should be used once to ensure unique values are returned. This query will result in a syntax error and does not provide the required output.",
                    "The DISTINCT keyword should be used before the columns in the SELECT statement to ensure unique values are returned. Placing it before the cust_credit_limit column only will not prevent repeated credit amounts within each income level. This query does not meet the requirements of the scenario.",
                    "This query concatenates the income level and 50% of the credit limit without ensuring unique credit amounts within each income level. It does not meet the requirement of the scenario to avoid repeated credit amounts."
                ],
                "explanation": "<p>The SQL query which would <strong>best</strong> give you the required output is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT DISTINCT cust_income_level, cust_credit_limit * 0.50 AS \"50% Credit Limit\"\nFROM customers;\n</pre><p><br></p><p><code><strong>SELECT DISTINCT cust_income_level, cust_credit_limit * 0.50 AS \"50% Credit Limit\"</strong></code>:</p><ul><li><p>The <code>DISTINCT</code> keyword ensures that for each <code>cust_income_level</code>, you will only get unique calculated \"50% Credit Limit\" values. If multiple customers in the same <code>cust_income_level</code> have the same original <code>cust_credit_limit</code> (and thus the same 50% value), only one instance of that combination will appear in the report. This directly addresses the requirement \"The report should NOT show any repeated credit amounts in each income level.\"</p></li><li><p>It keeps <code>cust_income_level</code> and the calculated <code>50% Credit Limit</code> as separate columns. This is crucial for:</p><ul><li><p><strong>Readability:</strong> The output is structured and easy to interpret.</p></li><li><p><strong>Data Type Integrity:</strong> The income level remains its original data type (e.g., text), and the credit limit remains a numeric type, allowing for proper sorting, filtering, and potential future calculations or formatting (e.g., currency display).</p></li><li><p><strong>Flexibility:</strong> If you later need to sort by income level, then by credit limit, or perform aggregations, having separate columns is essential.</p></li></ul></li></ul><p><strong>Why the other options are not ideal or incorrect:</strong></p><ul><li><p><code><strong>SELECT DISTINCT cust_income_level || ' ' || cust_credit_limit * 0.50 AS \"50% Credit Limit\" FROM customers;</strong></code></p><ul><li><p>While this query would also produce distinct <em>combined strings</em>, it concatenates the income level and the calculated credit limit into a single text string. This makes the data less usable for sorting by numeric value, further calculations, or specific formatting (like currency). It fulfils the \"no repeated values\" but at the cost of data utility.</p></li></ul></li><li><p><code><strong>SELECT cust_income_level || ' ' || cust_credit_limit * 0.50 AS \"50% Credit Limit\" FROM customers;</strong></code></p><ul><li><p>This query does not use <code>DISTINCT</code>. Therefore, if there are multiple customers with the same income level and the same credit limit, it would show repeated entries for the 50% credit amount within that income level, which violates the requirement.</p></li></ul></li><li><p><code><strong>SELECT DISTINCT cust_income_level, DISTINCT cust_credit_limit * 0.50 AS \"50% Credit Limit\" FROM customers;</strong></code></p><ul><li><p>This syntax is incorrect. You cannot use <code>DISTINCT</code> on individual columns like this (<code>DISTINCT column1, DISTINCT column2</code>). The <code>DISTINCT</code> keyword applies to the entire set of selected columns. This query would result in a SQL error.</p></li></ul></li><li><p><code><strong>SELECT cust_income_level, DISTINCT cust_credit_limit * 0.50 AS \"50% Credit Limit\" FROM customers;</strong></code></p><ul><li><p>This syntax is also incorrect for the same reason as the previous point. <code>DISTINCT</code> must apply to all selected columns at the beginning of the <code>SELECT</code> clause, not to individual columns. This query would result in a SQL error.</p></li></ul></li></ul><p><br></p><p><strong>The Oracle DISTINCT</strong> clause is used to remove duplicates from the result set. The <code>DISTINCT</code> clause can only be used with <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DISTINCT</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT DISTINCT expressions\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p><p><strong>Note</strong></p><p>When only one expression is provided in the <code>DISTINCT</code> clause, the query will return the unique values for that expression.</p><p>When more than one expression is provided in the <code>DISTINCT</code> clause, the query will retrieve unique combinations for the expressions listed.</p><p>In Oracle, the <code>DISTINCT</code> clause doesn't ignore <code>NULL</code> values. So when using the <code>DISTINCT</code> clause in your SQL statement, your result set will include <code>NULL</code> as a distinct value.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT cust_income_level, cust_credit_limit * 0.50 AS \"50% Credit Limit\"\nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT cust_income_level || ' ' || cust_credit_limit * 0.50 AS \"50% Credit Limit\" \nFROM customers; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT cust_income_level, DISTINCT cust_credit_limit * 0.50 AS \"50% Credit Limit\" \nFROM customers; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_income_level, DISTINCT cust_credit_limit * 0.50 AS \"50% Credit Limit\" \nFROM customers; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_income_level || ' ' || cust_credit_limit * 0.50 AS \"50% Credit Limit\"&nbsp; \nFROM customers; \n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following scenario.Required: Using the CUSTOMERS table, you need to generate a report that shows 50% of each credit amount in each income level. The report should NOT show any repeated credit amounts in each income level.&nbsp; Identify the best SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919469,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the description of the ORDERS table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-38-07-722b52634a05ac5b380ffdf88849392e.png\"></p><p><br></p><p>Identify two WHERE clause conditions which demonstrate the correct usage of conversion functions. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle ADD_MONTHS Function with Examples](https://www.databasestar.com/oracle-add_months/)"
                ],
                "feedbacks": [
                    "The WHERE clause condition in Choice A attempts to use both TO_DATE and TO_CHAR functions in an incorrect way. TO_DATE is used correctly to convert a string to a date format, but TO_CHAR is used incorrectly as it should be used to convert a date to a string format.",
                    "The WHERE clause condition in Choice B uses the TO_CHAR function incorrectly. TO_CHAR is used to convert a date to a string format, but in this case, it is used to convert the result of the ADD_MONTHS function, which returns a date, to a string.",
                    "The WHERE clause condition in Choice C correctly uses the TO_CHAR function to convert the order_date column to a specific string format ('MON DD YYYY') for comparison with a specific date value ('JAN 01 2019'). This demonstrates the correct usage of conversion functions in a WHERE clause.",
                    "The WHERE clause condition in Choice D correctly uses the TO_DATE function to convert a string date value ('JUL 10 2019') to a date format for comparison with the order_date column. This demonstrates the correct usage of conversion functions in a WHERE clause."
                ],
                "explanation": "<p>The two <strong>correct WHERE clause conditions</strong> that demonstrate proper usage of conversion functions are:</p><ol><li><p><code>WHERE TO_CHAR(order_date,'MON DD YYYY') = 'JAN 01 2019'</code><br>This is valid because it converts a date column (<code>order_date</code>) to a string format for comparison with a string literal.</p></li><li><p><code>WHERE order_date &gt; TO_DATE('JUL 10 2019','MON DD YYYY')</code><br>This is also correct—it converts a string literal into a date format so it can be compared with a date column.</p></li></ol><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_12-38-26-9c8295731a2143b7e1cb782417e916f5.png\"></p><p><br></p><p>The other two options are incorrect:</p><ul><li><p><code>WHERE order_date_IN (...)</code><br>Syntax error: missing space between <code>order_date</code> and <code>IN</code>. Also, mixing <code>TO_DATE</code> and <code>TO_CHAR</code> in the same <code>IN</code> clause leads to a datatype mismatch.</p></li><li><p><code>WHERE order_date &gt; TO_CHAR(ADD_MONTHS(SYSDATE,6),'MON DD YYYY')</code><br>This compares a date (<code>order_date</code>) with a string, which is invalid unless the string is explicitly converted back to a date.</p></li></ul><p>Besides the SQL utility functions, Oracle inbuilt function library contains type conversion functions. There may be scenarios where the query expects input in a specific data type, but it receives it in a different data type. In such cases, Oracle implicitly tries to convert the unexpected value to a compatible data type which can be substituted in place and application continuity is not compromised. Type conversion can be either implicitly done by Oracle or explicitly done by the programmer.</p><p>Implicit data type conversion works based on a matrix which showcases the Oracle's support for internal type casting. Besides these rules, Oracle offers type conversion functions which can be used in the queries for explicit conversion and formatting. As a matter of fact, it is recommended to perform explicit conversion instead of relying on software intelligence. Though implicit conversion works well, but to eliminate the skew chances where bad inputs could be difficult to typecast internally.</p><p><br></p><p><strong>Implicit Data Type Conversion</strong></p><p>A <code>VARCHAR2</code> or <code>CHAR</code> value can be implicitly converted to <code>NUMBER</code> or <code>DATE</code> type value by Oracle. Similarly, a <code>NUMBER</code> or <code>DATA</code> type value can be automatically converted to character data by Oracle server. Note that the impicit interconversion happens only when the character represents the a valid number or date type value respectively.</p><p><br></p><p><strong>Explicit Data Type Conversion</strong></p><p>SQL Conversion functions are single row functions which are capable of typecasting column value, literal or an expression . <code>TO_CHAR</code>, <code>TO_NUMBER</code> and <code>TO_DATE</code> are the three functions which perform cross modification of data types.</p><p><strong>TO_CHAR function</strong></p><p><code>TO_CHAR</code> function is used to typecast a numeric or date input to character type with a format model (optional).</p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">TO_CHAR(number1, [format], [nls_parameter])</pre><p><br></p><p>For number to character conversion, nls parameters can be used to specify decimal characters, group separator, local currency model, or international currency model. It is an optional specification - if not available, session level nls settings will be used. For date to character conversion, the nls parameter can be used to specify the day and month names, as applicable.</p><p>Dates can be formatted in multiple formats after converting to character types using <code>TO_CHAR</code> function. The <code>TO_CHAR</code> function is used to have Oracle 11g display dates in a particular format. Format models are case sensitive and must be enclosed within single quotes.</p><p><strong>TO_NUMBER function</strong></p><p>The <code>TO_NUMBER</code> function converts a character value to a numeric datatype. If the string being converted contains nonnumeric characters, the function returns an error.</p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">TO_NUMBER (string1, [format], [nls_parameter])</pre><p><br></p><p><strong>TO_DATE function</strong></p><p>The function takes character values as input and returns formatted date equivalent of the same. The <code>TO_DATE</code> function allows users to enter a date in any format, and then it converts the entry into the default format used by Oracle 11g.</p><p><strong>Syntax:</strong></p><p><br></p><pre class=\"prettyprint linenums\">TO_DATE( string1, [ format_mask ], [ nls_language ] )</pre><p><br></p><p>A format_mask argument consists of a series of elements representing exactly what the data should look like and must be entered in single quotation marks.</p><p><strong>Note:</strong> When using conversion functions in comparisons or evaluations, the formats must be consistent in the equation. For example, to compare <code>DATES</code>, you need to have all parts of the equation as <code>DATE</code>, not one part <code>DATE</code> and the other part <code>CHAR</code>. This is why the incorrect options fail in this problem. They are trying to rely on implicit conversion; it is best to use explicit conversion to ensure proper conversion of data.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE order_date_IN ( TO_DATE('OCT 21 2019','MON DD YYYY'), TO_CHAR('NOV 21 2019','MON DD YYYY') ) \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE order_date &gt; TO_CHAR(ADD_MONTHS(SYSDATE,6),'MON DD YYYY') \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE TO_CHAR(order_date,'MON DD YYYY') = 'JAN 01 2019' \n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE order_date &gt; TO_DATE('JUL 10 2019','MON DD YYYY') \n</pre>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the description of the ORDERS table. Identify two WHERE clause conditions which demonstrate the correct usage of conversion functions. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919471,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table. </p><p><strong>Table: CUSTOMERS </strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-35-51-559f67c51a754fdc2f9e47dca385b765.png\"></p><p><br></p><p><strong>Required: </strong>Generate a report showing the first names and credit limits of all customers whose first names start with A, B, or C, and credit limit is over 100.&nbsp; </p><p>Evaluate the following two queries.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) LIKE 'A%' OR\n    UPPER(cust_first_name) LIKE 'B%' OR\n    UPPER(cust_first_name) LIKE 'C%'\n)\nAND cust_credit_limit &gt; 100;\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) BETWEEN 'A' AND 'C'\n    AND cust_credit_limit &gt; 100\n);\n</pre><p><br></p><p>Identify the true statement regarding the execution of the above queries.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: BETWEEN Condition](https://www.techonthenet.com/oracle/between.php)",
                    "[Oracle / PLSQL: UPPER Function](https://www.techonthenet.com/oracle/functions/upper.php)"
                ],
                "feedbacks": [
                    "The first query correctly filters the customers whose first names start with A, B, or C and have a credit limit over 100. The second query does not include the condition for the credit limit, so it will not give the required result.",
                    "The first query correctly filters the customers based on the specified conditions, while the second query does not include the condition for the credit limit. Therefore, both queries do not give the required result.",
                    "The first query correctly filters the customers whose first names start with A, B, or C and have a credit limit over 100. The second query does not include the condition for the credit limit, so it will not give the required result.",
                    "The first query correctly filters the customers based on the specified conditions, while the second query does not include the condition for the credit limit. Therefore, both queries do not give the required result."
                ],
                "explanation": "<p>Correct Answer: <strong>Only the first query gives the correct result.</strong></p><p><strong>Requirement Recap</strong>: Show first names and credit limits of all customers whose <strong>first names start with A, B, or C</strong>, and <strong>credit limit is over 100</strong>.</p><p><strong>Exhibit 1</strong>:</p><pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) LIKE 'A%' OR\n    UPPER(cust_first_name) LIKE 'B%' OR\n    UPPER(cust_first_name) LIKE 'C%'\n)\nAND cust_credit_limit &gt; 100;\n</pre><ul><li><p>This <strong>explicitly checks</strong> if the first name starts with <strong>A, B, or C</strong>, using <code>LIKE 'A%'</code>, etc.</p></li><li><p>The <code>UPPER()</code> ensures case-insensitive comparison.</p></li><li><p>The credit limit condition is applied properly.</p></li><li><p>This query <strong>correctly returns</strong> the expected result.</p></li></ul><p><strong>Exhibit 2</strong>:</p><pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) BETWEEN 'A' AND 'C'\n    AND cust_credit_limit &gt; 100\n);\n</pre><ul><li><p>This uses <code>BETWEEN 'A' AND 'C'</code>, which <strong>does not mean \"starts with A, B, or C\"</strong>.</p></li><li><p><code>BETWEEN 'A' AND 'C'</code> is a <strong>lexicographic comparison</strong>, and:</p><ul><li><p>It will include names like <strong>\"Adam\", \"Brian\", \"Carl\"</strong>, which is good.</p></li><li><p>But it may <strong>also include names</strong> that do <strong>not start with A, B, or C</strong>, like <strong>\"Catherine\", \"Callie\", or \"Cab\"</strong>, depending on collation and database behavior.</p></li><li><p><strong>Most importantly</strong>, it may <strong>exclude</strong> names that start with <strong>C</strong> but are lexicographically greater than <code>'C'</code>, e.g., <strong>\"Chris\"</strong> (<code>'Chris' &gt; 'C'</code> is true).</p></li></ul></li><li><p>Therefore, this query may <strong>miss valid names</strong> and <strong>include invalid ones</strong>.</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_13-47-57-bd275748bbef3c7b96735d32950e9cf6.png\"></p><p><br></p><p><strong>The Oracle BETWEEN </strong>condition is used to retrieve values within a range in a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>BETWEEN</code> condition in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">expression BETWEEN value1 AND value2;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - A column or calculation. </p><p>value1 and value2 - Two values that create an inclusive range that <em>expression</em> is compared to.</p><p><strong>Note</strong></p><p>The Oracle <code>BETWEEN</code> condition will return the records where <em>expression</em> is within the range of <em>value1</em> and <em>value2</em> (inclusive).</p><p><br></p><p><strong>The Oracle/PLSQL UPPER</strong> function converts all letters in the specified string to uppercase. If there are characters in the string that are not letters, they are unaffected by this function.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>UPPER</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">UPPER( string1 )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to convert to uppercase.</p><p><strong>Returns</strong></p><p>The <code>UPPER</code> function returns a string value.</p><p><br></p><p>Both queries will run and produce results, however, the <code>BETWEEN</code> clause renders items which are between 'A and 'C' only. Anything which is not a single letter 'C' will be considered more than 'C' and not included in the results. </p><p>Using the <code>LIKE 'A%\" OR&nbsp;LIKE 'B%' OR&nbsp;LIKE 'C%'</code> will render a list of all records beginning with the letters requested. Then the list will be filtered for the remaining condition of credit limit.</p><p>The <code>UPPER</code> clause ensures that the field name is being compared to the conditions using <code>UPPER</code> case values in case the record had been entered using lower case characters.</p>",
                "answers": [
                    "<p>Only the second query gives the correct result.</p>",
                    "<p>Both execute successfully but do not give the required result.</p>",
                    "<p>Only the first query gives the correct result.</p>",
                    "<p>Both execute successfully and give the same result.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "BETWEEN",
            "question_plain": "View and examine the structure of the CUSTOMERS table. Table: CUSTOMERS Required: Generate a report showing the first names and credit limits of all customers whose first names start with A, B, or C, and credit limit is over 100.&nbsp; Evaluate the following two queries.Exhibit 1:SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) LIKE 'A%' OR\n    UPPER(cust_first_name) LIKE 'B%' OR\n    UPPER(cust_first_name) LIKE 'C%'\n)\nAND cust_credit_limit &gt; 100;\nExhibit 2:SELECT cust_first_name, cust_credit_limit\nFROM customers\nWHERE (\n    UPPER(cust_first_name) BETWEEN 'A' AND 'C'\n    AND cust_credit_limit &gt; 100\n);\nIdentify the true statement regarding the execution of the above queries.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919473,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given:</strong> In an Oracle 12c database:</p><ul><li><p>The employees.dat file is in the current directory where sqlldr is running.</p></li><li><p>SQL *Loader was invoked to load data into the EMPLOYEES table in the HR schema by issuing the following command. </p></li></ul><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">$&gt; sqldr hr/hr@pbd table-employees\n</pre><p><br></p><p>Identify the true statements regarding the command. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL*Loader Parameters](https://docs.oracle.com/cd/B28359_01/server.111/b28319/ldr_concepts.htm#i1007844)"
                ],
                "feedbacks": [
                    "This statement is correct because if the EMPLOYEES table belonging to HR is already defined in the database, SQL *Loader will succeed in loading data into that table using default settings without any issues.",
                    "This statement is incorrect because the SQL *Loader command does not fail due to the absence of a specified data file location. The employees.dat file is in the current directory where sqlldr is running, so it can be loaded into the EMPLOYEES table.",
                    "This statement is correct because if the HR user does not have the CREATE ANY DIRECTORY privilege, SQL *Loader will fail to load data into the EMPLOYEES table. This privilege is necessary for SQL *Loader to access and load data from the employees.dat file.",
                    "This statement is incorrect because the SQL *Loader command does not fail due to the absence of a specified control file location. The control file is not mentioned in the scenario, but SQL *Loader can still load data into the EMPLOYEES table using default settings."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><ol><li><p><strong>It succeeds with default settings if the EMPLOYEES table belonging to HR is already defined in the database.</strong></p><ul><li><p>Yes. As long as the required <code>control.ctl</code> file exists in the current directory and the control file points to a valid data file (like <code>employees.dat</code>), it will work.</p></li></ul></li><li><p><strong>It fails because no SQL*Loader control file location is specified.</strong></p><ul><li><p>True <strong>only if</strong> there is <strong>no </strong><code><strong>control.ctl</strong></code><strong> file in the current directory</strong>.</p></li><li><p>But technically, if <code>control.ctl</code> <strong>does exist</strong>, it <strong>will not fail</strong>.</p></li><li><p>However, for this question, this is considered a valid answer <strong>because the control file name is not specified</strong>, and it's a common issue that leads to failure.</p></li></ul></li></ol><p><br></p><p>Let's break down the SQL*Loader scenario and analyze what happens when the following command is executed:</p><p><strong>Command:</strong></p><pre class=\"prettyprint linenums\">$&gt; sqlldr hr/hr@pbd table=employees\n</pre><p><strong>Understanding the command:</strong></p><ul><li><p>This command uses <strong>default values</strong> for optional parameters not specified (like <code>control=</code>, <code>data=</code>, <code>log=</code>, etc.).</p></li><li><p>If not specified, SQL*Loader assumes the <strong>control file is named </strong><code><strong>control.ctl</strong></code> and exists in the <strong>current directory</strong>.</p></li><li><p>The <strong>data file name and location</strong> must be specified <strong>in the control file</strong>, not in the command line.</p></li><li><p><strong>Privileges like </strong><code><strong>CREATE ANY DIRECTORY</strong></code> are only needed when loading data <strong>from external tables or directories</strong>, <strong>not</strong> for basic SQL*Loader operations.</p></li></ul><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>It fails if the HR user does not have the CREATE ANY DIRECTORY privilege.</strong></p><ul><li><p><strong>Wrong</strong>. This privilege is required for <strong>external tables</strong>, not for SQL*Loader.</p></li></ul></li><li><p><strong>It fails because no SQL*Loader data file location is specified.</strong></p><ul><li><p><strong>Wrong</strong>. The data file is <strong>referenced in the control file</strong>, not in the command line.</p></li><li><p>SQL*Loader does <strong>not</strong> require the data file to be passed directly via the command.</p></li></ul></li></ul><p><br></p><p><strong>SQL*Loader Features</strong></p><p>SQL*Loader loads data from external files into tables of an Oracle database. It has a powerful data parsing engine that puts little limitation on the format of the data in the datafile. You can use SQL*Loader to do the following:</p><p>• Load data across a network if your data files are on a different system than the database.</p><p>• Load data from multiple datafiles during the same load session.</p><p>• Load data into multiple tables during the same load session.</p><p>• Specify the character set of the data.</p><p>• Selectively load data (you can load records based on the records' values).</p><p>• Manipulate the data before loading it, using SQL functions.</p><p>• Generate unique sequential key values in specified columns.</p><p>• Use the operating system's file system to access the datafiles.</p><p>• Load data from disk, tape, or named pipe.</p><p>• Generate sophisticated error reports, which greatly aid troubleshooting.</p><p>• Load arbitrarily complex object-relational data.</p><p>• Use secondary datafiles for loading LOBs and collections.</p><p>• Use either conventional or direct path loading. While conventional path loading is very flexible, direct path loading provides superior loading performance.</p><p><br></p><p><strong>SQL*Loader Parameters</strong></p><p>SQL*Loader is invoked when you specify the <code>sqlldr</code> command and, optionally, parameters that establish session characteristics.</p><p>In situations where you always use the same parameters for which the values seldom change, it can be more efficient to specify parameters using the following methods, rather than on the command line:</p><p>• Parameters can be grouped together in a parameter file. You could then specify the name of the parameter file on the command line using the <code>PARFILE</code> parameter.</p><p>• Certain parameters can also be specified within the SQL*Loader control file by using the <code>OPTIONS</code> clause.</p><p>Parameters specified on the command line override any parameter values specified in a parameter file or <code>OPTIONS</code> clause.</p>",
                "answers": [
                    "<p>It succeeds with default settings if the EMPLOYEES table belonging to HR is already defined in the database.</p>",
                    "<p>It fails because no SQL *Loader data file location is specified.</p>",
                    "<p>It fails if the HR user does not have the CREATE ANY DIRECTORY privilege.</p>",
                    "<p>It fails because no SQL *Loader control file location is specified.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following scenario.Given: In an Oracle 12c database:The employees.dat file is in the current directory where sqlldr is running.SQL *Loader was invoked to load data into the EMPLOYEES table in the HR schema by issuing the following command. Exhibit: 1$&gt; sqldr hr/hr@pbd table-employees\nIdentify the true statements regarding the command. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919475,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate the actions that can be performed using the ORACLE_DATAPUMP access driver. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Data Pump](https://docs.oracle.com/en/database/oracle/oracle-database/23/sutil/oracle-data-pump-overview.html)"
                ],
                "feedbacks": [
                    "This statement is incorrect. Data Pump Export and Import utilities can indeed be attached to a job in interactive-command mode, allowing for more control and customization during the data pump process.",
                    "This statement is correct. Data Pump processing is performed on the system specified by the database connect string, allowing for efficient data movement and manipulation between different systems.",
                    "This statement is incorrect. A log file can be written during the execution of a job, providing detailed information about the data pump process for troubleshooting and monitoring purposes.",
                    "This statement is correct. Job status can be displayed on request in interactive-command mode or by querying the DBA_DATAPUMP_JOBS view, providing visibility into the progress and status of data pump jobs.",
                    "This statement is correct. The ORACLE_DATAPUMP access driver allows for reading data from a table in the database and inserting it into an external table, facilitating data transfer and manipulation between different storage locations.",
                    "<p>This statement is incorrect. Character set conversions are not supported under Oracle Data Pump when using transportable tablespaces.</p>"
                ],
                "explanation": "<p>Let's evaluate each statement based on what the <code><strong>ORACLE_DATAPUMP</strong></code><strong> access driver</strong> allows in <strong>Oracle External Tables</strong> and <strong>Data Pump</strong> utilities.</p><p><strong>Correct Statements:</strong></p><p>1. <strong>Data Pump processing is done on the system selected by the specified database connect string.</strong></p><ul><li><p><strong>True</strong>.<br>The <strong>Data Pump server process</strong> runs on the <strong>database server</strong>, not the client.<br>When you specify a connect string, the location of processing depends on the connect destination.</p></li></ul><p>2. <strong>Job status can be displayed on request in interactive-command mode or by creating a query on DBA_DATAPUMP_JOBS.</strong></p><ul><li><p><strong>True</strong>.<br>You can <strong>attach to a Data Pump job</strong> interactively (<code>expdp</code> or <code>impdp</code> with <code>ATTACH</code>) and view the job status.<br>You can also query views like <code><strong>DBA_DATAPUMP_JOBS</strong></code> for job metadata and status.</p></li></ul><p>3. <strong>Character set conversions are supported under the Data Pump when using transportable tablespaces.</strong></p><ul><li><p><strong>True</strong>.<br>When using <strong>transportable tablespaces</strong>, <strong>character set conversion</strong> is supported <strong>if needed</strong>, between source and target databases.</p></li></ul><p><strong>Incorrect Statements:</strong></p><p><strong>Read data from a table in the database and insert it into an external table.</strong></p><ul><li><p><strong>False</strong>.<br>You <strong>cannot insert into an external table</strong>.<br>External tables are <strong>read-only or write-only</strong> depending on the access driver.<br>You <strong>read from ORACLE_LOADER or ORACLE_DATAPUMP external tables</strong>, but <strong>cannot perform DML like </strong><code><strong>INSERT INTO</strong></code> on them.</p></li></ul><p><strong>Data Pump Export and Import utilities cannot be attached to a job in interactive-command mode.</strong></p><ul><li><p><strong>False</strong>.<br>You <strong>can attach</strong> to a running Data Pump job using the <code><strong>ATTACH</strong></code> parameter.<br>This is one of the key features of Data Pump.</p></li></ul><p><strong>A log file cannot be written during the execution of a job.</strong></p><ul><li><p><strong>False</strong>.<br>Data Pump jobs <strong>do</strong> generate <strong>log files</strong> during execution if specified with the <code>LOGFILE=</code> parameter.</p><p><br></p></li></ul><p><strong>Oracle Data Pump technology </strong>enables very high-speed movement of data and metadata from one database to another. Oracle Data Pump is available only on Oracle Database 10g release 1 (10.1) and later.</p><p><br></p><p><strong>Data Pump Components</strong></p><p>Oracle Data Pump is made up of three distinct parts:</p><p>• The command-line clients, <code>expdp</code> and <code>impdp</code></p><p>• The <code>DBMS_DATAPUMP</code> PL/SQL package (also known as the Data Pump API)</p><p>• The <code>DBMS_METADATA</code> PL/SQL package (also known as the Metadata API)</p><p>• The Data Pump clients, <code>expdp</code> and <code>impdp</code>, invoke the Data Pump Export utility and Data Pump Import utility, respectively. They provide a user interface that closely resembles the original export (<code>exp</code>) and import (<code>imp</code>) utilities.</p><p>• The <code>expdp</code> and <code>impdp</code> clients use the procedures provided in the <code>DBMS_DATAPUMP</code> PL/SQL package to execute export and import commands, using the parameters entered at the command-line. These parameters enable the exporting and importing of data and metadata for a complete database or subsets of a database.</p><p><strong>Note:</strong></p><p> All Data Pump Export and Import processing, including the reading and writing of dump files, is done on the system (server) selected by the specified database connect string. <strong>This means that, for nonprivileged users, the database administrator (DBA) must create directory objects for the Data Pump files that are read and written on that server file system.</strong> For privileged users, a default directory object is available.</p><p>√&nbsp; Data Pump processing is done on the system selected by the specified database connect string.</p><p><br></p><p><strong>Monitoring Job Status</strong></p><p>The Data Pump Export and Import utilities can be attached to a job in either interactive-command mode or logging mode. In logging mode, real-time detailed status about the job is automatically displayed during job execution. The information displayed can include the job and parameter descriptions, an estimate of the amount of data to be exported, a description of the current operation or item being processed, files used during the job, any errors encountered, and the final job state (Stopped or Completed).</p><p>Job status can be displayed on request in interactive-command mode. The information displayed can include the job description and state, a description of the current operation or item being processed, files being written, and a cumulative status.</p><p>A log file can also be optionally written during the execution of a job. The log file summarizes the progress of the job, lists any errors that were encountered along the way, and records the completion status of the job.</p><p>An alternative way to determine job status or to get other information about Data Pump jobs, would be to query the <code>DBA_DATAPUMP_JOBS</code>, <code>USER_DATAPUMP_JOBS</code>, or <code>DBA_DATAPUMP_SESSIONS</code> views.</p><p>√&nbsp; Job status can be displayed on request in interactive-command mode or by creating a query on DBA_DATAPUMP_JOBS.</p><p><br></p><p>Data Pump supports character set conversion for both direct path and external tables. Most of the restrictions that exist for character set conversions in the original Import utility do not apply to Data Pump. The one case in which character set conversions are not supported under the Data Pump is when using transportable tablespaces.</p><p><em>√&nbsp; Read data from a table in the database and insert it into an external table.</em></p>",
                "answers": [
                    "<p>Data Pump Export and Import utilities cannot be attached to a job in interactive-command mode.</p>",
                    "<p>Data Pump processing is done on the system selected by the specified database connect string.</p>",
                    "<p>A log file cannot be written during the execution of a job.</p>",
                    "<p>Job status can be displayed on request in interactive-command mode or by creating a query on DBA_DATAPUMP_JOBS.</p>",
                    "<p>Read data from a table in the database and insert it into an external table.</p>",
                    "<p>Character set conversions are supported under the Data Pump is when using transportable tablespaces.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d",
                "e"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Indicate the actions that can be performed using the ORACLE_DATAPUMP access driver. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919477,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in the PRODUCTS table. </p><p><strong>Table: PRODUCTS </strong></p><pre class=\"prettyprint linenums\">PROD_ID               PROD_NAME\n3054                  Plasma Monitor\n1782                  Compact 400/Dq\n1791                  Industrial 700/HD\n2302                  Inject B/6\n2459                  LaserPro 1200/8/8W\n</pre><p><br></p><p><strong>Required:</strong> Add a column called PRICE which cannot contain NULL.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ALTER TABLE Statement](https://www.techonthenet.com/oracle/tables/alter_table.php)"
                ],
                "feedbacks": [
                    "This SQL query correctly adds a new column called PRICE to the PRODUCTS table with the data type NUMBER(8,2), a default value of 0, and the constraint NOT NULL. This ensures that the PRICE column cannot contain NULL values, meeting the requirement.",
                    "This SQL query attempts to add a new column called PRICE to the PRODUCTS table with the data type NUMBER(8,2) and a default value of NOT NULL. However, the syntax for setting a default value as NOT NULL is incorrect, making this choice invalid.",
                    "This SQL query tries to add a new column called PRICE to the PRODUCTS table with the data type NUMBER(8,2), a default value, and a constraint named p_nn that enforces the NOT NULL condition. While the intention is correct, the syntax for setting the default value and constraint is incorrect, making this choice invalid.",
                    "This SQL query attempts to modify the existing table by adding a new column called PRICE with the data type NUMBER(8,2) and a default value of NOT NULL. However, the correct syntax for adding a new column is ALTER TABLE, not MODIFY TABLE, making this choice invalid."
                ],
                "explanation": "<p>To add a column <code>PRICE</code> to the <code>PRODUCTS</code> table that:</p><ul><li><p>Is of type <code>NUMBER(8,2)</code></p></li><li><p><strong>Cannot contain NULLs</strong></p></li><li><p>Has a <strong>default value</strong> to ensure existing rows are valid (because <code>NOT NULL</code> requires a value for every row)</p></li></ul><p><strong>Correct Syntax:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE products \nADD price NUMBER(8,2) DEFAULT 0 NOT NULL;\n</pre><ul><li><p>Adds the <code>PRICE</code> column</p></li><li><p><code>NUMBER(8,2)</code> specifies precision and scale</p></li><li><p><code>DEFAULT 0</code> provides a value for existing and future rows</p></li><li><p><code>NOT NULL</code> ensures column cannot be NULL</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_16-25-55-286c05bfef1430a308ecdc335df38d08.png\"></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_16-46-00-a29b26ccfb1aa9df3d4ff1e6c094c5a3.png\"></p><p><br></p><p><strong>Incorrect Options:</strong></p><ol><li><p><code>ALTER TABLE products ADD price NUMBER(8,2) DEFAULT NOT NULL;</code></p><ul><li><p><strong>Invalid syntax</strong>: <code>DEFAULT</code> must be followed by a value (e.g., <code>0</code>), not by <code>NOT NULL</code>.</p></li></ul></li><li><p><code>ALTER TABLE products ADD price NUMBER(8,2) DEFAULT CONSTRAINT p_nn NOT NULL.</code></p><ul><li><p><strong>Invalid syntax</strong>: <code>DEFAULT</code> can't have a constraint name. Constraint naming should follow <code>CONSTRAINT p_nn CHECK (...)</code> or similar.</p></li></ul></li><li><p><code>MODIFY TABLE products ADD price NUMBER(8,2) DEFAULT NOT NULL;</code></p><ul><li><p><strong>Invalid syntax</strong>: <code>MODIFY TABLE</code> is not valid — it should be just <code>ALTER TABLE</code>.</p></li></ul></li></ol><p><br></p><p><strong>The Oracle ALTER TABLE</strong> statement is used to add, modify, or drop/delete columns in a table. The Oracle ALTER TABLE statement is also used to rename a table.</p><p><strong>Add column in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD A COLUMN</code> in a table, the Oracle <code>ALTER TABLE</code> syntax is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name column_definition;</pre><p><br></p><p><strong>Add multiple columns in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD MULTIPLE COLUMNS</code> to an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD (column_1 column_definition,\n       column_2 column_definition,\n       ...\n       column_n column_definition);</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table_name - The name of the table that you wish to create. </p><p>column1, column2, ... column_n - The columns that you wish to create in the table. Each column must have a datatype. The column should either be defined as \"null\" or \"not null\" and if this value is left blank, the database assumes \"null\" as the default.</p><p>The challenge in this problem is to add a column with a <code>NOT&nbsp;NULL</code> constraint to a table which already has data in it. If you add a column without any values in it, this will conflict the constraint of <code>NOT&nbsp;NULL</code> and product an error.</p><p><strong>Add column in table with a default value with constraint</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name data_type DEFAULT default_value constraint ;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table_name - The name of the table that you wish to create. </p><p>data_type - Specify the data type to be used in the column.</p><p>default_value -&nbsp; Indicate the default value for the column.</p><p>constraint - List any constraints for the column.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">ALTER TABLE products ADD price NUMBER(8,2) DEFAULT 0 NOT NULL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">ALTER TABLE products ADD price NUMBER(8,2) DEFAULT NOT NULL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">ALTER TABLE products ADD price NUMBER(8,2) DEFAULT CONSTRAINT p_nn NOT NULL. \n</pre>",
                    "<pre class=\"prettyprint linenums\">MODIFY TABLE products ADD price NUMBER(8,2) DEFAULT NOT NULL; \n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ALTER TABLE",
            "question_plain": "View and examine the data in the PRODUCTS table. Table: PRODUCTS PROD_ID               PROD_NAME\n3054                  Plasma Monitor\n1782                  Compact 400/Dq\n1791                  Industrial 700/HD\n2302                  Inject B/6\n2459                  LaserPro 1200/8/8W\nRequired: Add a column called PRICE which cannot contain NULL.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919479,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding group functions. (Choose four.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Group Operations](https://www.safaribooksonline.com/library/view/mastering-oracle-sql/0596006322/ch04.html)",
                    "[Is it possible to use Aggregate function in a Select statement without using Group By clause?](https://stackoverflow.com/questions/6467216/is-it-possible-to-use-aggregate-function-in-a-select-statment-without-using-grou)",
                    "[Nesting Functions Within Functions Oracle SQL Video Tutorial - Nested Functions Nesting Function](https://youtu.be/HbdgZFxl-0M?feature=shared)"
                ],
                "feedbacks": [
                    "Group functions can be applied to columns or expressions in SQL queries. They perform operations on a set of rows and return a single result for the entire set.",
                    "Group functions can be nested within each other as arguments in SQL queries. This allows for more complex calculations and aggregations to be performed on grouped data.",
                    "Group functions are commonly used in conjunction with the GROUP BY clause in SQL queries. This allows for data to be grouped based on specified criteria, and group functions to be applied to each group.",
                    "Group functions are not limited to operating on only one column in the SELECT clause of a SQL statement. They can be applied to multiple columns or expressions to perform calculations and aggregations.",
                    "Group functions can be combined with single-row functions in the SELECT clause of a SQL statement. This allows for both row-level and group-level calculations to be performed in the same query."
                ],
                "explanation": "<p>Let's examine each statement about <strong>group functions</strong> (also called <strong>aggregate functions</strong>) like <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, etc., and determine which are <strong>true</strong>.</p><p><strong>True Statements:</strong></p><p>1. <strong>They can be used on columns or expressions.</strong></p><ul><li><p><strong>True.</strong><br>Group functions can operate on:</p><ul><li><p><strong>Columns</strong>: <code>SUM(salary)</code></p></li><li><p><strong>Expressions</strong>: <code>SUM(salary + bonus)</code></p></li></ul></li></ul><p>2. <strong>They can be passed as an argument to another group function.</strong></p><ul><li><p><strong>True.</strong><br>This is known as a <strong>nested group function</strong> (though rarely used).<br>Example:</p><pre class=\"prettyprint linenums\">SELECT MAX(AVG(salary)) FROM employees GROUP BY department_id;\n</pre><p>(Here, <code>AVG(salary)</code> is grouped by department, then <code>MAX</code> is applied to those averages.)</p></li></ul><p>3. <strong>They can be used with a SQL statement that has the GROUP BY clause.</strong></p><ul><li><p><strong>True.</strong><br>In fact, group functions are <strong>commonly used</strong> with <code>GROUP BY</code> to get aggregated results per group.<br>Example:</p><pre class=\"prettyprint linenums\">SELECT department_id, SUM(salary)\nFROM employees\nGROUP BY department_id;\n</pre></li></ul><p>4. <strong>They can be used along with the single-row function in the SELECT clause of a SQL statement.</strong></p><ul><li><p><strong>True.</strong><br>Single-row functions and group functions can be used <strong>together</strong> in the <code>SELECT</code> clause.<br>Example:</p><pre class=\"prettyprint linenums\">SELECT UPPER(department_name), AVG(salary)\nFROM employees\nJOIN departments USING (department_id)\nGROUP BY department_name;\n</pre></li></ul><p><strong>False Statement:</strong></p><p><strong>They can be used on only one column in the SELECT clause of a SQL statement.</strong></p><ul><li><p><strong>False.</strong><br>You can use <strong>multiple group functions</strong> in the same <code>SELECT</code> clause:</p><pre class=\"prettyprint linenums\">SELECT AVG(salary), MAX(salary), MIN(salary)\nFROM employees;\n</pre></li></ul><p><br></p><p><strong>Oracle group operations.</strong> The features include aggregate functions, the <code>GROUP BY</code> clause, the <code>HAVING</code> clause, and the extensions to the <code>GROUP BY</code> clause—<code>ROLLUP</code>, <code>CUBE</code>, and <code>GROUPING SETS</code>.</p><p><strong>Aggregate Functions</strong></p><p>An <em>aggregate function</em> summarizes the results of an expression over a number of rows, returning a single value. </p><p><em>√&nbsp; They can be used on columns or expressions.</em></p><p><br></p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">aggregate_function([DISTINCT | ALL] expression)</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>aggregate_function - name of the function—e.g., <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code></p><p>DISTINCT - Specifies that the aggregate function should consider only distinct values of the argument expression.</p><p>ALL - Specifies that the aggregate function should consider all values, including all duplicate values, of the argument expression. The default is <code>ALL</code>.</p><p>expression - Specifies a column, or any other expression, on which you want to perform the aggregation.</p><p><br></p><p><strong>NULLs and Aggregate Functions</strong></p><p>All aggregate functions ignore <code>NULLs</code> other than <code>COUNT(*)</code> and <code>GROUP BY</code>.&nbsp; For example, <code>COUNT(column_name)</code> ignores <code>NULLs</code>, whereas <code>COUNT(*)</code> doesn’t. The reason <code>COUNT(*)</code> doesn’t ignore <code>NULLs</code> is because it counts rows, not column values. The concept of <code>NULL</code> doesn’t apply to a row as a whole.&nbsp; <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>AVG</code>, etc., all ignore <code>NULLs</code>.</p><p><strong>Use of DISTINCT and ALL</strong></p><p>Most aggregate functions allow the use of <code>DISTINCT</code> or <code>ALL</code> along with the expression argument. <code>DISTINCT</code> allows you to disregard duplicate expression values, while <code>ALL</code> causes duplicate expression values to be included in the result.</p><p>The aggregate functions that take more than one argument as input don’t allow the use of <code>DISTINCT</code>. These include <code>CORR</code>, <code>COVAR_POP</code>, <code>COVAR_SAMP</code>, and all the linear regression functions.</p><p>Functions that take only one argument as input don’t allow the use of <code>DISTINCT</code>. This category includes <code>STTDEV_POP</code>, <code>STDDEV_SAMP</code>, <code>VAR_POP</code>, <code>VAR_SAMP</code>, and <code>GROUPING</code>.</p><p><br></p><p><strong>The GROUP BY Clause</strong></p><p>The <code>GROUP BY</code> clause, along with the aggregate functions, groups a result set into multiple groups, and then produces a single row of summary information for each group.</p><p>• Generally speaking, any nonaggregate expression in your <code>SELECT</code> clause must also be reflected in your <code>GROUP BY</code> clause.</p><p>• Aggregate expressions generally require a <code>GROUP BY</code> clause.</p><p>• GROUP BY clause must include all nonaggregate expressions</p><p>• Aggregate functions not allowed in <code>GROUP BY</code> clause.</p><p>• Constants can be omitted from the <code>GROUP BY</code> clause.</p><p>In Oracle SQL, you can pass a group function as an argument to another group function. This is referred to as <strong>nested group functions</strong>.</p><p>A common example of this is when you want to calculate an aggregate of an aggregate. For instance, you could find the average of the maximum salaries for each department. The inner function, <code>MAX(salary)</code>, would first find the maximum salary for each group (in this case, each department). The outer function, <code>AVG()</code>, would then take those results and calculate their average.</p><p>It's important to remember a few key things when using nested group functions:</p><ul><li><p><strong>Two-Level Limit</strong>: Oracle typically allows for a maximum of two levels of nesting for group functions.4</p></li><li><p><strong>No Non-Group Columns</strong>: The <code>SELECT</code> list can only contain the nested group function and columns used in the <code>GROUP BY</code> clause. You cannot include any other non-aggregated columns in the <code>SELECT</code> list.</p></li><li><p><strong>Implicit </strong><code><strong>GROUP BY</strong></code>: The outermost group function operates on the entire set of results from the inner function, which is often a single value. This means it has an implicit <code>GROUP BY</code> and will return only one row, unless you use a <code>GROUP BY</code> clause for the inner function.</p></li></ul><p><em>√ They can be passed as an argument to another group function.</em></p><p><em>√ They can be used with a SQL statement that has the GROUP BY clause.</em></p><p><strong>Single-row function in the SELECT clause</strong></p><p>Examples of proper usage.</p><pre class=\"prettyprint linenums\">SELECT col1, col2, col3, MAX(col4)\n...\nGROUP BY col1, col2, col3</pre><pre class=\"prettyprint linenums\">SELECT col1, col2, col3, MAX(col4)\n...\nGROUP BY col1, col2, col3, col5, col6</pre><p><br></p><p>Examples of improper usage which will render an error.</p><pre class=\"prettyprint linenums\">SELECT col1, col2, col3, MAX(col4)\n...\nGROUP BY col1, col2</pre><p><br></p><p><em>√&nbsp; They can be used along with the single-row function in the SELECT clause of a SQL statement.</em></p>",
                "answers": [
                    "<p>They can be used on columns or expressions.</p>",
                    "<p>They can be passed as an argument to another group function.</p>",
                    "<p>They can be used with a SQL statement that has the GROUP BY clause.</p>",
                    "<p>They can be used on only one column in the SELECT clause of a SQL statement.</p>",
                    "<p>They can be used along with the single-row function in the SELECT clause of a SQL statement.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c",
                "e"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding group functions. (Choose four.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919481,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the SQL statement used to create the TRANSACTION table. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE transaction (\n  trn_id      CHAR(2) PRIMARY KEY,\n  start_date  DATE DEFAULT SYSDATE,\n  end_date    DATE NOT NULL\n);\n</pre><p><br></p><p><strong>Given: </strong> The value 'A5' does not exist for trn_id in this table.&nbsp; </p><p>Identify the SQL statement which successfully inserts a row into the table with the default value for START_DATE using 'A5' as the transaction identifier.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: INSERT Statement](https://www.techonthenet.com/oracle/insert.php)",
                    "[Oracle / PLSQL: TO_DATE Function](https://www.techonthenet.com/oracle/functions/to_date.php)"
                ],
                "feedbacks": [
                    "This choice attempts to insert a row into the TRANSACTION table with the default value for START_DATE using 'A5' as the transaction identifier. However, the syntax for DEFAULT+10 is incorrect and will result in a syntax error during execution.",
                    "This choice attempts to insert a row into the TRANSACTION table with the default value for START_DATE using 'A5' as the transaction identifier. However, the TO_DATE('SYSDATE+10') syntax is incorrect as it does not evaluate the SYSDATE function correctly, resulting in an error during execution.",
                    "This choice successfully inserts a row into the TRANSACTION table with 'A5' as the transaction identifier and the default value for START_DATE. The TO_DATE function correctly converts the date string '15-FEB-2023' to a date format, making this statement valid for insertion.",
                    "This choice attempts to insert a row into the TRANSACTION table with 'A5' as the transaction identifier and a specified start_date of '10-DEC-2025'. However, the syntax for the date value is incorrect, and it will result in a data type mismatch error during execution.",
                    "This choice attempts to insert a row into the TRANSACTION table with 'A5' as the transaction identifier and the default value for START_DATE. However, the usage of double quotes for 'A5' is incorrect, and it will result in a syntax error during execution.",
                    "This choice attempts to insert a row into the TRANSACTION table with 'A5' as the transaction identifier and a specified start_date of '10-DEC-2025'. However, the usage of double quotes for \"A5\" is incorrect, and it will result in a syntax error during execution."
                ],
                "explanation": "<p><strong>Correct SQL Statement:</strong></p><pre class=\"prettyprint linenums\">INSERT INTO transaction (trn_id, end_date)\nVALUES ('A5', TO_DATE('15-FEB-2023', 'DD-MONTH-YYYY'));\n</pre><ul><li><p><code>trn_id</code> = <code>'A5'</code> </p></li><li><p><code>end_date</code> = a valid date using <code>TO_DATE</code> </p></li><li><p><code>start_date</code> is <strong>omitted</strong>, so Oracle uses the default: <code>SYSDATE</code> </p></li><li><p>This is the <strong>only correct and syntactically valid</strong> insert statement among the options.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_18-33-42-7dc67ff345ec21595dcee73c11209904.png\"></p><p>In the solution, we did not list the start date so it was filled with the default system date as shown in the Exhibit. The explicit data conversion method <code>TO_DATE</code> was used to convert the date to the table format.</p><p><br></p><p>Let's review the table definition and evaluate the correct way to insert a row using the <strong>default value for </strong><code><strong>start_date</strong></code> and provide values for other columns.</p><p><strong>Table Definition (Exhibit 1)</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE transaction (\n  trn_id      CHAR(2) PRIMARY KEY,\n  start_date  DATE DEFAULT SYSDATE,\n  end_date    DATE NOT NULL\n);\n</pre><ul><li><p><code>trn_id</code>: must be provided, it's the <strong>primary key</strong>.</p></li><li><p><code>start_date</code>: has a <strong>default</strong> of <code>SYSDATE</code> if not explicitly provided.</p></li><li><p><code>end_date</code>: is <strong>NOT NULL</strong>, so it <strong>must</strong> be explicitly provided in the <code>INSERT</code>.</p></li></ul><p><strong>Incorrect Options (with reasons):</strong></p><ol><li><p><code>INSERT INTO transaction VALUES ('A1', DEFAULT, TO_DATE(DEFAULT+10));</code></p><ul><li><p><code>DEFAULT</code> cannot be used like this inside expressions (<code>DEFAULT+10</code> is invalid).</p></li><li><p>Also, <code>TO_DATE(DEFAULT+10)</code> makes no sense and will raise an error.</p></li></ul></li><li><p><code>INSERT INTO transaction VALUES ('A1', DEFAULT, TO_DATE('SYSDATE+10'));</code></p><ul><li><p><code>'SYSDATE+10'</code> is a string, <strong>not</strong> a valid date.</p></li><li><p><code>TO_DATE('SYSDATE+10')</code> is invalid unless it's a <strong>date literal</strong>, which this is not.</p></li></ul></li><li><p><code>INSERT INTO transaction (trn_id, start_date, end_date) VALUES ('A5, 10-DEC-2025');</code></p><ul><li><p>Syntax is incorrect:</p><ul><li><p>Missing closing <code>'</code> around <code>'A5'</code></p></li><li><p>Missing value for <code>start_date</code></p></li><li><p>Only <strong>2 values</strong> supplied for <strong>3 columns</strong></p></li></ul></li></ul></li><li><p><code>INSERT INTO transaction (trn_id, end_date) VALUES(\"A5\", TO_DATE('15-FEB-2023', 'DD-MM-RR'));</code></p><ul><li><p>Uses <strong>double quotes</strong> <code>\"A5\"</code> — which are for <strong>identifiers</strong>, not string literals.</p></li><li><p>Should use single quotes <code>'A5'</code>.</p></li></ul></li><li><p><code>INSERT INTO transaction (trn_id, start_date, end_date) VALUES (\"A5, 10-DEC-2025\");</code></p><ul><li><p>Same issues: bad quoting, wrong number of values, and invalid syntax.</p></li></ul></li></ol><p><br></p><p><strong>The Oracle INSERT statement</strong> is used to insert a single record or multiple records into a table in Oracle.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>INSERT</code> statement when inserting a single record using the VALUES keyword is:</p><pre class=\"prettyprint linenums\">INSERT INTO table\n(column1, column2, ... column_n )\nVALUES\n(expression1, expression2, ... expression_n );</pre><p><br></p><p>Or the syntax for the Oracle <code>INSERT</code> statement when inserting multiple records using a <code>SELECT</code> statement is:</p><pre class=\"prettyprint linenums\">INSERT INTO table\n(column1, column2, ... column_n )\nSELECT expression1, expression2, ... expression_n\nFROM source_table\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table - The table to insert the records into. </p><p>column1, column2, ... column_n - The columns in the <em>table</em> to insert values. </p><p>expression1, expression2, ... expression_n - The values to assign to the columns in the table. So <em>column1</em> would be assigned the value of <em>expression1</em>, <em>column2</em> would be assigned the value of <em>expression2</em>, and so on. source_table The source table when inserting data from another table. </p><p><code>WHERE</code> conditions Optional.&nbsp; - The conditions that must be met for the records to be inserted.</p><p><strong>Note</strong></p><p>When inserting records into a table using the Oracle <code>INSERT</code> statement, you must provide a value for every <code>NOT NULL</code> column.</p><p>You can omit a column from the Oracle <code>INSERT</code> statement if the column allows <code>NULL</code> values.</p><p><strong>The Oracle/PLSQL TO_DATE</strong> function converts a string to a date.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TO_DATE</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TO_DATE( string1 [, format_mask] [, nls_language] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string that will be converted to a date. </p><p>format_mask Optional. - This is the format that will be used to convert <em>string1</em> to a date.</p><p>nls_language Optional. - This is the nls language used to convert <em>string1</em> to a date.</p><p><strong>Returns</strong></p><p>The <code>TO_DATE</code> function returns a date value.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction&nbsp; \nVALUES ('A1', DEFAULT, TO_DATE(DEFAULT+10));\n</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction&nbsp; \nVALUES ('A1', DEFAULT, TO_DATE('SYSDATE+10'));\n</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction (trn_id, end_date)\nVALUES ('A5', TO_DATE('15-FEB-2023', 'DD-MONTH-YYYY'));\n</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction (trn_id, start_date, end_date)&nbsp; \nVALUES ('A5, 10-DEC-2025');\n</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction (trn_id, end_date)\nVALUES(\"A5\",TO_DATE('15-FEB-2023', 'DD-MM-RR'));\n</pre>",
                    "<pre class=\"prettyprint linenums\">INSERT INTO transaction (trn_id, start_date, end_date)&nbsp; \nVALUES (\"A5, 10-DEC-2025\");\n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the SQL statement used to create the TRANSACTION table. Exhibit: 1CREATE TABLE transaction (\n  trn_id      CHAR(2) PRIMARY KEY,\n  start_date  DATE DEFAULT SYSDATE,\n  end_date    DATE NOT NULL\n);\nGiven:  The value 'A5' does not exist for trn_id in this table.&nbsp; Identify the SQL statement which successfully inserts a row into the table with the default value for START_DATE using 'A5' as the transaction identifier.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919491,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required:</strong> Calculate the number of days from 15th March 2020 until today. </p><p><strong>Given:</strong> Dates are stored in the default format of DD-MON-RR.&nbsp; </p><p>Identify the SQL queries which would give you the required output. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle TO_DATE Function](https://www.oracletutorial.com/oracle-date-functions/oracle-to_date/)"
                ],
                "feedbacks": [
                    "This query correctly calculates the number of days between the current date (SYSDATE) and the specified date '15-MARCH-2020' by subtracting the two dates. The result will be the number of days between the two dates.",
                    "<p>This query correctly calculates the number of days between the current date (SYSDATE) and the specified date '15/MARCH/2020' by subtracting the two dates. The ROUND function is used to round the result to the nearest whole number, which is the number of days.</p>",
                    "This query attempts to subtract the specified date '15-MAR-2020' from the formatted current date (SYSDATE). However, the subtraction operation cannot be directly performed on formatted dates, resulting in an error.",
                    "This query tries to subtract the specified date '15-MAR-2020' from the current date (SYSDATE) without using the TO_DATE function to convert the date string to a date data type. This will result in an error as the subtraction operation cannot be performed on string and date data types.",
                    "This query attempts to convert the current date (SYSDATE) to a date format using the TO_DATE function but uses incorrect formatting parameters. Additionally, the subtraction operation is attempted on a string '15/MARCH/2020', which will result in an error."
                ],
                "explanation": "<p>Let's evaluate each SQL query based on the requirement:</p><p><strong>Calculate the number of days from 15th March 2020 until today</strong>, where:</p><ul><li><p>Dates are in <strong>default format: </strong><code><strong>DD-MON-RR</strong></code> (Oracle's default is typically <code>DD-MON-RR</code> or <code>DD-MON-YY</code>)</p></li><li><p>We need to use <strong>date arithmetic</strong>: <code>SYSDATE - &lt;some date&gt;</code> returns the number of days between the two dates.</p></li></ul><p><strong>Correct Queries):</strong></p><ol><li><pre class=\"prettyprint linenums\">SELECT SYSDATE - TO_DATE('15-MARCH-2020') \nFROM DUAL;</pre><ul><li><p><code>TO_DATE('15-MARCH-2020')</code> uses default format <code>DD-MON-RR</code></p></li><li><p>Oracle recognizes <code>'15-MARCH-2020'</code> because <code>TO_DATE()</code> handles long month names in many NLS settings</p></li><li><p><code>SYSDATE - date</code> returns the number of <strong>days</strong></p></li><li><p><strong>Correct and valid</strong></p></li></ul><p><br></p></li><li><pre class=\"prettyprint linenums\">SELECT ROUND(SYSDATE - TO_DATE('15/MARCH/2020')) \nFROM DUAL;</pre><ul><li><p><code>TO_DATE('15/MARCH/2020')</code> is valid <strong>if</strong> NLS_DATE_FORMAT allows for slashes and full month names — which is common</p></li><li><p><code>ROUND()</code> rounds the result to nearest whole day</p></li><li><p><strong>Also valid and gives desired result</strong></p></li></ul></li></ol><p><strong>Incorrect Queries:</strong></p><p><code>SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY') - '15-MAR-2020' FROM DUAL;</code></p><ul><li><p><code>TO_CHAR(...)</code> returns a <strong>string</strong>, not a date</p></li><li><p><code>'15-MAR-2020'</code> is also a string</p></li><li><p>Trying to subtract two strings → <strong>invalid</strong></p></li></ul><p><code>SELECT ROUND(SYSDATE - '15-MAR-2020') FROM DUAL;</code></p><ul><li><p><code>'15-MAR-2020'</code> is a <strong>string</strong>, not a date</p></li><li><p>Oracle <strong>doesn't automatically convert</strong> strings to dates in arithmetic</p></li><li><p>Will raise an error unless implicit conversion works — not reliable or best practice</p></li></ul><p><code>SELECT TO_DATE(SYSDATE, 'DD/MONTH/YYYY') - '15/MARCH/2020' FROM DUAL;</code></p><ul><li><p><code>SYSDATE</code> is already a <strong>date</strong> — passing it to <code>TO_DATE()</code> is wrong</p></li><li><p><code>'15/MARCH/2020'</code> is a <strong>string</strong>, not a date</p></li><li><p>Invalid on both sides; will fail</p></li></ul><p><br></p><p><strong>The Oracle/PLSQL TO_CHAR</strong> function converts a number or date to a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TO_CHAR</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TO_CHAR( value [, format_mask] [, nls_language] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>value - A number or date that will be converted to a string. </p><p>format_mask Optional. - This is the format that will be used to convert <em>value</em> to a string. </p><p>nls_language Optional. - This is the nls language used to convert <em>value</em> to a string.</p><p><strong>Returns</strong></p><p>The <code>TO_CHAR</code> function returns a string value.</p><p><strong>Arguments</strong></p><p>The <code>TO_DATE()</code> function accepts three arguments:</p><ol><li><p><code><strong>string</strong></code> is a string value which is converted to a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-date/\"><code>DATE</code></a> value. It can be a value of any data type <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-char/\"><code>CHAR</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-varchar2/\"><code>VARCHAR2</code></a>, <code>NCHAR</code>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-nvarchar2/\"><code>NVARCHAR2</code></a>.</p></li><li><p><code><strong>format</strong></code> is the date and time format for the <code>string</code>. The <code>format</code> argument is optional. If you omit the format, the string must be in the standard date format which is <code>DD-MON-YY</code> e.g., <code>31-DEC-2000</code></p></li><li><p><code><strong>nls_language</strong></code> is an expression that specifies the language for day and month names in the <code>string</code>. This <code>nls_language</code> argument has the following form:</p></li></ol><pre class=\"prettyprint linenums\">NLS_DATE_LANGUAGE = language</pre><p><br></p><p>This <code>ls_language</code> argument is optional. If you omit it, the <code>TO_DATE()</code> function will use the default language for your session.</p><p><strong><em>NOTE</em></strong><em>: If you omit the format, the string must be in the standard date format which is DD-MON-YY e.g., 31-DEC-2020... This nls_language argument is optional. If you omit it, the TO_DATE() function will use the default language for your session.</em></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT SYSDATE - TO_DATE('15-MARCH-2020') \nFROM DUAL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ROUND(SYSDATE - TO_DATE('15/MARCH/2020')) \nFROM DUAL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY') - '15-MAR-2020' \nFROM DUAL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ROUND(SYSDATE - '15-MAR-2020') \nFROM DUAL; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_DATE(SYSDATE, 'DD/MONTH/YYYY') - '15/MARCH/2020' \nFROM DUAL; \n</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "TO_DATE",
            "question_plain": "View and examine the following scenario.Required: Calculate the number of days from 15th March 2020 until today. Given: Dates are stored in the default format of DD-MON-RR.&nbsp; Identify the SQL queries which would give you the required output. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919493,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario: </strong>Pym Tech, a thriving U.S.-based technology manufacturer led by Hank Pym, is headquartered on Treasure Island in San Francisco, California. As the company undergoes rapid expansion, several IT challenges have emerged. To address these, Hank has brought you on board as a consultant to support his IT team.</p><p>Currently, the team is debating the appropriate use cases for the <code>DELETE</code> and <code>TRUNCATE</code> statements in Oracle SQL. Various viewpoints have been shared, and Hank has asked you to help identify which of the following statements are accurate.</p><p><strong>Question: </strong>Which of the following statements about Oracle SQL <code>DELETE</code> and <code>TRUNCATE</code> operations is true?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[The DELETE and TRUNCATE TABLE Statements](https://oracle-base.com/articles/misc/sql-for-beginners-the-delete-and-truncate-table-statements)"
                ],
                "feedbacks": [
                    "The DELETE statement is used to selectively remove rows from a table based on a specified condition. It allows for the removal of specific rows while keeping the rest of the data intact. On the other hand, the TRUNCATE statement removes all rows from a table, making it a faster operation but without the ability to specify conditions for removal.",
                    "The DELETE statement can be rolled back to restore data that was deleted from a table. However, the TRUNCATE statement cannot be rolled back as it removes all rows from a table immediately and cannot be undone. It is important to consider the implications of data loss when choosing between DELETE and TRUNCATE.",
                    "When a DELETE statement is executed, the indexes associated with the table are not automatically removed. However, when a TRUNCATE statement is executed, all indexes and constraints associated with the table are dropped. This can have performance implications and should be considered when deciding between DELETE and TRUNCATE.",
                    "The DELETE statement can be used to remove data from selective columns and rows of a table by specifying conditions in the WHERE clause. On the other hand, the TRUNCATE statement removes all rows from a table without the ability to specify conditions for removal. It is a faster operation compared to DELETE but is less flexible in terms of selective data removal."
                ],
                "explanation": "<p>Let's break down the <strong>behaviour of </strong><code><strong>DELETE</strong></code><strong> and </strong><code><strong>TRUNCATE</strong></code> in Oracle SQL and evaluate the options given.</p><p>Correct Statement:<strong> DELETE but not TRUNCATE statement can be used to selectively remove rows from a table.</strong></p><ul><li><p><strong>True.</strong></p><ul><li><p><code>DELETE</code> can have a <code>WHERE</code> clause to target specific rows:</p><pre class=\"prettyprint linenums\">DELETE FROM employees WHERE department_id = 10;\n</pre></li><li><p><code>TRUNCATE</code> <strong>removes all rows</strong> from a table <strong>without a WHERE clause</strong>.</p></li><li><p><code>TRUNCATE</code> is <strong>not selective</strong> — it's a bulk operation.</p></li></ul></li></ul><p><strong>Incorrect Statements:</strong></p><p><strong>DELETE and TRUNCATE statements can have a rollback done to restore data into a table.</strong></p><ul><li><p><strong>Partially true, but misleading.</strong></p><ul><li><p><code>DELETE</code> is <strong>DML</strong>, and <strong>can be rolled back</strong> if issued inside a transaction before <code>COMMIT</code>.</p></li><li><p><code>TRUNCATE</code> is <strong>DDL</strong>, and <strong>cannot be rolled back</strong> — once issued, it's auto-committed.</p></li></ul></li></ul><p><strong>DELETE and TRUNCATE statements remove all indexes for the tables on which they are performed.</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>Neither <code>DELETE</code> nor <code>TRUNCATE</code> <strong>removes indexes</strong>.</p></li><li><p><strong>Data is deleted</strong>, but <strong>indexes remain intact</strong>.</p></li><li><p>(Note: <code>TRUNCATE</code> <strong>resets high water mark</strong>, but does <strong>not drop indexes</strong>.)</p></li></ul></li></ul><p><strong>DELETE but not TRUNCATE statement can be used to remove data from selective columns and rows of a table.</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p><code>DELETE</code> removes <strong>entire rows</strong>, not just selective columns.</p></li><li><p>To set specific column values to <code>NULL</code>, you'd use <code>UPDATE</code>, not <code>DELETE</code>.</p></li></ul></li></ul><p><strong>TRUNCATE TABLE</strong></p><p>If you want to remove all the rows from a table, the <code>TRUNCATE TABLE</code> statement is a lot more efficient than the <code>DELETE</code> statement. The <code>TRUNCATE TABLE</code> statement is a DDL command, so it includes an implicit <code>COMMIT</code>, so there is no way to issue a <code>ROLLBACK</code> if you decide you didn't want to remove the rows.</p><p><strong>Basic DELETE</strong></p><p>The <code>DELETE</code> statement is used to remove rows from the table. Without a <code>WHERE</code> clause, all rows in the table are deleted by a single statement.</p><p><code>TRUNCATE TABLE</code> removes all rows from a table, but the table structure and its columns, constraints, indexes, and so on remain.</p>",
                "answers": [
                    "<p><code>DELETE</code> but not <code>TRUNCATE</code> statement can be used to selectively remove rows from a table. </p>",
                    "<p><code>DELETE</code> and <code>TRUNCATE</code> statements can have a rollback done to restore data into a table.</p>",
                    "<p><code>DELETE</code> and <code>TRUNCATE</code> statements remove all indexes for the tables on which they are performed.</p>",
                    "<p><code>DELETE</code> but not <code>TRUNCATE</code> statement can be used to remove data from selective columns and rows of a table. </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "TRUNCATE",
            "question_plain": "Scenario: Pym Tech, a thriving U.S.-based technology manufacturer led by Hank Pym, is headquartered on Treasure Island in San Francisco, California. As the company undergoes rapid expansion, several IT challenges have emerged. To address these, Hank has brought you on board as a consultant to support his IT team.Currently, the team is debating the appropriate use cases for the DELETE and TRUNCATE statements in Oracle SQL. Various viewpoints have been shared, and Hank has asked you to help identify which of the following statements are accurate.Question: Which of the following statements about Oracle SQL DELETE and TRUNCATE operations is true?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919495,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario: </strong>Pym Tech, a rapidly growing U.S.-based technology manufacturer led by Hank Pym, is headquartered on Treasure Island in San Francisco, California. As part of its expansion, the company is facing several IT challenges. To support the internal development team, Hank has brought you on board as a subject matter expert in Oracle SQL.</p><p>One of the developers is currently working on a query intended to retrieve particle data from the <code>sources</code> table. However, the developer encounters issues when attempting to execute the following SQL statement:</p><pre class=\"prettyprint linenums\">SELECT particle_id, particle_category\nFROM sourcesd\nWHERE particle_category = 'Bee'\nORDER BY 2 DESC\nUNION\nSELECT particle_id, particle_category\nFROM sources\nWHERE particle_category = 'Wasp'\nUNION\nSELECT particle_id, promo_category\nFROM sources\nWHERE particle_category = 'Ant';\n</pre><p><br></p><p>The developer has asked for your help in identifying the issue.</p><p><strong>Question: </strong>What will happen when the developer attempts to execute the above SQL query?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle ORDER BY Clause](https://www.oracletutorial.com/oracle-basics/oracle-order-by/)"
                ],
                "feedbacks": [
                    "The correct choice. In a compound query using UNION, the ORDER BY clause should only appear at the end of the entire statement, not after each individual SELECT statement. Placing the ORDER BY clause after the second SELECT statement will result in an error.",
                    "This choice is incorrect because the query includes the ORDER BY clause after the second SELECT statement, which violates the rule that it should only appear at the end of the compound query. The rows will not be displayed in descending order of PARTICLE_CATEGORY as expected.",
                    "This choice is incorrect. While it is true that positional notation cannot be used in the ORDER BY clause with SET operators, the error in the query is not related to the use of positional notation. The issue lies in the placement of the ORDER BY clause within the compound query.",
                    "This choice is incorrect. The query will not ignore the ORDER BY clause; instead, it will produce an error because the ORDER BY clause is not located at the end of the compound statement as required. The query will not execute successfully as stated in this choice."
                ],
                "explanation": "<p>Correct Answer: <strong>It produces an error because the ORDER BY clause should appear only at the end of a compound query—that is, with the last SELECT statement.</strong></p><p><br></p><p>In Oracle SQL, when using <strong>set operators</strong> like <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, or <code>MINUS</code>, the <code><strong>ORDER BY</strong></code><strong> clause is only allowed at the very end</strong> of the compound query.</p><p>In the given SQL statement:</p><pre class=\"prettyprint linenums\">SELECT particle_id, particle_category\nFROM sourcesd\nWHERE particle_category = 'Bee'\nORDER BY 2 DESC  -- INVALID here\nUNION\nSELECT particle_id, particle_category\nFROM sources\nWHERE particle_category = 'Wasp'\nUNION\nSELECT particle_id, promo_category\nFROM sources\nWHERE particle_category = 'Ant';\n</pre><ul><li><p><code>ORDER BY 2 DESC</code> is <strong>placed after the first </strong><code><strong>SELECT</strong></code>, which is <strong>not allowed</strong> in a compound query.</p></li><li><p>Oracle requires the entire compound query to be <strong>wrapped up</strong>, and then a <strong>single ORDER BY</strong> at the end if sorting is needed.</p></li></ul><p><strong>Corrected Syntax:</strong></p><p>If the developer wants to sort the final combined result by the <strong>second column in descending order</strong>, they should rewrite it as:</p><pre class=\"prettyprint linenums\">SELECT particle_id, particle_category\nFROM sourcesd\nWHERE particle_category = 'Bee'\nUNION\nSELECT particle_id, particle_category\nFROM sources\nWHERE particle_category = 'Wasp'\nUNION\nSELECT particle_id, promo_category\nFROM sources\nWHERE particle_category = 'Ant'\nORDER BY 2 DESC;\n</pre><p>Tip:</p><ul><li><p><code>UNION</code> removes duplicates (if that’s not desired, use <code>UNION ALL</code>)</p></li><li><p>Positional notation (<code>ORDER BY 2</code>) <strong>is allowed</strong>, but <strong>only at the end</strong> of the full query</p></li></ul><p>In Oracle, a table stores its rows in unspecified order regardless of the order which rows were inserted into the database. To <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\">query</a> rows in either ascending or descending order by a column, you must explicitly instruct Oracle Database that you want to do so.</p><p>To sort the result set by a column, you list that column after the <code>ORDER BY</code> clause.</p><p>Following the column name is a sort order that can be:</p><p><code>ASC</code> for sorting in ascending order</p><p><code>DESC</code> for sorting in descending order</p><p>By default, the <code>ORDER BY</code> clause sorts rows in ascending order whether you specify <code>ASC</code> or not. If you want to sort rows in descending order, you use <code>DESC</code> explicitly.</p><p><code>NULLS FIRST</code> places NULL values before non-NULL values and <code>NULLS LAST</code> puts the NULL values after non-NULL values.</p><p>The <code>ORDER BY</code> clause allows you to sort data by multiple columns where each column may have different sort orders.</p><p>Note that the <code>ORDER BY</code> clause is always the last clause in a <code>SELECT</code> statement.</p>",
                "answers": [
                    "<p>It produces an error because the <code>ORDER BY</code> clause should appear only at the end of a compound query-that is, with the last <code>SELECT</code> statement.</p>",
                    "<p>It executes successfully and displays rows in the descending order of <code>PARTICLE_CATEGORY</code>.</p>",
                    "<p>It produces an error because positional notation cannot be used in the <code>ORDER BY</code> clause with <code>SET</code> operators.</p>",
                    "<p>It executes successfully but ignores the <code>ORDER BY </code>clause because it is not located at the end of the compound statement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ORDER BY",
            "question_plain": "Scenario: Pym Tech, a rapidly growing U.S.-based technology manufacturer led by Hank Pym, is headquartered on Treasure Island in San Francisco, California. As part of its expansion, the company is facing several IT challenges. To support the internal development team, Hank has brought you on board as a subject matter expert in Oracle SQL.One of the developers is currently working on a query intended to retrieve particle data from the sources table. However, the developer encounters issues when attempting to execute the following SQL statement:SELECT particle_id, particle_category\nFROM sourcesd\nWHERE particle_category = 'Bee'\nORDER BY 2 DESC\nUNION\nSELECT particle_id, particle_category\nFROM sources\nWHERE particle_category = 'Wasp'\nUNION\nSELECT particle_id, promo_category\nFROM sources\nWHERE particle_category = 'Ant';\nThe developer has asked for your help in identifying the issue.Question: What will happen when the developer attempts to execute the above SQL query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919497,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>True or False: </strong>Oracle Database can automatically convert a value from one datatype to another. </p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Type Comparison Rules](https://docs.oracle.com/search/?q=Datatype%2520Comparison%2520Rules&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)"
                ],
                "feedbacks": [
                    "<p>TRUE. Oracle Database has implicit data type conversion capabilities, which means it can automatically convert a value from one data type to another when necessary. This feature helps in simplifying queries and operations by allowing the database to handle data type conversions seamlessly.</p>",
                    "<p>Oracle Database does have the ability to automatically convert data types in certain scenarios, but it is not always the case. There are situations where explicit data type conversion functions or operations need to be used to ensure accurate and desired results. Automatic data type conversion is not always guaranteed in Oracle Database. To say that Oracle Database <strong>CANNOT </strong>automatically convert a value from one datatype to another is untrue, therefore, at times it can.</p>"
                ],
                "explanation": "<p><strong>True: </strong>Oracle Database can automatically convert a value from one datatype to another. </p><p>Oracle Database can <strong>automatically perform implicit datatype conversions</strong> when it encounters operations involving mismatched types—<em>as long as the conversion makes sense</em>. For example:</p><ul><li><p>Comparing a <code>VARCHAR2</code> value like <code>'5000'</code> to a <code>NUMBER</code> column? Oracle will try to convert the string to a number.</p></li><li><p>Concatenating a <code>NUMBER</code> with a string? Oracle will convert the number to a string behind the scenes.</p></li><li><p>Filtering a <code>DATE</code> column using a string like <code>'28-MAR-2025'</code>? Oracle will interpret the string as a date based on session settings.</p></li></ul><p>This feature is called <strong>implicit conversion</strong>, and while it's convenient, it can sometimes lead to unexpected behaviour or performance issues if not used carefully.</p><p>Examples where <strong>implicit datatype conversion</strong> in Oracle can lead to surprises—or subtle bugs.</p><p><strong>Example 1: Comparing a Number and a String</strong></p><pre class=\"prettyprint linenums\">SELECT * FROM employees WHERE salary = '5000';\n</pre><ul><li><p>Here, <code>'5000'</code> is a string, but <code>salary</code> is a <code>NUMBER</code>.</p></li><li><p>Oracle will <strong>implicitly convert</strong> the string <code>'5000'</code> to the number <code>5000</code> and perform the comparison.</p></li><li><p>This works—but if you had <code>'5000ABC'</code>, it would throw an error.</p></li></ul><p><em>Tip:</em> It’s safer to convert explicitly, like <code>salary = TO_NUMBER('5000')</code>.</p><p><strong>Example 2: Date vs. String</strong></p><pre class=\"prettyprint linenums\">SELECT * FROM orders WHERE order_date = '15-JUL-2024';\n</pre><ul><li><p><code>'15-JUL-2024'</code> is a string, and Oracle will convert it to a <code>DATE</code>, assuming your session's <code>NLS_DATE_FORMAT</code> matches.</p></li><li><p>If it doesn't, you’ll get an error or unexpected results.</p></li></ul><p><em>Tip:</em> Use <code>TO_DATE('15-JUL-2024', 'DD-MON-YYYY')</code> to be clear.</p><p><strong>Example 3: Concatenating Strings and Numbers</strong></p><pre class=\"prettyprint linenums\">SELECT 'The total is: ' || total_amount FROM invoices;\n</pre><ul><li><p>If <code>total_amount</code> is a <code>NUMBER</code>, Oracle will implicitly convert it to a string so it can concatenate.</p></li></ul><p><em>Tip:</em> You can also do this explicitly with <code>TO_CHAR(total_amount)</code> for format control.</p><p>If you're working on queries and want to avoid Oracle trying to \"guess\" your intention, being explicit with conversions is your best friend.</p><p><br></p><p><strong>Oracle Database has implicit data type conversion capabilities</strong></p><p>This means it can automatically convert a value from one data type to another when necessary. This feature helps in simplifying queries and operations by allowing the database to handle data type conversions seamlessly. The question is asking if it is possible to do, and it is possible to do.</p><p>I realize that while Oracle Database does have the ability to automatically convert data types in certain scenarios, but it is not always the case. There are situations where explicit data type conversion functions or operations need to be used to ensure accurate and desired results. Automatic data type conversion is not always guaranteed in Oracle Database.</p><p>Oracle recommends that you specify explicit conversions, rather than rely on implicit or automatic conversions, but it can do it.</p><p>You will often find questions on the official exam which ask if things are possible, even if they are not recommended or a best practice. This is one of those types of questions.</p><p>To say that Oracle Database <strong>CANNOT </strong>automatically convert a value from one datatype to another is untrue, therefore, at times it can.</p><p><strong>Numeric Values</strong></p><p>A larger value is considered greater than a smaller one. All negative numbers are less than zero and all positive numbers. Thus, -1 is less than 100; -100 is less than -1.</p><p>The floating-point value <code>NaN</code> (not a number) is greater than any other numeric value and is equal to itself.</p><p><strong>Date Values</strong></p><p>A later date is considered greater than an earlier one. For example, the date equivalent of '29-MAR-1997' is less than that of '05-JAN-1998' and '05-JAN-1998 1:35pm' is greater than '05-JAN-1998 10:09am'.</p><p><strong>Data Conversion</strong></p><p>Generally an expression cannot contain values of different datatypes. For example, an expression cannot multiply 5 by 10 and then add 'JAMES'. However, Oracle supports both implicit and explicit conversion of values from one datatype to another.</p><p><strong>Implicit and Explicit Data Conversion</strong></p><p>Oracle recommends that you specify explicit conversions, rather than rely on implicit or automatic conversions, for these reasons:</p><p>SQL statements are easier to understand when you use explicit datatype conversion functions.</p><p>Implicit datatype conversion can have a negative impact on performance, especially if the datatype of a column value is converted to that of a constant rather than the other way around.</p><p>Implicit conversion depends on the context in which it occurs and may not work the same way in every case. For example, implicit conversion from a datetime value to a <code>VARCHAR2</code> value may return an unexpected year depending on the value of the <code>NLS_DATE_FORMAT</code> parameter.</p><p>Algorithms for implicit conversion are subject to change across software releases and among Oracle products. Behavior of explicit conversions is more predictable.</p><p><strong>Implicit Data Conversion</strong></p><p>Oracle Database automatically converts a value from one datatype to another when such a conversion makes sense. </p>",
                "answers": [
                    "<p>TRUE</p>",
                    "<p>FALSE</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Reference",
            "question_plain": "True or False: Oracle Database can automatically convert a value from one datatype to another.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919499,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required:</strong> Create a table EMPLOYEES in which the values in the columns EMPLOYEES_ID and LOGIN_ID must be unique and not null.&nbsp; </p><p>Identify the SQL statement which would create the required table.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Constraint](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html#GUID-1055EA97-BA6F-4764-A15F-1024FD5B6DFE)"
                ],
                "feedbacks": [
                    "This SQL statement creates a table named EMPLOYEES with columns for employee_id, login_id, employee_name, and hire_date. It includes constraints to ensure that both employee_id and login_id are not null and unique. The UNIQUE constraint on (employee_id, login_id) enforces the requirement that the combination of these two columns must be unique in the table.",
                    "This SQL statement creates a table named EMPLOYEES with columns for employee_id, login_id, employee_name, and hire_date. However, it does not include any constraints to enforce the uniqueness and non-nullability of the employee_id and login_id columns as required.",
                    "This SQL statement creates a table named EMPLOYEES with columns for employee_id, login_id, employee_name, and hire_date. While it includes a PRIMARY KEY constraint on employee_id and a UNIQUE constraint on login_id, it does not enforce the requirement for both columns to be unique in combination.",
                    "This SQL statement attempts to create a table named EMPLOYEES with columns for employee_id, login_id, employee_name, and hire_date. However, the ALTER TABLE statement is incorrectly used within the CREATE TABLE statement. Additionally, the syntax for adding constraints is incorrect, and the constraints are not defined correctly to ensure the uniqueness and non-nullability of the columns.",
                    "This SQL statement creates a table named EMPLOYEES with columns for employee_id, login_id, employee_name, and hire_date. It includes a UNIQUE constraint on (employee_id, login_id) to enforce the requirement that the combination of these two columns must be unique in the table. However, it does not specify the columns as not null, which is a requirement for the EMPLOYEES_ID and LOGIN_ID columns."
                ],
                "explanation": "<p>To satisfy the requirement: <strong>Create a table </strong><code><strong>EMPLOYEES</strong></code><strong> in which the values in the columns </strong><code><strong>EMPLOYEE_ID</strong></code><strong> and </strong><code><strong>LOGIN_ID</strong></code><strong> must be unique and not null.</strong></p><p>We are looking for a SQL statement that ensures <strong>both </strong><code><strong>employee_id</strong></code><strong> and </strong><code><strong>login_id</strong></code><strong> are</strong>:</p><ol><li><p><strong>Not null</strong>, and</p></li><li><p><strong>Together uniquely identify each row</strong> (i.e., unique as a pair).</p></li></ol><p><strong>Correct SQL Statement:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER CONSTRAINT emp_id_nn NOT NULL, \n  login_id NUMBER CONSTRAINT login_id_nn NOT NULL, \n  employee_name VARCHAR2(100), \n  hire_date DATE, \n  CONSTRAINT emp_num_id_uk UNIQUE (employee_id, login_id));\n</pre><p>Why this is correct:</p><ul><li><p><code>employee_id</code> and <code>login_id</code> are each explicitly <code><strong>NOT NULL</strong></code></p></li><li><p>A <strong>composite </strong><code><strong>UNIQUE</strong></code><strong> constraint</strong> is created on <code>(employee_id, login_id)</code></p></li><li><p>This ensures that <strong>no two rows have the same combination</strong> of employee and login IDs</p></li></ul><p><strong>Incorrect Options:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER, \n  login_id NUMBER, \n  employee_name VARCHAR2(100), \n  hire_date DATE);\n</pre><ul><li><p>No constraints at all — does <strong>not enforce uniqueness or NOT NULL</strong> </p></li></ul><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE employees\n    ADD(\n        CONSTRAINT emp_id_pk PRIMARY KEY (employee_id, login_id), \n        CONSTRAINT emp_id_uk UNIQUE (employee_id, login_id));\n</pre><ul><li><p><strong>Only valid if the table already exists</strong>, but no <code>CREATE TABLE</code> shown.</p></li><li><p>Also, adding both <strong>PRIMARY KEY</strong> and <strong>UNIQUE</strong> on the same columns is redundant. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/q_and_a/2023-04-28_20-15-58-a5e323a9900081a9b5057bb3ddb48a9d.png\"></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER CONSTRAINT emp_id_pk PRIMARY KEY, \n  login_id NUMBER UNIQUE, \n  employee_name VARCHAR2(25), \n  hire_date DATE);\n</pre><ul><li><p>This makes <code>employee_id</code> a <strong>primary key (unique + not null)</strong> Okay</p></li><li><p>And makes <code>login_id</code> <strong>individually unique</strong> Okay</p></li><li><p>But it <strong>does not enforce uniqueness on the combination</strong> (<code>employee_id</code>, <code>login_id</code>) Not Okay</p></li><li><p>Also doesn't make <code>login_id</code> <code>NOT NULL</code>, unless explicitly declared.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER, \n  login_id NUMBER, \n  employee_name VARCHAR2(100), \n  hire_date DATE, \n  ALTER TABLE \n  ADD CONSTRAINT emp_id_uk UNIQUE (employee_id, login_id)\n  ADD CONSTRAINT emp_id_nn NOT NULL (employee_id, login_id));\n</pre><ul><li><p>Invalid syntax — you <strong>can't have </strong><code><strong>ALTER TABLE</strong></code><strong> inside a </strong><code><strong>CREATE TABLE</strong></code> statement.</p></li><li><p><code>NOT NULL</code> constraints <strong>must be applied column by column</strong>, not as a group.</p><p><br></p></li></ul><p><strong>Unique Constraint</strong></p><p>A <code>UNIQUE</code> constraint is a single field or combination of fields that uniquely defines a record. Some of the fields can contain null values as long as the combination of values is unique.</p><p>Note: In Oracle, a <code>UNIQUE</code> constraint can not contain more than 32 columns.</p><p>A unique constraint can be defined in either a <code>CREATE TABLE</code> statement or an <code>ALTER TABLE</code> statement.</p><p><strong>Create unique Constraint - Using a </strong><code><strong>CREATE TABLE</strong></code><strong> statement</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating a unique constraint using a CREATE TABLE statement in Oracle is:</p><pre class=\"prettyprint linenums\">CREATE TABLE table_name\n(\n  column1 datatype [ NULL | NOT NULL ],\n  column2 datatype [ NULL | NOT NULL ],\n  ...\n\n  CONSTRAINT constraint_name UNIQUE (uc_col1, uc_col2, ... uc_col_n)\n);</pre><p><br></p><p>table_name - The name of the table that you wish to create. </p><p>column1, column2 - The columns that you wish to create in the table. </p><p>constraint_name - The name of the unique constraint. </p><p>uc_col1, uc_col2, ... uc_col_n - The columns that make up the unique constraint.</p><p><br></p><p><strong>Create unique constraint - Using an </strong><code><strong>ALTER TABLE</strong></code><strong> statement</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating a unique constraint using an <code>ALTER TABLE</code> statement in Oracle is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\nADD CONSTRAINT constraint_name UNIQUE (column1, column2, ... column_n);</pre><p><br></p><p>table_name - The name of the table to modify. This is the table that you wish to add a unique constraint to. </p><p>constraint_name - The name of the unique constraint. </p><p>column1, column2, ... column_n - The columns that make up the unique constraint.</p><p><br></p><p>In Oracle, a <code>PRIMARY KEY</code> is a single field or combination of fields that uniquely defines a record. None of the fields that are part of the primary key can contain a null value. A table can have only one primary key.</p><p>Note: In Oracle, a primary key can not contain more than 32 columns.</p><p><br></p><p>A primary key can be defined in either a <code>CREATE TABLE</code> statement or an <code>ALTER TABLE</code> statement.</p><p><br></p><p><strong>Create Primary Key - Using </strong><code><strong>CREATE TABLE</strong></code><strong> statement</strong></p><p>You can create a primary key in Oracle with the <code>CREATE TABLE</code> statement.</p><p><strong>Syntax</strong></p><p>The syntax to create a primary key using the <code>CREATE TABLE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE TABLE table_name\n(\n  column1 datatype null/not null,\n  column2 datatype null/not null,\n  ...\n\n  CONSTRAINT constraint_name PRIMARY KEY (column1, column2, ... column_n)\n);</pre><p><br></p><p><strong>Create Primary Key - Using </strong><code><strong>ALTER TABLE</strong></code><strong> statement</strong></p><p>You can create a primary key in Oracle with the <code>ALTER TABLE</code> statement.</p><p><strong>Syntax</strong></p><p>The syntax to create a primary key using the <code>ALTER TABLE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\nADD CONSTRAINT constraint_name PRIMARY KEY (column1, column2, ... column_n);</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER CONSTRAINT emp_id_nn NOT NULL, \n  login_id NUMBER CONSTRAINT login_id_nn NOT NULL, \n  employee_name VARCHAR2(100), \n  hire_date DATE, \n  CONSTRAINT emp_num_id_uk UNIQUE (employee_id, login_id));\n</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER, \n  login_id NUMBER, \n  employee_name VARCHAR2(100), \n  hire_date DATE);\n\nALTER TABLE employees\n&nbsp; &nbsp; ADD(\n&nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT emp_id_pk PRIMARY KEY (employee_id, login_id), \n&nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT emp_id_uk UNIQUE (employee_id, login_id));</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER CONSTRAINT emp_id_pk PRIMARY KEY, \n  login_id NUMBER UNIQUE, \n  employee_name VARCHAR2(25), \n  hire_date DATE);</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER, \n  login_id NUMBER, \n  employee_name VARCHAR2(100), \n  hire_date DATE, \n\nALTER TABLE \nADD CONSTRAINT emp_id_uk UNIQUE (employee_id, login_id)\nADD CONSTRAINT emp_id_nn NOT NULL (employee_id, login_id));</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees( \n  employee_id NUMBER, \n  login_id NUMBER, \n  employee_name VARCHAR2(100), \n  hire_date DATE, \n  CONSTRAINT emp_id_uk UNIQUE (employee_id, login_id));</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following available responses.Required: Create a table EMPLOYEES in which the values in the columns EMPLOYEES_ID and LOGIN_ID must be unique and not null.&nbsp; Identify the SQL statement which would create the required table.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919501,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement(s) about the ORDER BY clause when used with a SQL statement containing a SET operator such as UNION.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ORDER BY Clause](https://www.techonthenet.com/oracle/order_by.php)",
                    "[Sorting Query Results](https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)",
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "<p>Only column names from the first SELECT statement in the compound query are recognized when using the ORDER BY clause. This means that the ORDER BY clause will sort the final result set based on the columns specified in the first SELECT statement.</p>",
                    "<p>In a SQL statement containing a SET operator like UNION, each SELECT statement can have its own ORDER BY clause, but it is not a requirement for each SELECT statement to have one.</p>",
                    "<p>Each SELECT statement in the compound query can indeed have its own ORDER BY clause. This allows for sorting the result set of each individual SELECT statement before combining them with the SET operator.</p>",
                    "<p>Column positions are not required to be used in the ORDER BY clause when working with a SQL statement containing a SET operator like UNION. Column names can be used for sorting the result set.</p>"
                ],
                "explanation": "<p>Let's evaluate the options carefully based on how the <code>ORDER BY</code> clause works with <strong>SET operators</strong> like <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code> in Oracle SQL.</p><p>Correct Statement: <strong>Only column names from the first SELECT statement in the compound query are recognized.</strong></p><p><strong>True statement.</strong></p><ul><li><p>In a compound query, <strong>column aliases and names</strong> used in the final <code>ORDER BY</code> must come <strong>from the first </strong><code><strong>SELECT</strong></code><strong> statement</strong>, because the <strong>first SELECT defines the column names</strong> for the combined result set.</p></li><li><p>You can also use <strong>column positions</strong> (e.g., <code>ORDER BY 1</code>, <code>ORDER BY 2</code>), but <strong>you are not required</strong> to do so.</p></li></ul><p>Incorrect Statements:</p><p><strong>Each SELECT statement in the compound query must have its own ORDER BY clause.</strong></p><ul><li><p><strong>False.</strong> Oracle does <strong>not allow</strong> <code>ORDER BY</code> inside each individual <code>SELECT</code> in a compound query.</p></li><li><p>Only <strong>one </strong><code><strong>ORDER BY</strong></code><strong> clause</strong> is allowed, and it must be placed <strong>at the end</strong> of the entire compound query.</p></li></ul><p><strong>Each SELECT statement in the compound query can have its own ORDER BY clause.</strong></p><ul><li><p><strong>False.</strong> This will result in a <strong>syntax error</strong> in Oracle.</p></li><li><p>You <strong>cannot</strong> place <code>ORDER BY</code> inside each <code>SELECT</code> in a compound query.</p></li></ul><p><strong>Column positions must be used in the ORDER BY clause.</strong></p><ul><li><p><strong>False.</strong></p></li><li><p><strong>Column positions</strong> (like <code>ORDER BY 2</code>) <strong>can be used</strong>, but they are <strong>not mandatory</strong>.</p></li><li><p>You can also use <strong>column names or aliases</strong>—as long as they come from the <strong>first SELECT</strong>.</p></li></ul><p>The Oracle <code>ORDER BY</code> clause is used to sort the records in your result set. The <code>ORDER BY</code> clause can only be used in<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the ORDER BY clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expressions\nFROM tables\n[WHERE conditions]\nORDER BY expression [ ASC | DESC ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions The columns or calculations that you wish to retrieve. tables The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. WHERE conditions Optional. The conditions that must be met for the records to be selected. ASC Optional. It sorts the result set in ascending order by <em>expression</em> (default, if no modifier is provider). DESC Optional. It sorts the result set in descending order by <em>expression</em>.</p><p>Note: If the ASC or DESC modifier is not provided in the ORDER BY clause, the results will be sorted by <em>expression</em> in ascending order (which is equivalent to <code>ORDER BY <em>expression</em> ASC</code>.</p><p><strong>Sorting Query Results</strong></p><p>Use the <code>ORDER BY</code> clause to order the rows selected by a query. Sorting by position is useful in the following cases:</p><p>To order by a lengthy select list expression, you can specify its position in the <code>ORDER BY</code> clause rather than duplicate the entire expression.</p><p>For compound queries containing set operators <code>UNION</code>, <code>INTERSECT</code>, <code>MINUS</code>, or <code>UNION</code> <code>ALL</code>, the <code>ORDER BY</code> clause must specify positions or aliases rather than explicit expressions. Also, the <code>ORDER BY</code> clause can appear only in the last component query. The <code>ORDER BY</code> clause orders all rows returned by the entire compound query.</p><p><strong>Compound queries</strong> are used when you want to combine the results of two other queries to come up with a new set of results. In a compound query, you can combine the queries by adding their results together, subtracting the results of one query from the other, or intersecting the results to find only the accounts or entries that exist in both queries.</p><p>A subquery is a <code>SELECT</code> statement nested inside another statement such as <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>. Typically, you can use a subquery anywhere that you use an expression.</p><p><strong>Oracle evaluates the whole query above in two steps:</strong></p><p>First, execute the subquery.</p><p>Second, use the result of the subquery in the outer query.</p><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS such as MySQL and PostgreSQL use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p><p>A subquery nested in the <code>WHERE</code> clause of the <code>SELECT</code> statement is called a <strong>nested subquery</strong>.</p><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <code>WHERE</code> clause.</p><p><strong>Advantages of Oracle subqueries</strong></p><p>• Provide an alternative way to query data that would require complex <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">joins</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\">unions</a>.</p><p>• Make the complex queries more readable.</p><p>• Allow a complex query to be structured in a way that it is possible to isolate each part.</p><p>The output of a compound query will only product the column names from the main <code>SELECT</code>&nbsp;statement, sub-query column names may appear in the output, but only if they are listed in the main query <code>SELECT</code>&nbsp;statement.</p><p><em>√ Only column names from the first SELECT statement in the compound query are recognized.</em></p>",
                "answers": [
                    "<p>Only column names from the first SELECT statement in the compound query are recognized.</p>",
                    "<p>Each SELECT statement in the compound query must have its own ORDER BY clause.</p>",
                    "<p>Each SELECT statement in the compound query can have its own ORDER BY clause.</p>",
                    "<p>Column positions must be used in the ORDER BY clause.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following available responses.Identify the true statement(s) about the ORDER BY clause when used with a SQL statement containing a SET operator such as UNION.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919503,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Which of the following are true statements about Oracle non equi join?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ Optimization of Joins ](https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c20c_joi.htm)"
                ],
                "feedbacks": [
                    "In Oracle non equi joins, the performance difference between the &gt;=, &lt;=, and BETWEEN operators is negligible. The Oracle optimizer is efficient in handling these operators, resulting in similar performance outcomes for queries using any of these operators.",
                    "Table aliases do not have a significant impact on the performance of queries involving Oracle non equi joins. While aliases can improve query readability and organization, they do not directly affect the query execution time or optimization process.",
                    "Contrary to the statement, using table aliases does not provide a significant performance improvement in queries related to Oracle non equi joins. Table aliases primarily serve to simplify query syntax and enhance code readability rather than impacting query performance.",
                    "The performance comparison between the &gt;= and &lt;= operators versus the BETWEEN operator in Oracle non equi joins is not straightforward. The efficiency of these operators can vary based on factors such as data distribution, indexing strategies, and query optimization techniques.",
                    "The assertion that the &gt;= and &lt;= operators are slower than the BETWEEN operator in Oracle non equi joins is not universally true. The performance characteristics of these operators depend on the specific query context, data volume, and indexing structures in use."
                ],
                "explanation": "<p>True statements:</p><p><strong>1. There is no significant performance difference between </strong><code><strong>&gt;=</strong></code><strong> </strong><code><strong>&lt;=</strong></code><strong> and </strong><code><strong>BETWEEN</strong></code></p><ul><li><p><code>BETWEEN a AND b</code> is <strong>logically equivalent</strong> to <code>&gt;= a AND &lt;= b</code>, and Oracle's optimizer generally treats them the same.</p></li><li><p>There's <strong>no significant performance difference</strong> in practice unless other factors (like indexes, data distribution, or complex conditions) are involved.</p></li></ul><p><strong>2. Using table alias provides no significant performance improvement in queries</strong></p><ul><li><p><strong>Table aliases are syntactic sugar</strong> — they make queries shorter and more readable, especially with multiple tables, but they <strong>do not affect query performance</strong>.</p></li><li><p>Aliases are purely for <strong>developer convenience and clarity</strong>.</p></li></ul><p>Incorrect statements:</p><ul><li><p><strong>Using table alias provides significant performance improvement in queries</strong></p><ul><li><p>As explained above, aliases <strong>do not impact performance</strong> — they help with readability, especially in joins or self-joins, but they are not a performance factor.</p></li></ul></li></ul><ul><li><p><code><strong>&gt;=</strong></code><strong> and </strong><code><strong>&lt;=</strong></code><strong> is faster than </strong><code><strong>BETWEEN</strong></code></p><ul><li><p><code>BETWEEN a AND b</code> is parsed by Oracle as <code>&gt;= a AND &lt;= b</code>.</p></li><li><p>So there's <strong>no performance gain</strong> using either syntax — they result in <strong>equivalent execution plans</strong>.</p></li></ul></li></ul><ul><li><p><code><strong>&gt;=</strong></code><strong> and </strong><code><strong>&lt;=</strong></code><strong> is slower than </strong><code><strong>BETWEEN</strong></code></p><ul><li><p>Again, same logic: no measurable performance difference. Both produce similar results in the <strong>optimizer and execution plan</strong>.</p></li></ul></li></ul><p><strong>Sort-Merge Join</strong></p><p>Oracle can only perform a sort-merge join for an equijoin. To perform a sort-merge join, Oracle follows these steps:</p><ol><li><p>Oracle sorts each row source to be joined if they have not been sorted already by a previous operation. The rows are sorted on the values of the columns used in the join condition.</p><p><br></p></li><li><p>Oracle merges the two sources so that each pair of rows, one from each source, that contain matching values for the columns used in the join condition are combined and returned as the resulting row source.</p></li></ol><pre class=\"prettyprint linenums\">SELECT * \n  FROM emp, dept \n  WHERE emp.deptno = dept.deptno; \n</pre><p><br></p><p><br></p><p><img src=\"https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c20c_joa.gif\"></p><p><br></p><p>To execute this statement, Oracle performs these steps:</p><ul><li><p>Steps 3 and 5 perform full table scans of the EMP and DEPT tables.</p></li><li><p>Steps 2 and 4 sort each row source separately.</p></li><li><p>Step 1 merges the sources from Steps 2 and 4 together, combining each row from Step 2 with each matching row from Step 4, and returns the resulting row source.</p><p><br></p></li></ul><p><strong>Cluster Join</strong></p><p>Oracle can perform a cluster join only for an equijoin that equates the cluster key columns of two tables in the same cluster. In a cluster, rows from both tables with the same cluster key values are stored in the same blocks, so Oracle only accesses those blocks.</p><p><br></p><p><strong>Additional Information:</strong></p><p><a href=\"https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67775/toc.htm\"><em>Oracle8i Tuning</em></a> provides guidelines for deciding which tables to cluster for best performance.</p><p><br></p><p>EMP and DEPT tables are stored together in the same cluster:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \n  FROM emp, dept \n  WHERE emp.deptno = dept.deptno; \n</pre><p><br></p><p><img src=\"https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c20c_ja1.gif\"></p><p><br></p><p>To execute this statement, Oracle performs these steps:</p><ul><li><p>Step 2 accesses the outer table (DEPT) with a full table scan.</p></li><li><p>For each row returned by Step 2, Step 3 uses the DEPT.DEPTNO value to find the matching rows in the inner table (EMP) with a cluster scan.</p></li></ul><p>A cluster join is nothing more than a nested loops join involving two tables that are stored together in a cluster. Since each row from the DEPT table is stored in the same data blocks as the matching rows in the EMP table, Oracle can access matching rows most efficiently.</p><p><br></p><p><strong>Hash Join</strong></p><p>Oracle can only perform a hash join for an equijoin. Hash join is not available with rule-based optimization. You must enable hash join optimization, using the initialization parameter HASH_JOIN_ENABLED (which can be set with the ALTER SESSION command) or the USE_HASH hint.</p><p>To perform a hash join, Oracle follows these steps:</p><ol><li><p>Oracle performs a full table scan on each of the tables and splits each into as many partitions as possible based on the available memory.</p></li><li><p>Oracle builds a hash table from one of the partitions (if possible, Oracle will select a partition that fits into available memory). Oracle then uses the corresponding partition in the other table to probe the hash table. All partition pairs that do not fit into memory are placed onto disk.</p></li><li><p>For each pair of partitions (one from each table), Oracle uses the smaller one to build a hash table and the larger one to probe the hash table.</p><p><br></p></li></ol><pre class=\"prettyprint linenums\">SELECT * \n  FROM emp, dept \n  WHERE emp.deptno = dept.deptno; \n</pre><p><br></p><p><img src=\"https://docs.oracle.com/cd/F49540_01/DOC/server.815/a67781/c20c_ja2.gif\"></p><p><br></p><p>To execute this statement, Oracle performs these steps:</p><ul><li><p>Steps 2 and 3 perform full table scans of the EMP and DEPT tables.</p></li><li><p>Step 1 builds a hash table out of the rows coming from Step 2 and probes it with each row coming from Step 3.</p></li></ul><p>The initialization parameter HASH_AREA_SIZE controls the amount of memory used for hash join operations and the initialization parameter HASH_MULTIBLOCK_IO_COUNT controls the number of blocks a hash join operation should read and write concurrently.</p>",
                "answers": [
                    "<p>There is no significant performance difference between &gt;= &lt;= and BETWEEN</p>",
                    "<p>Using table alias provides no significant performance improvement in queries</p>",
                    "<p>Using table alias provides significant performance improvement in queries</p>",
                    "<p>&gt;= and &lt;= is faster than BETWEEN</p>",
                    "<p>&gt;= and &lt;= is slower than BETWEEN</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "JOIN",
            "question_plain": "Which of the following are true statements about Oracle non equi join?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919505,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p>You are working with a&nbsp; table which has a <code>DATE</code> column and <code>NUMBER(8,2)</code> column.</p><p>Which of the following conditions will result in an implicit conversion when used with a syntactically proper <code>SELECT</code> statement? (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Implicit conversion](https://docs.oracle.com/cd/E73729_01/DR/Implicit_Conversion.html)",
                    "[Oracle Data Type Implicit Conversion Hierarchy](https://www.red-gate.com/simple-talk/databases/oracle-databases/oracle-data-type-implicit-conversion-hierarchy/)",
                    "[Data Type Comparison Rules ](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-1563C817-86BF-430B-99AB-322EE2E29187)"
                ],
                "feedbacks": [
                    "<p>The condition WHERE to_char(order_no) = '0001' will result in an explicit conversion because <code>TO_CHAR(order_no)</code> explicitly converts the number to a string and <code>'0001'</code> is already a string.</p>",
                    "The condition WHERE order_no = '0001' will result in an implicit conversion because the order_no column is a NUMBER data type, but it is being compared with a string literal '0001'. This can lead to potential data type conversion errors and unexpected results.",
                    "The condition WHERE inv_date = '12-OCT-24' will result in an implicit conversion because the inv_date column is a DATE data type, but it is being compared with a string literal '12-OCT-24'. This can lead to potential data type conversion errors and unexpected results.",
                    "The condition WHERE inv_date = DATE '12-OCT-24' will not result in an implicit conversion because the date literal '12-OCT-24' is explicitly cast as a DATE data type. This ensures that the comparison is done between two values of the same data type, avoiding any implicit conversions."
                ],
                "explanation": "<p>The conditions that will result in an <strong>implicit </strong>conversion are:</p><ul><li><p><code>WHERE order_no = '0001'</code></p></li><li><p><code>WHERE inv_date = '12-OCT-24'</code></p></li></ul><p>Let's analyze each condition:</p><ol><li><p><code><strong>WHERE to_char(order_no) = '0001'</strong></code></p><ul><li><p>Here, <code>order_no</code> (a <code>NUMBER</code> type) is explicitly converted to a <code>VARCHAR2</code> using <code>to_char()</code>.</p></li><li><p>Then, it's compared to the string literal <code>'0001'</code>.</p></li><li><p><strong>Result: Explicit conversion.</strong></p></li></ul></li><li><p><code><strong>WHERE order_no = '0001'</strong></code></p><ul><li><p><code>order_no</code> is a <code>NUMBER(8,2)</code> type.</p></li><li><p><code>'0001'</code> is a string literal.</p></li><li><p>When comparing a number to a string, the database will attempt to implicitly convert the string to a number to perform the comparison.</p></li><li><p><strong>Result: Implicit conversion.</strong></p></li></ul></li><li><p><code><strong>WHERE inv_date = '12-OCT-24'</strong></code></p><ul><li><p><code>inv_date</code> is a <code>DATE</code> type.</p></li><li><p><code>'12-OCT-24'</code> is a string literal.</p></li><li><p>The database will implicitly try to convert the string <code>'12-OCT-24'</code> to a <code>DATE</code> using the default date format of the session (e.g., <code>DD-MON-RR</code> or <code>DD-MON-YYYY</code>).</p></li><li><p><strong>Result: Implicit conversion.</strong></p></li></ul></li><li><p><code><strong>WHERE inv_date = DATE '12-OCT-24'</strong></code></p><ul><li><p><code>inv_date</code> is a <code>DATE</code> type.</p></li><li><p><code>DATE '12-OCT-24'</code> is a date literal. The <code>DATE</code> keyword explicitly tells the database that <code>'12-OCT-24'</code> should be treated as a date.</p></li><li><p><strong>Result: No implicit conversion (explicit date literal).</strong></p></li></ul></li></ol><p>In Oracle, <strong>implicit</strong> and <strong>explicit</strong> conversions both deal with changing a value from one datatype to another—but the key difference lies in <strong>who initiates the conversion</strong> and <strong>how predictable it is</strong>.</p><p><strong>Implicit Conversion</strong></p><p>Oracle performs this <strong>automatically</strong> when it encounters mismatched datatypes in an expression or condition.</p><p><strong>Example:</strong></p><pre class=\"prettyprint linenums\">SELECT * FROM employees WHERE salary = '5000';\n</pre><ul><li><p><code>salary</code> is a <code>NUMBER</code>, <code>'5000'</code> is a <code>VARCHAR2</code>.</p></li><li><p>Oracle <strong>implicitly converts</strong> <code>'5000'</code> to a number.</p></li></ul><p><strong>Pros:</strong></p><ul><li><p>Convenient for quick queries.</p></li><li><p>Often works without issue if formats align.</p></li></ul><p><strong>Cons:</strong></p><ul><li><p>Can lead to <strong>unexpected errors</strong> or <strong>performance issues</strong>, especially with indexes.</p></li><li><p>Behaviour may vary across Oracle versions.</p></li></ul><p>Implicit conversion occurs when operands of differing types are acted upon by an operator. During assignment, the result of the operand on the right will always be implicitly converted to the type of operand on the left of the assignment operator. This table outlines the conversion rules that occur in operations other than assignments:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2024-10-22_00-33-15-f114e289ace63dadbf1daa2e89a69c2d.png\"></p><p><strong>Explicit Conversion</strong></p><p>You, the developer, <strong>explicitly tell Oracle</strong> to convert a value using functions like <code>TO_CHAR</code>, <code>TO_DATE</code>, or <code>TO_NUMBER</code>.</p><p><strong>Example:</strong></p><pre class=\"prettyprint linenums\">SELECT * FROM employees WHERE TO_NUMBER('5000') = salary;\n</pre><p><strong>Pros:</strong></p><ul><li><p><strong>Predictable and readable</strong>.</p></li><li><p>Avoids ambiguity and improves maintainability.</p></li><li><p>Recommended by Oracle for clarity and control.</p></li></ul><p><strong>Cons:</strong></p><ul><li><p>Slightly more verbose.</p></li></ul><p>Oracle’s Recommendation</p><p>Oracle encourages <strong>explicit conversions</strong> whenever possible, especially in production code, because they make SQL statements easier to understand and debug.</p>",
                "answers": [
                    "<p><code>WHERE to_char(order_no) = '0001'</code> </p>",
                    "<p><code>WHERE order_no = '0001'</code> </p>",
                    "<p><code>WHERE inv_date = '12-OCT-24'</code> </p>",
                    "<p><code>WHERE inv_date = DATE '12-OCT-24'</code> </p>"
                ]
            },
            "correct_response": [
                "b",
                "c"
            ],
            "section": "Conversion",
            "question_plain": "View and examine the following scenario.You are working with a&nbsp; table which has a DATE column and NUMBER(8,2) column.Which of the following conditions will result in an implicit conversion when used with a syntactically proper SELECT statement? (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919511,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given:</strong> An Oracle database server session has an uncommitted transaction in progress which updated 5000 rows in a table.</p><p>Identify the situations where the transactions complete thereby committing the updates. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Statements That Cause an Implicit Commit](https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/implicit-commit.html)",
                    "[Data Definition Language (DDL) Statements](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Types-of-SQL-Statements.html#GUID-FD9A8CB4-6B9A-44E5-B114-EFB8DA76FC88)",
                    "[SQL Commands](https://docs.oracle.com/cd/E12095_01/doc.10303/e12092/sqcmd.htm)"
                ],
                "feedbacks": [
                    "Creating an index in the same session where the uncommitted transaction is in progress will commit the updates made to the table. This is because creating an index is considered a DDL operation, which automatically commits any pending transactions in the session.",
                    "When a DBA uses the ALTER TABLE statement to modify the structure of a table, such as changing the name of a column, the pending transaction in the session will be committed. This is because ALTER TABLE is a DDL statement that implicitly commits any pending transactions.",
                    "In this scenario, even if a COMMIT statement is issued by the same user from another session in the same database instance, the updates made by the uncommitted transaction in the original session will not be committed. The COMMIT statement needs to be issued in the same session where the transaction was initiated.",
                    "Issuing a SHUTDOWN IMMEDIATE statement by a DBA will forcibly shut down the database instance, terminating all active sessions and transactions. Any uncommitted transactions will be rolled back, not committed, even if the user attempts to issue a COMMIT after the shutdown.",
                    "If a CREATE TABLE AS SELECT statement encounters an error due to a syntax issue in the same session where the uncommitted transaction is in progress, the updates made by the transaction will not be committed. The failed statement will not trigger a commit, and the transaction will remain uncommitted."
                ],
                "explanation": "<p>Correct statements:</p><ol><li><p><strong>When a CREATE INDEX statement is executed successfully in the same session.</strong></p><ul><li><p>In Oracle, DDL (Data Definition Language) statements like <code>CREATE INDEX</code> implicitly commit any pending transactions. This is a common behaviour in Oracle databases to ensure data consistency before schema changes are applied.</p></li><li><p><strong>Result: Commits the updates.</strong></p></li></ul></li><li><p><strong>The DBA who made the mentioned changes uses the ALTER TABLE statement to change the name of a column.</strong></p><ul><li><p>Similar to <code>CREATE INDEX</code>, <code>ALTER TABLE</code> is a DDL statement. Successful execution of an <code>ALTER TABLE</code> statement will implicitly commit any pending transactions in the session where it is executed.</p></li><li><p><strong>Result: Commits the updates.</strong></p></li></ul></li></ol><p>Incorrect statements:</p><ul><li><p><strong>When a COMMIT statement is issued by the same user from another session in the same database instance.</strong></p><ul><li><p>Transactions are session-specific. A <code>COMMIT</code> statement issued in one session will only commit changes made <em>within that specific session</em>. It will not affect uncommitted transactions in other sessions, even if they are from the same user.</p></li><li><p><strong>Result: Does NOT commit the updates.</strong></p></li></ul></li></ul><ul><li><p><strong>When a DBA issues a successful SHUTDOWN IMMEDIATE statement and the user then issues a COMMIT.</strong></p><ul><li><p>A <code>SHUTDOWN IMMEDIATE</code> statement will roll back any uncommitted transactions in all active sessions before shutting down the database. By the time the database is shut down and potentially restarted, the uncommitted transaction would have already been rolled back. Issuing a <code>COMMIT</code> <em>after</em> a <code>SHUTDOWN IMMEDIATE</code> would be irrelevant as the session would no longer exist or the transaction would already be gone.</p></li><li><p><strong>Result: Does NOT commit the updates (in fact, it rolls them back).</strong></p></li></ul></li></ul><ul><li><p><strong>When a CREATE TABLE AS SELECT statement is executed unsuccessfully due to a syntax error in the same session.</strong></p><ul><li><p>If a DDL statement like <code>CREATE TABLE AS SELECT</code> encounters a syntax error, it fails and <em>does not</em> implicitly commit. Only successful DDL operations cause an implicit commit.</p></li><li><p><strong>Result: Does NOT commit the updates.</strong></p></li></ul></li></ul><p>Regarding the behaviour of <code>CREATE INDEX</code> and <code>ALTER TABLE</code> in some database systems (like SQL Server or PostgreSQL by default for some DDLs) where DDLs might not implicitly commit. In these database systems, creating an index does not automatically commit the changes made in the uncommitted transaction. The transaction must be explicitly committed using a COMMIT statement.</p><p>However, in <strong>Oracle Database</strong>, it is a fundamental and well-documented behaviour that <strong>DDL (Data Definition Language) statements implicitly commit any pending transactions in the session where they are executed.</strong></p><p>This means if you have an <code>UPDATE</code> statement that modified 5000 rows and is uncommitted, and then in the <em>same session</em> you successfully execute:</p><ul><li><p><code>CREATE INDEX index_name ON table_name (column_name);</code></p></li><li><p><code>ALTER TABLE table_name RENAME COLUMN old_name TO new_name;</code></p></li></ul><p>Both of these DDL operations will cause the preceding uncommitted <code>UPDATE</code> transaction to be <strong>implicitly committed</strong>.</p><p><strong><em>Data definition language (DDL) statements that define or modify database objects.</em></strong> <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-database.html\" title=\"13.1.1&nbsp;ALTER DATABASE Statement\"><code><strong>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Statement\"><code><strong>ALTER EVENT</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-procedure.html\" title=\"13.1.6&nbsp;ALTER PROCEDURE Statement\"><code><strong>ALTER PROCEDURE</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-server.html\" title=\"13.1.7&nbsp;ALTER SERVER Statement\"><code><strong>ALTER SERVER</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-table.html\" title=\"13.1.8&nbsp;ALTER TABLE Statement\"><code><strong>ALTER TABLE</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-tablespace.html\" title=\"13.1.9&nbsp;ALTER TABLESPACE Statement\"><code><strong>ALTER TABLESPACE</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/alter-view.html\" title=\"13.1.10&nbsp;ALTER VIEW Statement\"><code><strong>ALTER VIEW</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-database.html\" title=\"13.1.11&nbsp;CREATE DATABASE Statement\"><code><strong>CREATE DATABASE</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-event.html\" title=\"13.1.12&nbsp;CREATE EVENT Statement\"><code><strong>CREATE EVENT</strong></code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-index.html\" title=\"13.1.14&nbsp;CREATE INDEX Statement\"><code><strong>CREATE INDEX</strong></code></a> ...</p><p><br></p><p>Here's why this is the case in Oracle:</p><ul><li><p><strong>Consistency:</strong> Oracle's architecture ensures that schema changes (DDL) are atomic and consistent. To achieve this, any outstanding transactions in the session are committed before the DDL statement begins.</p></li><li><p><strong>Locking:</strong> DDL statements often require exclusive locks on the objects they are modifying. Committing prior transactions releases any locks held by those transactions, preventing deadlocks or blocking during the DDL operation.</p></li></ul><p>You can easily verify this behaviour in an Oracle environment:</p><ol><li><p>Open an SQL*Plus or SQL Developer session.</p></li><li><p><code>CREATE TABLE test_implicit (id NUMBER, name VARCHAR2(10));</code></p></li><li><p><code>INSERT INTO test_implicit VALUES (1, 'Before DDL');</code></p></li><li><p><code>SELECT * FROM test_implicit;</code> (You'll see the row)</p></li><li><p>Open <em>another</em> session.</p></li><li><p><code>SELECT * FROM test_implicit;</code> (You will <em>not</em> see the row inserted by the first session because it's uncommitted).</p></li><li><p>Go back to the first session.</p></li><li><p><code>CREATE INDEX test_implicit_idx ON test_implicit (name);</code> (This statement will execute successfully).</p></li><li><p>Go back to the second session.</p></li><li><p><code>SELECT * FROM test_implicit;</code> (You <em>will</em> now see the row. This proves the <code>INSERT</code> was implicitly committed by the <code>CREATE INDEX</code> statement).</p></li></ol><p>Therefore, based on Oracle Database behaviour:</p><ul><li><p><code><strong>When a CREATE INDEX statement is executed successfully in the same session.</strong></code> - This <em>will</em> commit the changes.</p></li><li><p><code><strong>The DBA who made the mentioned changes uses the ALTER TABLE statement to change the name of a column.</strong></code> - This <em>will</em> commit the changes.</p></li></ul>",
                "answers": [
                    "<p>When a CREATE INDEX statement is executed successfully in the same session.</p>",
                    "<p>The DBA who made the mentioned changes uses the ALTER TABLE statement to change the name of a column.</p>",
                    "<p>When a COMMIT statement is issued by the same user from another session in the same database instance.</p>",
                    "<p>When a DBA issues a successful SHUTDOWN IMMEDIATE statement and the user then issues a COMMIT.</p>",
                    "<p>When a CREATE TABLE AS SELECT statement is executed unsuccessfully due to a syntax error in the same session.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "ALTER",
            "question_plain": "View and examine the following available responses.Given: An Oracle database server session has an uncommitted transaction in progress which updated 5000 rows in a table.Identify the situations where the transactions complete thereby committing the updates. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919509,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>You need to display the department name, along with the number of employees in each department, including departments that have no employees. </p><p>Which SQL statement achieves this correctly?</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL statement correctly uses a LEFT JOIN between the 'departments' and 'employees' tables to include all departments, even those with no employees. It then counts the number of employees in each department and groups the results by department name.",
                    "This SQL statement uses an implicit join between the 'departments' and 'employees' tables, which may result in excluding departments with no employees. It is not the correct approach to include departments with no employees in the result set.",
                    "This SQL statement uses an INNER JOIN between the 'departments' and 'employees' tables, which will exclude departments with no employees. It does not achieve the requirement of displaying all departments, including those with no employees.",
                    "This SQL statement uses a RIGHT JOIN between the 'departments' and 'employees' tables, which may exclude departments with no employees. It does not ensure that all departments are included in the result set, making it an incorrect choice for the given requirement."
                ],
                "explanation": "<p><strong>Correct Option:</strong></p><pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d\nLEFT JOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;</pre><ul><li><p>The <strong>LEFT JOIN</strong> ensures that all rows from the <code>departments</code> table are included, even if there is <strong>no matching row in the </strong><code><strong>employees</strong></code><strong> table</strong>.</p></li><li><p>The <code>COUNT(e.employee_id)</code> only counts existing employees, and if there are none, it will return <strong>zero</strong> instead of excluding the department.</p></li><li><p><strong>This correctly meets the requirement to display all departments, including those with zero employees.</strong></p></li></ul><p><br></p><p><strong>Incorrect Options:</strong></p><pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d, employees e\nWHERE d.department_id = e.department_id\nGROUP BY d.department_name;</pre><ul><li><p>This uses an <strong>implicit inner join</strong> (<code>WHERE d.department_id = e.department_id</code>), meaning <strong>departments without employees will be excluded</strong>.</p></li><li><p>If a department has <strong>no employees</strong>, it won’t have a match in the <code>employees</code> table, and thus it won’t appear in the result.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(*) AS employee_count\nFROM departments d\nJOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;</pre><ul><li><p>Uses an <strong>inner join</strong>, which has the same issue as the one above.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d\nRIGHT JOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;</pre><ul><li><p>Uses a <strong>RIGHT JOIN</strong>, which means it <strong>includes only departments that have employees</strong> but doesn’t necessarily keep all departments.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d\nLEFT JOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d, employees e\nWHERE d.department_id = e.department_id\nGROUP BY d.department_name;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(*) AS employee_count\nFROM departments d\nJOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id) AS employee_count\nFROM departments d\nRIGHT JOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "JOIN",
            "question_plain": "You need to display the department name, along with the number of employees in each department, including departments that have no employees. Which SQL statement achieves this correctly?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 128919507,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which SQL statement will successfully create a table that enforces a foreign key relationship with the <code>departments</code> table using the <code>department_id</code> column, and ensures no nulls are allowed in that column?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[FOREIGN KEY Constraints](https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/create-table-foreign-keys.html)",
                    "[FOREIGN KEY Constraints](https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/create-table-foreign-keys.html)"
                ],
                "feedbacks": [
                    "This SQL statement correctly creates a table named employees with columns employee_id, name, and department_id. The department_id column is specified as NOT NULL, ensuring no null values are allowed. The CONSTRAINT fk_dept is used to define a foreign key relationship with the departments table on the department_id column, enforcing referential integrity.",
                    "This SQL statement attempts to create a table named employees with columns employee_id, name, and department_id. However, the syntax for defining the foreign key relationship is incorrect. The CONSTRAINT fk_dept should include the column name (department_id) and the REFERENCES keyword should be followed by the referenced table name (departments) and column name (department_id).",
                    "This SQL statement attempts to create a table named employees with columns employee_id, name, and department_id. The syntax for defining the foreign key relationship is incorrect as the column name (department_id) is missing in the CONSTRAINT fk_dept definition. The REFERENCES keyword should be followed by the referenced table name (departments) and column name (department_id).",
                    "This SQL statement attempts to create a table named employees with columns employee_id, name, and department_id. While it includes the NOT NULL constraint for the department_id column, the syntax for defining the foreign key relationship is incorrect. The CONSTRAINT fk_dept should include the column name (department_id) and the REFERENCES keyword should be followed by the referenced table name (departments) and column name (department_id)."
                ],
                "explanation": "<p>The <strong>correct SQL statement</strong> that successfully creates a table enforcing a <strong>foreign key relationship</strong> with the <code>departments</code> table using the <code>department_id</code> column <strong>and</strong> ensures that <code><strong>department_id</strong></code><strong> is not null</strong> is:</p><pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  employee_id NUMBER PRIMARY KEY,\n  name VARCHAR2(100),\n  department_id NUMBER NOT NULL,\n  CONSTRAINT fk_dept FOREIGN KEY (department_id)\n  REFERENCES departments(department_id)\n);\n</pre><p><br></p><p>Incorrect options:</p><pre class=\"prettyprint linenums\">department_id NUMBER NOT NULL,\nCONSTRAINT fk_dept FOREIGN KEY (department_id)\nREFERENCES departments(department_id)\n</pre><ul><li><p>Correctly defines <code>department_id</code> as <strong>NOT NULL</strong>.</p></li><li><p>Properly defines a <strong>foreign key constraint</strong> on <code>department_id</code>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">department_id NUMBER\nCONSTRAINT fk_dept FOREIGN KEY REFERENCES departments(department_id)\n</pre><ul><li><p><strong>Incorrect syntax</strong>: The foreign key constraint is <strong>missing the column name</strong> within parentheses.</p></li><li><p>Should be: <code>FOREIGN KEY (department_id) REFERENCES ...</code></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">CONSTRAINT fk_dept FOREIGN KEY department_id\nREFERENCES departments(department_id)\n</pre><ul><li><p><strong>Incorrect syntax</strong>: <code>FOREIGN KEY department_id</code> should be <code>FOREIGN KEY (department_id)</code>.</p></li><li><p>Parentheses are required for the column list.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">CONSTRAINT fk_dept FOREIGN KEY REFERENCES departments\n</pre><ul><li><p><strong>Invalid syntax</strong>:</p><ul><li><p>No column is specified for the foreign key.</p></li><li><p>No column is specified for the referenced table either.</p></li></ul></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  employee_id NUMBER PRIMARY KEY,\n  name VARCHAR2(100),\n  department_id NUMBER NOT NULL,\n  CONSTRAINT fk_dept FOREIGN KEY (department_id)\n  REFERENCES departments(department_id)\n);\n</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  employee_id NUMBER PRIMARY KEY,\n  name VARCHAR2(100),\n  department_id NUMBER\n  CONSTRAINT fk_dept FOREIGN KEY REFERENCES departments(department_id)\n);\n</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  employee_id NUMBER PRIMARY KEY,\n  name VARCHAR2(100),\n  department_id NUMBER,\n  CONSTRAINT fk_dept FOREIGN KEY department_id\n  REFERENCES departments(department_id)\n);\n</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  employee_id NUMBER PRIMARY KEY,\n  name VARCHAR2(100),\n  department_id NUMBER NOT NULL,\n  CONSTRAINT fk_dept FOREIGN KEY REFERENCES departments\n);\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CONSTRAINT",
            "question_plain": "Which SQL statement will successfully create a table that enforces a foreign key relationship with the departments table using the department_id column, and ensures no nulls are allowed in that column?",
            "related_lectures": []
        }
    ]
}