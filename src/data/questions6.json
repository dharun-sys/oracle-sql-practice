{
    "count": 80,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 120478763,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-13_17-58-23-0dcbf776ef5b4e68cd755c6c198244d2.png\"></p><p><br></p><p><strong>Given: </strong>Evaluate the following SQL statement.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_city, COUNT(cust_last_name)\nFROM&nbsp;customers\nWHERE cust_credit_limit &gt; 1000\nGROUP&nbsp;BY cust_city\nHAVING&nbsp;AVG(cust_credit_limit) BETWEEN 5000 AND 6000;\n</pre><p><br></p><p>Identify the true statement regarding the outcome of the above query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle GROUP BY HAVING](https://www.educba.com/oracle-group-by-having/)"
                ],
                "feedbacks": [
                    "The BETWEEN operator is typically used in the WHERE clause to filter rows based on a range of values. Using it in the HAVING clause, which is used with aggregate functions, may not produce the intended results and could lead to an error in this context.",
                    "Combining the WHERE and HAVING clauses in the same SELECT statement is allowed in SQL. The WHERE clause filters rows before any groupings are made, while the HAVING clause filters groups after the grouping has been done. Therefore, there should not be an error due to the presence of both clauses.",
                    "The WHERE and HAVING clauses serve different purposes in SQL queries. The WHERE clause filters individual rows based on specified conditions, while the HAVING clause filters groups of rows based on aggregate information. There is no restriction on applying conditions on the same column using both clauses.",
                    "The SQL statement provided appears to be syntactically correct and does not violate any rules regarding the usage of WHERE and HAVING clauses. As long as the column names and conditions are valid, the query should execute successfully without any errors."
                ],
                "explanation": "<p>The correct answer is: <strong>It executes successfully.</strong></p><p>Let’s break it down logically:</p><p>What This SQL Statement Does:</p><ul><li><p><code><strong>SELECT cust_city, COUNT(cust_last_name)</strong></code><br>→ Returns the number of customers in each city.</p></li><li><p><code><strong>WHERE cust_credit_limit &gt; 1000</strong></code><br>→ Filters rows before grouping—only includes customers with a credit limit greater than 1000.</p></li><li><p><code><strong>GROUP BY cust_city</strong></code><br>→ Groups the filtered results by city.</p></li><li><p><code><strong>HAVING AVG(cust_credit_limit) BETWEEN 5000 AND 6000</strong></code><br>→ Applies an aggregate condition <em>after</em> grouping. Checks that the average credit limit of customers in each city (from filtered data) falls within the range.</p></li></ul><p>Why It Executes Successfully:</p><ul><li><p><code>BETWEEN</code> <strong>is perfectly valid</strong> in a <code>HAVING</code> clause when used with an aggregate function like <code>AVG()</code>.</p></li><li><p>It's <strong>acceptable</strong> to use both <code>WHERE</code> and <code>HAVING</code> in the same query—they serve different purposes.</p></li><li><p>Using them on the same column (<code>cust_credit_limit</code>) isn't an issue—the context of filtering (row-level in <code>WHERE</code>, group-level in <code>HAVING</code>) is distinct and respected.</p></li></ul><p>Improvements for better readability, efficiency, and clarity.</p><p>Potential Improvements</p><p>1. <strong>Use Aliases for Readability</strong></p><pre class=\"prettyprint linenums\">SELECT cust_city, COUNT(cust_last_name) AS customer_count\nFROM customers\nWHERE cust_credit_limit &gt; 1000\nGROUP BY cust_city\nHAVING AVG(cust_credit_limit) BETWEEN 5000 AND 6000;\n</pre><ul><li><p>Adding an alias like <code>AS customer_count</code> makes the output clearer to the reader or application layer consuming it.</p></li></ul><p>2. <strong>Use DISTINCT if Needed</strong></p><p>If you’re counting unique last names (rather than raw number of rows), consider:</p><pre class=\"prettyprint linenums\">COUNT(DISTINCT cust_last_name)\n</pre><p>This avoids duplicate counts if customers share the same last name.</p><p>3. <strong>Avoid Potential Ambiguity</strong></p><p>If you're only interested in cities with a certain average credit limit, you might want to also return the average itself:</p><pre class=\"prettyprint linenums\">SELECT cust_city,\n       COUNT(cust_last_name) AS customer_count,\n       AVG(cust_credit_limit) AS avg_credit\nFROM customers\nWHERE cust_credit_limit &gt; 1000\nGROUP BY cust_city\nHAVING avg_credit BETWEEN 5000 AND 6000;\n</pre><p>Depending on your SQL engine, you may need to use the full function again in the <code>HAVING</code> clause:</p><pre class=\"prettyprint linenums\">HAVING AVG(cust_credit_limit) BETWEEN 5000 AND 6000;\n</pre><p>4. <strong>Performance Optimization</strong></p><p>Make sure <code>cust_credit_limit</code> and <code>cust_city</code> are indexed—especially if the dataset is large and queried often.</p><p><br></p><p><strong>Oracle GROUP BY HAVING</strong></p><p><code>GROUP BY</code> in oracle database can be defined as a clause which when used with <code>SELECT</code> statement can be used to arrange the identical data in a table to groups or clusters and <code>HAVING</code> clause can be defined as a filter clause which when used with <code>GROUP BY</code> can be used to filter the groups retrieved or returned by the <code>GROUP BY</code> clause, it follows the <code>WHERE</code> clause in a <code>SELECT</code> statement but it precedes the <code>ORDER BY</code> clause.</p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">SELECT\nexpression_1, expression_2, expression_n, aggregate_function(expression)\nFROM\ntable_name\nWHERE\ncondition\nGROUP BY\nexpression_1, expression_2, expression_n\nHAVING\ncondition;</pre><p><br></p><p><strong>Parameters</strong></p><p><strong>expression_1, expression_2, expression_n:</strong> This refers to the expressions which must be used with GROUP BY function.</p><p><strong>aggregate_function(expression):</strong> It refers to an aggregate function like SUM, COUNT, MAX, MIN</p><p><strong>table_name:</strong> It refers to the name of the table on which GROUP BY function is applied.</p><p><strong>condition:</strong> It refers to the condition which we want to apply on the result set from the GROUP BY clause to restrict or filter the rows returned by the GROUP BY. Only those groups for which the condition evaluates to true are included and the rest is not included.</p><p>The data is grouped in groups based on some expression which is mentioned after the group by clause. This returns a result set which consists of many groups. The HAVING clause now filters or checks each group from the result set returned by the GROUP BY clause based on the condition mentioned after the HAVING clause. If the condition evaluates to be true it will be included in the group or else it is not included. One important point to note is that the HAVING clause filters groups whereas the WHERE clause filters rows.</p><p><br></p>",
                "answers": [
                    "<p>It returns an error because the BETWEEN operator cannot be used in the HAVING clause.</p>",
                    "<p>It returns an error because WHERE and HAVING clauses cannot be used in the same SELECT statement.</p>",
                    "<p>It returns an error because WHERE and HAVING clauses cannot be used to apply conditions on the same column.</p>",
                    "<p>It executes successfully.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "GROUP BY",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Given: Evaluate the following SQL statement.Exhibit 1:SELECT cust_city, COUNT(cust_last_name)\nFROM&nbsp;customers\nWHERE cust_credit_limit &gt; 1000\nGROUP&nbsp;BY cust_city\nHAVING&nbsp;AVG(cust_credit_limit) BETWEEN 5000 AND 6000;\nIdentify the true statement regarding the outcome of the above query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478765,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDER_ITEMS and ORDERS tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-55-22-e17f53e9e5856e32f50d3c045af592cd.png\"></p><p><br></p><p><strong>Required:</strong> Retrieve the ORDER_ID, product_ID, and total price (UNIT_PRICE multiplied by QUANTITY), where the total price is greater than 50,000.</p><p><strong>Given:</strong> The following SQL statement has been executed.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT order_id, product_id, unit_price * quantity \"Total Price\"\nFROM order_items\nWHERE unit_price * quantity &gt; 50000\nNATURAL&nbsp;JOIN orders;\n</pre><p><br></p><p>Identify the true statement regarding the execution of the statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Natural Join in Oracle](https://www.educba.com/natural-join-in-oracle/)"
                ],
                "feedbacks": [
                    "The statement would not execute and provide the desired result because the WHERE clause is incorrectly placed before the NATURAL JOIN clause, which would result in a syntax error.",
                    "The statement would not execute because the ON keyword is missing in the NATURAL JOIN clause, which is necessary to specify the join condition between the tables.",
                    "The statement would not execute because the WHERE clause is incorrectly placed before the NATURAL JOIN clause. The WHERE clause should come after the JOIN clause to filter the results based on the specified conditions.",
                    "The statement would not execute because the USING keyword is missing in the NATURAL JOIN clause, which is used to specify the columns used for the join condition. Without the USING keyword, the join condition between the tables is not properly defined."
                ],
                "explanation": "<p>Correct option: <strong>The statement would not execute because the WHERE clause is before the NATURAL JOIN clause.</strong></p><p><br></p><p>Let's break down the query:</p><ol><li><p><code>SELECT order_id, product_id, unit_price * quantity \"Total Price\"</code>: This part selects the <code>order_id</code>, <code>product_id</code>, and calculates <code>unit_price * quantity</code> aliased as \"Total Price\".</p></li><li><p><code>FROM order_items</code>: Specifies the primary table as <code>order_items</code>.</p></li><li><p><code>WHERE unit_price * quantity &gt; 50000</code>: This is a <code>WHERE</code> clause that filters the results based on the calculated total price being greater than 50,000.</p></li><li><p><code>NATURAL JOIN orders</code>: This attempts to join <code>order_items</code> with <code>orders</code> using a <code>NATURAL JOIN</code>.</p></li></ol><p>The crucial point here is the placement of the <code>WHERE</code> clause relative to the <code>NATURAL JOIN</code>. In SQL, the <code>FROM</code> clause (which includes joins) is logically processed <em>before</em> the <code>WHERE</code> clause. This means that the join operation (in this case, <code>NATURAL JOIN orders</code>) should come <em>immediately after</em> the <code>FROM order_items</code> clause, and <em>before</em> the <code>WHERE</code> clause.</p><p>The provided query has the <code>WHERE</code> clause placed between <code>FROM order_items</code> and <code>NATURAL JOIN orders</code>. This is syntactically incorrect. The <code>JOIN</code> clause must immediately follow the table it is joining <em>from</em> or another <code>JOIN</code> clause.</p><p>Therefore, the statement would not execute due to a syntax error.</p><p>Let's evaluate the given options:</p><ul><li><p><strong>The statement would not execute because the WHERE clause is before the NATURAL JOIN clause.</strong> This aligns with our analysis. The <code>WHERE</code> clause is misplaced.</p></li><li><p><strong>The statement would execute and provide the desired result.</strong> This is false because of the syntax error.</p></li><li><p><strong>The statement would not execute because the ON keyword is missing in the NATURAL JOIN clause.</strong> <code>NATURAL JOIN</code> explicitly does <em>not</em> use <code>ON</code> or <code>USING</code> clauses. It automatically joins based on columns with the same name. So, this statement is false.</p></li><li><p><strong>The statement would not execute because the USING keyword is missing in the NATURAL JOIN clause.</strong> Similar to the <code>ON</code> keyword, <code>NATURAL JOIN</code> does not use <code>USING</code>. This statement is false.</p></li></ul><p>The correct placement for the query to execute would be:</p><pre class=\"prettyprint linenums\">SELECT order_id, product_id, unit_price * quantity \"Total Price\"\nFROM order_items NATURAL JOIN orders\nWHERE unit_price * quantity &gt; 50000;\n</pre><p><br></p><p>A Natural Join in Oracle is a SQL query technique that combines row(s) from two or more Tables, View or Materialized View. A Natural Join performs join based on column(s) of the tables which are participating in a join that have the same column name and data type. To perform this join operation, the Natural Join keyword explicitly is used.</p><p><strong>Points of Concentration:</strong></p><p>A Natural Join combines multi Tables, View or Materialized View to retrieve data.</p><p>A Natural Join returns all rows that satisfy the same column name and data type condition.</p><p>Oracle provides the Natural Join keyword to perform Natural Join.</p><p>If the Natural Join doesn’t satisfy the same column name and data type condition then it returns a Cartesian result.</p><p><strong>Proper Syntax</strong>\nNatural Join does not exclude duplicate record(s).</p><p><br></p><pre class=\"prettyprint linenums\">SELECT Column_1, Column_2, Column_n \nFROM Table1 NATURAL JOIN Table2 \nWHERE condition;\n</pre>",
                "answers": [
                    "<p>The statement would execute and provide the desired result.</p>",
                    "<p>The statement would not execute because the ON keyword is missing in the NATURAL JOIN clause.</p>",
                    "<p>The statement would not execute because the WHERE clause is before the NATURAL JOIN clause.</p>",
                    "<p>The statement would not execute because the USING keyword is missing in the NATURAL JOIN clause.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the structure of the ORDER_ITEMS and ORDERS tables.Required: Retrieve the ORDER_ID, product_ID, and total price (UNIT_PRICE multiplied by QUANTITY), where the total price is greater than 50,000.Given: The following SQL statement has been executed.Exhibit 1:SELECT order_id, product_id, unit_price * quantity \"Total Price\"\nFROM order_items\nWHERE unit_price * quantity &gt; 50000\nNATURAL&nbsp;JOIN orders;\nIdentify the true statement regarding the execution of the statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478769,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Which statements are true about performing Data Manipulation Language (DML) operations on a view in Oracle? (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[About DML Statements and Transactions](https://docs.oracle.com/en/database/oracle/oracle-database/19/tdddg/dml-and-transactions.html)"
                ],
                "feedbacks": [
                    "This statement is true because when adding rows to an underlying table through a view, Oracle requires that all columns that do not have default values and are marked as NOT NULL in the table must be included in the defining query of the view to ensure data integrity.",
                    "DML operations such as INSERT, UPDATE, and DELETE are not allowed on views that contain group functions, a GROUP BY clause, the DISTINCT keyword, or the ROWNUM pseudocolumn. This restriction is in place to maintain the integrity of the data and prevent ambiguous results.",
                    "The WITH CHECK OPTION clause is used to ensure that any data modification made through a view complies with the view's defining query. However, this clause has no effect when deleting rows from the underlying table through the view, as it only applies to INSERT and UPDATE operations.",
                    "While INSERT statements can generally be performed on a table through a view, there are certain restrictions such as the presence of NOT NULL columns without default values that must be considered. It is not always guaranteed that insert statements can be executed on a table through a view.",
                    "This statement is incorrect because views can be used to query rows from an underlying table even if the table has a PRIMARY KEY. The defining query of the view does not necessarily need to reference the PRIMARY KEY columns as long as the view's query returns valid results."
                ],
                "explanation": "<p>The <strong>correct statements</strong> about performing DML (Data Manipulation Language) operations on views in Oracle are:</p><p>1. <strong>Views cannot be used to add rows to an underlying table if the table has columns with NOT NULL constraints lacking default values which are not referenced in the defining query of the view.</strong></p><ul><li><p><strong>True.</strong> If the view does not include all columns of the underlying table that are defined as <strong>NOT NULL</strong> and have <strong>no default values</strong>, an <strong>INSERT</strong> operation will fail because the database does not know what values to insert into those NOT NULL columns.</p></li></ul><p>2. <strong>DML operations are not permitted on views that include group functions, a GROUP BY clause, the DISTINCT keyword, or the ROWNUM pseudocolumn.</strong></p><ul><li><p><strong>True.</strong> Views that include <strong>group functions</strong> (like <code>SUM</code>, <code>AVG</code>), <strong>GROUP BY</strong>, <strong>DISTINCT</strong>, or <strong>ROWNUM</strong> are <strong>not inherently updatable</strong>, and Oracle <strong>disallows</strong> DML operations (INSERT, UPDATE, DELETE) on them unless an <strong>INSTEAD OF trigger</strong> is used.</p></li></ul><p>3.&nbsp; The <strong>WITH CHECK</strong> clause has no effect when deleting rows from the underlying table through the view.</p><ul><li><p>The <code>WITH CHECK OPTION</code> <strong>only applies to </strong><code><strong>INSERT</strong></code><strong> and </strong><code><strong>UPDATE</strong></code><strong> operations</strong> to ensure any data added or modified through the view conforms to the view’s defining <code>WHERE</code> clause.</p></li><li><p>It <strong>does not apply to </strong><code><strong>DELETE</strong></code><strong> operations</strong>.</p><ul><li><p>This means <strong>you <em>can</em> delete rows</strong> through the view, even if the rows do <strong>not</strong> satisfy the view’s <code>WHERE</code> clause.</p></li><li><p>In that sense, the <code>WITH CHECK OPTION</code> has <strong>no effect</strong> on <code>DELETE</code>.</p></li></ul></li></ul><p><br></p><p><strong>False Statements:</strong></p><p>Insert statements can always be done on a table through a view.</p><ul><li><p><strong>False.</strong> INSERTs through a view are only allowed if certain conditions are met: the view must not include joins, group functions, etc., and all required columns (e.g., NOT NULL without default) must be present in the view.</p></li></ul><p>Views cannot be used to query rows from an underlying table if the table has a PRIMARY KEY and the PRIMARY KEY columns are not referenced in the defining query of the view.</p><ul><li><p><strong>False.</strong> You <strong>can</strong> query data through a view regardless of whether the <strong>PRIMARY KEY</strong> columns are included. However, excluding PRIMARY KEY columns might affect <strong>updatability</strong> or <strong>uniqueness</strong>, not the ability to query.</p></li></ul><p><br></p><p>The following list summarizes the guidelines regulating DML operations on complex views: </p><ul><li><p>DML operations that violate a constraint aren’t permitted. </p></li><li><p>A value can’t be added to a column containing an arithmetic expression. </p></li><li><p>DML operations aren’t permitted on non-key-preserved tables. </p></li><li><p>DML operations aren’t permitted on views that include group functions, a GROUP BY clause, the DISTINCT keyword, or the ROWNUM pseudocolumn.</p></li></ul>",
                "answers": [
                    "<p>Views cannot be used to add rows to an underlying table if the table has columns with NOT NULL constraints lacking default values which are not referenced in the defining query of the view.</p>",
                    "<p>DML operations are not permitted on views that include group functions, a GROUP BY clause, the DISTINCT keyword, or the ROWNUM pseudocolumn.</p>",
                    "<p>The WITH CHECK clause has no effect when deleting rows from the underlying table through the view.</p>",
                    "<p>Insert statements can always be done on a table through a view.</p>",
                    "<p>Views cannot be used to query rows from an underlying table if the table has a PRIMARY KEY and the PRIMARY KEY columns are not referenced in the defining query of the view.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "DML Statements",
            "question_plain": "View and examine the following available responses.Which statements are true about performing Data Manipulation Language (DML) operations on a view in Oracle? (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478775,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding external tables.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Managing External Tables](https://docs.oracle.com/search/?q=Managing%2520External%2520Tables&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)"
                ],
                "feedbacks": [
                    "The CREATE TABLE AS SELECT statement can indeed be used to upload data into a normal table in the database from an external table. This allows for easy data transfer and integration between external and internal tables.",
                    "The data and metadata for an external table are stored outside the database. External tables are defined in the database but their data resides in external files, such as CSV or text files, located outside the database.",
                    "The default REJECT LIMIT for external tables is not UNLIMITED. The default REJECT LIMIT for external tables is set to 0, meaning that any rows that fail to load during the data load process will be rejected.",
                    "ORACLE_LOADER and ORACLE_DATAPUMP do not have exactly the same functionality when used with an external table. ORACLE_LOADER is used for loading data from external files into database tables, while ORACLE_DATAPUMP is used for exporting and importing data and metadata between Oracle databases."
                ],
                "explanation": "<p>The correct answer is: <strong>The CREATE TABLE AS SELECT statement can be used to upload data into a normal table in the database from an external table.</strong></p><ul><li><p>You can use <code>CREATE TABLE new_table AS SELECT * FROM external_table;</code> to read data from the external table and store it permanently in a regular (internal) table.</p></li></ul><p>Incorrect options:</p><p><strong>\"The data and metadata for an external table are stored outside the database.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>The <strong>data</strong> is stored outside the database (e.g., in flat files), but the <strong>metadata</strong> (table definition, structure) is stored <strong>inside the database</strong>.</p></li></ul></li></ul><p><strong>\"The default REJECT LIMIT for external tables is UNLIMITED.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>The <strong>default reject limit is 0</strong>, which means <strong>any row that causes an error will reject the load</strong> unless the limit is explicitly changed.</p></li><li><p>You can set it using <code>REJECT LIMIT N</code> or <code>REJECT LIMIT UNLIMITED</code>, but it's not the default.</p></li></ul></li></ul><p><strong>\"ORACLE_LOADER and ORACLE_DATAPUMP have exactly the same functionality when used with an external table.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p><code>ORACLE_LOADER</code> is used for <strong>reading data from flat files</strong> (like CSV).</p></li><li><p><code>ORACLE_DATAPUMP</code> is used for <strong>loading and unloading data in Oracle's binary format</strong>.</p></li><li><p>Their functionalities are different in use cases and capabilities.</p></li></ul></li></ul><p><br></p><p>The <code>ORACLE_DATAPUMP</code> access driver lets you upload data--that is, read data from the database and insert it into an external table, represented by one or more external files--and then reload it into an Oracle Database.</p>",
                "answers": [
                    "<p>The CREATE TABLE AS SELECT statement can be used to upload data into a normal table in the database from an external table.</p>",
                    "<p>The data and metadata for an external table are stored outside the database.</p>",
                    "<p>The default REJECT LIMIT for external tables is UNLIMITED.</p>",
                    "<p>ORACLE_LOADER and ORACLE_DATAPUMP have exactly the same functionality when used with an external table.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Managing External Tables",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding external tables.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478773,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the tasks which can be performed using SQL functions built into Oracle Database.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle CONCAT Function](https://www.oracletutorial.com/oracle-string-functions/oracle-concat/)",
                    "[Oracle TO_CHAR Function](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/TO_CHAR-datetime.html)",
                    "[Oracle LENGTH() Function](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/LENGTH.html)"
                ],
                "feedbacks": [
                    "Displaying a date in a nondefault format can be achieved using SQL functions like TO_CHAR to convert a date to a specific format for display purposes. This is a common task in SQL queries when presenting dates in a user-friendly manner.",
                    "Finding the number of characters in an expression can be done using SQL functions like LENGTH or CHAR_LENGTH. These functions return the number of characters in a string, which can be useful for various data manipulation tasks in SQL queries.",
                    "Substituting a character string in a text expression with a specified string can be accomplished using SQL functions like REPLACE. This function allows you to search for a specific substring within a string and replace it with another substring, which is a common requirement in data cleaning and transformation tasks.",
                    "Combining more than two columns or expressions into a single column in the output can be achieved using SQL functions like CONCAT or || operator for string concatenation. This is useful when you need to combine multiple values or expressions into a single column for reporting or analysis purposes."
                ],
                "explanation": "<p>All listed options are correct answers. Oracle provides a set of pre-defined functions that are readily available for use within SQL statements without requiring any additional definition or setup. These are known as built-in functions:</p><p>1. <strong>Displaying a date in a nondefault format</strong></p><ul><li><p>This can be done using the <code>TO_CHAR</code> function:</p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY') FROM dual;\n</pre></li><li><p>Changes how the date appears in the result.</p></li></ul><p>2. <strong>Finding the number of characters in an expression</strong></p><ul><li><p>Use the <code>LENGTH()</code> function:</p><pre class=\"prettyprint linenums\">SELECT LENGTH('Oracle') FROM dual; -- Returns 6\n</pre></li></ul><p>3. <strong>Substituting a character string in a text expression with a specified string</strong></p><ul><li><p>Use the <code>REPLACE()</code> function:</p><pre class=\"prettyprint linenums\">SELECT REPLACE('Oracle SQL', 'SQL', 'PL/SQL') FROM dual;\n</pre></li></ul><p>4. <strong>Combining more than two columns or expressions into a single column in the output</strong></p><ul><li><p>Use the <code>CONCAT()</code> function: </p></li><li><pre class=\"prettyprint linenums\">SELECT CONCAT('juan','pedro') FROM dual;\n</pre></li><li><p>It is specifically a built-in character function designed for string manipulation, specifically for concatenating (joining) two strings.</p><p>While the <code>||</code> operator is more commonly used for string concatenation in Oracle SQL due to its ANSI standard compliance and ease of use, <code>CONCAT()</code> remains a valid and available built-in function.</p></li><li><p><code>CONCAT()</code> in Oracle only accepts <strong>two</strong> arguments.</p></li><li><p>For more than two, you'd need nested calls or use <code>||</code>.</p></li></ul><p>Example:</p><pre class=\"prettyprint linenums\">SELECT first_name || ' ' || last_name FROM employees;\n</pre><ul><li><p>This is an <strong>operator</strong>, not strictly a <strong>function</strong>.</p></li></ul>",
                "answers": [
                    "<p>Displaying a date in a nondefault format</p>",
                    "<p>Finding the number of characters in an expression</p>",
                    "<p>Substituting a character string in a text expression with a specified string</p>",
                    "<p>Combining more than two columns or expressions into a single column in the output</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c",
                "d"
            ],
            "section": "Functions",
            "question_plain": "View and examine the following available responses.Identify the tasks which can be performed using SQL functions built into Oracle Database.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478777,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the primary difference between the relational database (RDB) and object-oriented database (OODB) models.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Difference between RDBMS and OODBMS](https://www.geeksforgeeks.org/difference-between-rdbms-and-oodbms/)"
                ],
                "feedbacks": [
                    "<p>This statement is incorrect. Object-Oriented Databases (OODB) support multiple objects within the same database, allowing for the storage of complex data types (such as classes, objects, and relationships) and their associated methods (functions). This aligns with object-oriented principles like inheritance, encapsulation, and polymorphism.</p><p>Relational Databases (RDB), on the other hand, support only tables, where data is stored in rows and columns. Relationships between data are defined using keys (primary and foreign keys), and operations are performed using SQL queries.</p><p>In summary, OODBs store and manage data as objects, while RDBs manage data in a tabular format.</p>",
                    "This statement is incorrect. Relational databases (RDB) do follow E.F. Codd's rules, which are a set of principles for relational database management systems. Object-oriented databases (OODB) may have different principles and structures, but it is not accurate to say that they do not support Codd's rules.",
                    "This statement is correct. Object-oriented databases (OODB) allow the incorporation of methods along with data structure definitions, enabling the storage and manipulation of complex data structures. Relational databases (RDB), on the other hand, do not support this feature and focus primarily on data storage and retrieval.",
                    "This statement is incorrect. Relational databases (RDB) do allow the definition of relationships between different tables through the use of foreign keys and joins. Object-oriented databases (OODB) may have a different approach to data modeling, but they also support relationships between objects or data entities."
                ],
                "explanation": "<p>The correct answer is: <strong>OODB incorporates methods with data structure definition, whereas RDB does not allow this.</strong></p><p>Explanation of Each Option:</p><p><strong>\"OODB incorporates methods with data structure definition, whereas RDB does not allow this.\"</strong></p><ul><li><p><strong>True.</strong></p><ul><li><p>Object-Oriented Databases (OODB) allow <strong>data and behavior</strong> (i.e., methods) to be stored together, like in object-oriented programming.</p></li><li><p>Relational Databases (RDB) only store <strong>data</strong>, not the <strong>methods</strong> that operate on it.</p></li></ul></li></ul><p><strong>\"RDB supports multiple objects in the same database, whereas OODB supports only tables.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>RDB uses <strong>tables</strong> to store data.</p></li><li><p>OODB supports <strong>objects</strong>, not just tables. In fact, OODB is more flexible in terms of data modeling.</p></li></ul></li></ul><p><strong>\"RDB supports only E.F. Codd's rules, whereas OODB does not support them.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>Codd’s rules define relational database characteristics, but <strong>RDBs may or may not strictly follow all rules</strong>.</p></li><li><p>This is not a primary difference, and <strong>OODBs were developed based on different principles</strong>, not necessarily in opposition to Codd’s rules.</p></li></ul></li></ul><p><strong>\"RDB allows the definition of relationships between different tables, whereas OODB does not allow this.\"</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>OODBs <strong>can model relationships</strong> between objects (e.g., through object references), similar to how classes relate in object-oriented languages.</p></li><li><p>They just don’t use <strong>foreign keys and joins</strong> the way RDBs do.</p></li></ul></li></ul><p><br></p><p><strong>RDBMS: </strong><br>RDBMS stands for Relational Database Management System. It is a database management system based on the relational model i.e. the data and relationships are represented by a collection of inter-related tables. It is a DBMS that enables the user to create, update, administer and interact with a relational database. RDBMS is the basis for SQL, and for all modern database systems like MS SQL Server, IBM DB2, Oracle, MySQL, and Microsoft Access.</p><p><strong>OODBMS: </strong><br>OODBMS stands for Object-Oriented Database Management System. It is a DBMS where data is represented in the form of objects, as used in object-oriented programming. OODB implements object-oriented concepts such as classes of objects, object identity, polymorphism, encapsulation, and inheritance. An object-oriented database stores complex data as compared to relational database. Some examples of OODBMS are Versant Object Database, Objectivity/DB, ObjectStore, Caché and ZODB.</p><p><strong>Differences Between RDBMS and OODBMS:</strong></p><p>RDBMS stores only data. OODBS stores data as well as methods to use it. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-02-22_17-35-25-bcd0735d645419cf1c1ce00eca5a4d74.png\"></p>",
                "answers": [
                    "<p>RDB supports multiple objects in the same database, whereas OODB supports only tables.</p>",
                    "<p>RDB supports only E.F. Codd's rules, whereas OODB does not support them.</p>",
                    "<p>OODB incorporates methods with data structure definition, whereas RDB does not allow this.</p>",
                    "<p>RDB allows the definition of relationships between different tables, whereas OODB does not allow this.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Relational Databases",
            "question_plain": "View and examine the following available responses.Identify the primary difference between the relational database (RDB) and object-oriented database (OODB) models.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478779,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PROMOTIONS table:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-56-32-704c9c2c8f4f81487d675d543d6456c9.png\"></p><p><br></p><p><strong>Required:</strong> Find out the average cost for all promos in the range $0-2000 and $2000-5000 in category A.</p><p><strong>Given:</strong> The following SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT \n  AVG(CASE \n        WHEN promo_cost BETWEEN 0 AND 2000 AND promo_category = 'A' \n        THEN promo_cost \n        ELSE NULL \n      END) AS CAT_2000A,\n  AVG(CASE \n        WHEN promo_cost BETWEEN 2001 AND 5000 AND promo_category = 'A' \n        THEN promo_cost \n        ELSE NULL \n      END) AS CAT_5000A\nFROM promotions;\n</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CASE Expressions](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CASE-Expressions.html)"
                ],
                "feedbacks": [
                    "This choice is incorrect because multiple conditions can be specified for the WHEN clause in a CASE statement. It allows for conditional logic to be applied to different values in the result set.",
                    "This choice is correct because the SQL statement provided uses a CASE statement to categorize the promos based on their cost range and category A. It will execute successfully and provide the average cost for promos in the specified ranges and category.",
                    "This choice is incorrect because CASE can be used with group functions like AVG, SUM, etc. to perform conditional operations on the result set. It is a valid and common practice in SQL queries.",
                    "This choice is incorrect because NULL can be specified as a return value in a CASE statement. It is often used to handle cases where there is no matching condition in the statement."
                ],
                "explanation": "<p>The correct answer is: <strong>It executes successfully and gives the required result.</strong></p><p>Why it works:</p><ul><li><p><strong>CASE inside aggregate functions (like </strong><code><strong>AVG</strong></code><strong>) is valid</strong> — It allows you to selectively include values in the aggregation.</p></li><li><p><strong>Multiple conditions</strong> in the <code>WHEN</code> clause (<code>promo_cost BETWEEN ... AND promo_category = 'A'</code>) are perfectly valid using logical <code>AND</code>.</p></li><li><p><strong>NULL as a return value</strong> is acceptable — <code>AVG</code> ignores <code>NULL</code>, which is exactly what we want for values that don't match the condition.</p></li></ul><p>Common misconceptions avoided:</p><ul><li><p>CASE <strong>can</strong> be used inside aggregation functions.</p></li><li><p>SQL allows <strong>multiple conditions</strong> using <code>AND</code>.</p></li><li><p><code>NULL</code> is <strong>not an error</strong> — it’s a standard placeholder for “no value”.</p></li></ul><p><br></p><p><strong>CASE Expression</strong></p><p>Facilitates conditional inquiries by doing the work of an <code>IF-THEN-ELSE</code> statement:</p><p><code>CASE</code> expr <code>WHEN</code> comparison_expr1 <code>THEN</code> return_expr1</p><p><br></p><pre class=\"prettyprint linenums\">[WHEN comparison_expr2 THEN return_expr2\nWHEN comparison_exprn THEN return_exprn\nELSE else_expr]\nEND\n</pre>",
                "answers": [
                    "<p>It generates an error because multiple conditions cannot be specified for the WHEN clause.</p>",
                    "<p>It executes successfully and gives the required result.</p>",
                    "<p>It generates an error because CASE cannot be used with group functions.</p>",
                    "<p>It generates an error because NULL cannot be specified as a return value.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "CASE",
            "question_plain": "View and examine the structure of the PROMOTIONS table:Required: Find out the average cost for all promos in the range $0-2000 and $2000-5000 in category A.Given: The following SQL statement has been executed.Exhibit: 1SELECT \n  AVG(CASE \n        WHEN promo_cost BETWEEN 0 AND 2000 AND promo_category = 'A' \n        THEN promo_cost \n        ELSE NULL \n      END) AS CAT_2000A,\n  AVG(CASE \n        WHEN promo_cost BETWEEN 2001 AND 5000 AND promo_category = 'A' \n        THEN promo_cost \n        ELSE NULL \n      END) AS CAT_5000A\nFROM promotions;\nIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478767,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the SHIPMENTS table:</p><p><strong>Table: SHIPMENTS </strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPO_ID            NOT NULL          NUMBER(3)\nPO_DATE          NOT NULL          DATE\nSHIPMENT_DATE    NOT NULL          DATE\nSHIPMENT_MODE                      VARCHAR2(30)\nSHIPMENT_COST                      NUMBER(8,2)\n</pre><p><br></p><p><strong>Required:</strong> Generate a report that displays the PO_ID and the penalty amount to be paid if the SHIPMENT_DATE is later than one month from the PO_DATE. The penalty is $20 per day.</p><p>Evaluate the following two queries.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT po_id, CASE\n  WHEN MONTHS_BETWEEN(shipment_date, po_date) &gt; 1 THEN\n    TO_CHAR((shipment_date - po_date) * 20)\n  ELSE 'No Penalty'\nEND PENALTY\nFROM shipments;\n</pre><p><br></p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">SELECT po_id,\n  DECODE\n    (MONTHS_BETWEEN(po_date, shipment_date)&lt;1,\n     TO_CHAR((shipment_date - po_date) * 20), 'No Penalty') PENALTY\nFROM shipments;\n</pre><p><br></p><p>Identify the true statement regarding the above commands.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[DECODE ](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/DECODE.html)",
                    "[TRUNC (number) ](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/TRUNC-number.html)",
                    "[TRUNC (date)](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/TRUNC-date.html)"
                ],
                "feedbacks": [
                    "Both queries may not give correct results due to potential errors in the logic or syntax of the queries. It is not guaranteed that they will execute successfully and provide accurate penalty amounts.",
                    "The first query may execute successfully, but it may not always give the correct result. There could be issues with the logic or calculations in the query that may lead to incorrect penalty amounts being displayed.",
                    "The first query may execute successfully, but it may not always give the correct result. There could be issues with the logic or calculations in the query that may lead to incorrect penalty amounts being displayed. However, the query will run without syntax errors.",
                    "The second query may execute successfully, but it is likely to give a wrong result. The logic used in the query may not accurately calculate the penalty amount based on the conditions specified in the question.",
                    "The second query may execute successfully and give the correct result. However, the logic used in the query may not accurately calculate the penalty amount based on the conditions specified in the question.",
                    "<p>The first query may execute successfully, but it may not always give the correct result. There could be issues with the logic or calculations in the query that may lead to incorrect penalty amounts being displayed. However, the query will run without syntax errors.</p>"
                ],
                "explanation": "<p>True Statement: <strong>Only the first query executes successfully but may not give the correct result.</strong></p><p>Analysis of Exhibit 1</p><pre class=\"prettyprint linenums\">SELECT po_id, CASE\n  WHEN MONTHS_BETWEEN(shipment_date, po_date) &gt; 1 THEN\n    TO_CHAR((shipment_date - po_date) * 20)\n  ELSE 'No Penalty'\nEND PENALTY\nFROM shipments;\n</pre><p><strong>Observations:</strong></p><ul><li><p>Correct syntax for <code>CASE</code> and date arithmetic.</p></li><li><p>Checks whether the month difference is more than one.</p></li><li><p>Calculates penalty by multiplying day difference by $20.</p></li><li><p>The use of <code>MONTHS_BETWEEN(shipment_date, po_date) &gt; 1</code> may not be precise. It measures fractional months, so 1.1 would count—but what if shipment is delayed by exactly 31 days? That might be misclassified depending on the month.</p></li><li><p>Penalty is calculated from <code>po_date</code>, not from exactly one month after <code>po_date</code>. So the number of days used in penalty could be overstated.</p></li></ul><p><strong>Conclusion:</strong> Executes successfully, but the <strong>logic doesn’t precisely match the requirement</strong>.</p><p><br></p><p>Analysis of Exhibit 2</p><pre class=\"prettyprint linenums\">SELECT po_id,\n  DECODE\n    (MONTHS_BETWEEN(po_date, shipment_date)&lt;1,\n     TO_CHAR((shipment_date - po_date) * 20), 'No Penalty') PENALTY\nFROM shipments;\n</pre><p><strong>Issues:</strong></p><ul><li><p><code>DECODE</code> does <strong>not support full boolean expressions</strong> as its first argument (<code>MONTHS_BETWEEN(po_date, shipment_date)&lt;1</code> returns a boolean, which isn't valid here).</p></li><li><p><code>DECODE</code> requires the full structure: <code>DECODE(expression, search1, result1, search2, result2, ...)</code></p></li><li><p>The logic in <code>DECODE</code> is flawed; comparing <code>MONTHS_BETWEEN &lt; 1</code> as the expression is syntactically incorrect.</p></li><li><p>Incorrect formatting: It should be <code>DECODE(condition, value1, result1, value2, result2, ...)</code> — this use is not syntactically valid.</p></li></ul><p><strong>Conclusion:</strong> <strong>Does not execute successfully</strong> due to incorrect use of <code>DECODE</code>.</p><p><br></p><p>Although it runs and produces a correct output, the logic might not correctly assess whether the shipment is more than 30 days late.</p><p><strong>Correct Query</strong></p><p>To be precise about the 30-day rule, use <code>TRUNC</code> and direct date subtraction:</p><pre class=\"prettyprint linenums\">SELECT po_id,\n  CASE \n    WHEN shipment_date &gt; ADD_MONTHS(po_date, 1) THEN \n      TO_CHAR((shipment_date - ADD_MONTHS(po_date, 1)) * 20)\n    ELSE 'No Penalty' \n  END AS penalty\nFROM shipments;\n</pre>",
                "answers": [
                    "<p>Both execute successfully and give correct results.</p>",
                    "<p>Only the first query executes successfully and always gives the correct result.</p>",
                    "<p>Only the first query executes successfully but may not give the correct result.</p>",
                    "<p>Only the second query executes successfully but gives a wrong result.</p>",
                    "<p>Only the second query executes successfully and gives the correct result.</p>",
                    "<p>Neither executes successfully.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "TRUNC",
            "question_plain": "View and examine the structure of the SHIPMENTS table:Table: SHIPMENTS Name             Null??            Type\nPO_ID            NOT NULL          NUMBER(3)\nPO_DATE          NOT NULL          DATE\nSHIPMENT_DATE    NOT NULL          DATE\nSHIPMENT_MODE                      VARCHAR2(30)\nSHIPMENT_COST                      NUMBER(8,2)\nRequired: Generate a report that displays the PO_ID and the penalty amount to be paid if the SHIPMENT_DATE is later than one month from the PO_DATE. The penalty is $20 per day.Evaluate the following two queries.Exhibit: 1SELECT po_id, CASE\n  WHEN MONTHS_BETWEEN(shipment_date, po_date) &gt; 1 THEN\n    TO_CHAR((shipment_date - po_date) * 20)\n  ELSE 'No Penalty'\nEND PENALTY\nFROM shipments;\nExhibit: 2SELECT po_id,\n  DECODE\n    (MONTHS_BETWEEN(po_date, shipment_date)&lt;1,\n     TO_CHAR((shipment_date - po_date) * 20), 'No Penalty') PENALTY\nFROM shipments;\nIdentify the true statement regarding the above commands.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478771,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE product (\n  pcode NUMBER(2),\n  pname VARCHAR2(20)\n);\n\nINSERT INTO product VALUES (1, 'pen');\nINSERT INTO product VALUES (2, 'pencil');\nINSERT INTO product VALUES (3, 'fountain pen');\nSAVEPOINT a;\nCOMMIT;\n\nDELETE FROM product WHERE pcode = 2;\nSAVEPOINT b;\n\nUPDATE product SET pcode = 30 WHERE pcode = 3;\nSAVEPOINT c;\n\nDELETE FROM product WHERE pcode = 10;\n\nROLLBACK TO SAVEPOINT b;\nCOMMIT;\n</pre><p><br></p><p><strong>Given:</strong> These statements have been executed in a single session.</p><p>Identify three true statements.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement \"The code for pen is 1\" is true because the SELECT query returns a row where the item is 'pen' and the code is 1.",
                    "The statement \"There is no row containing pencil\" is true because the SELECT query does not return any rows where the item is 'pencil'.",
                    "The statement \"The code for fountain pen is 3\" is true because the SELECT query returns a row where the item is 'fountain pen' and the code is 3.",
                    "The statement \"The code for pen is 10\" is false because the SELECT query returns a row where the item is 'pen' and the code is 1, not 10.",
                    "The statement \"There is no row containing fountain pen\" is false because the SELECT query returns a row where the item is 'fountain pen'.",
                    "The statement \"There is no row containing pen\" is false because the SELECT query returns a row where the item is 'pen'."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ul><li><p><strong>The code for pen is 1.</strong></p></li><li><p><strong>There is no row containing pencil.</strong></p></li><li><p><strong>The code for fountain pen is 3.</strong></p></li></ul><p>Initial Table and Inserts</p><pre class=\"prettyprint linenums\">CREATE TABLE product (\n  pcode NUMBER(2),\n  pname VARCHAR2(20)\n);\n\nINSERT INTO product VALUES (1, 'pen');\nINSERT INTO product VALUES (2, 'pencil');\nINSERT INTO product VALUES (3, 'fountain pen');\nSAVEPOINT a;\nCOMMIT;\n</pre><ul><li><p>Table <code>product</code> created.</p></li><li><p>Three rows inserted:</p><ul><li><p><code>(1, 'pen')</code></p></li><li><p><code>(2, 'pencil')</code></p></li><li><p><code>(3, 'fountain pen')</code></p></li></ul></li><li><p>Savepoint <code>a</code> created.</p></li><li><p><code>COMMIT</code> is issued, so these changes are <strong>permanent</strong>.</p></li></ul><p>Delete and Update Phase</p><pre class=\"prettyprint linenums\">DELETE FROM product WHERE pcode = 2;  -- removes pencil\nSAVEPOINT b;\n\nUPDATE product SET pcode = 30 WHERE pcode = 3;  -- changes fountain pen code from 3 to 30\nSAVEPOINT c;\n\nDELETE FROM product WHERE pcode = 10;  -- nothing is deleted (no pcode 10)\n\nROLLBACK TO SAVEPOINT b;\nCOMMIT;\n</pre><ul><li><p><strong>DELETE pcode = 2</strong> → removes <code>'pencil'</code></p></li><li><p><strong>SAVEPOINT b</strong> is set</p></li><li><p><strong>UPDATE pcode = 3 → 30</strong> → fountain pen becomes <code>(30, 'fountain pen')</code></p></li><li><p><strong>SAVEPOINT c</strong> is set</p></li><li><p><strong>DELETE pcode = 10</strong> → does nothing (no such row)</p></li><li><p><strong>ROLLBACK TO b</strong> → undoes everything <strong>after</strong> savepoint <code>b</code>:</p><ul><li><p>Reverts the update to fountain pen (pcode is back to 3)</p></li><li><p>The attempted delete of pcode 10 is also undone</p></li></ul></li><li><p><strong>COMMIT</strong> → final state saved</p></li></ul><p>Final Table State</p><p>After all commands, the table <code>product</code> contains:</p><p>pcode pname 1 pen 3 fountain pen</p><p>Note: The row with <code>'pencil'</code> (pcode 2) was deleted <strong>before</strong> savepoint <code>b</code> and never rolled back.</p><p>Evaluate Each Statement</p><ol><li><p><strong>The code for pen is 1.</strong><br>→ TRUE. Never modified or deleted.</p></li><li><p><strong>There is no row containing pencil.</strong><br>→ TRUE. It was deleted before savepoint <code>b</code>, and not rolled back.</p></li><li><p><strong>The code for fountain pen is 3.</strong><br>→ TRUE. The update to 30 was rolled back.</p></li><li><p><strong>The code for pen is 10.</strong><br>→ FALSE. Never updated.</p></li><li><p><strong>There is no row containing fountain pen.</strong><br>→ FALSE. It still exists with pcode 3.</p></li><li><p><strong>There is no row containing pen.</strong><br>→ FALSE. <code>(1, 'pen')</code> is still present.</p></li></ol>",
                "answers": [
                    "<p>The code for pen is 1.</p>",
                    "<p>There is no row containing pencil.</p>",
                    "<p>The code for fountain pen is 3.</p>",
                    "<p>The code for pen is 10.</p>",
                    "<p>There is no row containing fountain pen.</p>",
                    "<p>There is no row containing pen.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1CREATE TABLE product (\n  pcode NUMBER(2),\n  pname VARCHAR2(20)\n);\n\nINSERT INTO product VALUES (1, 'pen');\nINSERT INTO product VALUES (2, 'pencil');\nINSERT INTO product VALUES (3, 'fountain pen');\nSAVEPOINT a;\nCOMMIT;\n\nDELETE FROM product WHERE pcode = 2;\nSAVEPOINT b;\n\nUPDATE product SET pcode = 30 WHERE pcode = 3;\nSAVEPOINT c;\n\nDELETE FROM product WHERE pcode = 10;\n\nROLLBACK TO SAVEPOINT b;\nCOMMIT;\nGiven: These statements have been executed in a single session.Identify three true statements.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478781,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Internet'\nORDER BY 2 DESC\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'TV'\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Radio';\n</pre><p><br></p><p>Identify the true statement regarding the outcome of the above query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ORDER BY](https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "This statement is incorrect because the query uses positional notation in the ORDER BY clause with SET operators, which is not allowed in SQL.",
                    "This statement is correct because using positional notation in the ORDER BY clause with SET operators is not allowed in SQL, resulting in an error.",
                    "This statement is incorrect because the ORDER BY clause should be located at the end of the compound statement to be valid in SQL. Placing it elsewhere will result in an error.",
                    "This statement is correct because the ORDER BY clause should appear only at the end of a compound query, specifically with the last SELECT statement. Placing it elsewhere will result in an error in SQL."
                ],
                "explanation": "<p>Correct Answer: <strong>It produces an error because the ORDER BY clause should appear only at the end of a compound query—that is, with the last SELECT statement.</strong></p><p>Evaluate the <strong>compound SQL query</strong> step-by-step, focusing on the placement of the <code>ORDER BY</code> clause and how it behaves with <code>UNION</code>.</p><p>SQL Query:</p><pre class=\"prettyprint linenums\">SELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Internet'\nORDER BY 2 DESC\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'TV'\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Radio';\n</pre><p>Key Concepts to Understand:</p><ol><li><p><strong>ORDER BY in a Compound Query (</strong><code><strong>UNION</strong></code><strong>, </strong><code><strong>UNION ALL</strong></code><strong>, </strong><code><strong>INTERSECT</strong></code><strong>, </strong><code><strong>MINUS</strong></code><strong>)</strong>:</p><ul><li><p><strong>Only allowed at the end of the entire compound query</strong>.</p></li><li><p>Cannot appear within individual <code>SELECT</code> statements in a set operation.</p></li></ul></li><li><p><strong>Using </strong><code><strong>ORDER BY</strong></code><strong> in the first `SELECT</strong> (as in this example)**:</p><ul><li><p><strong>Not allowed</strong>. Causes an error.</p></li><li><p>The parser treats <code>ORDER BY</code> in the middle of a compound query as incorrect syntax.</p></li></ul></li><li><p><strong>Correct Placement</strong>:<br>You must place <code>ORDER BY</code> <strong>at the end</strong>, like this:</p><pre class=\"prettyprint linenums\">SELECT ...\nUNION\nSELECT ...\nUNION\nSELECT ...\nORDER BY promo_category DESC;\n</pre></li><li><p><strong>Positional notation (</strong><code><strong>ORDER BY 2</strong></code><strong>)</strong>:</p><ul><li><p><strong>Allowed</strong>, but again, <strong>only at the end</strong> of the compound query.</p></li></ul></li></ol><p>What Happens Here?</p><ul><li><p>The query attempts to use <code>ORDER BY</code> <strong>in the first SELECT</strong>.</p></li><li><p>That's <strong>invalid syntax</strong> in a compound query using <code>UNION</code>.</p></li></ul>",
                "answers": [
                    "<p>It executes successfully and displays rows in the descending order of PROMO_CATEGORY.</p>",
                    "<p>It produces an error because positional notation cannot be used in the ORDER BY clause with SET operators.</p>",
                    "<p>It executes successfully but ignores the ORDER BY clause because it is not located at the end of the compound statement.</p>",
                    "<p>It produces an error because the ORDER BY clause should appear only at the end of a compound query-that is, with the last SELECT statement.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following available responses.Evaluate the following SQL statement.Exhibit: 1SELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Internet'\nORDER BY 2 DESC\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'TV'\nUNION\nSELECT promo_id, promo_category\nFROM promotions\nWHERE promo_category = 'Radio';\nIdentify the true statement regarding the outcome of the above query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478783,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding multiple-row subqueries. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "Multiple-row subqueries can indeed contain group functions, allowing for aggregation and calculation of values across multiple rows in the subquery results.",
                    "Multiple-row subqueries do not always contain a subquery within a subquery. They can be standalone subqueries that return multiple rows of data for comparison in the main query.",
                    "Multiple-row subqueries do not necessarily use the &lt; ALL operator to imply less than the maximum. They can use various comparison operators based on the specific requirements of the query.",
                    "Multiple-row subqueries are not limited to retrieving multiple rows from a single table only. They can retrieve data from multiple tables based on the query logic and relationships.",
                    "It is true that multiple-row subqueries should not be used with the NOT IN operator in the main query if NULL is likely to be a part of the result of the subquery. This is because NULL values can lead to unexpected results when used with the NOT IN operator."
                ],
                "explanation": "<p>Correct options:</p><p><strong>1. They can contain group functions.</strong></p><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. </p><ul><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT employee_id\nFROM employees\nWHERE salary &gt; (SELECT AVG(salary) FROM employees);\n</pre></li></ul><p>Typically, you can use a subquery anywhere that you use an expression. Oracle subquery in the <code>FROM</code> clause example:</p><p>A subquery in the <code>FROM</code> clause of a <code>SELECT</code> statement is called an inline view which has the following syntax:</p><pre class=\"prettyprint linenums\"> SELECT * FROM (subquery) [AS] inline_view;</pre><p><br></p><p>For example, the following statement returns the top 10 orders with the highest values:</p><pre class=\"prettyprint linenums\">SELECT order_id, order_value\nFROM\n    (\n        SELECT\n            order_id,\n            SUM( quantity * unit_price ) order_value\n        FROM\n            order_items\n        GROUP BY\n            order_id\n        ORDER BY\n            order_value DESC\n    )\nFETCH FIRST 10 ROWS ONLY; </pre><p><br></p><p><strong>2. They should not be used with the NOT IN operator in the main query if NULL is likely to be a part of the result of the subquery.</strong></p><p>Oracle subquery with <code>IN</code> and <code>NOT IN</code> operators</p><ul><li><p>The subquery that uses the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-in/\"><code>IN</code></a> operator often returns a list of zero or more values. After the subquery returns the result set, the outer query makes uses of them.</p></li><li><p>Using <code>NOT IN</code> with a subquery that returns <strong>even a single NULL</strong> results in <strong>no rows</strong> being returned, due to <strong>unknown comparison</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">WHERE dept_id NOT IN (SELECT dept_id FROM departments)\n</pre><p>If one of the <code>dept_id</code>s is <code>NULL</code>, the condition fails.</p></li></ul><p><br></p><p>Incorrect options:</p><p><strong>They always contain a subquery within a subquery.</strong></p><ul><li><p><strong>False.</strong></p></li><li><p>A multiple-row subquery is simply a subquery that returns <strong>more than one row</strong>.</p></li><li><p>It does <strong>not</strong> have to be <strong>nested within another subquery</strong>.</p></li></ul><p><strong>They use the </strong><code><strong>&lt; ALL</strong></code><strong> operator to imply less than the maximum.</strong></p><ul><li><p><strong>Only partially accurate</strong>, and <strong>not always used that way</strong>.</p></li><li><p><code>&lt; ALL</code> means \"less than the <strong>smallest</strong> value in the list\".</p></li><li><p>So yes, it's less than the minimum, not the maximum.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">WHERE salary &lt; ALL (SELECT salary FROM employees WHERE department_id = 10)\n</pre></li></ul><ul><li><p>The statement says \"<strong>imply less than the maximum</strong>\", which is <strong>not correct</strong> — <code>&lt; ALL</code> means less than the <strong>minimum</strong>, not maximum.</p></li><li><p><strong>False due to incorrect explanation.</strong></p></li></ul><p><strong>They can be used to retrieve multiple rows from a single table only.</strong></p><ul><li><p><strong>False.</strong></p></li><li><p>Multiple-row subqueries can retrieve data from <strong>multiple tables</strong>, not just one.</p></li></ul>",
                "answers": [
                    "<p>They can contain group functions.</p>",
                    "<p>They always contain a subquery within a subquery.</p>",
                    "<p>They use the &lt; ALL operator to imply less than the maximum.</p>",
                    "<p>They can be used to retrieve multiple rows from a single table only.</p>",
                    "<p>They should not be used with the NOT IN operator in the main query if NULL is likely to be a part of the result of the subquery.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding multiple-row subqueries. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478785,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The SALES table has columns PROD_ID and QUANTITY_SOLD of data type NUMBER.</p><p>Identify the queries which execute successfully. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[HAVING ](https://docs.oracle.com/javadb/10.8.2.2/ref/rrefsqlj14854.html)",
                    "[GROUP BY](https://docs.oracle.com/javadb/10.3.3.0/ref/rrefsqlj32654.html)",
                    "[COUNT](https://docs.oracle.com/cd/B13789_01/server.101/b10759/functions028.htm)"
                ],
                "feedbacks": [
                    "This query successfully selects the PROD_ID from the SALES table where the QUANTITY_SOLD is greater than 55000. It then groups the results by PROD_ID and applies a HAVING clause to filter out the results where the count of rows for each PROD_ID is greater than 10.",
                    "This query has a syntax error as the COUNT(*) function cannot be used directly in the WHERE clause. The COUNT(*) function can only be used in the SELECT statement, GROUP BY clause, or HAVING clause.",
                    "This query successfully counts the occurrences of PROD_ID where the QUANTITY_SOLD is greater than 55000. It groups the results by PROD_ID, providing a count for each unique PROD_ID in the SALES table.",
                    "This query has a syntax error as the COUNT(*) function cannot be used directly in the WHERE clause. The COUNT(*) function can only be used in the SELECT statement, GROUP BY clause, or HAVING clause. Additionally, the GROUP BY clause is incorrectly used with a condition instead of a column.",
                    "This query has a syntax error as the WHERE clause should come before the GROUP BY clause in a SQL query. The COUNT function is also incorrectly used before the GROUP BY clause, which should be used in the SELECT statement to count the occurrences of a column."
                ],
                "explanation": "<p>Break down each query to determine which ones will execute successfully based on standard SQL syntax and logic:</p><p><strong>Query 1</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nGROUP BY prod_id \nHAVING COUNT(*) &gt;10;\n</pre><ul><li><p><strong>Valid</strong>: Filters rows first, groups them by <code>prod_id</code>, then applies a <code>HAVING</code> clause.</p></li><li><p>Correct use of <code>WHERE</code>, <code>GROUP BY</code>, and <code>HAVING</code>.</p></li></ul><p><strong>Query 2</strong></p><pre class=\"prettyprint linenums\">SELECT COUNT(prod_id) \nFROM sales \nWHERE quantity_sold &gt; 55000 \nGROUP BY prod_id;\n</pre><ul><li><p><strong>Valid</strong>: Aggregates count of <code>prod_id</code> for each group, after filtering by quantity sold.</p></li><li><p>Works as expected.</p></li></ul><p><strong>Query 3</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nAND COUNT(*) &gt; 10 \nGROUP BY prod_id \nHAVING COUNT(*) &gt;10;\n</pre><ul><li><p><strong>Invalid</strong>: <code>COUNT(*)</code> cannot be used in the <code>WHERE</code> clause — that’s what <code>HAVING</code> is for.</p></li></ul><p><strong>Query 4</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nAND COUNT(*) &gt; 10 \nGROUP BY COUNT(*) &gt;10;\n</pre><ul><li><p><strong>Invalid</strong>: Same problem — <code>COUNT(*)</code> used in <code>WHERE</code>, plus grouping by an aggregate is nonsensical here.</p></li></ul><p><strong>Query 5</strong></p><pre class=\"prettyprint linenums\">SELECT COUNT(prod_id) \nFROM sales \nGROUP BY prod_id \nWHERE quantity_sold &gt; 55000;\n</pre><ul><li><p><strong>Invalid</strong>: <code>WHERE</code> must come <em>before</em> <code>GROUP BY</code>.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nGROUP BY prod_id \nHAVING COUNT(*) &gt;10;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nAND COUNT(*) &gt; 10 \nGROUP BY prod_id \nHAVING COUNT(*) &gt;10;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (prod_id) \nFROM sales \nWHERE quantity_sold &gt; 55000 \nGROUP BY prod_id;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id \nFROM sales \nWHERE quantity_sold &gt; 55000 \nAND COUNT(*) &gt; 10 \nGROUP BY COUNT(*) &gt;10;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT(prod_id) \nFROM sales \nGROUP BY prod_id \nWHERE quantity_sold &gt; 55000;\n</pre>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "HAVING",
            "question_plain": "View and examine the following available responses.Given: The SALES table has columns PROD_ID and QUANTITY_SOLD of data type NUMBER.Identify the queries which execute successfully. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478787,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about external tables. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This statement is correct as external tables allow users to retrieve data using SQL or PL/SQL queries without the need to load the data into the database.",
                    "This statement is incorrect as while the actual data is stored outside the database, the metadata for external tables is stored within the database.",
                    "This statement is incorrect as indexes cannot be created on external tables. External tables do not support indexing.",
                    "This statement is correct as external tables can be populated from existing data in the database using the CREATE TABLE AS SELECT command, which allows for data transfer between internal and external tables.",
                    "This statement is incorrect as SELECT DML statements cannot be used on external tables. External tables do not support DML operations like INSERT, UPDATE, or DELETE."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ul><li><p><strong>You can populate them from existing data in the database by using the CREATE TABLE AS SELECT command.</strong> (This refers to unloading data <em>from</em> the database <em>to</em> external files using the external table mechanism, which is a valid use case).</p></li><li><p><strong>Their data can be retrieved by using only SQL or PL/SQL.</strong> (External tables are designed to be queried using standard SQL, and PL/SQL can execute SQL).</p></li></ul><p>Examine each statement regarding external tables:</p><ul><li><p><strong>You can populate them from existing data in the database by using the CREATE TABLE AS SELECT command.</strong></p><ul><li><p>While you can use <code>CREATE TABLE AS SELECT</code> <em>from</em> an external table to populate a regular database table, you generally don't \"populate\" an external table <em>from</em> existing data in the database in the same way you would a regular table. External tables are typically used to query data that resides <em>outside</em> the database (e.g., flat files). However, some database systems (like SQL Server with PolyBase) do allow <code>CREATE EXTERNAL TABLE AS SELECT</code> to export data from the database to an external location. In Oracle, you can use the external table framework to unload data from a database table using <code>CREATE TABLE ... ORGANIZATION EXTERNAL AS SELECT</code>. So this statement has some truth to it, specifically in the context of <em>unloading</em> data <em>to</em> an external location using the external table framework.</p></li></ul></li><li><p><strong>SELECT DML statements can be used on them.</strong></p><ul><li><p><code>SELECT</code> is a Data Query Language (DQL) statement, not a Data Manipulation Language (DML) statement. DML statements include <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>. External tables are read-only, meaning you <strong>cannot</strong> use <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> on them. However, you absolutely <em>can</em> use <code>SELECT</code> to retrieve data from them. So, the phrasing \"SELECT DML statements\" makes this statement inaccurate as <code>SELECT</code> is not a DML statement. If it said \"SELECT statements can be used on them,\" it would be true.</p></li></ul></li><li><p><strong>Their data can be retrieved by using only SQL or PL/SQL.</strong></p><ul><li><p>External tables provide a way to access external data using standard SQL queries. PL/SQL can also be used to execute SQL queries against external tables. This statement is generally true.</p></li></ul></li><li><p><strong>Their metadata and actual data are both stored outside the database.</strong></p><ul><li><p>This is incorrect. The <em>metadata</em> (the table definition, column names, data types, and location of the external files) of an external table is stored <em>within</em> the database's data dictionary. The <em>actual data</em> resides <em>outside</em> the database in flat files (or other external sources).</p></li></ul></li><li><p><strong>Indexes can be created on them.</strong></p><ul><li><p>This is incorrect. External tables are read-only and you cannot create indexes on them. Queries against external tables typically perform full table scans on the external data.</p></li></ul></li></ul><p>Based on the analysis, the true statements are:</p><ol><li><p><strong>You can populate them from existing data in the database by using the CREATE TABLE AS SELECT command.</strong> (Specifically for unloading data <em>to</em> an external location using the external table framework in some database systems like Oracle with ORACLE_DATAPUMP access driver, or SQL Server's CETAS).</p></li><li><p><strong>Their data can be retrieved by using only SQL or PL/SQL.</strong> (This is the primary way to interact with external tables).</p></li></ol><p>In Oracle, <code>CREATE TABLE ... ORGANIZATION EXTERNAL AS SELECT</code> is used to <em>unload</em> data from an existing database table <em>into</em> external files, where the external table then refers to these newly created files. This is a form of \"populating\" the external files <em>from</em> existing data in the database.</p>",
                "answers": [
                    "<p>Their data can be retrieved by using only SQL or PL/SQL.</p>",
                    "<p>Their metadata and actual data are both stored outside the database.</p>",
                    "<p>Indexes can be created on them.</p>",
                    "<p>You can populate them from existing data in the database by using the CREATE TABLE AS SELECT command.</p>",
                    "<p><code>SELECT </code>DML statements can be used on them.</p>"
                ]
            },
            "correct_response": [
                "d",
                "a"
            ],
            "section": "External tables",
            "question_plain": "View and examine the following available responses.Identify the true statements about external tables. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478789,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCT_INFORMATION and INVENTORIES tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-52-08-6f2ff2a7f6bf6ede9d37f5fa637da17f.png\"></p><p><br></p><p><strong>Required:</strong> Create a list containing PRODUCT_ID, SUPPLIER_ID, and QUANTITY_ON_HAND for all the products wherein QUANTITY_ON_HAND is less than five.</p><p>Identify two SQL statements can accomplish the task. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL statement correctly joins the PRODUCT_INFORMATION and INVENTORIES tables on the PRODUCT_ID column and filters the results based on the condition that QUANTITY_ON_HAND is less than 5. The SELECT clause retrieves the required columns, PRODUCT_ID, QUANTITY_ON_HAND, and SUPPLIER_ID.",
                    "This SQL statement attempts to use a NATURAL JOIN between the PRODUCT_INFORMATION and INVENTORIES tables, but the syntax is incorrect as the condition for filtering QUANTITY_ON_HAND is placed after the JOIN keyword. This results in a syntax error and does not achieve the desired outcome.",
                    "This SQL statement correctly joins the PRODUCT_INFORMATION and INVENTORIES tables on the PRODUCT_ID column and filters the results based on the condition that QUANTITY_ON_HAND is less than 5. The SELECT clause retrieves the required columns, PRODUCT_ID, QUANTITY_ON_HAND, and SUPPLIER_ID.",
                    "This SQL statement attempts to use the USING clause to join the tables on the PRODUCT_ID column and filter the results based on the condition that QUANTITY_ON_HAND is less than 5. However, the syntax is incorrect as the AND keyword is used after the USING clause, which results in a syntax error and does not achieve the desired outcome."
                ],
                "explanation": "<p>Evaluate each SQL statement to determine which <strong>two</strong> successfully produce a list of <code>PRODUCT_ID</code>, <code>SUPPLIER_ID</code>, and <code>QUANTITY_ON_HAND</code> for products where <code>QUANTITY_ON_HAND &lt; 5</code> </p><p>Statement 1</p><pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi \nJOIN inventories i\nON (pi.product_id = i.product_id)\nWHERE quantity_on_hand &lt; 5;\n</pre><ul><li><p><strong>Valid</strong></p></li><li><p>Correct syntax.</p></li><li><p>Joins the two tables on <code>product_id</code>, then filters with <code>WHERE</code>.</p></li></ul><p>Statement 2</p><pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi\nJOIN inventories i\nON (pi.product_id = i.product_id) \nAND quantity_on_hand &lt; 5;\n</pre><ul><li><p><strong>Valid</strong></p></li><li><p>The <code>AND</code> condition inside the <code>ON</code> clause applies before filtering, which is allowed.</p></li><li><p>Returns correct columns.</p></li></ul><p>Statement 3</p><pre class=\"prettyprint linenums\">SELECT product_id, quantity_on_hand, supplier_id\nFROM product_information\nNATURAL JOIN inventories \nAND quantity_on_hand &lt; 5;\n</pre><ul><li><p><strong>Invalid Syntax</strong></p></li><li><p>You cannot use <code>AND</code> directly after a <code>NATURAL JOIN</code>. The filter must come in a <code>WHERE</code> clause.</p></li></ul><p>Statement 4</p><pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi \nJOIN inventories i\nUSING (product_id) \nAND quantity_on_hand &lt; 5;\n</pre><ul><li><p><strong>Invalid Syntax</strong></p></li><li><p><code>AND</code> cannot follow <code>USING</code> like this — use <code>WHERE</code> instead.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi \nJOIN inventories i\nON (pi.product_id=i.product_id)\nWHERE quantity_on_hand &lt; 5;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT product_id, quantity_on_hand, supplier_id\nFROM product_information\nNATURAL JOIN inventories \nAND quantity_on_hand &lt; 5;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi\n JOIN inventories i\nON (pi.product_id=i.product_id) \nAND quantity_on_hand &lt; 5;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT i.product_id, i.quantity_on_hand, pi.supplier_id\nFROM product_information pi \nJOIN inventories i\nUSING (product_id) \nAND quantity_on_hand &lt; 5;</pre>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the structure of the PRODUCT_INFORMATION and INVENTORIES tables.Required: Create a list containing PRODUCT_ID, SUPPLIER_ID, and QUANTITY_ON_HAND for all the products wherein QUANTITY_ON_HAND is less than five.Identify two SQL statements can accomplish the task. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478791,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Identify the missing word(s) in the following sentence within the context of Oracle SQL.</p><p>If any item in a list following a <code>NOT IN</code> operation evaluates to null, then all rows evaluate to [____] or [____] and no rows are returned. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[IN Condition](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/IN-Condition.html)"
                ],
                "feedbacks": [
                    "In Oracle SQL, if any item in a list following a NOT IN operation evaluates to null, then all rows evaluate to FALSE. This means that no rows are returned in this scenario.",
                    "In Oracle SQL, if any item in a list following a NOT IN operation evaluates to null, then all rows evaluate to UNKNOWN. This results in no rows being returned due to the unknown evaluation.",
                    "The term \"ERR\" is not a valid response in the context of Oracle SQL when dealing with NULL evaluations in a NOT IN operation. It does not accurately reflect the behavior of NULL evaluations in this scenario.",
                    "The value \"0\" is not a valid response in the context of Oracle SQL when dealing with NULL evaluations in a NOT IN operation. It does not accurately reflect the behavior of NULL evaluations in this scenario.",
                    "The error code ORA-00851 is not relevant to the behavior of NULL evaluations in a NOT IN operation in Oracle SQL. It does not provide information on how NULL evaluations impact the results of the operation.",
                    "The value \"-1\" is not a valid response in the context of Oracle SQL when dealing with NULL evaluations in a NOT IN operation. It does not accurately reflect the behavior of NULL evaluations in this scenario.",
                    "The error code ORA-00850 is not relevant to the behavior of NULL evaluations in a NOT IN operation in Oracle SQL. It does not provide information on how NULL evaluations impact the results of the operation."
                ],
                "explanation": "<p>The missing words are:</p><ul><li><p><strong>UNKNOWN</strong></p></li><li><p><strong>FALSE</strong></p></li></ul><p>In Oracle SQL, when using the <code>NOT IN</code> operator, <strong>if any item in the list contains </strong><code><strong>NULL</strong></code>, the result of the condition becomes <strong>UNKNOWN</strong> for all rows, and <strong>no rows are returned</strong> — even if there might be matches.</p><p>Correct understanding:</p><p>Given:</p><pre class=\"prettyprint linenums\">WHERE column NOT IN (value1, NULL, value2)\n</pre><p>If even <strong>one</strong> item in the list is <code>NULL</code>, Oracle cannot guarantee that any value is <strong>not equal</strong> to the unknown (<code>NULL</code>). So the condition evaluates to:</p><ul><li><p><code><strong>UNKNOWN</strong></code> — due to Oracle’s 3-valued logic (TRUE, FALSE, UNKNOWN).</p></li><li><p>And any condition that evaluates to <code>UNKNOWN</code> in a <code>WHERE</code> clause <strong>is treated as FALSE</strong>, meaning <strong>no rows are returned</strong>.</p></li></ul><p>Incorrect options:</p><ul><li><p><code>ERR</code>, <code>ORA-00850</code>, <code>ORA-00851</code>: Not related to this logic.</p></li><li><p><code>-1</code>, <code>0</code>: Numeric values — irrelevant in logical evaluations.</p></li></ul><p><br></p><p>If any item in a list following a <code>NOT IN</code> operation evaluates to null, then all rows evaluate to <code>FALSE</code> or <code>UNKNOWN</code>, and no rows are returned. For example, the following statement returns the string '<code>True</code>' for each row:</p><pre class=\"prettyprint linenums\">SELECT 'True' FROM employees\n   WHERE department_id NOT IN (10, 20);</pre><p><br></p><p>However, the following statement returns no rows:</p><pre class=\"prettyprint linenums\">SELECT 'True' FROM employees\n    WHERE department_id NOT IN (10, 20, NULL); </pre><p><br></p><p>The preceding example returns no rows because the WHERE clause condition evaluates to:</p><pre class=\"prettyprint linenums\">department_id != 10 AND department_id != 20 AND department_id != null </pre>",
                "answers": [
                    "<p><code>FALSE</code></p>",
                    "<p><code>UNKNOWN</code></p>",
                    "<p><code>ERR</code> </p>",
                    "<p>0</p>",
                    "<p>ORA-00851</p>",
                    "<p>-1</p>",
                    "<p>ORA-00850</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "IN",
            "question_plain": "Identify the missing word(s) in the following sentence within the context of Oracle SQL.If any item in a list following a NOT IN operation evaluates to null, then all rows evaluate to [____] or [____] and no rows are returned. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478793,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description of the CUSTOMERS table:</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nCUST_ID          NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME       NOT NULL           VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(50\n</pre><p><br></p><p><strong>Required:</strong> Display details of all customers who reside in cities starting with the letter D followed by at least two characters.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query will only return customers who reside in a city that starts with the letter 'D' followed by exactly one character, not at least two characters as required.",
                    "This query will only return customers who reside in a city that starts with the letter 'D' followed by exactly one character, not at least two characters as required.",
                    "This query uses the 'LIKE' operator with the pattern 'D__%' to match cities starting with the letter 'D' followed by at least two characters. This will give the required output of all customers who reside in cities meeting the specified criteria.",
                    "This query uses the equality operator '=' with the pattern '%D__' which is not correct for matching cities starting with the letter 'D' followed by at least two characters. It will not provide the required output.",
                    "This query uses the 'LIKE' operator with the pattern 'D_%' which will only match cities starting with the letter 'D' followed by exactly one character, not at least two characters as required."
                ],
                "explanation": "<p>Correct answer:</p><ul><li><p><code><strong>SELECT * FROM customers WHERE city LIKE 'D__%';</strong></code></p></li></ul><p><strong>Requirement</strong>: Display details of <strong>all customers</strong> who reside in cities <strong>starting with the letter D</strong>, <strong>followed by at least two characters</strong>.</p><p>This means:</p><ul><li><p>City name must start with <code>'D'</code></p></li><li><p>Must have <strong>at least 3 characters total</strong> (D + 2 or more characters)</p></li></ul><p><strong>Pattern Breakdown</strong>:</p><ul><li><p><code>'D__%'</code></p><ul><li><p><code>D</code> = starts with D</p></li><li><p><code>__</code> = exactly 2 characters after D</p></li><li><p><code>%</code> = any number of additional characters (including none)</p></li><li><p><strong>Matches cities starting with D and at least 2 more characters</strong></p></li><li><p><strong>Correct</strong></p></li></ul></li></ul><p>Examine the others:</p><ul><li><p><code>'D_%'</code></p><ul><li><p><code>D</code> followed by <strong>any number</strong> of characters (even just 1)</p></li><li><p>Matches cities like \"De\" or \"D1\"</p></li><li><p><strong>Allows only one character after D</strong> — doesn't enforce <em>at least two</em></p></li></ul></li><li><p><code>'D_'</code></p><ul><li><p>Exactly 2 characters total (e.g., \"De\", \"D1\")</p></li><li><p><strong>Too short</strong></p></li></ul></li><li><p><code>'%D__'</code></p><ul><li><p>Ends with 2 characters after a D, but not necessarily at the start</p></li><li><p><strong>Doesn’t require city to start with D</strong></p></li></ul></li><li><p><code>'D_%'</code> again — same as above</p><ul><li><p><strong>Too broad</strong>, allows only one or more characters, not necessarily two or more</p></li></ul></li></ul>",
                "answers": [
                    "<p><code>SELECT * FROM customers WHERE city = 'D_%';</code> </p>",
                    "<p><code>SELECT * FROM customers WHERE city LIKE 'D_';</code> </p>",
                    "<p><code>SELECT * FROM customers WHERE city LIKE 'D__%';</code> </p>",
                    "<p><code>SELECT * FROM customers WHERE city = '%D__';</code> </p>",
                    "<p><code>SELECT * FROM customers WHERE city LIKE 'D_%';</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the description of the CUSTOMERS table:Table: CUSTOMERS Name             Null??            Type\nCUST_ID          NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME       NOT NULL           VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(50\nRequired: Display details of all customers who reside in cities starting with the letter D followed by at least two characters.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478795,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><br></p><p><strong>Given: </strong>The SQL statements executed in a user session are as follows.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE product (\n  pcode NUMBER(2),\n  pname VARCHAR2(10)\n);\n\nINSERT INTO product VALUES (1, 'pen');\nINSERT INTO product VALUES (2, 'pencil');\nSAVEPOINT a;\n\nUPDATE product SET pcode = 10 WHERE pcode = 1;\nSAVEPOINT b;\n\nDELETE FROM product WHERE pcode = 2;\nCOMMIT;\n\nDELETE FROM product WHERE pcode = 10;\n\nROLLBACK TO SAVEPOINT a;\n</pre><p><br></p><p>Identify the statements which describe the consequences of issuing the ROLLBACK TO SAVE POINT a command in the session. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement is incorrect. When issuing the ROLLBACK TO SAVE POINT command, it does not generate an error. It simply rolls back the transaction to the specified savepoint.",
                    "This statement is correct. When using ROLLBACK TO SAVE POINT, no SQL statements are rolled back except for the statements executed after the specified savepoint.",
                    "This statement is incorrect. The ROLLBACK TO SAVE POINT command rolls back all SQL statements executed after the specified savepoint, not just DELETE statements.",
                    "This statement is incorrect. When using ROLLBACK TO SAVE POINT, all SQL statements executed after the specified savepoint are rolled back, not just the second DELETE statement.",
                    "This statement is incorrect. ROLLBACK TO SAVE POINT rolls back all SQL statements executed after the specified savepoint, including both DELETE and UPDATE statements."
                ],
                "explanation": "<p>Final Correct Answers:</p><ul><li><p><strong>The rollback generates an error.</strong></p></li><li><p><strong>No SQL statements are rolled back.</strong></p></li></ul><p><br></p><p>Examine the SQL operations and understand what <code><strong>ROLLBACK TO SAVEPOINT a</strong></code> will do.</p><p><strong>Statements Executed (in order):</strong></p><ol><li><p><code>CREATE TABLE product (pcode, pname);</code></p><ul><li><p>Table created.</p></li></ul></li><li><p><code>INSERT INTO product VALUES (1, 'pen');</code></p></li><li><p><code>INSERT INTO product VALUES (2, 'pencil');</code></p><ul><li><p><code>SAVEPOINT a;</code><br>Savepoint <strong>a</strong> created.</p></li></ul></li><li><p><code>UPDATE product SET pcode = 10 WHERE pcode = 1;</code></p><ul><li><p><code>SAVEPOINT b;</code><br>Savepoint <strong>b</strong> created.</p></li></ul></li><li><p><code>DELETE FROM product WHERE pcode = 2;</code></p></li><li><p><code>COMMIT;</code></p><ul><li><p><strong>All changes up to this point are permanent.</strong></p></li></ul><ul><li><p>Savepoints <code>a</code> and <code>b</code> are <strong>no longer valid</strong> after the <code>COMMIT</code>.</p></li></ul></li><li><p><code>DELETE FROM product WHERE pcode = 10;</code></p><ul><li><p>A new DML operation <strong>after commit</strong>.</p></li></ul></li><li><p><code>ROLLBACK TO SAVEPOINT a;</code></p><ul><li><p><strong>Invalid</strong>, because <strong>savepoint </strong><code><strong>a</strong></code><strong> was created before the COMMIT</strong>, and <strong>no longer exists</strong> after it.</p></li></ul></li></ol><p>Evaluate each statement:</p><p><strong>\"The rollback generates an error.\"</strong></p><ul><li><p><strong>True.</strong></p></li><li><p>You <strong>cannot roll back to a savepoint that was created before a COMMIT</strong>.</p></li><li><p>Oracle will raise <strong>ORA-01086: savepoint never established</strong>.</p></li></ul><p><strong>\"No SQL statements are rolled back.\"</strong></p><ul><li><p><strong>True.</strong></p></li><li><p>Since the rollback to an invalid savepoint fails, <strong>nothing is rolled back</strong>.</p></li><li><p>The <code>DELETE FROM product WHERE pcode = 10</code> remains in effect unless a full <code>ROLLBACK</code> is issued instead.</p></li></ul><p><strong>\"Only the DELETE statements are rolled back.\"</strong></p><ul><li><p>Incorrect.</p></li><li><p><strong>No statements are rolled back</strong>, and one of the deletes (before COMMIT) is permanent.</p></li></ul><p><strong>\"Only the second DELETE statement is rolled back.\"</strong></p><ul><li><p>Incorrect.</p></li><li><p>The second DELETE (of pcode=10) occurred after the COMMIT, but the savepoint <code>a</code> is not valid anymore. And the rollback <strong>fails</strong>.</p></li></ul><p><strong>\"Both the DELETE statements and the UPDATE statement are rolled back.\"</strong></p><ul><li><p>Incorrect.</p></li><li><p>All of those were committed and are now permanent.</p></li></ul>",
                "answers": [
                    "<p>The rollback generates an error.</p>",
                    "<p>No SQL statements are rolled back.</p>",
                    "<p>Only the DELETE statements are rolled back.</p>",
                    "<p>Only the second DELETE statement is rolled back.</p>",
                    "<p>Both the DELETE statements and the UPDATE statement are rolled back.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "ROLLBACK",
            "question_plain": "View and examine the following available responses.Given: The SQL statements executed in a user session are as follows.Exhibit: 1CREATE TABLE product (\n  pcode NUMBER(2),\n  pname VARCHAR2(10)\n);\n\nINSERT INTO product VALUES (1, 'pen');\nINSERT INTO product VALUES (2, 'pencil');\nSAVEPOINT a;\n\nUPDATE product SET pcode = 10 WHERE pcode = 1;\nSAVEPOINT b;\n\nDELETE FROM product WHERE pcode = 2;\nCOMMIT;\n\nDELETE FROM product WHERE pcode = 10;\n\nROLLBACK TO SAVEPOINT a;\nIdentify the statements which describe the consequences of issuing the ROLLBACK TO SAVE POINT a command in the session. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478797,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-13_19-38-21-3f461b655874613ee0895f83e1e32227.png\"></p><p><br></p><p>Identify the tasks which would require subqueries or joins to be executed in a single statement. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This task requires finding the average credit limit of all customers and then comparing it with the credit limit of customers in each city. This involves using a subquery to calculate the average credit limit and then joining the result with the CUSTOMERS table to filter customers based on the comparison.",
                    "To find the average credit limit of male customers in specific cities, a join operation is needed to filter customers based on gender and city. This task involves joining the CUSTOMERS table with another table or subquery to retrieve the required data and calculate the average credit limit.",
                    "This task involves filtering customers based on multiple conditions (lack of credit limit and birth year) which requires using a subquery or join operation to combine the conditions and retrieve the desired results from the CUSTOMERS table.",
                    "Finding the number of customers with a specific marital status in each city requires grouping the data by city and marital status. This task involves using a join or subquery to combine the conditions and retrieve the count of customers meeting the criteria from the CUSTOMERS table.",
                    "Listing customers with the same credit limit as those in a specific city involves comparing the credit limit of each customer with the credit limit of customers in the specified city. This task requires a subquery or join operation to retrieve and compare the credit limit data from the CUSTOMERS table."
                ],
                "explanation": "<p>Tasks which would require subqueries or joins to be executed in a single statement:</p><ul><li><p><strong>Finding the number of customers, in each city, whose credit limit is more than the average credit limit of all the customers</strong></p></li><li><p><strong>Listing of those customers, whose credit limit is the same as the credit limit of customers residing in the city 'Tokyo'</strong></p></li></ul><p>Evaluate each of the listed tasks to determine which <strong>require subqueries or joins</strong> to be executed in a <strong>single SQL statement</strong>.</p><p>Task 1:</p><p><strong>Finding the number of customers, in each city, whose credit limit is more than the average credit limit of all the customers</strong></p><ul><li><p><strong>Requires a subquery</strong> to get the average credit limit of all customers.</p></li><li><p><strong>Main query</strong> groups by city and filters on the result of that subquery.</p></li><li><p><strong>This requires a subquery.</strong></p></li></ul><p>Task 2:</p><p><strong>Listing of those customers, whose credit limit is the same as the credit limit of customers residing in the city 'Tokyo'.</strong></p><ul><li><p><strong>Requires a subquery</strong> that fetches the credit limits of customers in 'Tokyo'.</p></li><li><p>Used in a <code>WHERE credit_limit IN (...)</code> clause.</p></li><li><p><strong>This requires a subquery.</strong></p></li></ul><p>Task 3:</p><p><strong>Finding the average credit limit of male customers residing in 'Tokyo' or 'Sydney'</strong></p><ul><li><p>Can be done with a <strong>single SELECT</strong> using <code>WHERE gender = 'M' AND city IN (...)</code>.</p></li><li><p>No subquery or join required.</p></li><li><p><strong>Does not require subquery or join.</strong></p></li></ul><p>Task 4:</p><p><strong>Listing of customers who do not have a credit limit and were born before 1980</strong></p><ul><li><p>Can be done with:</p></li></ul><pre class=\"prettyprint linenums\">SELECT * FROM customers \nWHERE credit_limit IS NULL AND birth_date &lt; TO_DATE('1980-01-01', 'YYYY-MM-DD');\n</pre><ul><li><p>Straightforward filtering — no subquery or join.</p></li><li><p><strong>Does not require subquery or join.</strong></p></li></ul><p>Task 5:</p><p><strong>Finding the number of customers, in each city, whose marital status is 'married'.</strong></p><ul><li><p>This can be written as:</p></li></ul><pre class=\"prettyprint linenums\">SELECT city, COUNT(*) \nFROM customers \nWHERE marital_status = 'married' \nGROUP BY city;\n</pre><ul><li><p>Simple aggregation — no subquery or join.</p></li><li><p><strong>Does not require subquery or join.</strong></p></li></ul>",
                "answers": [
                    "<p>Finding the number of customers, in each city, whose credit limit is more than the average credit limit of all the customers.</p>",
                    "<p>Finding the average credit limit of male customers residing in 'Tokyo' or 'Sydney'.</p>",
                    "<p>Listing of customers who do not have a credit limit and were born before 1980.</p>",
                    "<p>Finding the number of customers, in each city, whose marital status is 'married'.</p>",
                    "<p>Listing of those customers, whose credit limit is the same as the credit limit of customers residing in the city 'Tokyo'.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Identify the tasks which would require subqueries or joins to be executed in a single statement. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478799,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE order_item(\n  order_id NUMBER(3),\n  item_id NUMBER(2),\n  qty NUMBER(4).\n  CONSTRAINT order_itm_id_pk\n    PRIMARY KEY (order_id, item_id)\n    USING INDEX (\n      CREATE INDEX ord_itm_idx\n      ON order_item (order_id, item_id)\n    )\n);\n</pre><p><br></p><p>Identify the true statement regarding the above SQL statement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This statement is incorrect because the SQL statement includes the creation of two indexes, not just the ORD_ITM_IDX index.",
                    "This statement is incorrect because the error is not related to the composite primary key, but rather to the use of the USING INDEX clause.",
                    "This statement is correct as the SQL statement includes the creation of two indexes, ORD_ITM_IDX and ORD_ITM_ID_PK.",
                    "This statement is incorrect because the USING INDEX clause is permitted in the CREATE TABLE command, but the error is related to its usage in this specific context.",
                    "This statement is correct as the SQL statement would give an error, but the reason for the error is not listed in the choices provided."
                ],
                "explanation": "<p>Correct Answer: <strong> It would give an error for a reason not listed. </strong>(Because of the <strong>syntax error</strong> on the line defining <code>qty NUMBER(4).</code>)</p><p>Analyze the SQL statement carefully to determine the <strong>true statement</strong> about its behaviour.</p><p><strong>Exhibit Analysis:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE order_item(\n  order_id NUMBER(3),\n  item_id NUMBER(2),\n  qty NUMBER(4).   --- This line contains a syntax error (period instead of comma)\n  CONSTRAINT order_itm_id_pk\n    PRIMARY KEY (order_id, item_id)\n    USING INDEX (\n      CREATE INDEX ord_itm_idx\n      ON order_item (order_id, item_id)\n    )\n);\n</pre><p>Issue Identified:</p><ul><li><p>The line:</p><pre class=\"prettyprint linenums\">qty NUMBER(4).\n</pre><p>contains a <strong>period (</strong><code><strong>.</strong></code><strong>)</strong> instead of a <strong>comma (</strong><code><strong>,</strong></code><strong>)</strong> to separate the column definitions.</p></li></ul><p><strong>This will cause a syntax error</strong> during table creation — but not because of the <code>USING INDEX</code> clause or the composite key.</p><p>Understanding the <code>USING INDEX</code> clause:</p><ul><li><p>Oracle <strong>allows</strong> the <code>USING INDEX</code> clause in a <code>PRIMARY KEY</code> definition.</p></li><li><p>You <strong>can</strong> use it on a <strong>composite key</strong>.</p></li><li><p>It <strong>prevents Oracle from automatically creating a system-named index</strong>, by allowing you to specify your own.</p></li></ul><p>Va<strong>lid Oracle syntax</strong> — no error from that.</p><p>What happens overall?</p><ul><li><p>The use of <code>USING INDEX</code> with a composite key is <strong>valid</strong>.</p></li><li><p>The period (<code>.</code>) instead of a comma is a <strong>syntax error</strong>.</p></li><li><p>Therefore, the statement <strong>will fail</strong>, but <strong>not for any reason listed</strong> among the incorrect options like \"composite key\" or \"using index clause.\"</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-06-27_15-42-47-6805632bc389eb79fe7329aa6cf038b6.png\"></p><p><br></p><p>Corrected query:</p><pre class=\"prettyprint linenums\">CREATE TABLE order_item(\n  order_id NUMBER(3),\n  item_id NUMBER(2),\n  qty NUMBER(4),   --- Corrected syntax error (replaced period with comma)\n  CONSTRAINT order_itm_id_pk\n    PRIMARY KEY (order_id, item_id)\n    USING INDEX (\n      CREATE INDEX ord_itm_idx\n      ON order_item (order_id, item_id)\n    )\n);\n</pre>",
                "answers": [
                    "<p>It would execute successfully and only ORD_ITM_IDX index would be created.</p>",
                    "<p>It would give an error because the USING INDEX clause cannot be used on a composite primary.</p>",
                    "<p>It would execute successfully and two indexes ORD_ITM_IDX and ORD_ITM_ID_PK would be created.</p>",
                    "<p>It would give an error because the USING INDEX clause is not permitted in the CREATE TABLE command.</p>",
                    "<p>It would give an error for a reason&nbsp;not listed.</p>"
                ]
            },
            "correct_response": [
                "e"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1CREATE TABLE order_item(\n  order_id NUMBER(3),\n  item_id NUMBER(2),\n  qty NUMBER(4).\n  CONSTRAINT order_itm_id_pk\n    PRIMARY KEY (order_id, item_id)\n    USING INDEX (\n      CREATE INDEX ord_itm_idx\n      ON order_item (order_id, item_id)\n    )\n);\nIdentify the true statement regarding the above SQL statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478721,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding subqueries. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Using Subqueries](https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/Using-Subqueries.html#GUID-53A705B6-0358-4E2B-92ED-A83DE83DFD20)",
                    "[Oracle subquery to retrieve data from multiple tables?](https://stackoverflow.com/questions/26922808/oracle-subquery-to-retrieve-data-from-multiple-tables)",
                    "[Oracle SQL - return multiple columns from subquery](https://stackoverflow.com/questions/56039376/oracle-sql-return-multiple-columns-from-subquery)"
                ],
                "feedbacks": [
                    "A main query can indeed have multiple subqueries, allowing for complex and nested query structures to be formed.",
                    "A subquery typically retrieves data from a single main query, although it can be nested within multiple levels of subqueries. It does not directly relate to having more than one main query.",
                    "The subquery and main query do not necessarily have to retrieve data from the same table. They can retrieve data from different tables as long as the relationship is properly defined in the query.",
                    "The subquery and main query can retrieve data from different tables, as long as the necessary joins or conditions are specified to link the data appropriately.",
                    "In a subquery, multiple columns or expressions can be compared between the subquery and main query, allowing for more complex filtering and correlation of data.",
                    "While it is true that multiple columns or expressions can be compared between the subquery and main query, it is not limited to only one column or expression. This flexibility allows for more advanced and specific data retrieval and filtering."
                ],
                "explanation": "<p>Correct Answers:</p><ol><li><p><strong>A Main query can have many subqueries.</strong></p></li><li><p><strong>The subquery and main query can retrieve data from different tables.</strong></p></li><li><p><strong>Multiple columns or expressions can be compared between the subquery and main query.</strong></p></li></ol><p>Evaluate each statement about <strong>subqueries</strong>.</p><p><strong>1. \"A Main query can have many subqueries.\"</strong></p><ul><li><p><strong>True</strong></p><ul><li><p>A main (outer) query can contain <strong>multiple subqueries</strong> — in the <code>SELECT</code>, <code>FROM</code>, or <code>WHERE</code> clauses.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT name \nFROM employees \nWHERE salary &gt; (SELECT AVG(salary) FROM employees)\n  AND dept_id IN (SELECT dept_id FROM departments WHERE location_id = 100);\n</pre></li></ul></li></ul><p><strong>2. \"The subquery and main query can retrieve data from different tables.\"</strong></p><ul><li><p><strong>True</strong></p><ul><li><p>Subqueries often retrieve data from <strong>other tables</strong> to be compared with values in the main query.</p></li><li><p>This is one of the primary uses of subqueries (e.g., correlated subqueries, filtering).</p></li></ul></li></ul><p><strong>3. \"Multiple columns or expressions can be compared between the subquery and main query.\"</strong></p><ul><li><p><strong>True</strong> </p><ul><li><p>You can compare <strong>tuples</strong> or <strong>multiple columns</strong> between a subquery and the main query.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT * \nFROM employees e\nWHERE (e.salary, e.job_id) IN \n      (SELECT salary, job_id FROM job_grades WHERE grade = 'A');\n</pre></li></ul></li></ul><p><strong>4. \"A subquery can have more than one main query.\"</strong></p><ul><li><p><strong>False</strong> </p><ul><li><p>A subquery is <strong>part of a single main query</strong>.</p></li><li><p>A subquery can <strong>appear in many queries</strong>, but each instance is linked to <strong>one main query</strong>.</p></li></ul></li></ul><p><strong>5. \"The subquery and main query must retrieve data from the same table.\"</strong></p><ul><li><p><strong>False</strong> </p><ul><li><p>They <strong>can</strong> retrieve from the same table, but it's <strong>not required</strong>.</p></li><li><p>Often, subqueries retrieve from <strong>different tables</strong> than the main query.</p></li></ul></li></ul><p><strong>6. \"Only one column or expression can be compared between the subquery and main query.\"</strong></p><ul><li><p><strong>False</strong> </p><ul><li><p>As seen above, you <strong>can</strong> compare multiple columns in a composite form.</p></li></ul></li></ul>",
                "answers": [
                    "<p>A Main query can have many subqueries.</p>",
                    "<p>A subquery can have more than one main query.</p>",
                    "<p>The subquery and main query must retrieve data from the same table.</p>",
                    "<p>The subquery and main query can retrieve data from different tables.</p>",
                    "<p>Only one column or expression can be compared between the subquery and main query.</p>",
                    "<p>Multiple columns or expressions can be compared between the subquery and main query.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d",
                "f"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding subqueries. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478723,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the Exhibit and examine the structure of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(40)\nCUST_GENDER             NOT NULL          CHAR(1)\nCUST_YEAR_OF_BIRTH      NOT NULL          NUMBER(4)\nCUST_MARITAL_STATUS     NOT NULL          VARCHAR2(20)\nCUST_STREET_ADDRESS     NOT NULL          VARCHAR2(40)\nCUST_POSTAL_CODE        NOT NULL          VARCHAR2(10)\nCUST_CITY               NOT NULL          VARCHAR2(30)\nCUST_STATE_PROVINCE     NOT NULL          VARCHAR2(40)\nCOUNTRY_ID              NOT NULL          NUMBER\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBER\nCUST_EMAIL                                VARCHAR2(30)\n</pre><p><br></p><p><strong>Required: </strong></p><ul><li><p>Using the CUSTOMERS table, generate a report that displays a credit limit increase of 15% for all customers.</p></li><li><p>Customers with no credit limit should have \"Not Available\" displayed.</p></li></ul><p>Identify the response which would meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice correctly uses the NVL function to handle customers with no credit limit by displaying \"Not Available\". It also calculates the credit limit increase of 15% for all customers by multiplying the cust_credit_limit by 0.15 and then converting it to a string using TO_CHAR.",
                    "This choice incorrectly applies the NVL function and the calculation for the credit limit increase. The NVL function should be used to handle customers with no credit limit, and the calculation should be done by multiplying the cust_credit_limit by 0.15 before converting it to a string.",
                    "This choice correctly calculates the credit limit increase of 15% for all customers by multiplying the cust_credit_limit by 0.15. However, it does not handle customers with no credit limit as \"Not Available\" as required in the question.",
                    "This choice incorrectly applies the NVL function and the calculation for the credit limit increase. The NVL function should be used to handle customers with no credit limit, and the calculation should be done by multiplying the cust_credit_limit by 0.15."
                ],
                "explanation": "<p>To meet the requirement: <strong>Display a credit limit increase of 15% for all customers,</strong><br>and for customers with <strong>no credit limit (i.e., NULL),</strong> display <code>\"Not Available\"</code>.</p><p>Correct SQL Option:</p><pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(cust_credit_limit*.15), 'Not Available') \"NEW CREDIT\" \nFROM customers;\n</pre><p>Explanation:</p><ul><li><p><code>cust_credit_limit * 0.15</code> → Calculates the 15% increase.</p></li><li><p><code>TO_CHAR(...)</code> → Converts the number to a string so that <code>NVL()</code> can work with a <strong>string fallback</strong> (<code>'Not Available'</code>).</p></li><li><p><code>NVL(..., 'Not Available')</code> → Substitutes <code>'Not Available'</code> when the result is <code>NULL</code>.</p></li></ul><p>Why the other options are incorrect:</p><ol><li><p><code><strong>SELECT TO_CHAR(NVL(cust_credit_limit*.15,'Not Available'))</strong></code></p><ul><li><p><code>NVL(..., 'Not Available')</code> mixes <strong>NUMBER and VARCHAR2</strong> — Oracle will error when trying to use <code>'Not Available'</code> as a numeric default.</p></li></ul></li><li><p><code><strong>SELECT NVL(cust_credit_limit*.15,'Not Available')</strong></code></p><ul><li><p>Same issue — applying <code>NVL</code> to a number expression but using a <strong>string fallback</strong>. This causes a <strong>datatype mismatch error</strong>.</p></li></ul></li><li><p><code><strong>SELECT NVL(cust_credit_limit,'Not Available')*.15</strong></code></p><ul><li><p><code>NVL(cust_credit_limit, 'Not Available')</code> still returns a <strong>string</strong> for nulls, and then multiplies by 0.15 — this causes an error because <code>'Not Available' * 0.15</code> is invalid.</p></li></ul></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(cust_credit_limit*.15),'Not Available') \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(NVL(cust_credit_limit*.15,'Not Available')) \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(cust_credit_limit*.15,'Not Available') \"NEW CREDIT\" \nFROM customers;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(cust_credit_limit,'Not Available')*.15 \"NEW CREDIT\" \nFROM customers;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL statement",
            "question_plain": "View the Exhibit and examine the structure of the CUSTOMERS table.Table: CUSTOMERS Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(40)\nCUST_GENDER             NOT NULL          CHAR(1)\nCUST_YEAR_OF_BIRTH      NOT NULL          NUMBER(4)\nCUST_MARITAL_STATUS     NOT NULL          VARCHAR2(20)\nCUST_STREET_ADDRESS     NOT NULL          VARCHAR2(40)\nCUST_POSTAL_CODE        NOT NULL          VARCHAR2(10)\nCUST_CITY               NOT NULL          VARCHAR2(30)\nCUST_STATE_PROVINCE     NOT NULL          VARCHAR2(40)\nCOUNTRY_ID              NOT NULL          NUMBER\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBER\nCUST_EMAIL                                VARCHAR2(30)\nRequired: Using the CUSTOMERS table, generate a report that displays a credit limit increase of 15% for all customers.Customers with no credit limit should have \"Not Available\" displayed.Identify the response which would meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478725,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario and the exhibit.</p><p><strong>Given:</strong> The PRODUCT_INFORMATION table has a UNIT_PRICE column of data type NUMBER (8, 2).&nbsp; </p><p>Evaluate the following exhibit.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(unit_price, '$9,999')\nFROM product_information;\n</pre><p><br></p><p>Identify the true statements about the output. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This statement is true because the data type NUMBER(8,2) means that the column can store up to 8 digits, with 2 of them being decimal places. Therefore, the value 1023.99 will be rounded up to $1,024 when displayed.",
                    "This statement is incorrect because the data type NUMBER(8,2) can only store up to 8 digits, including decimal places. The value 10235.99 exceeds this limit and would not be displayed as $1,0236.",
                    "This statement is true because when a value exceeds the defined precision and scale of a NUMBER data type, it will be displayed as a series of pound signs (####) to indicate that the value cannot be fully displayed within the specified format.",
                    "This statement is incorrect because the value 10235.99 exceeds the precision and scale defined for the UNIT_PRICE column. It would not be displayed as $1,023 due to the limitations of the data type.",
                    "This statement is incorrect because the value 1023.99 will be displayed as $1,024 due to the rounding up of the decimal value in the UNIT_PRICE column."
                ],
                "explanation": "<p>Correct options:</p><ul><li><p><strong>A row whose UNIT_PRICE column contains the value 1023.99 will be displayed as </strong><code><strong>$1,024</strong></code><strong>.</strong></p></li><li><p><strong>A row whose UNIT_PRICE column contains the value 10235.99 will be displayed as </strong><code><strong>#######</strong></code><strong>.</strong></p></li></ul><p>Break down the formatting and evaluate the options.</p><p><strong>Given:</strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(unit_price, '$9,999') FROM product_information;\n</pre><ul><li><p>Format model: <code>'$9,999'</code></p></li><li><p>This allows for <strong>up to 4 digits before the decimal point</strong> (i.e., up to <code>9999</code>)</p></li><li><p>Only <strong>whole numbers</strong> will be displayed (no decimal precision)</p></li><li><p>The <code><strong>$</strong></code> is part of the format string</p></li><li><p>If the number exceeds the defined space (<code>$9,999</code>), it results in <code><strong>#######</strong></code></p></li></ul><p><strong>Analyze possible outputs:</strong></p><p><strong>Statement: A row whose UNIT_PRICE column contains the value </strong><code><strong>1023.99</strong></code><strong> will be displayed as </strong><code><strong>$1,024</strong></code><strong>.</strong></p><ul><li><p><code>TO_CHAR(1023.99, '$9,999')</code> → Rounds to nearest whole number → <code>1024</code></p></li><li><p>Fits in format → <code>$1,024</code></p></li><li><p><strong>Correct</strong></p></li></ul><p><strong>Statement: A row whose UNIT_PRICE column contains the value </strong><code><strong>10235.99</strong></code><strong> will be displayed as </strong><code><strong>#######</strong></code><strong>.</strong></p><ul><li><p><code>10235.99</code> rounds to <code>10236</code>, which needs <strong>5 digits</strong></p></li><li><p>Format supports <strong>only 4 digits</strong> (<code>$9,999</code>)</p></li><li><p>So the result is <code>#######</code></p></li><li><p><strong>Correct</strong></p></li></ul><p><strong>Statement: A row whose UNIT_PRICE column contains the value </strong><code><strong>10235.99</strong></code><strong> will be displayed as </strong><code><strong>$1,0236</strong></code><strong>.</strong></p><ul><li><p>Incorrect formatting — that’s not a valid output</p></li><li><p>Format <code>$9,999</code> doesn’t split 5-digit numbers like that</p></li><li><p><strong>Incorrect</strong></p></li></ul><p><strong>Statement: A row whose UNIT_PRICE column contains the value </strong><code><strong>10235.99</strong></code><strong> will be displayed as </strong><code><strong>$1,023</strong></code><strong>.</strong></p><ul><li><p>That would be true <strong>only</strong> if the value was <code>1023.99</code>, <strong>not</strong> <code>10235.99</code></p></li><li><p><strong>Incorrect</strong></p></li></ul><p><strong>Statement: A row whose UNIT_PRICE column contains the value </strong><code><strong>1023.99</strong></code><strong> will be displayed as </strong><code><strong>$1,023</strong></code><strong>.</strong></p><ul><li><p>Oracle rounds <code>1023.99</code> to <code>1024</code></p></li><li><p>The format does <strong>not</strong> show decimal digits</p></li><li><p>So the output would be <code>$1,024</code></p></li><li><p><strong>Incorrect</strong></p></li></ul>",
                "answers": [
                    "<p>A row whose UNIT_PRICE column contains the value 1023.99 will be displayed as $1,024.</p>",
                    "<p>A row whose UNIT_PRICE column contains the value 10235.99 will be displayed as $1,0236.</p>",
                    "<p>A row whose UNIT_PRICE column contains the value 10235.99 will be displayed as #######.</p>",
                    "<p>A row whose UNIT_PRICE column contains the value 10235.99 will be displayed as $1,023.</p>",
                    "<p>A row whose UNIT_PRICE column contains the value 1023.99 will be displayed as $1,023.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following scenario and the exhibit.Given: The PRODUCT_INFORMATION table has a UNIT_PRICE column of data type NUMBER (8, 2).&nbsp; Evaluate the following exhibit.Exhibit: 1 SELECT TO_CHAR(unit_price, '$9,999')\nFROM product_information;\nIdentify the true statements about the output. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478727,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES table.</p><p><strong>Table: EMPLOYEES </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\n</pre><p><br></p><p><strong>Required: </strong>Display the maximum and minimum salaries of employees hired 1 year ago.</p><p>Identify the statements which would provide the correct output. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[GROUP BY in Oracle](https://www.educba.com/group-by-in-oracle/)"
                ],
                "feedbacks": [
                    "This query is incorrect because the GROUP BY clause should not include the aggregate functions MIN and MAX. The correct syntax is to use the aggregate functions in the SELECT statement without grouping by them.",
                    "This query is correct because it correctly calculates the minimum and maximum salaries of employees hired 1 year ago by first selecting the salaries, then applying the MIN and MAX functions, and finally grouping by the calculated values.",
                    "This query is incorrect because the GROUP BY clause should not include the aggregate functions MIN and MAX. The correct syntax is to group by the non-aggregated columns or expressions used in the SELECT statement.",
                    "This query is correct because it selects the minimum and maximum salaries of employees hired 1 year ago without unnecessary grouping. The query structure is appropriate for retrieving the desired output."
                ],
                "explanation": "<p><strong>Understand the requirement:</strong></p><p>We want the <strong>minimum and maximum salary values</strong> from the <code>EMPLOYEES</code> table <strong>for employees whose </strong><code><strong>HIRE_DATE</strong></code><strong> is more than 1 year ago</strong>. That is:</p><pre class=\"prettyprint linenums\">WHERE hire_date &lt; SYSDATE - 365\n</pre><p><br></p><p>We also want to <strong>avoid unnecessary grouping</strong> — MIN and MAX are aggregate functions and don’t require a <code>GROUP BY</code> when applied over the full result set.</p><p><strong>Option 1:</strong></p><pre class=\"prettyprint linenums\">SELECT minsal, maxsal \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT MIN(salary) minsal, MAX(salary) maxsal \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;WHERE hire_date &lt; SYSDATE - 365) \nGROUP BY maxsal, minsal;\n</pre><ul><li><p>The inner query correctly computes <code>MIN</code> and <code>MAX</code> for employees hired more than a year ago.</p></li><li><p>The outer <code>GROUP BY</code> is unnecessary but <strong>not harmful</strong> — it just groups on the already aggregated result.</p></li><li><p><strong>Valid and correct</strong></p></li></ul><p><strong>Option 2:</strong></p><pre class=\"prettyprint linenums\">SELECT MIN(Salary), MAX(salary) \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT salary \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;WHERE hire_date &lt; SYSDATE - 365);\n</pre><ul><li><p>This query filters employees by hire date in the inner query.</p></li><li><p>Then calculates <code>MIN</code> and <code>MAX</code> salary on that filtered result.</p></li><li><p><strong>Valid and correct</strong></p></li></ul><p><strong>Option 3:</strong></p><pre class=\"prettyprint linenums\">SELECT MIN(Salary) minsal, MAX(salary) maxsal \nFROM employees \nWHERE hire_date &lt; SYSDATE - 365 \nGROUP BY MIN(salary), MAX(salary);\n</pre><ul><li><p><code>GROUP BY MIN(salary), MAX(salary)</code> is invalid — you <strong>cannot group by aggregate functions.</strong></p></li><li><p><strong>Invalid syntax — will cause error</strong></p></li></ul><p><strong>Option 4:</strong></p><pre class=\"prettyprint linenums\">SELECT minsal, maxsal \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT MIN(salary) minsal, MAX(salary) maxsal \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;GROUP BY MIN(salary), MAX(salary));\n</pre><ul><li><p>Again, <code>GROUP BY MIN(salary), MAX(salary)</code> is <strong>invalid</strong> — you can’t use aggregate functions in a <code>GROUP BY</code> clause.</p></li><li><p><strong>Invalid syntax — will cause error</strong></p></li></ul><p>The <code>GROUP BY</code> <a href=\"https://www.educba.com/oracle-clauses/\">Oracle clause is used to</a> decide the rows in a table into groups. It is used in the <code>SELECT</code> statement for grouping the rows by values of column or expression. The <code>GROUP BY</code> clause groups the results by one or more columns value.</p><ul><li><p>If the group function is included in a <code>SELECT</code> statement then individual result column(s) cannot be used without <code>GROUP BY</code> clause.</p></li><li><p>The extra non-group functional columns should be declared in the <code>GROUP BY</code> clause.</p></li><li><p>Rows can be pre excluded before dividing them into groups by using the <code>WHERE</code> clause.</p></li><li><p>Column <code>ALIAS</code> cannot be used in the <code>GROUP BY</code> clause.</p></li><li><p>By default, rows are sorted by ascending order of the column(s) included in the <code>GROUP BY</code> list.</p></li><li><p>The columns applied upon the <code>GROUP BY</code> clause need not be part of the <code>SELECT</code> list.</p></li><li><p>If the group function is included with the non-group functional column in a <code>SELECT</code> statement then <code>GROUP BY</code> clause must be used.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT MIN(Salary) minsal, MAX(salary) maxsal \nFROM employees \nWHERE hire_date &lt; SYSDATE-365 \nGROUP BY MIN(salary), MAX(salary);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT minsal, maxsal \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT MIN(salary) minsal, MAX(salary) maxsal \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;WHERE hire_date &lt; SYSDATE-365) \nGROUP BY maxsal, minsal;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT minsal, maxsal \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT MIN(salary) minsal, MAX(salary) maxsal \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;GROUP BY MIN(salary), MAX(salary));\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT MIN(Salary), MAX(salary) \nFROM (\n&nbsp; &nbsp; &nbsp;SELECT salary \n&nbsp; &nbsp; &nbsp;FROM employees \n&nbsp; &nbsp; &nbsp;WHERE hire_date &lt; SYSDATE-365);\n</pre>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "GROUP BY",
            "question_plain": "View and examine the structure of the EMPLOYEES table.Table: EMPLOYEES Name                    Null??            Type\nEMPLOYEE_ID             NOT NULL          NUMBER(6)\nFIRST_NAME                                VARCHAR2(20)\nLAST_NAME               NOT NULL          VARCHAR2(25)\nEMAIL                   NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                              VARCHAR2(20)\nHIRE_DATE               NOT NULL          DATE\nJOB_ID                  NOT NULL          VARCHAR2(10)\nSALARY                                    NUMBER(8,2)\nCOMMISSION_PCT                            NUMBER(2,2)\nMANAGER_ID                                NUMBER(6)\nDEPARTMENT_ID                             NUMBER(4)\nRequired: Display the maximum and minimum salaries of employees hired 1 year ago.Identify the statements which would provide the correct output. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478729,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the BOOKS_TRANSACTIONS table:</p><p><strong>Table: BOOKS_TRANSACTIONS</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nTRANSACTION_ID          NOT NULL          VARCHAR2(6)\nTRANSACTION_TYPE                          VARCHAR(3)\nBORROWED_DATE                             DATE\nBOOK_ID                                   VARCHAR2(6)\nMEMBER_ID                                 VARCHAR2(6)\n</pre><p><br></p><p>Examine the following exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM books_transactions\nWHERE borrowed_date &lt; SYSDATE\nAND transaction_type = 'RM'\nOR member_id IN ('A101', 'A102');\n</pre><p><br></p><p>Identify the true statement about the outcome.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This statement is incorrect because the query in the exhibit does not filter the results based on the TRANSACTION_TYPE being RM. It only filters based on the TRANSACTION_TYPE being RM or the MEMBER_ID being A101 or A102.",
                    "This statement is incorrect because the query in the exhibit does not filter the results based on the MEMBER_ID being A101 or A102. It only filters based on the TRANSACTION_TYPE being RM or the MEMBER_ID being A101 or A102.",
                    "This statement is incorrect because the query in the exhibit does not filter the results for only members A101 and A102. It includes all members who have borrowed before today with RM as TRANSACTION_TYPE or members A101 and A102.",
                    "This statement is correct because the query in the exhibit filters the results for members who have borrowed before today with RM as TRANSACTION_TYPE or for members A101 and A102."
                ],
                "explanation": "<p>Correct Answer: <strong>\"It displays details for members who have borrowed before today with RM as TRANSACTION_TYPE or the details for members A101 or A102.\"</strong></p><p>Analyze the query carefully:</p><p><strong>Query:</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM books_transactions\nWHERE borrowed_date &lt; SYSDATE\nAND transaction_type = 'RM'\nOR member_id IN ('A101', 'A102');\n</pre><p><strong>Operator Precedence in SQL:</strong></p><p>In SQL, <code><strong>AND</strong></code> has <strong>higher precedence</strong> than <code><strong>OR</strong></code>. That means the condition:</p><pre class=\"prettyprint linenums\">borrowed_date &lt; SYSDATE AND transaction_type = 'RM' OR member_id IN ('A101', 'A102')\n</pre><p>is interpreted as:</p><pre class=\"prettyprint linenums\">(borrowed_date &lt; SYSDATE AND transaction_type = 'RM') \nOR \n(member_id IN ('A101', 'A102'))\n</pre><p><strong>What This Means:</strong></p><p>The query will return rows that satisfy either:</p><ol><li><p><code>borrowed_date &lt; SYSDATE</code> <strong>AND</strong> <code>transaction_type = 'RM'</code><br><strong>OR</strong></p></li><li><p><code>member_id IN ('A101', 'A102')</code> <em>(regardless of date or transaction type)</em></p></li></ol>",
                "answers": [
                    "<p>It displays details only for members who have borrowed before today with RM as TRANSACTION_TYPE.</p>",
                    "<p>It displays details for members who have borrowed before today's date with either RM as TRANSACTION_TYPE or MEMBER_ID as A101 and A102.</p>",
                    "<p>It displays details for only members A101 and A102 who have borrowed before today with RM TRANSACTION_TYPE.</p>",
                    "<p>It displays details for members who have borrowed before today with RM as TRANSACTION_TYPE or the details for members A101 or A102.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the structure of the BOOKS_TRANSACTIONS table:Table: BOOKS_TRANSACTIONSName                    Null??            Type\nTRANSACTION_ID          NOT NULL          VARCHAR2(6)\nTRANSACTION_TYPE                          VARCHAR(3)\nBORROWED_DATE                             DATE\nBOOK_ID                                   VARCHAR2(6)\nMEMBER_ID                                 VARCHAR2(6)\nExamine the following exhibit.Exhibit: 1SELECT *\nFROM books_transactions\nWHERE borrowed_date &lt; SYSDATE\nAND transaction_type = 'RM'\nOR member_id IN ('A101', 'A102');\nIdentify the true statement about the outcome.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478731,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given:</strong></p><ul><li><p>The CUSTOMERS table has a CUST_LAST_NAME column of data type VARCHAR2.</p></li><li><p>The table has two rows whose CUST_LAST_NAME values are Anderson and Ausson.</p></li></ul><p>Identify the query which produces output for CUST_LAST_NAME containing Oder for the first row and Aus for the second.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query uses the REPLACE function to remove 'son' from the end of the CUST_LAST_NAME values, then replaces 'An' with 'o'. However, it does not handle the case where 'son' is not at the end of the value, so it will not produce the correct output for the given requirements.",
                    "This query uses the REPLACE function to remove 'son' from the CUST_LAST_NAME values, then extracts a substring starting from the first occurrence of 'An' and replaces it with 'O'. It does not accurately meet the requirement of producing 'Oder' for the first row and 'Aus' for the second row.",
                    "This query extracts the last 3 characters of the CUST_LAST_NAME values and replaces 'An' with 'O'. However, it does not consider the 'son' part of the value, so it will not generate the correct output for the given scenario.",
                    "This query first removes 'son' from the CUST_LAST_NAME values using the REPLACE function, then replaces 'An' with 'O'. It accurately meets the requirement of producing 'Oder' for the first row and 'Aus' for the second row, making it the correct choice for the given scenario.",
                    "This choice states that none of the listed responses are correct for the given scenario."
                ],
                "explanation": "<p>Analyze each query to determine which one produces the expected output.</p><p>Given Data:</p><ul><li><p>CUST_LAST_NAME</p></li><li><p>Anderson</p></li><li><p>Ausson</p></li></ul><p>Expected Output:</p><ul><li><p>CUST_LAST_NAME (Modified)</p></li><li><p>Oder</p></li><li><p>Aus</p></li></ul><p>Actual output:</p><ul><li><p>Anderson becomes Oder</p></li><li><p>Ausson becomes Aus</p></li></ul><p> <strong>Query 1:</strong></p><pre class=\"prettyprint linenums\">SELECT REPLACE (TRIM(TRAILING 'son' FROM cust_last_name), 'An', 'o') \nFROM customers;\n</pre><ul><li><p><strong>Issue:</strong></p><ul><li><p>The <code>TRIM(TRAILING 'son' FROM cust_last_name)</code> syntax is invalid in Oracle SQL. Oracle only supports <code>TRIM</code> with single characters or predefined options (LEADING, TRAILING, BOTH).</p></li><li><p>Even if it worked, <code>TRIM(TRAILING 'son' FROM 'Anderson')</code> would result in <code>'Ander'</code>, and replacing <code>'An'</code> with <code>'o'</code> would result in <code>'Oder'</code> (which is correct for the first row).</p></li><li><p>For <code>'Ausson'</code>, trimming <code>'son'</code> would yield <code>'Aus'</code>, and no replacement would occur, giving <code>'Aus'</code>, which matches the expected output.</p></li></ul></li><li><p><strong>Status:</strong>&nbsp; Invalid Syntax.</p></li></ul><p><strong>Query 2:</strong></p><pre class=\"prettyprint linenums\">SELECT SUBSTR (REPLACE(TRIM('son' FROM cust_last_name), 'An', 'O')) \nFROM customers;\n</pre><ul><li><p><strong>Issue:</strong></p><ul><li><p><code>TRIM('son' FROM cust_last_name)</code> is <strong>not valid</strong> in Oracle.</p></li><li><p>Even if it were valid, <code>REPLACE(TRIM('son' FROM 'Anderson'), 'An', 'O')</code> would result in <code>'Oder'</code>, and <code>'Ausson'</code> would become <code>'Aus'</code>, which matches expectations.</p></li></ul></li><li><p><strong>Status:</strong>&nbsp; Invalid Syntax.</p></li></ul><p><strong>Query 3:</strong></p><pre class=\"prettyprint linenums\">SELECT REPLACE (SUBSTR(cust_last_name, -3), 'An', 'O') \nFROM customers;\n</pre><ul><li><p><strong>Issue:</strong></p><ul><li><p><code>SUBSTR(cust_last_name, -3)</code> extracts the last three characters of the string.</p></li><li><p>For <code>'Anderson'</code>, <code>SUBSTR('Anderson', -3)</code> results in <code>'rson'</code>, and <code>REPLACE('rson', 'An', 'O')</code> does <strong>not</strong> modify the string as <code>'An'</code> is not found.</p></li><li><p>For <code>'Ausson'</code>, <code>SUBSTR('Ausson', -3)</code> results in <code>'son'</code>, and <code>REPLACE('son', 'An', 'O')</code> does <strong>not</strong> modify the string.</p></li><li><p><strong>Does not produce the expected output.</strong></p></li></ul></li><li><p><strong>Status:</strong>&nbsp; Incorrect Logic.</p></li></ul><p><br></p><p> <strong>Query 4:</strong></p><pre class=\"prettyprint linenums\">SELECT REPLACE (REPLACE(cust_last_name, 'son', ''), 'An', 'O') \nFROM customers;\n</pre><ul><li><p><strong>Step-by-step Execution:</strong></p><ul><li><p><code>REPLACE(cust_last_name, 'son', '')</code> removes <code>'son'</code> from both names:</p><ul><li><p><code>'Anderson' → 'Ander'</code></p></li><li><p><code>'Ausson' → 'Aus'</code></p></li></ul></li><li><p><code>REPLACE('Ander', 'An', 'O')</code> results in <code>'Oder'</code> </p></li><li><p><code>REPLACE('Aus', 'An', 'O')</code> does nothing, so it remains <code>'Aus'</code> </p></li></ul></li><li><p><strong>Final Output:</strong></p><p>ResultOderAus</p></li><li><p><strong>Status:</strong>&nbsp; <strong>Correct Query!</strong></p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT REPLACE (TRIM(TRAILING 'son' FROM cust_last_name), 'An', 'o') \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT SUBSTR (REPLACE(TRIM('son' FROM cust_last_name), 'An', 'O')) \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT REPLACE (SUBSTR(cust_last_name, -3), 'An', 'O') \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT REPLACE (REPLACE(cust_last_name, 'son', ''), 'An', 'O') \nFROM customers;\n</pre>",
                    "<p>None of the listed responses.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following available responses.Given:The CUSTOMERS table has a CUST_LAST_NAME column of data type VARCHAR2.The table has two rows whose CUST_LAST_NAME values are Anderson and Ausson.Identify the query which produces output for CUST_LAST_NAME containing Oder for the first row and Aus for the second.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478733,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following image. </p><p><strong>Exhibit: 1 </strong></p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-53-23-467554a3dea34dae8ae6ba50a596d8d6.png\"><p><br></p><p>Indicate the JOIN type best represented by the available choices.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "There is no such JOIN type as a COMPLETE JOIN in SQL. The available JOIN types are INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN.",
                    "An INNER JOIN returns only the rows where there is a match between the columns in both tables being joined. In the given image, the JOIN type is not limited to only matching rows, so it is not an INNER JOIN.",
                    "LEFT RIGHT JOIN is not a valid JOIN type in SQL. The correct syntax is either LEFT JOIN or RIGHT JOIN, depending on the side of the table where you want to include unmatched rows.",
                    "PARTIAL OUTER JOIN is not a standard JOIN type in SQL. The available options for OUTER JOINs are LEFT OUTER JOIN, RIGHT OUTER JOIN, and FULL OUTER JOIN.",
                    "The image represents a LEFT JOIN, where all the rows from the left table are included, regardless of whether there is a match in the right table. This is the correct choice based on the visual representation provided in the exhibit."
                ],
                "explanation": "<p>The <code>LEFT JOIN</code> keyword returns all records from the left table, even if there are no matches in the right table.</p><p><strong>LEFT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>LEFT OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p>Syntax</p><p>The syntax for the Oracle <code>LEFT OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nLEFT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>LEFT OUTER JOIN</code> keywords are replaced with LEFT JOIN.</p><p>Visual Illustration</p><p>In this visual diagram, the Oracle <code>LEFT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-17-2ee387b09bb38b1b8dc835df5f025fa0.png\"></p><p>The Oracle <code>LEFT OUTER JOIN</code> would return the all records from <em>table1</em> and only those records from <em>table2</em> that intersect with <em>table1</em>.</p>",
                "answers": [
                    "<p><code>COMPLETE JOIN</code> </p>",
                    "<p><code>INNER JOIN</code> </p>",
                    "<p><code>LEFT RIGHT JOIN</code> </p>",
                    "<p><code>PARTIAL OUTER JOIN</code> </p>",
                    "<p><code>LEFT JOIN</code> </p>"
                ]
            },
            "correct_response": [
                "e"
            ],
            "section": "Joins",
            "question_plain": "View and examine the following image. Exhibit: 1 Indicate the JOIN type best represented by the available choices.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478735,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the DELETE and TRUNCATE commands. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[The DELETE and TRUNCATE TABLE Statements](https://oracle-base.com/articles/misc/sql-for-beginners-the-delete-and-truncate-table-statements)"
                ],
                "feedbacks": [
                    "DELETE is a DML (Data Manipulation Language) command that operates on a single table at a time. It can remove rows from only one table in a single statement, making it suitable for targeted row deletions.",
                    "Unlike DELETE, TRUNCATE is a DDL (Data Definition Language) command that can remove all rows from a table at once. However, DELETE cannot be used to remove rows from multiple tables in one statement, as it is designed for single-table operations.",
                    "DELETE can be used to remove rows from tables that have referential integrity constraints, but it is not limited to only parent tables. It can delete rows from any table, regardless of its relationship with other tables in the database.",
                    "DELETE can be used to remove complete rows from a table, but it cannot selectively remove data from specific columns within those rows. If column-specific deletions are required, additional SQL statements or conditions must be used in conjunction with the DELETE command.",
                    "Both DELETE and TRUNCATE can be used on tables that are parents for child tables with referential integrity constraints. This means that rows can be deleted from parent tables even if they have child tables with ON DELETE rules defined, ensuring data consistency across related tables."
                ],
                "explanation": "<p>Evaluate each statement carefully regarding the <code>DELETE</code> and <code>TRUNCATE</code> commands in SQL:</p><p><strong>1. DELETE can be used to remove rows from only one table in one statement.</strong></p><ul><li><p><strong>True</strong> —</p></li><li><p><code>DELETE</code> targets a single table per statement (unless using complex joins or subqueries in <code>WHERE</code>, which still affects only one table at a time).</p></li></ul><p><strong>2. DELETE cannot be used to remove rows from multiple tables in one statement.</strong></p><ul><li><p><strong>True</strong> —</p></li><li><p>This is essentially a rewording of the first. In standard SQL, <code>DELETE</code> removes data from one table at a time.</p></li><li><p>Deleting from multiple tables requires separate statements or use of cascading deletes via foreign keys.</p></li></ul><p><strong>3. DELETE and TRUNCATE can be used for tables that are parents for a child table that has a referential integrity constraint having an ON DELETE rule.</strong></p><ul><li><p><strong>True (with clarification)</strong> —</p></li><li><p>If a parent table has a foreign key constraint with an <code>ON DELETE CASCADE</code> or <code>ON DELETE SET NULL</code>, <code>DELETE</code> works fine.</p></li><li><p><strong>However</strong>, <code>TRUNCATE</code> ignores the <code>ON DELETE</code> rules — Oracle <strong>won’t allow </strong><code><strong>TRUNCATE</strong></code> if there is a child table referencing the parent <strong>unless</strong> the foreign key is disabled or defined with <code>ON DELETE CASCADE</code> <strong>and</strong> is <strong>self-referential</strong>.</p></li><li><p>In general practice, <code>TRUNCATE</code> is more restricted when referential integrity constraints are present.</p></li><li><p><strong>Thus, this statement is conditionally true for </strong><code><strong>DELETE</strong></code><strong> and must be interpreted cautiously for </strong><code><strong>TRUNCATE</strong></code><strong>.</strong></p></li></ul><p><strong>4. DELETE can be used to remove rows only for tables that are parents for a child table that has a referential integrity constraint referring to the parent.</strong></p><ul><li><p><strong>False</strong> — </p></li><li><p><code>DELETE</code> can be used on <strong>any table</strong>, regardless of whether it's a parent or child in a foreign key relationship. This statement wrongly limits its applicability.</p></li></ul><p><strong>5. DELETE can be used to remove data from specific columns as well as complete rows.</strong></p><p><strong>False</strong> —</p><ul><li><p><code>DELETE</code> removes <strong>entire rows</strong>, <strong>not columns</strong>.</p></li><li><p>To \"remove\" data from specific columns, you'd use <code>UPDATE</code>, not <code>DELETE</code>.</p></li></ul><p><br></p><p><strong>Basic DELETE</strong></p><p>The <code>DELETE</code> statement is used to remove rows from the table. Without a <code>WHERE</code> clause, all rows in the table are deleted by a single statement.</p><p>The following example deletes all the rows from the EMPLOYEES table, then issues a <code>ROLLBACK</code> to cancel the deletion.</p><pre class=\"prettyprint linenums\">DELETE FROM employees;\n14 rows deleted.\nSQL&gt;\nROLLBACK;</pre><p><br></p><p>The <code>WHERE</code> clause allows you to limit the rows to be deleted.</p><pre class=\"prettyprint linenums\">DELETE FROM employees\nWHERE employee_id = 7369; \n1 row deleted.\nSQL&gt;\nROLLBACK;</pre><p><br></p><p><strong>DELETE via View</strong></p><p>It's possible to delete from the base table associated with a view. </p><pre class=\"prettyprint linenums\">CREATE OR REPLACE VIEW employees_v AS\nSELECT * FROM employees;\n\nDELETE FROM employees_v\nWHERE employee_id = 7369;\n\n1 row updated.\n\nSQL&gt;\n\nROLLBACK;</pre><p><br></p><p><strong>TRUNCATE TABLE</strong></p><p>If you want to remove all the rows from a table, the <code>TRUNCATE TABLE</code> statement is a lot more efficient than the <code>DELETE</code> statement. The <code>TRUNCATE TABLE</code> statement is a DDL command, so it includes an implicit <code>COMMIT</code>, so there is no way to issue a <code>ROLLBACK</code> if you decide you didn't want to remove the rows.</p><p>In the following example, we check the number of rows in the table, issue the <code>TRUNCATE TABLE</code> statement, immediately <code>ROLLBACK</code> and check the number of rows in the table again. You will see from the output, the <code>ROLLBACK</code> does not cancel the <code>TRUNCATE TABLE</code> statement.</p><pre class=\"prettyprint linenums\">SELECT COUNT(*)\nFROM   employees;\n\n  COUNT(*)\n----------\n        14\n\n1 row selected.\n\nSQL&gt; TRUNCATE TABLE employees;\n\nTable truncated.\n\nSQL&gt; ROLLBACK;\n\nRollback complete.\n\nSQL&gt;\n\nSELECT COUNT(*)\nFROM   employees;\n\n  COUNT(*)\n----------\n         0\n\n1 row selected.\n\nSQL&gt;</pre><p><br></p><p>The <code>TRUNCATE TABLE</code> statement can remove the storage associated with the table, or leave it to be reused later.</p><pre class=\"prettyprint linenums\">-- Remove storage.\nTRUNCATE TABLE employees;\nTRUNCATE TABLE employees DROP STORAGE;\n\n-- Keep storage.\nTRUNCATE TABLE employees REUSE STORAGE;</pre>",
                "answers": [
                    "<p>DELETE can be used to remove rows from only one table in one statement.</p>",
                    "<p>DELETE cannot be used to remove rows from multiple tables in one statement.</p>",
                    "<p>DELETE can be used to remove rows only for tables that are parents for a child table that has a referential integrity constraint referring to the parent.</p>",
                    "<p>DELETE can be used to remove data from specific columns as well as complete rows.</p>",
                    "<p>DELETE and TRUNCATE can be used for tables that are parents for a child table that has a referential integrity constraint having an ON DELETE rule.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "e"
            ],
            "section": "TRUNCATE",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the DELETE and TRUNCATE commands. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478737,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Given:</strong> These SQL statements are executed in the given order.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE emp(\nemp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY&nbsp;KEY,\nename VARCHAR2(15),\nsalary NUMBER(8,2,),\nmgr_no NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp (emp_no)\n);\n\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;\n\nALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\n</pre><p><br></p><p>Identify the status of the foreign key EMP_MGR_FK.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Enabling a foreign key constraint immediately means that the constraint will be enforced as soon as it is enabled. In this case, the foreign key EMP_MGR_FK will not be immediately enabled as it remains disabled in the given SQL exhibit.",
                    "Enabling a foreign key constraint as deferred means that the constraint will be checked at the end of the transaction. In the given SQL exhibit, the foreign key EMP_MGR_FK is not set to be deferred, so it will not be enabled in a deferred manner.",
                    "The foreign key EMP_MGR_FK will remain disabled based on the SQL exhibit provided. It can be manually re-enabled later if needed, but it will not be automatically enabled by the SQL statements shown.",
                    "The foreign key EMP_MGR_FK will not be automatically enabled based on the SQL exhibit. If there is a need to enable the foreign key constraint, it will require dropping the constraint and re-creating it to enforce the relationship."
                ],
                "explanation": "<p>Correct option: <strong>It will remain disabled and can be re-enabled manually.</strong></p><p>Analyze the given SQL statements and their effect on the status of the foreign key <code>EMP_MGR_FK</code>.</p><p><strong>Step-by-step Analysis</strong></p><p>1. <strong>Table Creation</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE emp(\n  emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\n  ename VARCHAR2(15),\n  salary NUMBER(8,2,),\n  mgr_no NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp (emp_no)\n);\n</pre><ul><li><p><code>emp_emp_no_pk</code>: A <strong>primary key</strong> constraint on <code>emp_no</code>.</p></li><li><p><code>emp_mgr_fk</code>: A <strong>foreign key</strong> on <code>mgr_no</code> referencing the same table's <code>emp_no</code> — this is a <strong>self-referencing</strong> foreign key.</p></li></ul><p>2. <strong>Disable the Primary Key with CASCADE</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;\n</pre><ul><li><p><code>CASCADE</code> disables all <strong>dependent constraints</strong>.</p></li><li><p>Since <code>emp_mgr_fk</code> <strong>depends</strong> on the primary key <code>emp_emp_no_pk</code>, it is <strong>also disabled</strong>.</p></li></ul><p>3. <strong>Re-enable the Primary Key</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\n</pre><ul><li><p><strong>Important:</strong> Enabling the primary key does <strong>not</strong> automatically re-enable any dependent foreign key constraints that were disabled via <code>CASCADE</code>.</p></li><li><p>Thus, <code>emp_mgr_fk</code> remains <strong>disabled</strong>.</p></li><li><p><strong>Correct Answer:</strong></p></li></ul><p><strong>It will remain disabled and can be re-enabled manually.</strong></p><p>Additional Notes:</p><ul><li><p>To re-enable the foreign key <code>emp_mgr_fk</code>, you'd need to run:</p></li></ul><pre class=\"prettyprint linenums\">ALTER TABLE emp ENABLE CONSTRAINT emp_mgr_fk;\n</pre><ul><li><p>Oracle does <strong>not</strong> automatically re-enable dependent foreign keys when the parent key is re-enabled.</p></li></ul><p>Why the Other Options Are Incorrect:</p><ul><li><p><strong>\"It will be enabled and immediate\"</strong> – Not true; foreign key is not automatically re-enabled.</p></li><li><p><strong>\"It will be enabled and deferred\"</strong> – Constraint mode is not deferred by default, and again, it is still disabled.</p></li><li><p><strong>\"It will remain disabled and can be enabled only by dropping the foreign key constraint and re-creating it\"</strong> – Not true; you can enable it manually without dropping.</p></li></ul><p><br></p><p><strong>There are multiple ways to disable constraints in Oracle.</strong></p><p>The \"alter table\" disable constrains syntax can be used to disable constraints in Oracle</p><pre class=\"prettyprint linenums\">alter table\ntable_name\nDISABLE constraint\nconstraint_name;</pre><p><br></p><p>Another way to enable and disable constraints in Oracle would be to either use a plsql block or write a script.<br><br>Here is a script that makes use of Oracle disable constraint:</p><pre class=\"prettyprint linenums\">begin\nfor i in (select constraint_name, table_name from user_constraints) LOOP\nexecute immediate 'alter table '||i.table_name||' disable constraint '||i.constraint_name||'';\nend loop;\nend;\n/</pre><p><br></p><p>or here is an alternate example of Oracle disable constraints:</p><pre class=\"prettyprint linenums\">select 'alter table '||table_name||' disable constraint '||constraint_name||';' from user_constraints;</pre><p><br></p><p>Be careful when disabling constraints in Oracle, because of the implicit commits in DDL statements like this, sometimes you will find it necessary to \"cache\" the results of the cursor before starting to execute the DDLs used to disable constraints and avoid \"snapshot too old\" errors. This only happen occasionally, but if it does use this method to disable constraints in Oracle:</p><p>Declare<br>is<br>Type varchar2Array is table of varchar2(1000) index by binary_integer;<br>tabCons mypkg.varchar2Array;</p><pre class=\"prettyprint linenums\">begin\nselect constraint_name Bulk Collect Into tabCons\nfrom\n(\nselect constraint_name\nfrom user_constraints\nwhere table_name = :tab_name\n);</pre><p><br></p><p>If tabSQL.count &gt; 0 Then<br>For numCount in tabCons.first .. tabCons.Last</p><pre class=\"prettyprint linenums\">Loop\nExecute Immediate 'alter table '||:tab_name||' disable constraint '||tabCons(numCount);\nend loop;\nEnd If;\nEnd;</pre>",
                "answers": [
                    "<p>It will be enabled and immediate.</p>",
                    "<p>It will be enabled and deferred.</p>",
                    "<p>It will remain disabled and can be re-enabled manually.</p>",
                    "<p>It will remain disabled and can be enabled only by dropping the foreign key constraint and re-creating it.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following SQL exhibit.Given: These SQL statements are executed in the given order.Exhibit: 1CREATE TABLE emp(\nemp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY&nbsp;KEY,\nename VARCHAR2(15),\nsalary NUMBER(8,2,),\nmgr_no NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES emp (emp_no)\n);\n\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk CASCADE;\n\nALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\nIdentify the status of the foreign key EMP_MGR_FK.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478739,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDERS table.</p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-55-22-e17f53e9e5856e32f50d3c045af592cd.png\"><p><br></p><p>Identify the valid UPDATE statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[UPDATE ](https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/UPDATE.html)"
                ],
                "feedbacks": [
                    "This statement attempts to update the order_date column to a specific date value and set the order_total column to NULL for the order with order_id 2455. The syntax for setting a column to NULL is correct, but there is a syntax error with the order_total column being set to NULL.",
                    "This statement attempts to update the order_date column to a specific date value and set the order_total column to NULL using the TO_NUMBER function. However, the syntax for setting a column to NULL is incorrect, and the use of the TO_NUMBER function with NULL is unnecessary and incorrect.",
                    "This statement correctly updates the order_date column to a specific date value and sets the order_total column to NULL for the order with order_id 2455. The syntax for setting a column to NULL is correct in this statement.",
                    "This statement attempts to update the order_date column to a specific date value using the TO_DATE function and set the order_total column to NULL using the TO_NUMBER function. However, there are syntax errors with the use of multiple SET keywords and the unnecessary use of the TO_NUMBER function with NULL."
                ],
                "explanation": "<p>Evaluate each of the provided <code>UPDATE</code> statements to determine which one is <strong>valid</strong> in Oracle SQL:</p><p><strong>Correct Statement:</strong></p><pre class=\"prettyprint linenums\">UPDATE orders \nSET order_date = '12-mar-2019', order_total = NULL \nWHERE order_id = 2455;\n</pre><ul><li><p>This is <strong>syntactically and logically correct</strong>.</p></li><li><p><code>'12-mar-2019'</code> will be implicitly converted to a <code>DATE</code> using Oracle's default date format (<code>DD-MON-YY</code> or <code>DD-MON-YYYY</code>, depending on NLS settings).</p></li><li><p><code>order_total = NULL</code> correctly sets the column to <code>NULL</code>.</p></li></ul><p><strong>Incorrect Statements:</strong></p><p>1.</p><pre class=\"prettyprint linenums\">UPDATE orders \nSET order_date = '12-mar-2019', order_total IS NULL \nWHERE order_id = 2455;\n</pre><ul><li><p><code>IS NULL</code> is used in <code>WHERE</code> clauses, <strong>not</strong> in <code>SET</code> clauses.</p></li><li><p>This is a <strong>syntax error</strong>.</p></li></ul><p>2.</p><pre class=\"prettyprint linenums\">UPDATE orders \nSET order_date = '12-mar-2019', AND order_total = TO_NUMBER(NULL) \nWHERE order_id = 2455;\n</pre><ul><li><p>The comma <code>,</code> and the keyword <code>AND</code> are <strong>not</strong> valid together in the <code>SET</code> clause.</p></li><li><p><code>AND</code> is used in <code>WHERE</code> clauses, not in <code>SET</code>.</p></li></ul><p>3.</p><pre class=\"prettyprint linenums\">UPDATE orders \nSET order_date = TO_DATE('12-mar-2019','dd-mon-yyyy'), SET order_total = TO_NUMBER (NULL) \nWHERE order_id = 2455;\n</pre><ul><li><p>You cannot use <strong>two </strong><code><strong>SET</strong></code><strong> keywords</strong> in the same <code>UPDATE</code> statement.</p></li><li><p>Only <strong>one </strong><code><strong>SET</strong></code> is allowed, followed by a comma-separated list of column assignments.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">UPDATE orders SET order_date = '12-mar-2019',order_total IS NULL \nWHERE order_id = 2455;\n</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE orders SET order_date = '12-mar-2019', AND order_total = TO_NUMBER(NULL) \nWHERE order_id = 2455;\n</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE orders SET order_date = '12-mar-2019',order_total = NULL \nWHERE order_id = 2455;\n</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE orders SET order_date = TO_DATE('12-mar-2019','dd-mon-yyyy'), SET order_total = TO_NUMBER (NULL) \nWHERE order_id = 2455;\n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "UPDATE",
            "question_plain": "View and examine the structure of the ORDERS table.Identify the valid UPDATE statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478741,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the data in the PRODUCT_INFORMATION table.</p><p><strong>Table: PRODUCT_INFORMATION </strong></p><pre class=\"prettyprint linenums\">PDT_ID      SUP_ID         PDT_STATU              LIST_PRICE        MIN_PRICE\n1797        102094         orderable              349                 288\n2254        102071         obsolete               453                 371\n2382        102050         under development      850                 731\n3459        102099         under development      699                 568\n3127        102087         orderable              498                 444\n3353        102071         obsolete               489                 413\n3354        102066         orderable              543                 478\n</pre><p><br></p><p>Identify the tasks which would require subqueries. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "This task requires a subquery to calculate the average list price of products with the status 'orderable' and then compare it to the minimum list prices of all products to filter out the products that meet the specified condition.",
                    "This task involves using a subquery to count the total number of products supplied by supplier 102071 and having the product status 'OBSOLETE' by filtering the data based on the given criteria.",
                    "To display the number of products whose list prices are more than the average list price, a subquery is needed to calculate the average list price and then compare it to the list prices of individual products to determine which ones meet the condition.",
                    "This task does not require a subquery as it involves a straightforward comparison of the average list price of all products with a fixed value (500) to filter out the supplier IDs that meet the specified condition.",
                    "This task requires a subquery to calculate the minimum list price for each product status by grouping the data based on product status and then finding the minimum list price within each group."
                ],
                "explanation": "<p>Correct answers:</p><ul><li><p><strong>Displaying all the products whose minimum list prices are more than average list price of products having the status orderable</strong></p></li><li><p><strong>Displaying the number of products whose list prices are more than the average list price</strong></p></li></ul><p>Analyze each task to determine which ones <strong>require subqueries</strong>. Subqueries are needed when a query depends on the result of another query (e.g., aggregate values like averages, counts, or comparisons involving them).</p><p><strong>1. Displaying all the products whose minimum list prices are more than average list price of products having the status 'orderable'</strong></p><ul><li><p><strong>Requires subquery</strong>: You need to first calculate the <strong>average list price of products</strong> with <code>PDT_STATU = 'orderable'</code>, then compare <code>MIN_PRICE</code> of each product against that value.</p></li><li><p><strong>This requires a subquery</strong>.</p></li></ul><p><strong>2. Displaying the number of products whose list prices are more than the average list price</strong></p><ul><li><p><strong>Requires subquery</strong>: You need the <strong>average list price</strong> (aggregate), and then compare each product's <code>LIST_PRICE</code> against it. The comparison involves an aggregate, so this needs a subquery.</p></li><li><p><strong>This requires a subquery</strong>.</p></li></ul><p><strong>3. Displaying the total number of products supplied by supplier 102071 and having product status OBSOLETE</strong></p><ul><li><p><strong>Does not require subquery</strong>: This can be done with a simple <code>WHERE</code> clause and <code>COUNT(*)</code>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT COUNT(*) \nFROM product_information \nWHERE sup_id = 102071 AND pdt_statu = 'obsolete';\n</pre><ul><li><p><strong>Does not need a subquery</strong>.</p></li></ul><p><strong>4. Displaying all supplier IDs whose average list price is more than 500</strong></p><ul><li><p><strong>Does not require subquery</strong>: This can be done using <code>GROUP BY</code> and <code>HAVING</code>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT sup_id \nFROM product_information \nGROUP BY sup_id \nHAVING AVG(list_price) &gt; 500;\n</pre><ul><li><p><strong>No subquery needed</strong>.</p></li></ul><p><strong>Displaying the minimum list price for each product status</strong></p><ul><li><p><strong>Does not require subquery</strong>: This is a straightforward <code>GROUP BY</code> query:</p></li></ul><pre class=\"prettyprint linenums\">SELECT pdt_statu, MIN(list_price) \nFROM product_information \nGROUP BY pdt_statu;\n</pre><ul><li><p><strong>No subquery needed</strong>.</p><p><br></p></li></ul><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. Typically, you can use a subquery anywhere that you use an expression.</p><p>Oracle evaluates the whole query above in two steps:</p><ol><li><p>First, execute the subquery.</p></li><li><p>Second, use the result of the subquery in the outer query.</p></li></ol><ul><li><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS such as MySQL and PostgreSQL use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p></li><li><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p></li><li><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p></li></ul>",
                "answers": [
                    "<p>Displaying all the products whose minimum list prices are more than average list price of products having the status orderable</p>",
                    "<p>Displaying the total number of products supplied by supplier 102071 and having product status OBSOLETE</p>",
                    "<p>Displaying the number of products whose list prices are more than the average list price</p>",
                    "<p>Displaying all supplier IDs whose average list price is more than 500</p>",
                    "<p>Displaying the minimum list price for each product status</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the data in the PRODUCT_INFORMATION table.Table: PRODUCT_INFORMATION PDT_ID      SUP_ID         PDT_STATU              LIST_PRICE        MIN_PRICE\n1797        102094         orderable              349                 288\n2254        102071         obsolete               453                 371\n2382        102050         under development      850                 731\n3459        102099         under development      699                 568\n3127        102087         orderable              498                 444\n3353        102071         obsolete               489                 413\n3354        102066         orderable              543                 478\nIdentify the tasks which would require subqueries. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478743,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the actions you can perform on an existing table containing data. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Adding NOT NULL Columns with DEFAULT values](https://chandlerdba.com/2014/10/30/adding-not-null-columns-with-default-values/)",
                    "[Changing the Row Height and Column Width](https://docs.oracle.com/cd/E57185_01/HFWCG/changing_the_row_height_and_column_width.htm#HFWCG-customizing_grids_390)"
                ],
                "feedbacks": [
                    "Adding a new NOT NULL column with a DEFAULT value is a valid action that can be performed on an existing table containing data. This operation ensures that the new column will have a default value if no value is provided during insertion.",
                    "Changing the default value of a column is a permissible action on an existing table containing data. This allows for the modification of the default value that is automatically inserted into the column if no value is specified during insertion.",
                    "Changing a DATE column containing data to a NUMBER data type is not a valid action that can be performed on an existing table containing data. Altering the data type of a column containing data can lead to data loss or conversion errors.",
                    "Adding a new column as the table's first column is a valid action that can be performed on an existing table containing data. This operation allows for the addition of a new column at the beginning of the table's column list.",
                    "Defining a default value that is automatically inserted into a column containing nulls is a valid action that can be performed on an existing table containing data. This ensures that the specified default value is inserted into the column if no value is provided during insertion.",
                    "Increasing the width of a numeric column is a valid action that can be performed on an existing table containing data. This operation allows for the expansion of the storage capacity of the numeric column to accommodate larger values."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ul><li><p>Add a new NOT NULL column with a DEFAULT value</p></li><li><p>Change the default value of a column</p></li><li><p>Increase the width of a numeric column</p></li></ul><p>Identify valid <strong>DDL (Data Definition Language)</strong> actions that you can perform on a <strong>table that already contains data</strong> in Oracle Database.</p><p><strong>1. Add a new NOT NULL column with a DEFAULT value</strong></p><ul><li><p><strong>Valid.</strong></p></li><li><p>Oracle allows you to add a new column with the <code>NOT NULL</code> constraint <strong>if</strong> a <strong>DEFAULT value</strong> is specified. This ensures all existing rows get a valid value.</p></li></ul><p><strong>2. Change the default value of a column</strong></p><ul><li><p><strong>Valid.</strong></p></li><li><p>You can change the default value of an existing column at any time. It only affects <strong>new rows</strong> inserted without a value in that column.</p></li></ul><p><strong>3. Increase the width of a numeric column</strong></p><ul><li><p><strong>Valid.</strong></p></li><li><p>You can safely increase the width (precision) of a numeric column even if it contains data, as long as the new definition accommodates existing values.</p></li></ul><p><strong>4. Change a DATE column containing data to a NUMBER data type</strong></p><ul><li><p><strong>Invalid.</strong></p></li><li><p>Changing the data type of a column with existing data (especially from <code>DATE</code> to <code>NUMBER</code>) is not allowed directly—you'd need to create a new column and convert the data manually.</p></li></ul><p><strong>5. Add a new column as the table's first column</strong></p><ul><li><p><strong>Invalid.</strong></p></li><li><p>Oracle does not support specifying the <strong>position</strong> of a new column when using <code>ALTER TABLE</code>. New columns are always added to the <strong>end</strong>.</p></li></ul><p><strong>6. Define a default value that is automatically inserted into a column containing nulls</strong></p><ul><li><p><strong>Invalid.</strong></p></li><li><p>Default values only apply when a row is <strong>inserted without specifying a value</strong> for the column. They are <strong>not retroactively applied</strong> to existing nulls.</p></li></ul>",
                "answers": [
                    "<p>Add a new NOT NULL column with a DEFAULT value</p>",
                    "<p>Change the default value of a column</p>",
                    "<p>Change a DATE column containing data to a NUMBER data type</p>",
                    "<p>Add a new column as the table's first column</p>",
                    "<p>Define a default value that is automatically inserted into a column containing nulls</p>",
                    "<p>Increase the width of a numeric column</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "f"
            ],
            "section": "Data Definition Language",
            "question_plain": "View and examine the following available responses.Identify the actions you can perform on an existing table containing data. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478745,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the following tables and exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-58-58-8536e2671c8fd7db5d6ba0b731c74faa.png\"></p><p><br></p><p><strong>Given: </strong>The following SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">INSERT INTO sales\nVALUES(\n  23,              \n  2300,            \n  SYSDATE,         \n  (SELECT channel_id FROM channels WHERE channel_desc = 'Direct Sales'),\n  12,              \n  1,               \n  500              \n);</pre><p><br></p><p><strong>Assumption:</strong> Any Foreign Keys will have compatible data types.</p><p>Identify the true statements. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement will execute successfully and a new row will be inserted into the SALES table because the INSERT INTO SALES statement is providing values for all the columns in the SALES table.",
                    "A product can have a different unit price at different times is a true statement because the SALES table likely stores historical sales data, which means the unit price for a product can vary over time.",
                    "The statement will fail because a subquery may not be contained in a VALUES clause is incorrect. The provided SQL statement does not contain a subquery in the VALUES clause, so this is not a valid reason for the statement to fail.",
                    "The statement will fail if a row already exists in the SALES table for product 23 is incorrect. The provided SQL statement is an INSERT INTO SALES statement, which means it will insert a new row into the SALES table, regardless of existing rows.",
                    "The SALES table has five foreign keys is a true statement because the SALES table likely has relationships with other tables through foreign keys, which enforce referential integrity between the tables."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ul><li><p>The statement will execute successfully and a new row will be inserted into the SALES table.</p></li><li><p>A product can have a different unit price at different times.</p></li></ul><p>The question is asking you to identify true statements that can be derived from the information provided. The best way to approach a question like this is to look at the possible answers and then eliminate the ones that do not fit, and don't do any more that is required.</p><p>Matching up the field in the SALES table to the linked tables, it can be concluded:</p><ul><li><p>&nbsp;product_id in the PRODUCTS table links to product_id in the SALES table</p></li><li><p>&nbsp;promo_id in the PROMOTIONS table links to promo_id in the SALES table</p></li><li><p>&nbsp;cust_id in the CUSTOMERS table links to cust_id in the SALES table</p></li><li><p>&nbsp;time_id in the TIMES table links to time_id in the SALES table</p></li><li><p>&nbsp;channel_id in the CHANNELS table links to channel_id in the SALES table</p><p><br></p></li></ul><p>Analyze the SQL statement and the claims step-by-step.</p><p><strong>Given SQL Statement:</strong></p><pre class=\"prettyprint linenums\">INSERT INTO sales\nVALUES(\n  23,              -- product_id\n  2300,            -- customer_id\n  SYSDATE,         -- time_id\n  (SELECT channel_id FROM channels WHERE channel_desc = 'Direct Sales'), -- channel_id\n  12,              -- promo_id\n  1,               -- quantity_sold\n  500              -- amount_sold\n);\n</pre><p><br></p><p><strong>Statement Evaluation:</strong></p><p><strong>1. The statement will execute successfully and a new row will be inserted into the SALES table.</strong></p><ul><li><p>The subquery returns exactly <strong>one row</strong>.</p></li><li><p>The provided foreign key values exist in their referenced tables.</p></li><li><p>No constraints (like unique constraints or primary keys) are violated.</p></li></ul><p><strong>Conclusion</strong>: <strong>TRUE</strong></p><p><strong>2. A product can have a different unit price at different times.</strong></p><ul><li><p>Based on the structure of the <code>SALES</code> table (which includes columns like product_id, time_id or sales_date, quantity_sold, amount_sold), unit price is derived by:</p><pre class=\"prettyprint linenums\">unit_price = amount_sold / quantity_sold\n</pre></li><li><p>Since <code>amount_sold</code> and <code>quantity_sold</code> are inserted along with <code>product_id</code> and a timestamp (SYSDATE), this suggests unit price can <strong>vary over time</strong> for the same product.</p></li></ul><p><strong>Conclusion</strong>: <strong>True</strong>.</p><p><strong>3. The SALES table has five foreign keys.</strong></p><ul><li><p>From the data:</p><ul><li><p>Foreign keys: <code>product_id</code>, <code>customer_id</code>, <code>channel_id</code>, <code>promo_id</code>, <code>time_id</code> (or date).</p></li></ul></li></ul><p><strong>Conclusion</strong>: <strong>True</strong>.</p><p><strong>4. The statement will fail because a subquery may not be contained in a VALUES clause.</strong></p><ul><li><p><strong>False.</strong> A <strong>scalar subquery</strong> (returning <strong>one value</strong>) is <strong>perfectly valid</strong> inside a <code>VALUES</code> clause.</p></li></ul><p><strong>Conclusion</strong>: <strong>False</strong>.</p><p><strong>5. The statement will fail if a row already exists in the SALES table for product 23.</strong></p><ul><li><p><strong>Unlikely.</strong> Unless <code>product_id</code> is part of a <strong>primary key</strong> or <strong>unique constraint</strong> by itself (which is rare in sales tables), <strong>multiple rows for the same product</strong> are expected.</p></li><li><p>More commonly, sales data is <strong>transactional</strong>, and <code>product_id</code> is just a <strong>foreign key</strong>, not a unique column.</p></li></ul><p><strong>Conclusion</strong>: <strong>False</strong>.</p>",
                "answers": [
                    "<p>The statement will execute successfully and a new row will be inserted into the SALES table.</p>",
                    "<p>A product can have a different unit price at different times.</p>",
                    "<p>The statement will fail because a subquery may not be contained in a VALUES clause.</p>",
                    "<p>The statement will fail if a row already exists in the SALES table for product 23.</p>",
                    "<p>The SALES table has five foreign keys.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e",
                "b"
            ],
            "section": "INSERT",
            "question_plain": "View and examine the structure of the following tables and exhibit.Given: The following SQL statement has been executed.Exhibit: 1INSERT INTO sales\nVALUES(\n  23,              \n  2300,            \n  SYSDATE,         \n  (SELECT channel_id FROM channels WHERE channel_desc = 'Direct Sales'),\n  12,              \n  1,               \n  500              \n);Assumption: Any Foreign Keys will have compatible data types.Identify the true statements. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478747,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the data dictionary. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Dictionary](https://docs.oracle.com/cd/B10501_01/server.920/a96524/c05dicti.htm)"
                ],
                "feedbacks": [
                    "The SYS user, being the owner of the Oracle database, owns all base tables and user-accessible views in the data dictionary. This is to ensure the integrity and security of the data dictionary.",
                    "By default, not all users have permissions to access all information in the data dictionary. Access to specific data dictionary views and tables may be restricted based on user privileges and roles assigned within the database.",
                    "<p>The data dictionary is continuously updated to reflect changes to database objects, permissions, and data. It serves as a centralized repository of metadata that provides information about the database structure and configuration. It is not constantly updated.</p>",
                    "While the data dictionary does capture certain user actions, such as DDL statements and changes to database objects, it does not record all user actions. It primarily focuses on maintaining metadata about the database itself rather than tracking every user interaction.",
                    "The data dictionary is designed to be a read-only set of tables. This means that users can query and retrieve information from the data dictionary to understand the database structure and configuration, but they cannot directly modify or update the data dictionary tables."
                ],
                "explanation": "<p>The true statements are:</p><ul><li><p><strong>The SYS user owns all base tables and user-accessible views in the data dictionary.</strong></p></li><li><p><strong>It is a read-only set of tables.</strong></p></li></ul><p>Examine each statement about the data dictionary:</p><ul><li><p><strong>The SYS user owns all base tables and user-accessible views in the data dictionary.</strong></p><ul><li><p>This statement is <strong>true</strong>. In Oracle databases (a common context for data dictionaries), the <code>SYS</code> user is the superuser who owns the fundamental base tables of the data dictionary. These base tables store the core metadata about the database. User-accessible views (like <code>ALL_TABLES</code>, <code>USER_TABLES</code>, <code>DBA_TABLES</code>, etc.) are built upon these base tables to provide structured and accessible information to users with appropriate privileges.</p></li></ul></li><li><p><strong>It is a read-only set of tables.</strong></p><ul><li><p>This statement is <strong>true</strong>. While the data dictionary is <em>updated</em> by the database system itself in response to DDL (Data Definition Language) operations, users typically cannot directly <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> data in the data dictionary tables. They can only <code>SELECT</code> information from the dictionary views. This prevents accidental corruption of the critical metadata that describes the database.</p></li></ul></li><li><p><strong>All users have permissions to access all information in the data dictionary by default.</strong></p><ul><li><p>This statement is <strong>false</strong>. Users typically have access to data dictionary views that show information relevant to their own schema or objects they have privileges on. For example, <code>USER_TABLES</code> shows tables owned by the current user, while <code>ALL_TABLES</code> shows tables accessible to the current user. To access <code>DBA_TABLES</code> (which shows all tables in the database), a user would need specific <code>SELECT_CATALOG_ROLE</code> or <code>DBA</code> privileges. Granting all users access to all information in the data dictionary by default would be a security risk, as it contains sensitive metadata.</p></li></ul></li><li><p><strong>The data dictionary is constantly updated to reflect changes to database objects, permissions, and data.</strong></p><ul><li><p>This statement is <strong>partially true, but misleading regarding \"data.\"</strong> The data dictionary is indeed constantly updated to reflect changes to database <em>objects</em> (e.g., creating a table, adding a column, dropping an index) and <em>permissions</em> (e.g., granting a privilege, revoking a role). However, it does <em>not</em> typically record changes to the actual <em>data</em> within the tables (i.e., <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> operations on user data). Those operations are part of the transaction log and data files, not the data dictionary itself. The data dictionary describes the <em>structure</em> and <em>metadata</em>, not the individual data values.</p></li></ul></li><li><p><strong>All user actions are recorded in the data dictionary.</strong></p><ul><li><p>This statement is <strong>false</strong>. As mentioned above, the data dictionary primarily records metadata about database objects, schemas, and privileges. It does <em>not</em> record all user actions, such as every <code>SELECT</code> query executed, every <code>INSERT</code> statement, or every procedural call. Such actions might be recorded in audit trails or transaction logs, but not directly in the data dictionary.</p></li></ul></li></ul><p>One of the most important parts of an Oracle database is its <strong>data dictionary</strong>, which is a <strong>read-only</strong> set of tables that provides information about the database. A data dictionary contains:</p><ul><li><p>The definitions of all schema objects in the database (tables, views, indexes, clusters, synonyms, sequences, procedures, functions, packages, triggers, and so on)</p></li><li><p>How much space has been allocated for, and is currently used by, the schema objects</p></li><li><p>Default values for columns</p></li><li><p>Integrity constraint information</p></li><li><p>The names of Oracle users</p></li><li><p>Privileges and roles each user has been granted</p></li><li><p>Auditing information, such as who has accessed or updated various schema objects</p></li><li><p>Other general database information</p></li></ul><p>The data dictionary is structured in tables and views, just like other database data. All the data dictionary tables and views for a given database are stored in that database's <code>SYSTEM</code> tablespace.</p><p><br></p><p><strong>Tricky question</strong></p><p>This is a tricky question, but you will find tricky questions in the official exam. This question prepares you for such tricky questions.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/message/2023-06-01_13-44-34-3a9dd7a5da289d396cefde69bac256c1.png\"></p><p>Oracle modifies the data dictionary every time when a data definition language (DDL) statement but is issued (continuously) not \"constantly\"</p><p>Constantly means \"always\" or \"never stopping\".</p><p>Continuously means with \"regular intervals\" without interruption. In this case, every time when a data definition language (DDL) statement but is issued.</p>",
                "answers": [
                    "<p>The SYS user owns all base tables and user-accessible views in the data dictionary.</p>",
                    "<p>All users have permissions to access all information in the data dictionary by default.</p>",
                    "<p>The data dictionary is constantly updated to reflect changes to database objects, permissions, and data.</p>",
                    "<p>All user actions are recorded in the data dictionary.</p>",
                    "<p>It is a read-only set of tables.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "Data Dictionary",
            "question_plain": "View and examine the following available responses.Identify the true statements about the data dictionary. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478749,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT \n  INTERVAL '350' MONTH,\n  INTERVAL '54-4' YEAR TO MONTH,\n  INTERVAL '12:34:56.1234567' HOUR TO SECOND \nFROM DUAL;\n</pre><p><br></p><p>Identify the correct output of the above query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p>The output provided in this choice does not match the correct output of the query. The intervals '350 MONTH', '54-4 YEAR TO MONTH', and '12:34:56.1234567 HOUR TO SECOND' are not represented accurately in the given output.</p>",
                    "<p>The output provided in this choice correctly represents the intervals '350 MONTH' as +29-02, '54-4 YEAR TO MONTH' as +54-04, and '12:34:56.1234567 HOUR TO SECOND' as +00 12:34:56.123457 based on the SQL query provided in the exhibit.</p>",
                    "<p>The output provided in this choice does not accurately represent the intervals '350 MONTH', '54-4 YEAR TO MONTH', and '12:34:56.1234567 HOUR TO SECOND' as specified in the SQL query. The intervals are incorrectly displayed in this choice.</p>",
                    "<p>The output provided in this choice does not match the correct output of the SQL query provided in the exhibit. The intervals '350 MONTH', '54-4 YEAR TO MONTH', and '12:34:56.1234567 HOUR TO SECOND' are not represented correctly in this choice.</p>",
                    "<p>The output provided in this does not accurately represent the intervals '350 MONTH', '54-4 YEAR TO MONTH', and '12:34:56.1234567 HOUR TO SECOND' as specified in the SQL query. The intervals are incorrectly displayed in this choice.</p>"
                ],
                "explanation": "<p>The correct output is: <code>+29-02, +54-04, +00 12:34:56.123457</code> </p><p><br></p><p>Break down the SQL query and determine what the <strong>correct output</strong> would be based on Oracle's handling of <code>INTERVAL</code> literals.</p><p><strong>Query:</strong></p><pre class=\"prettyprint linenums\">SELECT \n  INTERVAL '350' MONTH,\n  INTERVAL '54-4' YEAR TO MONTH,\n  INTERVAL '12:34:56.1234567' HOUR TO SECOND \nFROM DUAL;\n</pre><p>Analysis:</p><p><strong>1. </strong><code><strong>INTERVAL '350' MONTH</strong></code></p><ul><li><p>This represents a period of <strong>350 months</strong>.</p></li><li><p>Oracle formats <code>INTERVAL MONTH</code> as:</p><pre class=\"prettyprint linenums\">+YY-MM\n</pre></li><li><p>350 months = 29 years and 2 months</p></li></ul><p>So Oracle displays this as:</p><pre class=\"prettyprint linenums\">+29-02\n</pre><p><strong>2. </strong><code><strong>INTERVAL '54-4' YEAR TO MONTH</strong></code></p><ul><li><p>This represents <strong>54 years and 4 months</strong>.</p></li><li><p>Format: <code>+YY-MM</code></p></li></ul><p>Output:</p><pre class=\"prettyprint linenums\">+54-04\n</pre><p><strong>3. </strong><code><strong>INTERVAL '12:34:56.1234567' HOUR TO SECOND</strong></code></p><ul><li><p>This represents:</p><ul><li><p>12 hours</p></li><li><p>34 minutes</p></li><li><p>56.1234567 seconds</p></li></ul></li><li><p>Oracle <strong>only supports up to 6 digits</strong> of fractional seconds, so it <strong>rounds</strong> the 7th digit.</p></li></ul><p><code>56.1234567</code> → <strong>rounded</strong> to <code>56.123457</code></p><p>Format: <code>+HH MI:SS.FFFFFF</code></p><p>Output:</p><pre class=\"prettyprint linenums\">+12 34:56.123457\n</pre><p><strong>Final Output:</strong></p>\n<img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-07-15_23-47-43-41e06b7f576d0b1a14888dc5775fa9b8.png\">",
                "answers": [
                    "<p><code>+00-300, +00-650, +00 12:34:56.123457</code> </p>",
                    "<p><code>+29-02, +54-04, +00 12:34:56.123457</code> </p>",
                    "<p><code>+00-300, +54-02, +00 12:34:56.123457</code> </p>",
                    "<p><code>+25-00, +00-650, +00 12:34:56.123457</code> </p>",
                    "<p><code>+29-02, +54-04, +00 12:34:56.123456</code> </p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "INTERVAL",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT \n  INTERVAL '350' MONTH,\n  INTERVAL '54-4' YEAR TO MONTH,\n  INTERVAL '12:34:56.1234567' HOUR TO SECOND \nFROM DUAL;\nIdentify the correct output of the above query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478751,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Given: </strong>The SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE citizens(\n  citizen_id CHAR(10) PRIMARY KEY,\n  last_name VARCHAR2(50) NOT NULL,\n  first_name VARCHAR2(50),\n  address VARCHAR2(100),\n  city VARCHAR2(30) DEFAULT 'SEATTLE' NOT NULL,\n  CONSTRAINT cnames CHECK(first_name&lt;&gt;last_name)\n);\n</pre><p><br></p><p>Identify the outcome.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Adding Columns with Default Values and Not Null in Oracle 11g](https://blog.pythian.com/adding-columns-with-default-values-and-not-null-in-oracle-11g/)",
                    "[Managing Indexes](https://docs.oracle.com/cd/A87860_01/doc/server.817/a76956/indexes.htm)"
                ],
                "feedbacks": [
                    "Combining the NOT NULL and DEFAULT options for the same column is a valid operation in Oracle Database SQL. This combination ensures that the column must have a value (NOT NULL) and provides a default value if one is not explicitly specified.",
                    "The SQL statement successfully executes and creates a constraint on the CITY column that allows only 'SEATTLE' or null values. This restriction ensures that the CITY column will only contain the specified values for all rows.",
                    "The condition for the CNAMES constraint is not relevant to the SQL statement provided in the exhibit. The statement focuses on the CITY column and the NOT NULL and DEFAULT options, so the CNAMES constraint does not impact the outcome of the execution.",
                    "The SQL statement executes successfully and creates a combination of NOT NULL and DEFAULT constraints for the CITY column. This means that the CITY column must have a value (NOT NULL) and will default to 'SEATTLE' if no value is explicitly provided."
                ],
                "explanation": "<p>Correct Answer: <strong>It executes successfully and creates a NOT NULL and DEFAULT combination for the CITY column.</strong></p><p>Analyze the SQL <code>CREATE TABLE</code> statement and the constraints carefully.</p><p><strong>SQL Exhibit:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE citizens(\n  citizen_id CHAR(10) PRIMARY KEY,\n  last_name VARCHAR2(50) NOT NULL,\n  first_name VARCHAR2(50),\n  address VARCHAR2(100),\n  city VARCHAR2(30) DEFAULT 'SEATTLE' NOT NULL,\n  CONSTRAINT cnames CHECK(first_name&lt;&gt;last_name)\n);\n</pre><p><strong>Analysis of Each Part:</strong></p><ol><li><p><code><strong>citizen_id CHAR(10) PRIMARY KEY</strong></code><br>✅ Valid. A <code>PRIMARY KEY</code> constraint implies <code>NOT NULL</code> and <code>UNIQUE</code>.</p></li><li><p><code><strong>last_name VARCHAR2(50) NOT NULL</strong></code><br>✅ Valid.</p></li><li><p><code><strong>first_name VARCHAR2(50)</strong></code><br>✅ Valid. No constraint here.</p></li><li><p><code><strong>address VARCHAR2(100)</strong></code><br>✅ Valid.</p></li><li><p><code><strong>city VARCHAR2(30) DEFAULT 'SEATTLE' NOT NULL</strong></code><br>✅ This is <strong>valid</strong> in Oracle. A column can have both a <code>DEFAULT</code> and <code>NOT NULL</code> constraint. This means:</p><ul><li><p>If no value is provided for <code>city</code>, Oracle assigns <code>'SEATTLE'</code> by default.</p></li><li><p>A user <strong>must not</strong> insert <code>NULL</code> explicitly for <code>city</code>.</p></li></ul></li><li><p><code><strong>CONSTRAINT cnames CHECK(first_name&lt;&gt;last_name)</strong></code><br>✅ Valid syntax. Oracle allows comparisons in <code>CHECK</code> constraints.</p><ul><li><p>However, if either <code>first_name</code> or <code>last_name</code> is <code>NULL</code>, the condition evaluates to <code>UNKNOWN</code>, and the row <strong>passes</strong> the check (as per SQL's 3-valued logic).</p></li><li><p>This doesn’t invalidate the constraint.</p></li></ul></li></ol><p>In the pre-11g releases, adding a new not null column with a default value would have caused a massive update on the entire table, locking it for the operation and generating tons of undo and redo. Oracle has improved this behaviour by storing the default value in the metadata and making the column addition instantaneous.</p><p><strong>Oracle</strong> enforces a UNIQUE <strong>key</strong> or <strong>PRIMARY</strong> <strong>KEY</strong> integrity constraint by creating a unique <strong>index</strong> <strong>on</strong> the unique <strong>key</strong> or <strong>primary</strong> <strong>key</strong>. This <strong>index</strong> <strong>is</strong> automatically <strong>created</strong> by <strong>Oracle</strong> when the constraint is enabled; no action is required by the issuer of the CREATE TABLE or ALTER TABLE statement to create the <strong>index</strong>.</p>",
                "answers": [
                    "<p>It fails because the NOT NULL and DEFAULT options cannot be combined for the same column.</p>",
                    "<p>It succeeds and CITY can contain only 'SEATTLE' or null for all rows.</p>",
                    "<p>It fails because the condition for the CNAMES constraint is not valid.</p>",
                    "<p>It executes successfully and creates a NOT NULL and DEFAULT combination for the CITY column.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following SQL exhibit.Given: The SQL statement has been executed.Exhibit: 1CREATE TABLE citizens(\n  citizen_id CHAR(10) PRIMARY KEY,\n  last_name VARCHAR2(50) NOT NULL,\n  first_name VARCHAR2(50),\n  address VARCHAR2(100),\n  city VARCHAR2(30) DEFAULT 'SEATTLE' NOT NULL,\n  CONSTRAINT cnames CHECK(first_name&lt;&gt;last_name)\n);\nIdentify the outcome.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478753,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements are true about Structured Query Language (SQL). (Select four.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Relational Database Management System (RDBMS)](https://docs.oracle.com/database/121/CNCPT/intro.htm#CNCPT88783)"
                ],
                "feedbacks": [
                    "SQL is specifically designed to work with relational databases, making it the best choice for querying and manipulating data in this type of database management system.",
                    "SQL is not used to define encapsulation and polymorphism for a relational table. These concepts are more related to object-oriented programming languages rather than SQL.",
                    "SQL is primarily used for relational databases, but it is not the only language that can be used for both relational and object-oriented databases. There are other languages and technologies that can be used for object-oriented databases.",
                    "SQL does guarantee ACID properties, which are essential for ensuring data integrity and consistency in database transactions.",
                    "SQL provides independence for logical data structures being manipulated from the underlying physical data storage. This separation allows for easier management and optimization of data storage.",
                    "SQL does support hierarchical queries, allowing users to select rows in a hierarchical order using the hierarchical query clause. This feature is particularly useful when dealing with data that has a parent-child relationship."
                ],
                "explanation": "<p>The true statements about Structured Query Language (SQL) are:</p><ol><li><p><strong>It best supports relational databases.</strong></p></li><li><p><strong>It guarantees atomicity, consistency, isolation, and durability (ACID) features.</strong> (Understanding that the RDBMS enforces these for SQL transactions.)</p></li><li><p><strong>If a table contains hierarchical data, you can select rows in a hierarchical order using the hierarchical query clause.</strong></p></li><li><p><strong>It provides independence for logical data structures being manipulated from the underlying physical data storage.</strong> (Understanding that this independence is a feature of the RDBMS that SQL interacts with, rather than being solely provided by the SQL language in isolation).</p></li></ol><p><br></p><p>Examination of the statements about Structured Query Language (SQL):</p><ul><li><p><strong>It best supports relational databases.</strong></p><ul><li><p><strong>True.</strong> SQL was specifically designed for and is the primary language used to manage and query relational databases.</p></li></ul></li><li><p><strong>It guarantees atomicity, consistency, isolation, and durability (ACID) features.</strong></p><ul><li><p><strong>True (with important clarification).</strong> SQL provides the commands (like <code>BEGIN TRANSACTION</code>, <code>COMMIT</code>, <code>ROLLBACK</code>) that define transactions. It is the underlying <strong>Relational Database Management System (RDBMS)</strong> that <em>implements and enforces</em> the ACID properties for these transactions. So, SQL enables you to define operations that <em>will</em> adhere to ACID, assuming the RDBMS is correctly designed and functioning.</p></li></ul></li><li><p><strong>If a table contains hierarchical data, you can select rows in a hierarchical order using the hierarchical query clause.</strong></p><ul><li><p><strong>True.</strong> Many SQL dialects, particularly through features like recursive Common Table Expressions (CTEs) (standard SQL) or specific vendor extensions like Oracle's <code>CONNECT BY</code> clause, allow for querying and ordering hierarchical data within a table.</p></li></ul></li><li><p><strong>It provides independence for logical data structures being manipulated from the underlying physical data storage.</strong></p><ul><li><p><strong>True.</strong> SQL operates on the logical data model (tables, rows, columns, relationships). Users write queries against this logical view, abstracting away the specifics of how the data is physically stored on disk (e.g., file organization, indexing, disk blocks). This \"physical data independence\" is a core feature of <strong>Relational Database Management Systems (RDBMS)</strong>, which SQL interacts with. While SQL commands can be used by DBAs to influence physical storage (e.g., <code>CREATE INDEX</code>), the language itself is designed to allow application developers to work primarily at the logical level, making their applications less susceptible to changes in the physical storage schema.</p></li></ul></li><li><p><strong>It is used to define encapsulation and polymorphism for a relational table.</strong></p><ul><li><p><strong>False.</strong> Encapsulation and polymorphism are fundamental concepts of object-oriented programming (OOP). Traditional SQL and relational databases do not inherently support these concepts directly for relational tables. While object-relational databases (ORDBMS) attempt to bridge the gap, SQL itself, in its core form, is not designed for this purpose.</p></li></ul></li><li><p><strong>It is the only language that can be used for both relational and object-oriented databases.</strong></p><ul><li><p><strong>False.</strong> While SQL is dominant for relational databases, there are other languages and paradigms for interacting with object-oriented databases (though OODBs are less common than RDBMS or NoSQL databases today). Furthermore, NoSQL databases use a variety of different query languages.</p></li></ul></li></ul><p><strong>Relational Database Management System (RDBMS)</strong></p><p>The relational model is the basis for a relational database management system (RDBMS). An RDBMS moves data into a database, stores the data, and retrieves it so that applications can manipulate it.</p><p>An RDBMS distinguishes between the following types of operations:</p><p><strong>Logical operations</strong></p><p>In this case, an application specifies what content is required. For example, an application requests an employee name or adds an employee record to a table.</p><p><strong>Physical operations</strong></p><p>In this case, the RDBMS determines how things should be done and carries out the operation. For example, after an application queries a table, the database may use an index to find the requested rows, read the data into memory, and perform many other steps before returning a result to the user. The RDBMS stores and retrieves data so that physical operations are transparent to database applications.</p><p>Oracle Database is an RDBMS. An RDBMS that implements object-oriented features such as user-defined types, inheritance, and polymorphism is called an <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-B5A50116-D8BD-431E-93E6-4C6516297756\">object-relational database management system (ORDBMS)</a>. Oracle Database has extended the relational model to an object-relational model, making it possible to store complex business models in a relational database.</p>",
                "answers": [
                    "<p>It best supports relational databases.</p>",
                    "<p>It is used to define encapsulation and polymorphism for a relational table.</p>",
                    "<p>It is the only language that can be used for both relational and object-oriented databases.</p>",
                    "<p>It guarantees atomicity, consistency, isolation, and durability (ACID) features.</p>",
                    "<p>It provides independence for logical data structures being manipulated from the underlying physical data storage.</p>",
                    "<p>If a table contains hierarchical data, you can select rows in a hierarchical order using the hierarchical query clause.</p>"
                ]
            },
            "correct_response": [
                "d",
                "f",
                "a",
                "e"
            ],
            "section": "Relational Databases",
            "question_plain": "View and examine the following available responses.Identify the true statements are true about Structured Query Language (SQL). (Select four.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478755,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding views. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle WITH CHECK OPTION](https://www.oracletutorial.com/oracle-view/oracle-with-check-option/)",
                    "[Oracle CREATE VIEW Statement](https://www.oracletutorial.com/oracle-view/oracle-create-view/)",
                    "[About Views](https://docs.oracle.com/cd/B28359_01/server.111/b28310/views001.htm#ADMIN11775)"
                ],
                "feedbacks": [
                    "The WITH CHECK OPTION constraint allows you to restrict the data that can be updated or inserted into a view based on a specified condition. This helps maintain data integrity and ensures that only valid data can be modified through the view.",
                    "The OR REPLACE option allows you to alter the definition of an existing view without having to drop and recreate it. This can be useful when you need to update the view's structure or query without losing any existing permissions or dependencies.",
                    "If a view definition includes the DISTINCT keyword, it may not be possible to delete rows through that view. The DISTINCT keyword ensures that only unique rows are returned, which can make it challenging to identify specific rows for deletion.",
                    "Rows added through a view are not automatically deleted from the underlying table when the view is dropped. Views are virtual representations of data and do not store the actual data themselves. Therefore, dropping a view does not affect the data in the underlying table.",
                    "In a simple view where column aliases are used, updates can still be performed as long as the underlying columns are updatable. Column aliases do not prevent updates to the underlying data, as they are just alternate names for the columns in the result set.",
                    "Subqueries used in complex view definitions can contain group functions and joins. There are no restrictions on the use of group functions or joins within subqueries in view definitions. These can be used to create more advanced and customized views based on the requirements of the query."
                ],
                "explanation": "<p>True Statements</p><ul><li><p><strong>The WITH CHECK OPTION constraint can be used to restrict what can be updated or inserted to the view.</strong></p><ul><li><p>The <code>WITH CHECK OPTION</code> clause is used for an <a href=\"https://www.oracletutorial.com/oracle-view/oracle-updatable-view/\">updatable view</a> to prohibits the changes to the view that would produce rows which are not included in the defining query.</p></li><li><p>This clause ensures that any <code>INSERT</code> or <code>UPDATE</code> performed through the view must result in rows that satisfy the view’s <code>WHERE</code> condition. It helps maintain <strong>view consistency</strong>.</p></li><li><p>To create a new view in a database, you use the following Oracle <code>CREATE VIEW</code> statement:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE [OR REPLACE] VIEW view_name [(column_aliases)] AS\ndefining-query\n[WITH READ ONLY]\n[WITH CHECK OPTION]</pre></li></ul></li><li><p><strong>The OR REPLACE option is used to change the definition of an existing view without dropping and re-creating it.</strong></p><ul><li><p>This allows you to redefine a view while preserving its name and any granted privileges. It’s supported in systems like Oracle and PostgreSQL.</p></li><li><p>The <code>OR REPLACE</code> option replaces the definition of existing view. It is handy if you have granted various privileges on the view. Because when you use the <a href=\"https://www.oracletutorial.com/oracle-view/oracle-drop-view/\"><code>DROP VIEW</code></a> and <code>CREATE VIEW</code> to change the view’s definition, Oracle removes the view privileges, which may not be what you want. To avoid this, you can use the <code>CREATE OR REPLACE</code> clause that preserves the view privileges.</p></li></ul></li><li><p><strong>Rows cannot be deleted through a view if the view definition contains the DISTINCT keyword.</strong></p><ul><li><p>Views with <code>DISTINCT</code>, <code>GROUP BY</code>, or aggregate functions are typically <strong>non-updatable</strong>, meaning you can't <code>DELETE</code>, <code>INSERT</code>, or <code>UPDATE</code> through them.</p></li><li><p>A view is a logical representation of another table or combination of tables. A view derives its data from the tables on which it is based. These tables are called base tables. Base tables might in turn be actual tables or might be views themselves. All operations performed on a view actually affect the base table of the view. You can use views in almost the same way as tables. You can query, update, insert into, and delete from views, just as you can standard tables.</p></li><li><p>Views can provide a different representation (such as subsets or supersets) of the data that resides within other tables and views. Views are very powerful because they allow you to tailor the presentation of data to different types of users.</p></li></ul></li></ul><p>False Statements</p><ul><li><p><strong>Rows added through a view are deleted from the table automatically when the view is dropped.</strong><br>Dropping a view <strong>does not affect</strong> the underlying base table or its data. The view is just a stored query definition.</p></li><li><p><strong>A simple view in which column aliases have been used cannot be updated.</strong><br>Column aliases <strong>do not prevent updates</strong>. As long as the view is based on a single table and avoids complex expressions, it remains updatable.</p></li><li><p><strong>A subquery used in a complex view definition cannot contain group functions or joins.</strong><br>Subqueries <strong>can</strong> contain <code>GROUP BY</code>, joins, and aggregate functions. However, if the overall view becomes too complex (e.g., includes joins, aggregates, or <code>DISTINCT</code>), it may become <strong>non-updatable</strong>, but the subquery itself is valid.</p></li></ul>",
                "answers": [
                    "<p>The WITH CHECK OPTION constraint can be used to restrict what can be updated or inserted to the view.</p>",
                    "<p>The OR REPLACE option is used to change the definition of an existing view without dropping and re-creating it.</p>",
                    "<p>Rows cannot be deleted through a view if the view definition contains the DISTINCT keyword.</p>",
                    "<p>Rows added through a view are deleted from the table automatically when the view is dropped.</p>",
                    "<p>A simple view in which column aliases have been used cannot be updated.</p>",
                    "<p>A subquery used in a complex view definition cannot contain group functions or joins.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "Views",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding views. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478757,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the usage of the WITH clause in complex correlated subqueries. </p>",
                "relatedLectureIds": [],
                "links": [
                    "[WITH Clause : Subquery Factoring in Oracle](https://oracle-base.com/articles/misc/with-clause)"
                ],
                "feedbacks": [
                    "The WITH clause can be used not only with the SELECT clause but also with other DML statements like INSERT, UPDATE, DELETE, and MERGE. It allows for defining subqueries that can be referenced multiple times within the main query.",
                    "The WITH clause can indeed hold more than one query, allowing for the creation of multiple named subqueries that can be referenced within the main query. This helps in simplifying complex queries by breaking them down into smaller, more manageable parts.",
                    "<p>If the query block name (defined in a <code>WITH</code> clause) and a table name in the database are the same, <strong>the table name takes precedence</strong> in SQL.</p><p>To explicitly reference the query block, you would need to qualify it properly or ensure unique naming to avoid ambiguity.</p><p>For example:</p><pre class=\"prettyprint linenums\">WITH employees AS (    SELECT employee_id, salary    FROM employees_table    WHERE salary &gt; 50000)SELECT * FROM employees; -- This will refer to the table \"employees\", not the query block.</pre>",
                    "The query name defined in the WITH clause is visible not only to the main query block but also to other query blocks within the WITH clause. This visibility allows for reusing the defined subqueries multiple times within the same query, enhancing code readability and maintainability."
                ],
                "explanation": "<p><strong>All statements are TRUE:</strong></p><ol><li><p>It can be used only with the SELECT clause.</p></li><li><p>The WITH clause can hold more than one query.</p></li><li><p>If the query block name and the table name are the same, then the table name takes precedence.</p></li><li><p>The query name in the WITH clause is visible to other query blocks in the WITH clause as well as to the main query block.</p></li></ol><p>Analyze each statement about the <code><strong>WITH</strong></code><strong> clause</strong> in SQL, especially regarding <strong>complex correlated subqueries</strong>.</p><p><strong>1. \"It can be used only with the SELECT clause.\"</strong></p><p><strong>True.</strong><br>The <code>WITH</code> clause (Common Table Expression or CTE) is used <strong>primarily with </strong><code><strong>SELECT</strong></code><strong> statements</strong>.</p><ul><li><p>In <strong>standard SQL</strong>, and most implementations (like Oracle, PostgreSQL, SQL Server), <code>WITH</code> is used to define subquery blocks to be <strong>referenced in a </strong><code><strong>SELECT</strong></code><strong> statement</strong>.</p></li><li><p>While some systems (like PostgreSQL or SQL Server) allow <code>WITH</code> to be used with <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, in <strong>Oracle SQL</strong>, it is <strong>typically used only with </strong><code><strong>SELECT</strong></code>.</p></li></ul><p><strong>This statement is considered <em>true</em>, especially in Oracle-focused contexts.</strong></p><p><strong>2. \"The WITH clause can hold more than one query.\"</strong></p><p><strong>True.</strong><br>You can define <strong>multiple query blocks (CTEs)</strong> in a single <code>WITH</code> clause, separated by commas:</p><pre class=\"prettyprint linenums\">WITH\n  dept_cte AS (SELECT * FROM departments),\n  emp_cte AS (SELECT * FROM employees)\nSELECT ...\nFROM emp_cte\nJOIN dept_cte ON ...;\n</pre><p>Multiple named subqueries are valid and often used for modular, readable query design.</p><p><strong>3. \"If the query block name and the table name are the same, then the table name takes precedence.\"</strong></p><p><strong>True.</strong><br>In Oracle SQL, if a <strong>CTE (query block)</strong> and a <strong>table</strong> have the <strong>same name</strong>, the <strong>table name takes precedence</strong> <strong>within the main query</strong>, unless the context forces it to refer to the CTE.</p><p>Oracle's precedence rules say that the optimizer will resolve references in the <strong>FROM clause</strong> to actual base tables first, unless qualified differently.</p><p>This is a subtle but <strong>correct</strong> observation.</p><p><strong>4. \"The query name in the WITH clause is visible to other query blocks in the WITH clause as well as to the main query block.\"</strong></p><p><strong>True.</strong><br>This means:</p><ul><li><p><strong>CTEs (query blocks)</strong> defined earlier in the <code>WITH</code> clause can be <strong>referenced by later CTEs</strong>.</p></li><li><p>All CTEs are also <strong>visible to the main query block</strong>.</p></li></ul><p>Example:</p><pre class=\"prettyprint linenums\">WITH cte1 AS (\n  SELECT ... FROM table1\n),\ncte2 AS (\n  SELECT ... FROM cte1\n)\nSELECT * FROM cte2;\n</pre><p>This demonstrates <strong>chained visibility</strong> and confirms that this statement is <strong>true</strong>.</p><p><br></p><p>The <code>WITH</code> clause, or subquery factoring clause, is part of the SQL-99 standard and was added into the Oracle SQL syntax in Oracle 9.2. The WITH clause may be processed as an inline view or resolved as a temporary table. The advantage of the latter is that repeated references to the subquery may be more efficient as the data is easily retrieved from the temporary table, rather than being requeried by each reference. You should assess the performance implications of the <code>WITH</code> clause on a case-by-case basis.</p><p>Oracle SQL can run faster when complex subqueries are replaced with global temporary tables. Starting in Oracle9i release 2, there was an incorporation of a subquery factoring utility implemented the SQL-99 WITH clause. The WITH clause is a tool for materializing subqueries to save Oracle from having to recompute them multiple times.</p><p>Use of the SQL WITH clause is very similar to the use of Global Temporary Tables (GTT), a technique that is often employed to improve query speed for complex subqueries. The following are some important notes about the Oracle WITH clause:</p><ul><li><p>The SQL WITH clause only works on Oracle 9i release 2 and beyond.</p></li><li><p>Formally, the WITH clause was called subquery factoring.</p></li><li><p>The SQL WITH clause is used when a subquery is executed multiple times.</p></li><li><p>The ANSI WITH clause is also useful for recursive queries, but this feature has not yet been implemented in Oracle SQL.</p></li></ul>",
                "answers": [
                    "<p>It can be used only with the SELECT clause.</p>",
                    "<p>The WITH clause can hold more than one query.</p>",
                    "<p>If the query block name and the table name are the same, then the table name takes precedence.</p>",
                    "<p>The query name in the WITH clause is visible to other query blocks in the WITH clause as well as to the main query block</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "d",
                "c"
            ],
            "section": "WITH",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the usage of the WITH clause in complex correlated subqueries.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478759,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS and CUST_HISTORY tables.</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_NAME                                 VARCHAR2(20)\nCUST_ADDRESS                              VARCHAR2(30)\nCUST_CITY                                 VARCHAR2(20)\n</pre><p><br></p><p><strong>Table: CUST_HISTORY </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_NAME                                 VARCHAR2(20)\nCUST_CITY                                 VARCHAR2(20)\nCHANGE_DATE                               DATE\n</pre><p><br></p><p><strong>Given: </strong>The CUSTOMERS table contains the current location of all currently active customers.</p><p>The CUST_HISTORY table stores historical details relating to any changes in the location of all current as well as previous customers who are no longer active with the company.</p><p><strong>Required:</strong> You need to find those customers who have never changed their address.</p><p>Identify the SET operator would you use to get the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle MINUS Operator](https://www.oracletutorial.com/oracle-basics/oracle-minus/)"
                ],
                "feedbacks": [
                    "The INTERSECT operator is used to return the intersection of two or more result sets. It would not be suitable for finding customers who have never changed their address as it would return common rows between the two tables.",
                    "The UNION ALL operator is used to combine the result sets of two or more SELECT statements, including duplicates. It would not be the correct choice for finding customers who have never changed their address as it would combine all rows from both tables.",
                    "The MINUS operator is used to return the rows that are present in the first result set but not in the second result set. In this case, using MINUS would help identify customers who have never changed their address by finding the rows in the CUSTOMERS table that are not present in the CUST_HISTORY table.",
                    "The UNION operator is used to combine the result sets of two or more SELECT statements, removing duplicates. It would not be the appropriate choice for finding customers who have never changed their address as it would combine all rows from both tables and remove duplicates.",
                    "The MERGE operator is used to perform insert, update, or delete operations on a target table based on the results of a join with a source table. It is not the correct choice for finding customers who have never changed their address as it is used for data manipulation, not for identifying specific rows."
                ],
                "explanation": "<p>Final Answer: <code><strong>MINUS</strong></code> is the correct set operator to find customers who have <strong>never changed their address</strong>.</p><p><br></p><p>To find <strong>customers who have never changed their address</strong>, we need to:</p><p>Identify customers in the <code>CUSTOMERS</code> table <strong>whose address and city do not appear in </strong><code><strong>CUST_HISTORY</strong></code> — i.e., those who <strong>never had any address change recorded</strong>.</p><p>Understanding the Tables:</p><ul><li><p><code>CUSTOMERS</code>: Current active customers with their current details.</p></li><li><p><code>CUST_HISTORY</code>: Log of <strong>address changes</strong>, including for <strong>both active and inactive customers</strong>.</p></li></ul><p>Required Logic:</p><p>We want customers from <code>CUSTOMERS</code> <strong>who never appear in </strong><code><strong>CUST_HISTORY</strong></code> — i.e., <strong>no matching record for them</strong> exists in the history table.</p><p>Best SET Operator: <code><strong>MINUS</strong></code></p><p>Why?</p><ul><li><p><code>MINUS</code> returns rows from the <strong>first query</strong> that <strong>do not exist</strong> in the <strong>second query</strong>.</p></li><li><p>This is ideal for finding <strong>non-overlapping</strong> records.</p></li></ul><p>Example SQL:</p><pre class=\"prettyprint linenums\">SELECT cust_id, cust_name, cust_city\nFROM customers\nMINUS\nSELECT cust_id, cust_name, cust_city\nFROM cust_history;\n</pre><p>This will return customers who are in <code>CUSTOMERS</code> <strong>but never had matching entries in </strong><code><strong>CUST_HISTORY</strong></code>, meaning they never changed their address or city.</p><p>Why not the others?</p><ul><li><p><code><strong>INTERSECT</strong></code> → Gives common records (we want the opposite).</p></li><li><p><code><strong>UNION</strong></code><strong> / </strong><code><strong>UNION ALL</strong></code> → Combines rows, doesn't exclude anything.</p></li><li><p><code><strong>MERGE</strong></code> → Used for updates/inserts, not selection or filtering.</p></li></ul><p>The Oracle <code>MINUS</code> operator compares two queries and returns <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select-distinct/\">distinct</a> rows from the first <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\">query</a> that are not output by the second query. In other words, the <code>MINUS</code> operator subtracts one result set from another.</p><p>The following illustrates the syntax of the Oracle <code>MINUS</code> operator:</p><pre class=\"prettyprint linenums\">SELECT\ncolumn_list_1\nFROM T1\nMINUS \nSELECT\ncolumn_list_2\nFROM T2;</pre><p><br></p><p>Similar to the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\"><code>UNION</code></a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-intersect/\"><code>INTERSECT</code></a> operators, the queries above must conform with the following rules:</p><p>The number of columns and their orders must match.</p><p>The <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-data-types/\">data type</a> of the corresponding columns must be in the same data type group such as numeric or character.</p>",
                "answers": [
                    "<p><code>INTERSECT</code> </p>",
                    "<p><code>UNION ALL</code> </p>",
                    "<p><code>MINUS</code> </p>",
                    "<p><code>UNION</code> </p>",
                    "<p><code>MERGE</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "MINUS",
            "question_plain": "View and examine the structure of the CUSTOMERS and CUST_HISTORY tables.Table: CUSTOMERS Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_NAME                                 VARCHAR2(20)\nCUST_ADDRESS                              VARCHAR2(30)\nCUST_CITY                                 VARCHAR2(20)\nTable: CUST_HISTORY Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_NAME                                 VARCHAR2(20)\nCUST_CITY                                 VARCHAR2(20)\nCHANGE_DATE                               DATE\nGiven: The CUSTOMERS table contains the current location of all currently active customers.The CUST_HISTORY table stores historical details relating to any changes in the location of all current as well as previous customers who are no longer active with the company.Required: You need to find those customers who have never changed their address.Identify the SET operator would you use to get the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478761,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the COUNT function. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[COUNT](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/COUNT.html)"
                ],
                "feedbacks": [
                    "The statement that a SELECT statement using the COUNT function with a DISTINCT keyword cannot have a WHERE clause is incorrect. The COUNT function can be used with a DISTINCT keyword and a WHERE clause in the same SELECT statement to filter the rows before counting.",
                    "The statement that COUNT(DISTINCT inv_amt) returns the number of rows excluding rows containing duplicates and NULLs in the INV_AMT column is correct. When using the DISTINCT keyword with COUNT, it only counts unique and non-NULL values in the specified column.",
                    "The statement that COUNT(inv_amt) returns the number of rows in a table including rows with NULL in the INV_AMT column is incorrect. The COUNT function, without the DISTINCT keyword, counts all rows, including those with NULL values in the specified column.",
                    "The statement that COUNT(*) returns the number of rows including duplicate rows and rows containing NULL value in any column is correct. COUNT(*) counts all rows, including duplicates and rows with NULL values in any column, regardless of the specified column.",
                    "The statement that the COUNT function can only be used for NUMBER data types is incorrect. The COUNT function can be used with any data type, not just NUMBER, to count the number of rows in a table or the number of non-NULL values in a specified column."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p><code>COUNT(DISTINCT inv_amt)</code> returns the number of rows excluding rows containing duplicates and NULLs in the <code>INV_AMT</code> column.</p></li><li><p><code>COUNT(*)</code> returns the number of rows including duplicate rows and rows containing NULL value in any column.</p></li></ol><p>Examine each statement about the <code>COUNT</code> function in SQL and identify which two are <strong>true</strong>.</p><p><strong>1. </strong><code><strong>COUNT(DISTINCT inv_amt)</strong></code><strong> returns the number of rows excluding rows containing duplicates and NULLs in the </strong><code><strong>INV_AMT</strong></code><strong> column.</strong></p><p><strong>True.</strong></p><ul><li><p><code>COUNT(DISTINCT column)</code> <strong>counts only unique non-NULL values</strong> in that column.</p></li><li><p><strong>Duplicates and NULLs are excluded</strong> from the count.</p></li></ul><p><strong>This is a correct statement.</strong></p><p><strong>2. </strong><code><strong>COUNT(*)</strong></code><strong> returns the number of rows including duplicate rows and rows containing NULL value in any column.</strong></p><p><strong>True.</strong></p><ul><li><p><code>COUNT(*)</code> counts <strong>all rows</strong> in the result set, <strong>regardless of NULLs or duplicates</strong>.</p></li><li><p>It does <strong>not ignore</strong> any row.</p></li></ul><p><strong>This is also correct.</strong></p><p><strong>3. A SELECT statement using the COUNT function with a DISTINCT keyword cannot have a WHERE clause.</strong></p><p><strong>False.</strong></p><ul><li><p>You <strong>can absolutely use</strong> a <code>WHERE</code> clause with <code>COUNT(DISTINCT ...)</code>.</p></li><li><p>The <code>WHERE</code> clause filters rows <strong>before</strong> aggregation.</p></li></ul><p>Example:</p><pre class=\"prettyprint linenums\">SELECT COUNT(DISTINCT inv_amt)\nFROM invoices\nWHERE status = 'PAID';\n</pre><p><strong>4. </strong><code><strong>COUNT(inv_amt)</strong></code><strong> returns the number of rows in a table including rows with NULL in the </strong><code><strong>INV_AMT</strong></code><strong> column.</strong></p><p><strong>False.</strong></p><ul><li><p><code>COUNT(column)</code> <strong>excludes NULLs</strong>.</p></li><li><p>So <code>COUNT(inv_amt)</code> returns the <strong>number of non-NULL values</strong> in the <code>INV_AMT</code> column.</p></li></ul><p><strong>5. It can only be used for NUMBER data types.</strong></p><p><strong>False.</strong></p><ul><li><p><code>COUNT()</code> can be used with <strong>any data type</strong>, including <code>VARCHAR</code>, <code>DATE</code>, etc.</p></li><li><p>It’s not limited to numeric types.</p><p><br></p></li></ul><p><strong>COUNT</strong></p><p><code>COUNT</code> returns the number of rows returned by the query. You can use it as an aggregate or analytic function.</p><p>If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed.</p><p>If you specify <code>expr</code>, then <code>COUNT</code> returns the number of rows where <code>expr</code> is not null. You can count either all rows, or only distinct values of <code>expr</code>.</p><p>If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. <code>COUNT</code> never returns null.</p>",
                "answers": [
                    "<p>A SELECT statement using the COUNT function with a DISTINCT keyword cannot have a WHERE clause.</p>",
                    "<p>COUNT(DISTINCT inv_amt) returns the number of rows excluding rows containing duplicates and NULLs in the INV_AMT column.</p>",
                    "<p>COUNT(inv_amt) returns the number of rows in a table including rows with NULL in the INV_AMT column.</p>",
                    "<p>COUNT(*) returns the number of rows including duplicate rows and rows containing NULL value in any column.</p>",
                    "<p>It can only be used for NUMBER data types.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "COUNT",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the COUNT function. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478801,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_name\nFROM products\nORDER&nbsp;BY product_id, price DESC;\n</pre><p><br></p><p><strong>Given:</strong> All table and column references exist within the database. </p><p>Indicate statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ORDER BY clause](https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "This statement is incorrect because it states that all rows will sort in descending order, which is not specified in the query. The default sorting order is ascending unless specified otherwise.",
                    "This statement is correct because the query orders the result set by PRODUCT_ID first and then by PRICE. The sorting order (ascending or descending) is not specified, so it will default to ascending.",
                    "This statement is incorrect because the ORDER BY list can include columns that are not in the select list. As long as those columns are part of the table being queried, the statement will execute successfully.",
                    "This statement is incorrect because the presence of a WHERE clause is not mandatory for a SELECT statement to execute. The absence of a WHERE clause does not necessarily mean the statement will fail."
                ],
                "explanation": "<p>Correct Answer: <strong>\"The rows will sort in order by PRODUCT_ID and then by PRICE.\"</strong></p><p>Analyze the SQL query:</p><p><strong>SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT product_name\nFROM products\nORDER BY product_id, price DESC;\n</pre><p><strong>Key Points:</strong></p><ol><li><p><code><strong>SELECT product_name</strong></code></p><ul><li><p>The query only <strong>displays </strong><code><strong>product_name</strong></code> in the result.</p></li></ul></li><li><p><code><strong>ORDER BY product_id, price DESC</strong></code></p><ul><li><p>The result <strong>will be sorted</strong> first by <code>product_id</code> in <strong>ascending order</strong> (default), then by <code>price</code> in <strong>descending order</strong>.</p></li><li><p>Even though <code>product_id</code> and <code>price</code> are <strong>not in the SELECT list</strong>, it's perfectly valid to <strong>order by columns not selected</strong> — SQL allows this.</p></li></ul></li><li><p><strong>No WHERE clause</strong></p><ul><li><p>A <code>WHERE</code> clause is <strong>optional</strong> in a <code>SELECT</code> statement.</p></li><li><p>Not having one does <strong>not cause an error</strong>; it simply means <strong>all rows</strong> will be considered.</p></li></ul></li></ol><p><strong>Correct Interpretation:</strong></p><p><strong>\"The rows will sort in order by </strong><code><strong>PRODUCT_ID</strong></code><strong> and then by </strong><code><strong>PRICE</strong></code><strong>.\"</strong></p><p>This is <strong>true</strong>.</p><ul><li><p>It <strong>does not sort all rows in descending order</strong>, only <code>price</code> is descending.</p></li><li><p>The <strong>absence of the </strong><code><strong>product_id</strong></code><strong> and </strong><code><strong>price</strong></code><strong> in the SELECT list is not an error</strong>.</p></li><li><p>The <strong>absence of a WHERE clause is valid</strong>.</p></li></ul><p>Incorrect Options:</p><ul><li><p><strong>\"All rows will sort in descending order\"</strong> → Only <code>price</code> is descending.</p></li><li><p><strong>\"The statement will fail... column not in select list\"</strong> → SQL allows <code>ORDER BY</code> on non-selected columns.</p></li><li><p><strong>\"The statement will fail because there is no WHERE clause\"</strong> → WHERE clause is optional.</p></li></ul><p>If the direction is not provided for a column in the <code>ORDER BY</code> clause, it is going to sort in ascending fashion by default. For PRODUCT_ID, the direction is not specified whereas for the PRICE column, the direction is specified as descending.</p><p>The <code>ORDER BY</code> clause is an optional element of the following: A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefselectexpression.html#rrefselectexpression\"><em>SelectExpression</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj11277.html#rrefsqlj11277\">VALUES expression</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefscalarsubquery.html#rrefscalarsubquery\"><em>ScalarSubquery</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreftablesubquery.html#rreftablesubquery\"><em>TableSubquery</em></a></p><p>It can also be used in an <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj40774.html#rrefsqlj40774\">INSERT statement</a> or a <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15446.html#rrefsqlj15446\">CREATE VIEW statement</a>.</p><p>An ORDER BY clause allows you to specify the order in which rows appear in the result set. In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqljoffsetfetch.html#rrefsqljoffsetfetch\">result offset and fetch first clauses</a> or in conjunction with the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreffuncrownumber.html#rreffuncrownumber\">ROW_NUMBER function</a>, since there is no guarantee that the order is retained in the outer result set. It is permissible to combine ORDER BY on the outer query with ORDER BY in subqueries.</p><p><br></p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">ORDER BY { column-Name | ColumnPosition | Expression }\n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    [ , column-Name | ColumnPosition | Expression \n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    ] * </pre><p><br></p><p>column-Name Refers to the names visible from the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. The column-Name that you specify in the ORDER BY clause does not need to be the SELECT list. ColumnPosition An integer that identifies the number of the column in the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. </p><p>ColumnPosition must be greater than 0 and not greater than the number of columns in the result table. In other words, if you want to order by a column, that column must be specified in the SELECT list. </p><p>Expression A sort key expression, such as numeric, string, and datetime expressions. <em>Expression</em> can also be a row value expression such as a scalar subquery or case expression. </p><ul><li><p>ASC Specifies that the results should be returned in ascending order. If the order is not specified, ASC is the default. </p></li><li><p>DESC Specifies that the results should be returned in descending order. </p></li><li><p>NULLS FIRST Specifies that NULL values should be returned before non-NULL values. </p></li><li><p>NULLS LAST Specifies that NULL values should be returned after non-NULL values.</p></li></ul>",
                "answers": [
                    "<p>The rows will sort in order by PRODUCT_ID and then by PRICE. All rows will sort in descending order.</p>",
                    "<p>The rows will sort in order by PRODUCT_ID and then by PRICE.</p>",
                    "<p>The statement will fail to execute because the ORDER BY list includes a column that is not in the select list.</p>",
                    "<p>The statement will fail to execute because there is no WHERE&nbsp;clause.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following SQL query.Exhibit: 1SELECT product_name\nFROM products\nORDER&nbsp;BY product_id, price DESC;\nGiven: All table and column references exist within the database. Indicate statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478803,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_id, product_name, unit_price, commission\nFROM products\nWHERE (unit_price + commission) * tax_rate &gt; 50\nORDER BY LIKE product_name;\n</pre><p><br></p><p><strong>Given: </strong>All table and column references exist in the database. </p><p>Indicate statement which is true regarding the result?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[LIKE](https://docs.oracle.com/cd/B12037_01/server.101/b10759/conditions016.htm)",
                    "[ORDER BY clause](https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "The statement will not execute successfully as intended because the ORDER BY clause contains the word \"LIKE,\" which is not a valid keyword for sorting results in SQL. This will cause an error during execution.",
                    "The statement will not execute as the ORDER BY clause is incorrect. The ORDER BY clause should specify the column name or expression to sort the results, not the keyword \"LIKE.\" This will result in a syntax error during execution.",
                    "The statement will fail to execute because the ORDER BY clause includes the word \"LIKE,\" which is not a valid keyword for sorting results in SQL. The ORDER BY clause should specify the column name or expression to sort the results, not a comparison operator like \"LIKE.\"",
                    "The statement will not fail because of a syntax error in the WHERE clause. The issue lies in the ORDER BY clause, where the word \"LIKE\" is used incorrectly. The WHERE clause may be valid, but the sorting of results will fail due to the incorrect usage of \"LIKE\" in the ORDER BY clause."
                ],
                "explanation": "<p>Correct Answer: <strong>The statement will fail to execute because the ORDER BY clause includes the word \"LIKE\".</strong></p><p>Analyze the SQL query from the exhibit:</p><p><strong>SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT product_id, product_name, unit_price, commission\nFROM products\nWHERE (unit_price + commission) * tax_rate &gt; 50\nORDER BY LIKE product_name;\n</pre><p>Step-by-step Analysis:</p><p><code><strong>SELECT</strong></code><strong> Clause:</strong></p><ul><li><p>Valid. Selecting existing columns.</p></li></ul><p><code><strong>FROM products</strong></code><strong>:</strong></p><ul><li><p>Valid. Assuming table and columns exist.</p></li></ul><p><code><strong>WHERE (unit_price + commission) * tax_rate &gt; 50</strong></code><strong>:</strong></p><ul><li><p>Valid. This is a valid arithmetic expression in the <code>WHERE</code> clause.</p></li></ul><p><code><strong>ORDER BY LIKE product_name</strong></code><strong>:</strong></p><ul><li><p>**This is <strong>not valid SQL syntax</strong>.</p></li><li><p><code>ORDER BY</code> should be followed by:</p><ul><li><p>Column name(s)</p></li><li><p>Position number(s) (e.g., <code>ORDER BY 1</code>)</p></li><li><p>Aliases</p></li><li><p>Or expressions</p></li></ul></li><li><p>The keyword <code><strong>LIKE</strong></code><strong> is not valid inside </strong><code><strong>ORDER BY</strong></code> — it is used in <code>WHERE</code> clauses for pattern matching, not for sorting.</p></li></ul><p>What happens?</p><p>The query <strong>will fail to execute</strong> due to a <strong>syntax error</strong> in the <code>ORDER BY</code> clause, specifically because of the misuse of the keyword <code><strong>LIKE</strong></code>.</p><p>The <code>LIKE</code> keyword is used to check for whether a column contains a sequence of characters. It does not belong in the <code>ORDER BY</code> Clause.</p><p><br></p><p>Here's the <strong>corrected version</strong> of the SQL query from the exhibit:</p><p><strong>Corrected SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT product_id, product_name, unit_price, commission\nFROM products\nWHERE (unit_price + commission) * tax_rate &gt; 50\nORDER BY product_name;\n</pre><p><strong>Explanation of the Fix:</strong></p><ul><li><p>Removed the invalid keyword <code><strong>LIKE</strong></code> from the <code>ORDER BY</code> clause.</p></li><li><p><code>ORDER BY product_name</code> correctly sorts the results alphabetically by the <code>product_name</code> column.</p></li></ul><p>If you want to sort in <strong>descending</strong> order or by another column (e.g., by price or computed total), let me know </p><p><br></p><p><br></p><p><strong>LIKE</strong></p><p>The <code>LIKE</code> conditions specify a test involving pattern matching. Whereas the equality operator (=) exactly matches one character value to another, the <code>LIKE</code> conditions match a portion of one character value to another by searching the first value for the pattern specified by the second. <code>LIKE</code> calculates strings using characters as defined by the input character set. <code>LIKEC</code> uses Unicode complete characters. <code>LIKE2</code> uses UCS2 code points. <code>LIKE4</code> uses UCS4 code points.</p><p><strong>Syntax</strong></p><p><code><em>char1</em></code> is a character expression, such as a character column, called the <strong>search value</strong>.</p><p><code><em>char2</em></code> is a character expression, usually a literal, called the <strong>pattern</strong>.</p><p><code><em>esc_char</em></code> is a character expression, usually a literal, called the <strong>escape character</strong>.</p><p>If <code><em>esc_char</em></code> is not specified, then there is no default escape character. If any of <code><em>char1</em></code>, <code><em>char2</em></code>, or <code><em>esc_char</em></code> is null, then the result is unknown. Otherwise, the escape character, if specified, must be a character string of length 1.</p><p>All of the character expressions (<code><em>char1</em></code>, <code><em>char2</em></code>, and <code><em>esc_char</em></code>) can be of any of the datatypes <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. If they differ, then Oracle converts all of them to the datatype of <code><em>char1</em></code>.</p><p>The pattern can contain special pattern-matching characters:</p><p>An underscore (_) in the pattern matches exactly one character (as opposed to one byte in a multibyte character set) in the value.</p><p>A percent sign (%) in the pattern can match zero or more characters (as opposed to bytes in a multibyte character set) in the value. The pattern '%' cannot match a null.</p><p><br></p><p><strong>ORDER BY</strong></p><p>The <code>ORDER BY</code> clause is an optional element of the following: A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefselectexpression.html#rrefselectexpression\"><em>SelectExpression</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj11277.html#rrefsqlj11277\">VALUES expression</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefscalarsubquery.html#rrefscalarsubquery\"><em>ScalarSubquery</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreftablesubquery.html#rreftablesubquery\"><em>TableSubquery</em></a></p><p>It can also be used in an <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj40774.html#rrefsqlj40774\">INSERT statement</a> or a <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15446.html#rrefsqlj15446\">CREATE VIEW statement</a>.</p><p>An ORDER BY clause allows you to specify the order in which rows appear in the result set. In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqljoffsetfetch.html#rrefsqljoffsetfetch\">result offset and fetch first clauses</a> or in conjunction with the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreffuncrownumber.html#rreffuncrownumber\">ROW_NUMBER function</a>, since there is no guarantee that the order is retained in the outer result set. It is permissible to combine ORDER BY on the outer query with ORDER BY in subqueries.</p><p><br></p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">ORDER BY { column-Name | ColumnPosition | Expression }\n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    [ , column-Name | ColumnPosition | Expression \n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    ] * </pre><p><br></p><p>column-Name Refers to the names visible from the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. The column-Name that you specify in the ORDER BY clause does not need to be the SELECT list. ColumnPosition An integer that identifies the number of the column in the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. </p><p>ColumnPosition must be greater than 0 and not greater than the number of columns in the result table. In other words, if you want to order by a column, that column must be specified in the SELECT list. </p><p>Expression A sort key expression, such as numeric, string, and datetime expressions. <em>Expression</em> can also be a row value expression such as a scalar subquery or case expression. </p><ul><li><p>ASC Specifies that the results should be returned in ascending order. If the order is not specified, ASC is the default. </p></li><li><p>DESC Specifies that the results should be returned in descending order. </p></li><li><p>NULLS FIRST Specifies that NULL values should be returned before non-NULL values. </p></li><li><p>NULLS LAST Specifies that NULL values should be returned after non-NULL values.</p></li></ul>",
                "answers": [
                    "<p>The statement will execute successfully as intended.</p>",
                    "<p>The statement will execute but not sort because the ORDER&nbsp;BY clause is wrong.</p>",
                    "<p>The statement will fail to execute because the ORDER&nbsp;BY clause includes the word \"LIKE\".</p>",
                    "<p>The statement will fail because the WHERE clause has a syntax error.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "LIKE",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT product_id, product_name, unit_price, commission\nFROM products\nWHERE (unit_price + commission) * tax_rate &gt; 50\nORDER BY LIKE product_name;\nGiven: All table and column references exist in the database. Indicate statement which is true regarding the result?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478805,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the ORDER BY clause. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ORDER BY clause](https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "The ORDER BY clause is optional in SQL queries. It is used to sort the result set based on specified columns, but it is not mandatory to include it in every query.",
                    "The ORDER BY clause can order data based on a column that is not necessarily specified in the SELECT list. This allows for sorting the result set based on columns that may not be displayed in the output.",
                    "When you specify a column in the ORDER BY clause, the default sorting mechanism for the data in that column is ascending order, not descending order. If you want to sort in descending order, you need to explicitly specify it in the query.",
                    "The ORDER BY clause is independent of the WHERE clause in SQL queries. You can use the ORDER BY clause to sort the result set regardless of whether there is a WHERE clause before it."
                ],
                "explanation": "<p>Correct Answers:</p><ul><li><p><strong>It is optional.</strong></p></li><li><p><strong>The ORDER BY clause can order data based on a column that is not specified in the SELECT list.</strong></p></li></ul><p>Evaluate each statement about the <code>ORDER BY</code> clause and identify the two <strong>true</strong> ones.</p><p><strong>1. \"It is optional.\"</strong></p><p><strong>True.</strong></p><ul><li><p>The <code>ORDER BY</code> clause is <strong>optional</strong> in a <code>SELECT</code> query.</p></li><li><p>If you omit it, the database returns rows in <strong>unspecified order</strong>, often based on how the data is stored internally.</p></li></ul><p><strong>This is a correct statement.</strong></p><p><strong>2. \"The ORDER BY clause can order data based on a column that is not specified in the SELECT list.\"</strong></p><p><strong>True.</strong></p><ul><li><p>SQL allows sorting based on columns <strong>not included in the SELECT list</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT product_name FROM products ORDER BY product_id;\n</pre><p>Even though <code>product_id</code> is not selected, it can still be used to <strong>sort</strong> the result set.</p></li></ul><p><strong>This is correct.</strong></p><p><strong>3. \"When you specify a column in the ORDER BY clause, the default sorting mechanism for the data in that column is descending order.\"</strong></p><p><strong>False.</strong></p><ul><li><p>The <strong>default</strong> sorting is <strong>ascending (</strong><code><strong>ASC</strong></code><strong>)</strong>, not descending.</p></li><li><p>You must explicitly specify <code>DESC</code> to get descending order.</p></li></ul><p><strong>4. \"You cannot use the ORDER BY clause if there is no WHERE clause before it.\"</strong></p><p><strong>False.</strong></p><ul><li><p>A <code>WHERE</code> clause is <strong>optional</strong>, and <code>ORDER BY</code> can be used <strong>without</strong> it.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT * FROM employees ORDER BY hire_date;\n</pre></li></ul><p><br></p><p><code>ORDER BY</code> is optional.</p><p>The <code>ORDER&nbsp;BY</code>&nbsp;clause can order data based on a column that is not specified in the <code>SELECT</code>&nbsp;list.</p><p>The <code>ORDER BY</code> clause is an optional element of the following: A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefselectexpression.html#rrefselectexpression\"><em>SelectExpression</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj11277.html#rrefsqlj11277\">VALUES expression</a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefscalarsubquery.html#rrefscalarsubquery\"><em>ScalarSubquery</em></a> A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreftablesubquery.html#rreftablesubquery\"><em>TableSubquery</em></a></p><p>It can also be used in an <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj40774.html#rrefsqlj40774\">INSERT statement</a> or a <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15446.html#rrefsqlj15446\">CREATE VIEW statement</a>.</p><p>An ORDER BY clause allows you to specify the order in which rows appear in the result set. In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqljoffsetfetch.html#rrefsqljoffsetfetch\">result offset and fetch first clauses</a> or in conjunction with the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreffuncrownumber.html#rreffuncrownumber\">ROW_NUMBER function</a>, since there is no guarantee that the order is retained in the outer result set. It is permissible to combine ORDER BY on the outer query with ORDER BY in subqueries.</p><p><br></p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">ORDER BY { column-Name | ColumnPosition | Expression }\n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    [ , column-Name | ColumnPosition | Expression \n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    ] * </pre><p><br></p><p>column-Name Refers to the names visible from the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. The column-Name that you specify in the ORDER BY clause does not need to be the SELECT list. ColumnPosition An integer that identifies the number of the column in the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. </p><p>ColumnPosition must be greater than 0 and not greater than the number of columns in the result table. In other words, if you want to order by a column, that column must be specified in the SELECT list. </p><p>Expression A sort key expression, such as numeric, string, and datetime expressions. <em>Expression</em> can also be a row value expression such as a scalar subquery or case expression. </p><ul><li><p>ASC Specifies that the results should be returned in ascending order. If the order is not specified, ASC is the default. </p></li><li><p>DESC Specifies that the results should be returned in descending order. </p></li><li><p>NULLS FIRST Specifies that NULL values should be returned before non-NULL values. </p></li><li><p>NULLS LAST Specifies that NULL values should be returned after non-NULL values.</p></li></ul>",
                "answers": [
                    "<p>It is optional.</p>",
                    "<p>The ORDER&nbsp;BY&nbsp;clause can order data based on a column that is not specified in the SELECT&nbsp;list.</p>",
                    "<p>When you specify a column in the ORDER&nbsp;BY clause, the default sorting mechanism for the data in that column is descending order.</p>",
                    "<p>You cannot use the ORDER&nbsp;BY clause if there is no WHERE clause before it.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the ORDER BY clause. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478807,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following image. </p><p><strong>Exhibit: 1 </strong></p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-54-00-4b5fbe64d1e96530caa65d0fc1688648.png\"><p><br></p><p>Indicate the JOIN type best represented by the available choices.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "There is no such JOIN type as a \"COMPLETE JOIN\" in Oracle Database SQL. The term \"COMPLETE JOIN\" is not a standard SQL JOIN type and is not applicable in this context.",
                    "An INNER JOIN is the most common type of JOIN in SQL. It returns rows when there is at least one match in both tables being joined. In the given image, the JOIN type represented is similar to an INNER JOIN as it only includes matching rows from both tables.",
                    "A FULL OUTER JOIN returns all rows when there is a match in either the left or right table. In the given image, the JOIN type does not include rows that do not have a match in both tables, making it different from a FULL OUTER JOIN.",
                    "There is no such JOIN type as a \"LEFT RIGHT JOIN\" in Oracle Database SQL. The correct syntax for combining LEFT and RIGHT JOINs is to use a UNION ALL statement to combine the results of both types of JOINs.",
                    "There is no standard JOIN type called a \"COMMON JOIN\" in Oracle Database SQL. The term \"COMMON JOIN\" is not recognized as a valid JOIN type in SQL and is not applicable in this context."
                ],
                "explanation": "<p>An <code>INNER JOIN</code> includes the common values between the 2 tables.</p><p><strong>INNER JOIN (simple join)</strong></p><p>Oracle <code>INNER JOIN</code> is the most common type of join.They return all rows from multiple tables where the join condition is met.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INNER JOIN</code> in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1 \nINNER JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In this visual diagram, the Oracle <code>INNER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-30_12-33-42-27f24b79227146600a1663c2a0debb51.png\"></p><p>The Oracle <code>INNER JOIN</code> would return the records where <em>table1</em> and <em>table2</em> intersect.</p>",
                "answers": [
                    "<p><code>COMPLETE JOIN</code> </p>",
                    "<p><code>INNER JOIN</code> </p>",
                    "<p><code>FULL OUTER JOIN</code> </p>",
                    "<p><code>LEFT RIGHT JOIN</code> </p>",
                    "<p><code>COMMON JOIN</code> </p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following image. Exhibit: 1 Indicate the JOIN type best represented by the available choices.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478809,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required:</strong> Create a SELECT query component which would allow for filtering for those employees whose first_name contains the letters 'ean' and also make salaries greater than or equal to 4000 and less than or equal to 8000.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle WILDCARDS](https://www.educba.com/oracle-wildcards/)"
                ],
                "feedbacks": [
                    "The LIKE operator in SQL requires the use of single quotes around the search string. The percentage sign (%) is used as a wildcard character to match any sequence of characters before or after the specified string. However, the syntax for the salary comparison is incorrect as it should be 'salary &gt; 4000 AND salary &lt; 8000' instead of 'salary &gt; 4000 AND &lt; 8000'.",
                    "The CONTAINS keyword is not a valid operator in SQL for string matching. The correct operator to use for pattern matching in this case is LIKE. Additionally, the syntax for the salary comparison is incorrect as it should be 'salary &gt;= 4000 AND salary &lt;= 8000' instead of 'salary &gt;= 4000 AND &lt;= 8000'.",
                    "The LIKE operator in SQL is case-sensitive, so using %EAN% will not match 'ean' in the first_name column. The correct syntax for case-insensitive matching should be 'LIKE '%ean%'. Additionally, the salary comparison should use the BETWEEN keyword as 'salary BETWEEN 4000 AND 8000' instead of 'salary BETWEEN 4000 AND 8000;'.",
                    "The correct SQL query uses the LIKE operator with the wildcard character (%) to match any sequence of characters before or after 'ean' in the first_name column. The salary comparison is correctly implemented using the BETWEEN keyword as 'salary BETWEEN 4000 AND 8000'."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name LIKE '%ean%' \nAND salary BETWEEN 4000 AND 8000;\n</pre><p><br></p><p>Examine each of the provided SQL <code>WHERE</code> clause options and identify the <strong>correct one</strong> for the requirement:</p><p><strong>Requirement:</strong></p><ul><li><p><strong>Filter employees</strong> whose:</p><ul><li><p><code>first_name</code> <strong>contains</strong> the letters <code>'ean'</code></p></li><li><p><code>salary</code> is <strong>between 4000 and 8000 inclusive</strong></p></li></ul></li></ul><p><strong>Correct SQL Syntax:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name LIKE '%ean%'\nAND salary BETWEEN 4000 AND 8000;\n</pre><p>Evaluate the given options:</p><p><strong>Option 1:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name LIKE '%ean%'\nAND salary BETWEEN 4000 AND 8000;\n</pre><p><strong>Correct syntax</strong> for both:</p><ul><li><p><code>%ean%</code> → matches any first name containing <code>'ean'</code> (e.g., <em>Sean</em>, <em>Deanna</em>)</p></li><li><p><code>BETWEEN 4000 AND 8000</code> → includes <strong>4000</strong> and <strong>8000</strong></p></li></ul><p><strong>This is the correct answer.</strong></p><p><strong>Option 2:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name LIKE %ean%\nAND salary &gt; 4000 AND &lt; 8000;\n</pre><p><strong>Incorrect syntax</strong>:</p><ul><li><p><code>LIKE %ean%</code> is missing quotes (<code>'%ean%'</code>)</p></li><li><p><code>AND &lt; 8000</code> is <strong>not valid SQL</strong> — should be <code>AND salary &lt; 8000</code></p></li></ul><p><strong>Option 3:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name CONTAINS '%ean%'\nAND salary &gt;= 4000 AND &lt;= 8000;\n</pre><p><strong>Invalid syntax</strong>:</p><ul><li><p><code>CONTAINS</code> is not standard SQL (used in full-text search in some systems, not here)</p></li><li><p><code>AND &lt;= 8000</code> is incomplete — should be <code>AND salary &lt;= 8000</code></p></li></ul><p><strong>Option 4:</strong></p><pre class=\"prettyprint linenums\">WHERE first_name LIKE %EAN%\nAND salary BETWEEN 4000 AND 8000;\n</pre><p><strong>Invalid syntax</strong>:</p><ul><li><p><code>LIKE %EAN%</code> is missing quotes (<code>'%EAN%'</code>)</p></li><li><p>Also, <code>'EAN'</code> is uppercase; unless the database is case-insensitive, it may not match lowercase values like <code>'Sean'</code></p></li></ul><p><br></p><p>The requirement asked for filtering on those employees whose first_name contains lowercase 'ean' not uppercase.</p><p>\"WHERE first_name LIKE '%EAN%' AND&nbsp;salary BETWEEN 4000 AND&nbsp; 8000;\" would be correct if it were not for the capitalized \"EAN\".</p><p>The other options are using illegal SQL syntax and will throw errors.</p><p>Oracle WILDCARDS are referred for character pattern matching operation as a WILD CARD SEARCH. The WILDCARDS can be used with the LIKE operator. The WILDCARDS with LIKE operator allows us to perform character pattern matching.</p><p>There are two WILDCARDS in Oracle which are:</p><ul><li><p><code>%</code>: It represents a sequence of any number of characters including zero.</p></li><li><p><code>_</code>: It represents any single character but only at the specified position.</p></li><li><p>WILDCARDS with <code>LIKE</code> operator must be used in <code>WHERE</code> clause</p></li><li><p>WILDCARDS with <code>LIKE</code> operator can be used in <code>SELECT</code> statement</p></li><li><p>WILDCARDS with <code>LIKE</code> operator can be used for DML operations (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE first_name LIKE %ean%\nAND&nbsp;salary &gt; 4000 AND&nbsp;&lt; 8000;\n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE first_name CONTAINS '%ean%'\nAND&nbsp;salary &gt;= 4000 AND&nbsp;&lt;= 8000;\n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE first_name LIKE %EAN%\nAND&nbsp;salary BETWEEN 4000 AND&nbsp; 8000;\n</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE first_name LIKE '%ean%'\nAND&nbsp;salary between 4000 AND&nbsp;8000;\n</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "WILDCARDS",
            "question_plain": "View and examine the following available responses.Required: Create a SELECT query component which would allow for filtering for those employees whose first_name contains the letters 'ean' and also make salaries greater than or equal to 4000 and less than or equal to 8000.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478811,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_id\nFROM products\nWHERE ((2*crates) + 50 - supply) IN (crates * 20, crates + weight);\n</pre><p><br></p><p><strong>Given: </strong>All table and column references exist within the database.</p><p>Identify the problem with the syntax of the following SQL query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[WHERE IN](https://www.dofactory.com/sql/where-in)"
                ],
                "feedbacks": [
                    "The syntax error before the word SUPPLY in the WHERE clause indicates that there may be a missing operator or condition that is required for the query to be valid.",
                    "The statement mentioning the need for an equal sign or a not equal sign suggests that the query may be missing a comparison operator to properly filter the results in the WHERE clause.",
                    "The syntax error after the word IN in the WHERE clause implies that there may be an issue with the syntax of the IN operator or the values provided within the parentheses.",
                    "This explanation states that there is nothing wrong with the syntax of the SQL query, indicating that the query is correctly written and does not contain any errors."
                ],
                "explanation": "<p>Correct Answer: <strong>There is nothing wrong with the syntax.</strong></p><p><br></p><p>Analyze the <strong>SQL query</strong> and determine if there’s a syntax error:</p><p><strong>SQL Query (Exhibit 1):</strong></p><pre class=\"prettyprint linenums\">SELECT product_id\nFROM products\nWHERE ((2*crates) + 50 - supply) IN (crates * 20, crates + weight);\n</pre><p><strong>Step-by-step Analysis:</strong></p><ol><li><p><code><strong>SELECT product_id</strong></code><br>→ Valid syntax.</p></li><li><p><code><strong>FROM products</strong></code><br>→ Assumed valid table and column names.</p></li><li><p><code><strong>WHERE ((2*crates) + 50 - supply) IN (crates * 20, crates + weight)</strong></code><br>→ Let's break this down:</p><ul><li><p>The left-hand side:</p><pre class=\"prettyprint linenums\">((2*crates) + 50 - supply)\n</pre><p>This is a valid arithmetic expression.</p></li><li><p>The right-hand side of <code>IN</code>:</p><pre class=\"prettyprint linenums\">(crates * 20, crates + weight)\n</pre><p>This is a <strong>valid expression list</strong> containing two computed values. SQL allows expressions inside <code>IN()</code> — not just static values.</p></li></ul><p>Parentheses are matched correctly.</p><p><code>IN</code> is being used properly with a scalar on the left-hand side and a list on the right-hand side.</p></li></ol><p>Is there a <strong>syntax error</strong>?</p><p><strong>No.</strong></p><ul><li><p>This SQL query is <strong>syntactically correct</strong>.</p></li><li><p>Whether it returns meaningful results depends on the data and logic, but that’s not a <strong>syntax issue</strong>.</p></li></ul><p><br></p><p><strong>WHERE IN</strong></p><p><code>WHERE IN</code> returns values that matches values in a list or subquery.</p><p>The <code>WHERE IN</code> clause is shorthand for multiple <code>OR</code> conditions.</p>",
                "answers": [
                    "<p>In the WHERE&nbsp;clause there is a syntax error before the word SUPPLY.</p>",
                    "<p>It needs to have either an equal sign or a not equal sign.</p>",
                    "<p>In the WHERE&nbsp;clause there is a syntax error after the word IN.</p>",
                    "<p>There is nothing wrong with the syntax.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "WHERE IN",
            "question_plain": "View and examine the following SQL query.Exhibit: 1SELECT product_id\nFROM products\nWHERE ((2*crates) + 50 - supply) IN (crates * 20, crates + weight);\nGiven: All table and column references exist within the database.Identify the problem with the syntax of the following SQL query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478813,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required:</strong> Update the sales_quota column in the top_salesperson table with the value from the salesperson table for the salesperson with store_id 80.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query updates the sales_quota column in the top_salesperson table with the sales_quota value from the entire salesperson table, without filtering for the specific store_id 80. It does not meet the requirement to update the sales_quota for the salesperson with store_id 80.",
                    "This query correctly updates the sales_quota column in the top_salesperson table by selecting the sales_quota value from the salesperson table where the salesperson_id matches between the two tables. It ensures that only the salesperson with store_id 80 has their sales_quota updated in the top_salesperson table.",
                    "This query attempts to use a non-standard syntax for updating data from another table in Oracle SQL. The correct syntax for updating data from another table in Oracle SQL involves using a subquery in the SET clause, as shown in the correct choice B. This query is incorrect and will not produce the desired result.",
                    "This query has a syntax error as it is missing the AND keyword between the conditions in the WHERE clause. Additionally, the FROM keyword is not used in the UPDATE statement in Oracle SQL. The correct way to update data from another table in Oracle SQL is to use a subquery in the SET clause, as demonstrated in the correct choice B."
                ],
                "explanation": "<p>Correct Answer:</p><pre class=\"prettyprint linenums\">UPDATE top_salesperson a\nSET sales_quota = (\n  SELECT sales_quota \n  FROM salesperson b \n  WHERE a.salesperson_id = b.salesperson_id\n)\nWHERE store_id = 80;\n</pre><p><br></p><p>Evaluate each SQL query and identify the <strong>correct one</strong> for the requirement.</p><p><strong>Requirement:</strong></p><p>Update the <code>sales_quota</code> column in the <code>top_salesperson</code> table <strong>with the value from the </strong><code><strong>salesperson</strong></code><strong> table</strong>, <strong>for the salesperson with </strong><code><strong>store_id = 80</strong></code>.</p><p>Review the options:</p><p><strong>Option 1:</strong></p><pre class=\"prettyprint linenums\">UPDATE top_salesperson a\nSET sales_quota = (\n  SELECT sales_quota \n  FROM salesperson b \n  WHERE a.salesperson_id = b.salesperson_id\n)\nWHERE store_id = 80;\n</pre><ul><li><p>Correlated subquery that matches <code>salesperson_id</code> between the two tables.</p></li><li><p>Filters the update to only <code>store_id = 80</code> in <code>top_salesperson</code>.</p></li><li><p>Valid syntax.</p></li><li><p><strong>This is the correct query.</strong></p></li></ul><p><strong>Option 2:</strong></p><pre class=\"prettyprint linenums\">UPDATE top_salesperson\nSET sales_quota = (\n  SELECT sales_quota \n  FROM salesperson\n)\nWHERE store_id = 80;\n</pre><ul><li><p>The subquery returns <strong>multiple rows</strong>, since there’s no <code>WHERE</code> clause — leading to <strong>\"subquery returns more than one row\"</strong> error.</p></li><li><p>Not valid unless <code>salesperson</code> has only one row (which is unlikely).</p></li></ul><p><strong>Option 3:</strong></p><pre class=\"prettyprint linenums\">UPDATE top_salesperson a \nFROM salesperson b\nSET a.sales_quota = b.sales_quota\nWHERE store_id = 80;\n</pre><ul><li><p>This is <strong>invalid in standard SQL</strong> (e.g., Oracle).</p></li><li><p>This syntax resembles <strong>T-SQL (SQL Server)</strong>, but is <strong>not valid in Oracle</strong> or ANSI SQL.</p></li><li><p>Also, <code>store_id = 80</code> is ambiguous (which table?).</p></li></ul><p><strong>Option 4:</strong></p><pre class=\"prettyprint linenums\">UPDATE top_salesperson a\nSET sales_quota = (\n  SELECT sales_quota \n  FROM salesperson b \n  WHERE a.salesperson_id = b.salesperson_id\n  store_id = 80);\n</pre><ul><li><p>Missing <code><strong>AND</strong></code> or <code><strong>WHERE</strong></code> clause operator before <code>store_id = 80</code>.</p></li><li><p>Syntax error due to malformed subquery.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">UPDATE top_salesperson\nSET sales_quota = (SELECT sales_quota \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FROM salesperson)\nWHERE&nbsp;store_id = 80;</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE top_salesperson a\nSET sales_quota = (SELECT sales_quota \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FROM salesperson b \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WHERE&nbsp;a.salesperson_id = b.salesperson_id)\nWHERE&nbsp;store_id = 80;</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE top_salesperson a \nFROM&nbsp;salesperson b\nSET a.sales_quota = b.sales_quota\nWHERE&nbsp;store_id = 80;</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE top_salesperson a\nSET sales_quota = (SELECT sales_quota \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FROM salesperson b \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE&nbsp;a.salesperson_id = b.salesperson_id\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;store_id = 80);</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "UPDATE",
            "question_plain": "View and examine the following available responses.Required: Update the sales_quota column in the top_salesperson table with the value from the salesperson table for the salesperson with store_id 80.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478815,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the EMPLOYEES table structure.</p><p><strong>Table: EMPLOYEES</strong></p><pre class=\"prettyprint linenums\">Name                                         Type\nEMP_ID                                       NUMBER(6)\nEMP_NAME                                     VARCHAR(20)\nEMP_STATUS                                   CHAR\nHIRE_DATE                                    DATE\nFULLTIME_STATUS                              VARCHAR2\nSALARY                                       NUMBER\n</pre><p><br></p><p>Identify the true statements regarding the creation and datatypes in the table structure. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle VARCHAR2](https://www.oracletutorial.com/oracle-basics/oracle-varchar2/)",
                    "[Oracle CHAR](https://www.oracletutorial.com/oracle-basics/oracle-char/)"
                ],
                "feedbacks": [
                    "The EMP_ID column is a common identifier column in tables and would not cause an error in the table structure. It is typically defined as a numerical data type to uniquely identify each employee.",
                    "The FULLTIME_STATUS column may cause an error in the table structure if it is not defined with a valid data type. It should be defined as a character or boolean data type to store information about whether an employee is full-time or not.",
                    "The SALARY column is typically defined as a numerical data type with precision and scale to store decimal values. It can accurately store decimal values such as cents in the salary amount for each employee.",
                    "The EMP_STATUS column would store exactly one character if it is defined with a character data type, such as CHAR or VARCHAR. This data type restriction ensures that only one character can be stored in the column for each employee's status.",
                    "The HIRE_DATE column can be defined with a date and time data type, such as TIMESTAMP, to store the date and time of when an employee was hired. This data type can include seconds and fractional seconds to provide precise timestamp information."
                ],
                "explanation": "<p>True statements:</p><ul><li><p><strong>The FULLTIME_STATUS column would cause an error.</strong> (due to missing length specification)</p></li><li><p><strong>The EMP_STATUS column would store exactly one character.</strong></p></li></ul><p>Analyze each statement about the <code>EMPLOYEES</code> table structure and identify the two <strong>true</strong> ones:</p><p>1. <strong>The FULLTIME_STATUS column would cause an error.</strong></p><ul><li><p><strong>No</strong>, this would <strong>not cause an error</strong>.</p></li><li><p><code>VARCHAR2</code> without length defaults are generally <strong>not valid</strong>, but some RDBMS allow it or default to max length.</p></li><li><p>In Oracle, <code><strong>VARCHAR2</strong></code><strong> must specify a length</strong> (e.g., <code>VARCHAR2(10)</code>).</p></li><li><p>If length is missing, this is an error in Oracle.</p></li></ul><p><strong>So this depends on context, but usually: TRUE (it causes error due to missing length).</strong></p><p>2. <strong>The EMP_STATUS column would store exactly one character.</strong></p><ul><li><p><code>CHAR</code> data type without length defaults to <code>CHAR(1)</code> in many RDBMS, including Oracle.</p></li><li><p>So yes, <code>EMP_STATUS CHAR</code> stores exactly <strong>one character</strong>.</p></li></ul><p><strong>True statement.</strong></p><p>3. <strong>The EMP_ID column would cause an error.</strong></p><ul><li><p><code>NUMBER(6)</code> means a number with up to 6 digits.</p></li><li><p>This is valid and commonly used for IDs.</p></li></ul><p><strong>False — no error here.</strong></p><p>4. <strong>The SALARY column would not be able to store decimals.</strong></p><ul><li><p><code>NUMBER</code> without precision or scale allows any number including decimals.</p></li></ul><p><strong>False — it can store decimals.</strong></p><p>5. <strong>The HIRE_DATE column would be able to store the date and time including seconds and fractional seconds.</strong></p><ul><li><p>In Oracle, <code>DATE</code> datatype stores date and time <strong>up to seconds</strong> (no fractional seconds).</p></li><li><p>For fractional seconds, Oracle uses <code>TIMESTAMP</code>.</p></li></ul><p><strong>False — </strong><code><strong>DATE</strong></code><strong> does not store fractional seconds.</strong></p>",
                "answers": [
                    "<p>The EMP_ID column would cause an error.</p>",
                    "<p>The FULLTIME_STATUS column would cause an error.</p>",
                    "<p>The SALARY&nbsp;column would not be able to store decimals.</p>",
                    "<p>The EMP_STATUS column would store exactly one character.</p>",
                    "<p>The HIRE_DATE column would be able to store the date and time including seconds and fractional seconds.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "VARCHAR2",
            "question_plain": "View and examine the EMPLOYEES table structure.Table: EMPLOYEESName                                         Type\nEMP_ID                                       NUMBER(6)\nEMP_NAME                                     VARCHAR(20)\nEMP_STATUS                                   CHAR\nHIRE_DATE                                    DATE\nFULLTIME_STATUS                              VARCHAR2\nSALARY                                       NUMBER\nIdentify the true statements regarding the creation and datatypes in the table structure. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478817,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibits.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT last_name, salary, hire_date\nFROM employees\nORDER&nbsp;BY salary DESC;\n</pre><p><br></p><p><strong>Exhibit: 2</strong></p><pre class=\"prettyprint linenums\">SELECT last_name, salary, hire_date\nFROM employees\nORDER&nbsp;BY 2 DESC;\n</pre><p><br></p><p>Indicate what is true about these queries.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ORDER BY clause](https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "The two statements produce identical results because they both retrieve data from the EMPLOYEES table and sort the results by the SALARY column in descending order.",
                    "The second statement does not return a syntax error. Both SQL statements are valid and will execute without any syntax errors.",
                    "There is no need to specify DESC in the ORDER BY clause because the results are sorted in ascending order by default. If you want to sort in descending order, you need to explicitly specify DESC in the ORDER BY clause.",
                    "Adding a column alias for the salary column in the second SQL statement will not make the two statements produce identical results. The column alias does not affect the sorting order of the results."
                ],
                "explanation": "<p>Correct answer: <strong>The two statements produce identical results.</strong></p><p><br></p><p>Analyze the two SQL queries carefully:</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT last_name, salary, hire_date\nFROM employees\nORDER BY salary DESC;\n</pre><ul><li><p>Orders the result by the <strong>salary</strong> column in descending order.</p></li></ul><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT last_name, salary, hire_date\nFROM employees\nORDER BY 2 DESC;\n</pre><ul><li><p>Orders the result by the <strong>second column</strong> in the <code>SELECT</code> list, which is <strong>salary</strong>.</p></li><li><p><code>ORDER BY 2</code> means order by the second selected column.</p></li><li><p>Adding <code>DESC</code> makes it descending order.</p></li></ul><p>Now, let's examine the statements:</p><ol><li><p><strong>The two statements produce identical results.</strong><br><strong>True</strong></p></li></ol><ul><li><p>Both sort by the <code>salary</code> column descending.</p></li><li><p><code>ORDER BY salary DESC</code> and <code>ORDER BY 2 DESC</code> are equivalent here.</p></li></ul><ol><li><p><strong>The second statement returns a syntax error.</strong><br>False</p></li></ol><ul><li><p>Ordering by column position is valid in SQL.</p></li></ul><ol><li><p><strong>There is no need to specify DESC because the results are sorted in descending order by default.</strong><br>False</p></li></ol><ul><li><p>Default order is <strong>ascending</strong>, so DESC is necessary to sort descending.</p></li></ul><ol><li><p><strong>The two statements can be made to produce identical results by adding a column alias for the salary column in the second SQL statement.</strong><br>False</p></li></ol><ul><li><p>Adding an alias is unnecessary since ordering by column position already works.</p></li></ul>",
                "answers": [
                    "<p>The two statements produce identical results.</p>",
                    "<p>The second statement returns a syntax error.</p>",
                    "<p>There is no need to specify DESC because the results are sorted in descending order by default.</p>",
                    "<p>The two statements can be made to produce identical results by adding a column alias for the salary column in the second SQL statement.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following SQL exhibits.Exhibit: 1SELECT last_name, salary, hire_date\nFROM employees\nORDER&nbsp;BY salary DESC;\nExhibit: 2SELECT last_name, salary, hire_date\nFROM employees\nORDER&nbsp;BY 2 DESC;\nIndicate what is true about these queries.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478819,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statement that is true about the usage of the BETWEEN condition.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle BETWEEN Operator](https://www.oracletutorial.com/oracle-basics/oracle-between/)",
                    "[TO_DATE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/TO_DATE.html)"
                ],
                "feedbacks": [
                    "The BETWEEN condition can indeed be used with dates in Oracle SQL. It is a valid and commonly used method for filtering date ranges in queries.",
                    "The statement that the BETWEEN condition will not return the records where the column or the calculation is equal to value1 or value2 is incorrect. In reality, the BETWEEN condition is inclusive, meaning it will include records where the column or calculation is equal to value1 or value2.",
                    "The usage of the BETWEEN clause in the provided SQL query is accurate. It demonstrates the correct syntax for using the BETWEEN condition to filter records based on a date range in the 'orders' table.",
                    "The usage of the BETWEEN clause in the second provided SQL query is inaccurate. The syntax used is incorrect as it does not follow the correct format for specifying date values in the BETWEEN condition. The correct format should include the TO_DATE function for date conversions."
                ],
                "explanation": "<p><strong>True statement:</strong></p><p>The following use of the BETWEEN clause is accurate.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN TO_DATE ('2019/04/19', 'yyyy/mm/dd')\nAND TO_DATE ('2019/05/01', 'yyyy/mm/dd')</pre><p><br></p><p>Review each statement about the <strong>BETWEEN</strong> condition carefully:</p><p>1. <strong>\"The following use of the BETWEEN clause is accurate.\"</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN TO_DATE ('2019/04/19', 'yyyy/mm/dd')\nAND TO_DATE ('2019/05/01', 'yyyy/mm/dd')</pre><ul><li><p>This is <strong>correct usage</strong>.</p></li><li><p><code>TO_DATE</code> converts the string to a proper date, and BETWEEN works inclusively with dates.</p></li></ul><p>2. <strong>\"The BETWEEN condition cannot be used with dates.\"</strong></p><ul><li><p>❌ False.</p></li><li><p>BETWEEN <strong>can be used with dates</strong>.</p></li></ul><p>3. <strong>\"Given the below syntax:\"</strong></p><pre class=\"prettyprint linenums\">&lt;column/calculation&gt; BETWEEN &lt;value1&gt; AND &lt;value2&gt;;</pre><p><br></p><p><strong>\"The </strong><code><strong>BETWEEN</strong></code><strong> condition will not return the records where the <em>column</em> or the <em>calculation </em>is equal to <em>value1</em> or <em>value2</em>.\"</strong></p><ul><li><p>False.</p></li><li><p>BETWEEN <strong>is inclusive</strong>, meaning it <strong>does include</strong> records where the value equals value1 or value2.</p></li></ul><p>4. <strong>\"The following use of the BETWEEN clause is accurate.\"</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN ('2019/04/19', 'yyyy/mm/dd')\nAND ('2019/05/01', 'yyyy/mm/dd')</pre><ul><li><p>False.</p></li><li><p>This syntax is invalid because the date strings are not converted by <code>TO_DATE</code>.</p></li><li><p>BETWEEN expects <strong>scalar values</strong> on both ends, not tuples.</p></li></ul><p><br></p><p><strong>BETWEEN </strong></p><p>The BETWEEN condition can work with date and numerical ranges and is inclusive of the start and end of the range elements. </p><p>For dates, you must make sure to use the <code>TO_DATE</code> function, this is exactly the reason why the following option is not correct.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN ('2019/04/19', 'yyyy/mm/dd')\nAND ('2019/05/01', 'yyyy/mm/dd')</pre>",
                "answers": [
                    "<p>The BETWEEN condition cannot be used with dates.</p>",
                    "<p>Given the below syntax:</p><pre class=\"prettyprint linenums\">&lt;column/calculation&gt; BETWEEN &lt;value1&gt; AND &lt;value2&gt;;</pre><p><br></p><p>The <code>BETWEEN</code> condition will not return the records where the <em>column</em> or the <em>calculation </em>is equal to <em>value1</em> or <em>value2</em>.</p>",
                    "<p>The following use of the BETWEEN clause is accurate.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN TO_DATE ('2019/04/19', 'yyyy/mm/dd')\nAND TO_DATE ('2019/05/01', 'yyyy/mm/dd')</pre>",
                    "<p>The following use of the BETWEEN clause is accurate.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nWHERE order_date BETWEEN ('2019/04/19', 'yyyy/mm/dd')\nAND ('2019/05/01', 'yyyy/mm/dd')</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "BETWEEN",
            "question_plain": "View and examine the following available responses.Identify the statement that is true about the usage of the BETWEEN condition.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478821,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the dictionary table would you use to list only those tables that you own.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[USER_TABLES](https://docs.oracle.com/search/?q=USER_TABLES&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)"
                ],
                "feedbacks": [
                    "The DB_TABLES table does not exist in Oracle Database SQL. It is not a valid dictionary table for listing tables that you own.",
                    "The DBA_TABLES table in Oracle Database SQL contains information about all tables in the database, not just the ones that you own. It is not the correct choice for listing only the tables that you own.",
                    "The ALL_TABLES table in Oracle Database SQL contains information about all tables accessible to the current user, not just the ones that you own. It is not the correct choice for listing only the tables that you own.",
                    "The USER_TABLES table in Oracle Database SQL contains information about the tables owned by the current user. It is the correct choice for listing only the tables that you own.",
                    "The MY_TABLES table does not exist in Oracle Database SQL. It is not a valid dictionary table for listing tables that you own."
                ],
                "explanation": "<p>The correct answer is: <code>USER_TABLES</code> is the correct view to list <strong>only the tables that you own</strong>.</p><p><br></p><p><strong>Dictionary View: Description </strong></p><p><code>USER_TABLES</code>: Lists <strong>only the tables owned by the current user</strong>. </p><p><code>DB_TABLES</code>: Invalid — <strong>no such dictionary view</strong> in Oracle. </p><p><code>DBA_TABLES </code>: Lists <strong>all tables in the database</strong>, but <strong>requires DBA privileges</strong>. </p><p><code>ALL_TABLES </code>: Lists <strong>all tables accessible to the user</strong>, including those owned by others. </p><p><code>MY_TABLES</code>: Not a valid Oracle dictionary view.</p>",
                "answers": [
                    "<p><code>DB_TABLES</code> </p>",
                    "<p><code>DBA_TABLES</code> </p>",
                    "<p><code>ALL_TABLES</code> </p>",
                    "<p><code>USER_TABLES</code> </p>",
                    "<p><code>MY_TABLES</code> </p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "Dictionary",
            "question_plain": "View and examine the following available responses.Identify the dictionary table would you use to list only those tables that you own.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478823,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the SQL EXISTS condition. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL: EXISTS Condition](https://www.techonthenet.com/sql/exists.php)"
                ],
                "feedbacks": [
                    "The statement that the EXISTS condition cannot be used inside a subquery is incorrect. The EXISTS condition is commonly used in subqueries to check for the existence of rows that meet specific criteria.",
                    "The statement that the EXISTS condition can only be used in the SELECT and UPDATE statements and cannot be used for INSERT and DELETE statements is incorrect. The EXISTS condition can be used in the WHERE clause of SELECT, UPDATE, INSERT, and DELETE statements to check for the existence of rows in a subquery.",
                    "The statement that if the subquery following an EXISTS clause returns no records, the outer query will also return no records is correct. The EXISTS condition returns true if the subquery returns at least one row, and false if the subquery returns no rows. Therefore, if the subquery returns no records, the outer query will also return no records.",
                    "The statement that similar to the EXISTS condition, you can also use a NOT EXISTS condition in SQL is correct. The NOT EXISTS condition is the opposite of the EXISTS condition and returns true if the subquery returns no rows. It is commonly used to check for the absence of rows that meet specific criteria."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><p><strong>1. \"If the subquery following an EXISTS clause returns no records, the outer query will also return no records.\"</strong></p><ul><li><p><strong>True</strong></p></li><li><p>The <code>EXISTS</code> condition evaluates to <strong>TRUE</strong> if the subquery returns <strong>at least one row</strong>.</p></li><li><p>If the subquery returns <strong>no rows</strong>, <code>EXISTS</code> is <strong>FALSE</strong>, and the outer query <strong>excludes</strong> those rows.</p></li></ul><p><strong>2. \"Similar to the EXISTS condition, you can also use a NOT EXISTS condition in SQL.\"</strong></p><ul><li><p><strong>True</strong></p></li><li><p><code>NOT EXISTS</code> is valid and commonly used to filter rows <strong>where the subquery returns no rows</strong>.</p></li></ul><p><strong>False Statements:</strong></p><ul><li><p><strong>\"The EXISTS condition cannot be used inside a subquery.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>EXISTS</code> is specifically designed to be used <strong>with subqueries</strong>, often correlated subqueries.</p></li></ul></li></ul><ul><li><p><strong>\"The EXISTS condition can only be used in the SELECT and UPDATE statements. It cannot be used for INSERT and DELETE statements.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>EXISTS</code> can be used in <strong>any DML statement</strong>, including <strong>INSERT</strong>, <strong>UPDATE</strong>, <strong>DELETE</strong>, and <strong>SELECT</strong>.</p></li></ul></li></ul>",
                "answers": [
                    "<p>The EXISTS condition cannot be used inside a subquery.</p>",
                    "<p>The EXITS condition can only be used in the SELECT and UPDATE statements. It cannot be used for INSERT and DELETE statements.</p>",
                    "<p>If the subquery following an EXISTS clause returns no records, the outer query will also return no records.</p>",
                    "<p>Similar to the EXISTS condition, you can also use a NOT&nbsp;EXISTS condition in SQL.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "EXISTS",
            "question_plain": "View and examine the following available responses.Identify the true statements about the SQL EXISTS condition. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478825,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the following statement which is syntactically accurate.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Creating Joins with the USING Clause](https://www.w3resource.com/oracle/joins/joins-with-using-clause.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect because the alias \"C\" is used in the JOIN clause without specifying the table name before it. The correct syntax should specify the table name before the alias in the JOIN clause.",
                    "This statement is correct because it uses aliases for the tables \"invoices\" and \"customers\" (I and C, respectively) and correctly specifies the column to join on using the USING keyword.",
                    "This statement is incorrect because it references a column \"D.customer.id\" that is not defined in the tables being queried. It also uses an incorrect syntax for specifying the table alias in the SELECT clause.",
                    "This statement is incorrect because it references a table alias \"D\" that is not defined in the query. Additionally, the syntax for the JOIN condition is incorrect as it should use the column names directly without specifying table aliases."
                ],
                "explanation": "<p>The <strong>syntactically accurate</strong> SQL statement is:</p><pre class=\"prettyprint linenums\">SELECT *\nFROM invoices I\nJOIN customers C USING (customer_id);\n</pre><p><br></p><p>Analyze each option:</p><p><strong>1. </strong><code><strong>SELECT * FROM invoices I JOIN customers C USING (customer_id);</strong></code></p><ul><li><p><strong>Correct syntax</strong></p></li><li><p><code>USING (customer_id)</code> tells SQL to join the two tables on the column <strong>customer_id</strong>, which must exist <strong>in both tables</strong> with the same name.</p></li><li><p>Aliases (<code>I</code> and <code>C</code>) are used correctly.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-06-27_18-09-58-1b5e37e799ec482284cf3b0da80f2a36.png\"></p></li><li><p>Even though 'no data found' was returned, it was executed successfully - there were only empty tables queried to show the syntax is correct.</p></li><li><p>When joining two tables on a common column name, the aliases must not be given to the common column name in the <code>USING</code> clause.</p></li></ul><p><strong>2. </strong><code><strong>SELECT * FROM invoices JOIN customers C USING (C.customer_id);</strong></code></p><ul><li><p><strong>Incorrect</strong></p></li><li><p>You <strong>cannot qualify</strong> a column name (e.g., <code>C.customer_id</code>) in a <code>USING()</code> clause.</p></li><li><p>The <code>USING</code> clause only accepts <strong>unqualified column names</strong> that exist in <strong>both tables</strong>.</p></li></ul><p><strong>3. </strong><code><strong>SELECT D.customer.id FROM invoices JOIN customers C USING (C.customer_id);</strong></code></p><ul><li><p><strong>Incorrect</strong></p></li><li><p><code>D.customer.id</code> is not valid syntax. Dot notation (<code>D.customer.id</code>) implies a <strong>schema or object path</strong> that isn't supported this way in SQL.</p></li><li><p>Also, <code>USING (C.customer_id)</code> is invalid, as explained above.</p></li></ul><p><strong>4. </strong><code><strong>SELECT D.customer.id FROM invoices JOIN customers C USING (C.customer_id = D.customer.id);</strong></code></p><ul><li><p><strong>Invalid syntax</strong></p></li><li><p><code>USING</code> cannot take a <strong>join condition</strong> — that's what <code>ON</code> is for.</p></li><li><p>And again, <code>D.customer.id</code> is not a valid SQL identifier.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM invoices\nJOIN customers C USING (C.customer_id);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM invoices I\nJOIN customers C USING (customer_id);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT D.customer.id\nFROM invoices\nJOIN customers C USING (C.customer_id);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT D.customer.id\nFROM invoices\nJOIN customers C USING (C.customer_id = D.customer.id);\n</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "USING",
            "question_plain": "View and examine the following available responses.Identify the following statement which is syntactically accurate.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478827,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT&nbsp;customer_name, address, recent_purchase_date\nFROM&nbsp;customers\nWHERE&nbsp;recent_purchase_date &gt; TRUNC(SYSDATE) - 5;\n</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SYSDATE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/SYSDATE.html)"
                ],
                "feedbacks": [
                    "This choice is incorrect because the query is filtering for customers who made a purchase within the last five days, not more than five days ago.",
                    "This choice is incorrect as the query is looking for customers who made a purchase within the last five days, not more than five years ago.",
                    "This choice is correct because the query structure includes the condition \"WHERE PURCHASE_DATE &gt; SYSDATE - 5\" which filters for customers who made a purchase within the last five days.",
                    "This choice is incorrect as the query is specifically filtering for customers who made a purchase within the last five days, not within the last five years.",
                    "This choice is incorrect as the query structure is valid and will not fail, it is designed to retrieve customers who made a purchase within the last five days."
                ],
                "explanation": "<p>Correct answer: <strong>Customers who made a purchase within the last five days.</strong></p><p><br></p><pre class=\"prettyprint linenums\">SELECT customer_name, address, recent_purchase_date\nFROM customers\nWHERE recent_purchase_date &gt; TRUNC(SYSDATE) - 5;\n</pre><ul><li><p><code>SYSDATE</code> returns the <strong>current date and time</strong>.</p></li><li><p>By default the calculation is done on the number of days. </p></li><li><p><code>TRUNC(SYSDATE)</code> removes the <strong>time component</strong>, leaving just the <strong>current date at midnight</strong>.</p></li><li><p>Subtracting 5 (<code>TRUNC(SYSDATE) - 5</code>) gives the <strong>date 5 days ago</strong> at <strong>00:00:00</strong>.</p></li></ul><p>The query finds:</p><ul><li><p>All customers whose <code>recent_purchase_date</code> is <strong>after</strong> that — meaning <strong>within the last 5 days</strong> (including today).</p></li></ul>",
                "answers": [
                    "<p>Customers who made a purchase more than five days ago.</p>",
                    "<p>Customers who made a purchase more than five years ago.</p>",
                    "<p>Customers who made a purchase within the last five days.</p>",
                    "<p>Customers who made a purchase within the last five years.</p>",
                    "<p>The query will fail and return an error.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SYSDATE",
            "question_plain": "View and examine the following SQL query structure. Exhibit: 1SELECT&nbsp;customer_name, address, recent_purchase_date\nFROM&nbsp;customers\nWHERE&nbsp;recent_purchase_date &gt; TRUNC(SYSDATE) - 5;\nIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478829,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate the statement that is true regarding the ordering of data in a SELECT statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Reason why oracle is case sensitive?](https://stackoverflow.com/questions/7425153/reason-why-oracle-is-case-sensitive)",
                    "[Oracle ORDER BY Clause](https://www.oracletutorial.com/oracle-basics/oracle-order-by/)"
                ],
                "feedbacks": [
                    "NULL values are considered by the ORDER BY clause and can be sorted either in ascending or descending order based on the specified sorting direction.",
                    "You can ORDER BY a column that is not stated in the SELECT clause as long as it is included in the FROM clause and is accessible in the query.",
                    "Numeric values are displayed in ascending order by default in a SELECT statement. To display them in descending order, you need to explicitly specify the DESC keyword in the ORDER BY clause.",
                    "When sorting on character data, the values are case-sensitive by default. This means that uppercase and lowercase letters are considered different when ordering the data."
                ],
                "explanation": "<p>The <strong>correct statement</strong> is: <strong>When sorting on character data, the values are case-sensitive.</strong></p><p><br></p><p><strong>1. \"When sorting on character data, the values are case-sensitive.\"</strong></p><ul><li><p><strong>True</strong></p></li><li><p>In most SQL implementations (like Oracle), sorting <strong>is case-sensitive</strong> by default.</p></li><li><p>Regardless of the fact that the SQL language is case-insensitive the data is not. </p></li><li><p><strong>Uppercase letters</strong> are sorted <strong>before</strong> lowercase ones (e.g., <code>'APPLE'</code> before <code>'apple'</code>).</p></li><li><p>When sorting character data, lowercase and uppercase characters are treated differently by the <code>ORDER BY</code> clause.</p></li></ul><p><strong>2. \"NULL values are not considered by the ORDER BY clause.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>NULL</code> <strong>values are included</strong> in sorting.</p></li><li><p>By default:</p><ul><li><p>In <strong>ascending order</strong>, <code>NULL</code> values appear <strong>last</strong>.</p></li><li><p>In <strong>descending order</strong>, <code>NULL</code> values appear <strong>first</strong>.</p></li><li><p>This can be customized using <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p></li></ul></li></ul><p><strong>3. \"You cannot ORDER BY a column that is not stated in the SELECT clause.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p>You <strong>can</strong> order by columns <strong>not included</strong> in the <code>SELECT</code> list.</p></li><li><p>This is valid SQL and commonly used for internal sorting while limiting displayed data.</p></li></ul><p><strong>4. \"By default numeric values are displayed in descending order.\"</strong></p><ul><li><p><strong>False</strong></p></li><li><p>The <strong>default sort order is ascending</strong> (from smallest to largest).</p></li></ul>",
                "answers": [
                    "<p>NULL&nbsp;values are not considered by the ORDER&nbsp;BY&nbsp;clause.</p>",
                    "<p>You cannot ORDER&nbsp;BY a column that is not stated in the SELECT clause.</p>",
                    "<p>By default numeric values are displayed in descending order.</p>",
                    "<p>When sorting on character data, the values are case-sensitive.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following available responses.Indicate the statement that is true regarding the ordering of data in a SELECT statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478831,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Given:</strong> There is a properly structured table with the suppliers: Microsoft, Google, IBM, AWS, Oracle and these are all under supplier_name.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DELETE&nbsp;FROM suppliers\nWHERE supplier_name &lt;&gt; 'microsoft';</pre><p><br></p><p><strong>Required: </strong>Delete data from the suppliers table where the supplier_name is not 'Microsoft'.</p><p>Identify the correct result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What does &lt;&gt; means in SQL language: Sample code is as follows](https://stackoverflow.com/questions/7646079/what-does-mean-in-oracle)"
                ],
                "feedbacks": [
                    "The query is incorrect because in Oracle SQL, the operator '&lt;&gt;' is used to represent 'not equal to', not '!='. Therefore, the correct operator to filter for all companies not named Microsoft should be '&lt;&gt;' instead of '!='.",
                    "<p>The supplier 'Microsoft' will be deleted from the suppliers table. This is because the query is specifically designed to delete data where the supplier_name is not 'microsoft', so Microsoft will be deleted.</p><ol><li><p><strong>Problem:</strong> <code>'microsoft'</code> is <strong>lowercase</strong>, but in Oracle, <strong>string comparisons are case-sensitive</strong> by default.</p></li><li><p>If <code>'Microsoft'</code> is stored with a capital <strong>'M'</strong>, this query <strong>will delete all rows</strong> because <code>'microsoft'</code> does not match <code>'Microsoft'</code>.</p></li></ol>",
                    "<p>The supplier 'Microsoft' will be deleted from the suppliers table. This is because the query is specifically designed to delete data where the supplier_name is not 'microsoft', so Microsoft will be deleted.</p><ol><li><p><strong>Problem:</strong> <code>'microsoft'</code> is <strong>lowercase</strong>, but in Oracle, <strong>string comparisons are case-sensitive</strong> by default.</p></li><li><p>If <code>'Microsoft'</code> is stored with a capital <strong>'M'</strong>, this query <strong>will delete all rows</strong> because <code>'microsoft'</code> does not match <code>'Microsoft'</code>.</p></li></ol>",
                    "<p>This is incorrect because choice \"The supplier 'Microsoft' will be deleted from the suppliers table\" correctly identifies that the query will delete all suppliers that are not named Microsoft.</p>"
                ],
                "explanation": "<p>The correct result of the query is:</p><ul><li><p>The supplier 'Microsoft' will be be deleted from the suppliers table, and so would all the other supplier names. The table would be empty.</p></li></ul><p>Data is always case-sensitive.&nbsp; The query will delete all suppliers&nbsp; which are not titled 'microsoft', since 'Microsoft' is not the same as 'microsoft', it will be deleted.</p><p><br></p><p>If the query were:</p><pre class=\"prettyprint linenums\">DELETE FROM&nbsp;suppliers\nWHERE&nbsp;supplier_name = 'microsoft';</pre><p><br></p><p>Nothing would be deleted from the table. The table would remain Microsoft, Google, IBM, AWS, Oracle.</p><p>If the query were:</p><pre class=\"prettyprint linenums\">DELETE FROM&nbsp;suppliers\nWHERE&nbsp;supplier_name &lt;&gt; 'Microsoft';</pre><p><br></p><p>Everything would be deleted that does not match the word&nbsp; 'Microsoft' removing Google, IBM, AWS, Oracle.</p>",
                "answers": [
                    "<p>The query is incorrect because the operator ' != ' should have been used in place of ' &lt;&gt; ' to filter for all companies not named Microsoft.</p>",
                    "<p>The query is correct and will delete all suppliers that are not named Microsoft.</p>",
                    "<p>The supplier 'Microsoft' will be deleted from the suppliers table.</p>",
                    "<p>None of the responses are correct.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL query structure. Given: There is a properly structured table with the suppliers: Microsoft, Google, IBM, AWS, Oracle and these are all under supplier_name.Exhibit: 1DELETE&nbsp;FROM suppliers\nWHERE supplier_name &lt;&gt; 'microsoft';Required: Delete data from the suppliers table where the supplier_name is not 'Microsoft'.Identify the correct result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478833,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT * \nFROM customers\nWHERE 1 = 1\nAND EXISTS (SELECT 1 FROM customers WHERE 4 &lt;&gt; 4);\n</pre><p><br></p><p><strong>Given:</strong> The customers table has 8 rows</p><p>Indicate the result of the executed query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle EXISTS Operator](https://www.oracletutorial.com/oracle-basics/oracle-exists/)"
                ],
                "feedbacks": [
                    "This query structure does not include any filtering conditions or criteria, so it will return all rows from the customers table. Since the table has 8 rows, all 8 rows will be returned.",
                    "This query structure does not include any filtering conditions or criteria, so it will return all rows from the customers table. Since the table has 8 rows, all 8 rows will be returned. Therefore, 4 rows will not be returned.",
                    "The query structure includes a condition that will never be met (1=0), which means that no rows will satisfy this condition and be returned from the customers table. Therefore, 0 rows will be returned as a result of the executed query.",
                    "While the query structure may seem unusual with the condition 1=0, it is a valid SQL query that will not result in an error. Instead, it will simply return 0 rows because the condition will never be true."
                ],
                "explanation": "<p>The correct answer is: <strong>0 rows will be returned.</strong></p><p>Analyze the query:</p><pre class=\"prettyprint linenums\">SELECT * \nFROM customers\nWHERE 1 = 1\nAND EXISTS (SELECT 1 FROM customers WHERE 4 &lt;&gt; 4);\n</pre><p>Step-by-step Explanation:</p><ol><li><p><code><strong>1 = 1</strong></code></p><ul><li><p>Always <strong>true</strong>, so it does <strong>not filter out</strong> any rows.</p></li></ul></li><li><p><strong>Subquery: </strong><code><strong>SELECT 1 FROM customers WHERE 4 &lt;&gt; 4</strong></code></p><ul><li><p>The expression <code>4 &lt;&gt; 4</code> is <strong>always false</strong>, so the <code>WHERE</code> clause fails for all rows.</p></li><li><p>Therefore, the subquery returns <strong>no rows</strong>.</p></li></ul></li><li><p><code><strong>EXISTS (SELECT 1 FROM customers WHERE 4 &lt;&gt; 4)</strong></code></p><ul><li><p><code>EXISTS</code> checks whether the subquery <strong>returns any rows</strong>.</p></li><li><p>Since the subquery returns <strong>zero rows</strong>, <code>EXISTS</code> evaluates to <strong>false</strong>.</p></li></ul></li></ol><p>Final Result:</p><ul><li><p>Since the <code>EXISTS</code> condition is false, <strong>no rows</strong> from the <code>customers</code> table will satisfy the full <code>WHERE</code> clause.</p></li><li><p>Therefore, the query returns: <strong>0 rows</strong></p></li><li><p>No rows will be returned. </p></li></ul><p>If the subquery following an <code>EXISTS</code> clause returns no records, the outer query will also return no records. As 4 = 4, no records can be returned making the subquery return an empty set of values, therefore the main query will also return no records.</p><p>The Oracle <code>EXISTS</code> operator is a Boolean operator that returns either true or false. The <code>EXISTS</code> operator is often used with a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\">subquery</a> to test for the existence of rows</p>",
                "answers": [
                    "<p>8 rows will be returned.</p>",
                    "<p>4&nbsp; rows will be returned.</p>",
                    "<p>0&nbsp; rows will be returned.</p>",
                    "<p>An error code will be returned.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "EXISTS",
            "question_plain": "View and examine the following SQL query structure. Exhibit: 1SELECT * \nFROM customers\nWHERE 1 = 1\nAND EXISTS (SELECT 1 FROM customers WHERE 4 &lt;&gt; 4);\nGiven: The customers table has 8 rowsIndicate the result of the executed query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478835,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following CUSTOMERS and ORDERS table along with the SQL query exhibit structure. </p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">CUST_ID                        CUST_NAME                 COUNTRY\n1                              Rachelle                  Mexico\n2                              Rhonda                    Canada\n3                              Roger                     Denmark\n4                              Rick                      Poland\n5                              Raj                       England\n6                              Roberta                   France\n7                              Renaldo                   Colombia\n</pre><p><br></p><p><strong>Table: ORDERS </strong></p><pre class=\"prettyprint linenums\">CUST_ID                        ORDER_ID                   ORDER_DATE\n5                              100                        2019/10/10\n2                              200                        2019/11/11\n4                              300                        2019/12/12\n4                              400                        2020/01/01\n5                              500                        2020/02/02\n</pre><p><br></p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DELETE FROM customers\nWHERE NOT EXISTS\n(SELECT *\nFROM orders\nWHERE customers.CUST_ID = orders.CUST_ID);\n</pre><p><br></p><p>Indicate the result of executing the DELETE statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Language Elements](https://docs.oracle.com/en/database/oracle/oracle-database/23/lnpls/plsql-language-elements.html)",
                    "[Collection Methods](https://docs.oracle.com/en/database/oracle/oracle-database/23/lnpls/collection-methods.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F)"
                ],
                "feedbacks": [
                    "The DELETE statement in the SQL query exhibit specifies a condition where only customers from the CUSTOMERS table who do not have a corresponding entry in the ORDERS table will be deleted. This means that only customers who have not placed an order will be deleted.",
                    "Customers with IDs 1 and 7 are not deleted because they have corresponding entries in the ORDERS table. The DELETE statement in the SQL query exhibit specifically targets customers without orders, so only those customers will be deleted.",
                    "Customers with IDs 1, 6, and 7 are not deleted because they have corresponding entries in the ORDERS table. The DELETE statement in the SQL query exhibit focuses on deleting customers without orders, so only those customers will be affected.",
                    "The DELETE statement in the SQL query exhibit is designed to delete customers who do not have a corresponding entry in the ORDERS table. Therefore, customers who have placed an order will not be deleted, and only customers without orders will be affected.",
                    "Customers with IDs 2, 4, and 5 are not deleted because they have corresponding entries in the ORDERS table. The DELETE statement in the SQL query exhibit targets customers without orders, so only those customers will be deleted."
                ],
                "explanation": "<p>The correct result of executing the DELETE statement is: <strong>All customers who have not placed an order will be deleted only.</strong></p><p><br></p><p>Break down the SQL <code>DELETE</code> statement and determine its result.</p><p><strong>The Query:</strong></p><pre class=\"prettyprint linenums\">DELETE FROM customers\nWHERE NOT EXISTS\n(SELECT *\nFROM orders\nWHERE customers.CUST_ID = orders.CUST_ID);\n</pre><p><strong>Explanation:</strong></p><ol><li><p><code><strong>DELETE FROM customers</strong></code>: This indicates that rows will be removed from the <code>CUSTOMERS</code> table.</p></li><li><p><code><strong>WHERE NOT EXISTS (...)</strong></code>: This is the filtering condition. The <code>DELETE</code> statement will only remove rows from <code>CUSTOMERS</code> for which the subquery (inside the parentheses) returns <strong>no rows</strong>.</p></li><li><p><code><strong>SELECT * FROM orders WHERE customers.CUST_ID = orders.CUST_ID</strong></code>: This is a correlated subquery. For each row in the <code>CUSTOMERS</code> table being considered for deletion, this subquery checks if there is a corresponding row in the <code>ORDERS</code> table with the same <code>CUST_ID</code>.</p><ul><li><p>If a customer <code>CUST_ID</code> from the <code>CUSTOMERS</code> table <strong>exists</strong> in the <code>ORDERS</code> table, the subquery will return at least one row.</p></li><li><p>If a customer <code>CUST_ID</code> from the <code>CUSTOMERS</code> table <strong>does NOT exist</strong> in the <code>ORDERS</code> table, the subquery will return no rows.</p></li></ul></li></ol><p><strong>Putting it together:</strong></p><p>The <code>DELETE</code> statement will target customers where <code>NOT EXISTS</code> is true. This means it will delete customers for whom the subquery returns <em>no rows</em>. In other words, it will delete customers who <strong>do not have any corresponding entries in the </strong><code><strong>ORDERS</strong></code><strong> table</strong> (i.e., customers who have not placed any orders).</p><p><strong>Let's check the customers from the </strong><code><strong>CUSTOMERS</strong></code><strong> table against the </strong><code><strong>ORDERS</strong></code><strong> table:</strong></p><ul><li><p><strong>CUST_ID 1 (Rachelle):</strong> Is <code>CUST_ID</code> 1 in the <code>ORDERS</code> table? No.</p><ul><li><p><code>NOT EXISTS</code> will be <code>TRUE</code> for Rachelle.</p></li><li><p><strong>Rachelle will be deleted.</strong></p></li></ul></li><li><p><strong>CUST_ID 2 (Rhonda):</strong> Is <code>CUST_ID</code> 2 in the <code>ORDERS</code> table? Yes (ORDER_ID 200).</p><ul><li><p><code>NOT EXISTS</code> will be <code>FALSE</code> for Rhonda.</p></li><li><p>Rhonda will NOT be deleted.</p></li></ul></li><li><p><strong>CUST_ID 3 (Roger):</strong> Is <code>CUST_ID</code> 3 in the <code>ORDERS</code> table? No.</p><ul><li><p><code>NOT EXISTS</code> will be <code>TRUE</code> for Roger.</p></li><li><p><strong>Roger will be deleted.</strong></p></li></ul></li><li><p><strong>CUST_ID 4 (Rick):</strong> Is <code>CUST_ID</code> 4 in the <code>ORDERS</code> table? Yes (ORDER_ID 300, 400).</p><ul><li><p><code>NOT EXISTS</code> will be <code>FALSE</code> for Rick.</p></li><li><p>Rick will NOT be deleted.</p></li></ul></li><li><p><strong>CUST_ID 5 (Raj):</strong> Is <code>CUST_ID</code> 5 in the <code>ORDERS</code> table? Yes (ORDER_ID 100, 500).</p><ul><li><p><code>NOT EXISTS</code> will be <code>FALSE</code> for Raj.</p></li><li><p>Raj will NOT be deleted.</p></li></ul></li><li><p><strong>CUST_ID 6 (Roberta):</strong> Is <code>CUST_ID</code> 6 in the <code>ORDERS</code> table? No.</p><ul><li><p><code>NOT EXISTS</code> will be <code>TRUE</code> for Roberta.</p></li><li><p><strong>Roberta will be deleted.</strong></p></li></ul></li><li><p><strong>CUST_ID 7 (Renaldo):</strong> Is <code>CUST_ID</code> 7 in the <code>ORDERS</code> table? No.</p><ul><li><p><code>NOT EXISTS</code> will be <code>TRUE</code> for Renaldo.</p></li><li><p><strong>Renaldo will be deleted.</strong></p></li></ul></li></ul><p><strong>Customers to be deleted:</strong> CUST_ID 1, 3, 6, 7.</p><p><strong>Now, let's look at the given options:</strong></p><ul><li><p>All customers who have not placed an order will be deleted only.</p><ul><li><p><strong>True.</strong> This is precisely what the query does, and it matches our finding of customers 1, 3, 6, and 7.</p></li></ul></li><li><p>Customers with IDs 1 and 7 will be deleted only.</p><ul><li><p><strong>False.</strong> Customers 3 and 6 will also be deleted.</p></li></ul></li><li><p>Customers with IDs 1, 6 and 7 will be deleted only.</p><ul><li><p><strong>False.</strong> Customer 3 will also be deleted.</p></li></ul></li><li><p>All customers who have placed an order will be deleted only.</p><ul><li><p><strong>False.</strong> The <code>NOT EXISTS</code> clause does the opposite.</p></li></ul></li><li><p>Customers with IDs 2, 4 and 5 will be deleted only.</p><ul><li><p><strong>False.</strong> These customers have placed orders and will not be deleted.</p></li></ul></li></ul>",
                "answers": [
                    "<p>All customers who have not placed an order will be deleted only.</p>",
                    "<p>Customers with IDs 1 and 7 will be deleted only.</p>",
                    "<p>Customers with IDs 1,6 and 7 will be deleted only.</p>",
                    "<p>All customers who have placed an order will be deleted only.</p>",
                    "<p>Customers with IDs 2, 4 and 5 will be deleted only.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "NOT EXISTS",
            "question_plain": "View and examine the following CUSTOMERS and ORDERS table along with the SQL query exhibit structure. Table: CUSTOMERS CUST_ID                        CUST_NAME                 COUNTRY\n1                              Rachelle                  Mexico\n2                              Rhonda                    Canada\n3                              Roger                     Denmark\n4                              Rick                      Poland\n5                              Raj                       England\n6                              Roberta                   France\n7                              Renaldo                   Colombia\nTable: ORDERS CUST_ID                        ORDER_ID                   ORDER_DATE\n5                              100                        2019/10/10\n2                              200                        2019/11/11\n4                              300                        2019/12/12\n4                              400                        2020/01/01\n5                              500                        2020/02/02\nExhibit: 1DELETE FROM customers\nWHERE NOT EXISTS\n(SELECT *\nFROM orders\nWHERE customers.CUST_ID = orders.CUST_ID);\nIndicate the result of executing the DELETE statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478837,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structures in the available choices.</p><p>Indicate the statement using correct syntax.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DISTINCT Clause](https://www.techonthenet.com/oracle/distinct.php)"
                ],
                "feedbacks": [
                    "The syntax of the NVL function is incorrect in this choice. The DISTINCT keyword should be placed before the column names, not inside the NVL function. Additionally, the column names should be separated by a comma.",
                    "This choice correctly uses the NVL function with the DISTINCT keyword before the column names. The syntax is valid and follows the correct structure for selecting distinct values from the specified columns in the employees table.",
                    "The syntax of the NVL function is incorrect in this choice. The closing parenthesis after 'emp_name' is misplaced, and the DISTINCT keyword should be placed before the column names, not after the NVL function. The column names should also be separated by a comma.",
                    "The syntax of the NVL function is incorrect in this choice. The opening parenthesis after NVL is unnecessary, and the DISTINCT keyword should be placed before the column names, not after the NVL function. The column names should be separated by a comma."
                ],
                "explanation": "<p><strong>Correct SQL statement with proper syntax:</strong></p><pre class=\"prettyprint linenums\">SELECT DISTINCT NVL(emp_name, 'ABC'),&nbsp; phone_number\nFROM&nbsp;employees;</pre><p><br></p><p>Let's break it down:</p><ul><li><p><code><strong>NVL(emp_name, 'ABC')</strong></code>:<br>Replaces <code>NULL</code> values in <code>emp_name</code> with <code>'ABC'</code>.</p></li><li><p><code><strong>DISTINCT</strong></code>:<br>Applies to the entire row of selected columns — removes duplicate combinations of <code>(NVL(emp_name, 'ABC'), phone_number)</code>.</p></li><li><p>This syntax is valid and commonly used in Oracle SQL.</p></li></ul><p>Incorrect Options Breakdown:</p><ol><li><p><code><strong>SELECT NVL(DISTINCT (emp_name), 'ABC'), phone_number</strong></code><br><strong>Incorrect syntax</strong> — <code>DISTINCT</code> is not an argument to the <code>NVL</code> function.</p></li><li><p><code><strong>SELECT NVL(emp_name), 'ABC'), DISTINCT phone_number</strong></code><br><strong>Syntax error</strong> — misplaced parentheses and invalid <code>DISTINCT</code> usage.</p></li><li><p><code><strong>SELECT NVL((emp_name), 'ABC'), DISTINCT phone_number</strong></code><br><strong>Syntax error</strong> — <code>DISTINCT</code> cannot be used like this on an individual column within the select list.</p></li></ol><p><br></p><p>The <code>DISTINCT</code> keyword should be used at the beginning of the <code>SELECT</code> statement right before the column declaration. </p><p>In this example, the <code>DISTINCT</code> clause would return each unique emp_name and phone_number combination.</p><p><strong>The Oracle DISTINCT clause</strong> is used to remove duplicates from the result set. The <code>DISTINCT</code> clause can only be used with <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DISTINCT</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT DISTINCT expressions\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause.</p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT NVL(DISTINCT (emp_name), 'ABC'),&nbsp; phone_number\nFROM&nbsp;employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT NVL(emp_name, 'ABC'),&nbsp; phone_number\nFROM&nbsp;employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(emp_name), 'ABC'),&nbsp; DISTINCT phone_number\nFROM&nbsp;employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL((emp_name), 'ABC'),&nbsp; DISTINCT phone_number\nFROM&nbsp;employees;\n</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "DISTINCT",
            "question_plain": "View and examine the following SQL query structures in the available choices.Indicate the statement using correct syntax.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478839,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following image. </p><p><strong>Exhibit: 1 </strong></p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-54-20-253b9db21fba9c038c888acda1f3e168.png\"><p><br></p><p>Indicate the JOIN type best represented by the available choices.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "There is no such JOIN type as a \"COMPLETE JOIN\" in SQL. It is not a valid option when considering JOIN types in Oracle Database SQL.",
                    "An INNER JOIN returns rows when there is at least one match in both tables being joined. However, based on the image provided, the JOIN type represented is not an INNER JOIN.",
                    "A FULL OUTER JOIN returns all rows when there is a match in one of the tables being joined. It also returns rows from both tables when there is no match. The image does not represent a FULL OUTER JOIN.",
                    "There is no such JOIN type as a \"RIGHT LEFT JOIN\" in SQL. It is not a valid option when considering JOIN types in Oracle Database SQL.",
                    "A RIGHT JOIN returns all rows from the right table and the matched rows from the left table. Based on the image provided, the JOIN type best represented is a RIGHT JOIN."
                ],
                "explanation": "<p>The <code>RIGHT JOIN</code> keyword returns all records from the right table, even if there are no matches in the left table.</p><p><strong>RIGHT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>RIGHT OUTER JOIN</code>. This type of join returns all rows from the RIGHT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>RIGHT OUTER JOIN</code> is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nRIGHT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>RIGHT OUTER JOIN</code> keywords are replaced with RIGHT JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>RIGHT OUTER JOIN</code> returns the shaded area:</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-48-1112abda363494f4f4674610d4a5828b.png\"></p><p><br></p><p>The Oracle <code>RIGHT OUTER JOIN</code> would return the all records from <em>table2</em> and only those records from <em>table1</em> that intersect with <em>table2</em>.</p><p>With a RIGHT OUTER JOIN, all the records of table2, whether they match table1 or not, some of the records in table2 may match records in table1 but matches are not necessary for successful execution.</p>",
                "answers": [
                    "<p><code>COMPLETE JOIN</code> </p>",
                    "<p><code>INNER JOIN</code> </p>",
                    "<p><code>FULL OUTER JOIN</code> </p>",
                    "<p><code>RIGHT LEFT JOIN</code> </p>",
                    "<p><code>RIGHT JOIN</code> </p>"
                ]
            },
            "correct_response": [
                "e"
            ],
            "section": "Joins",
            "question_plain": "View and examine the following image. Exhibit: 1 Indicate the JOIN type best represented by the available choices.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478841,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SUPPLIERS table along with the SQL query exhibit structure. </p><p><strong>Table: SUPPLIERS </strong></p><pre class=\"prettyprint linenums\">SUPPLIER_ID                 SUPPLIER_NAME               CITY                   STATE_PROVINCE\n100                         Microsoft                   Seattle                Washington\n200                         Google                      Mountain View          California\n300                         Oracle                      Redwood City           California\n400                         Kimberly-Clark              Irving                 Texas\n500                         Tyson Foods                 Vancouver              British Columbia\n600                         SC&nbsp;Johnson                  Suffolk                United Kingdom\n700                         Dole Food Co                Oakville               Ontario\n800                         Wonder Bakery               Racine                 Wisconsin\n900                         Electronic Arts             Los Angeles            California\n1000                        TD&nbsp;Bank                     Montreal               Quebec</pre><p><br></p><p>The following SQL query is executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM supplier\nWHERE \n  (state_province = 'California' AND supplier_id &lt;&gt; 900)\n  OR supplier_name = 'Electronic Arts'\n  OR supplier_id = 100;\n</pre><p><br></p><p>Indicated the number of records will the SQL Query return.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The SQL query in the exhibit does not include any conditions or filters, so it will return all records from the SUPPLIERS table. Therefore, it will not return 0 records.",
                    "The SQL query in the exhibit does not include any conditions or filters, so it will return all records from the SUPPLIERS table. Therefore, it will not return only 1 record.",
                    "The SQL query in the exhibit does not include any conditions or filters, so it will return all records from the SUPPLIERS table. Since the SUPPLIERS table has 4 records, the query will return 4 records.",
                    "The SQL query in the exhibit does not include any conditions or filters, so it will return all records from the SUPPLIERS table. Therefore, it will not return 5 records.",
                    "The SQL query in the exhibit does not include any conditions or filters, so it will return all records from the SUPPLIERS table. Since the table has a total of 4 records, the query will return all records."
                ],
                "explanation": "<p>Correct Option: <code><strong>4 records</strong></code><strong> will be returned.</strong></p><p><br></p><p>Break down the SQL query and evaluate it logically using the <strong>SUPPLIERS</strong> table.</p><p><strong>SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM supplier\nWHERE \n  (state_province = 'California' AND supplier_id &lt;&gt; 900)\n  OR supplier_name = 'Electronic Arts'\n  OR supplier_id = 100;\n</pre><p><strong>Step-by-step evaluation:</strong></p><p>Let's examine which rows satisfy <strong>any</strong> of the conditions in the <code>WHERE</code> clause (since it's an <code>OR</code> logic):</p><p><strong>Condition 1</strong>:</p><p><code><strong>state_province = 'California' AND supplier_id &lt;&gt; 900</strong></code></p><ul><li><p>California suppliers:</p><ul><li><p>supplier_id <strong>200</strong> → Google</p></li><li><p>supplier_id <strong>300</strong> → Oracle</p></li><li><p>supplier_id <strong>900</strong> → Electronic Arts (excluded due to <code>supplier_id &lt;&gt; 900</code>)</p></li></ul></li></ul><p>→ <strong>Matches: 200, 300</strong></p><p><strong>Condition 2</strong>:</p><p><code><strong>supplier_name = 'Electronic Arts'</strong></code></p><ul><li><p>supplier_id <strong>900</strong> (included again by name)</p></li></ul><p><strong>Condition 3</strong>:</p><p><code><strong>supplier_id = 100</strong></code></p><ul><li><p>Microsoft</p></li></ul><p><strong>Matching supplier IDs:</strong></p><ul><li><p>100 → Microsoft</p></li><li><p>200 → Google</p></li><li><p>300 → Oracle</p></li><li><p>900 → Electronic Arts</p></li></ul><p>After retrieving the records which conform to the WHERE clause condition mentioned, the OR conditions will be met to include supplier_id 100 and supplier_name 'Electronic Arts'.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-01-13_14-19-06-754fc875aec26c0f190fa55cf830a995.png\"></p><p><br></p><p>Even if it were not for the exclusion of &lt;&gt; 900, there would still be 4 records rendered.</p>",
                "answers": [
                    "<p>0 records.</p>",
                    "<p>1&nbsp; record.</p>",
                    "<p>4 records.</p>",
                    "<p>5 records.</p>",
                    "<p>All&nbsp; records.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "WHERE",
            "question_plain": "View and examine the following SUPPLIERS table along with the SQL query exhibit structure. Table: SUPPLIERS SUPPLIER_ID                 SUPPLIER_NAME               CITY                   STATE_PROVINCE\n100                         Microsoft                   Seattle                Washington\n200                         Google                      Mountain View          California\n300                         Oracle                      Redwood City           California\n400                         Kimberly-Clark              Irving                 Texas\n500                         Tyson Foods                 Vancouver              British Columbia\n600                         SC&nbsp;Johnson                  Suffolk                United Kingdom\n700                         Dole Food Co                Oakville               Ontario\n800                         Wonder Bakery               Racine                 Wisconsin\n900                         Electronic Arts             Los Angeles            California\n1000                        TD&nbsp;Bank                     Montreal               QuebecThe following SQL query is executed.Exhibit: 1SELECT *\nFROM supplier\nWHERE \n  (state_province = 'California' AND supplier_id &lt;&gt; 900)\n  OR supplier_name = 'Electronic Arts'\n  OR supplier_id = 100;\nIndicated the number of records will the SQL Query return.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478843,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees(                               -- Line 1\nemployee_number NUMBER NOT NULL,                      -- Line 2\nlast_name CHAR(50) NOT NULL,                          -- Line 3\nfirst_name VARCHAR2 NOT NULL,                         -- Line 4\nsalary NUMBER,                                        -- Line 5\ndept_id NUMBER,                                       -- Line 6\nCONSTRAINT employees_pk PRIMARY KEY (employee_number) -- Line 7\n);                                                    -- Line 8\n</pre><p><br></p><p><strong>Given:</strong> The SQL query results in a error.</p><p>Identify the line of the code which causes the error.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle VARCHAR2](https://www.oracletutorial.com/oracle-basics/oracle-varchar2/)"
                ],
                "feedbacks": [
                    "Line 1 is the SELECT statement, which is a valid and necessary part of the SQL query. It does not cause the error.",
                    "Line 2 is the FROM clause, specifying the table from which the data is being queried. It is a valid part of the SQL query and does not cause the error.",
                    "Line 3 is the WHERE clause, which filters the data based on specified conditions. It is a standard part of the SQL query and does not cause the error.",
                    "<p>The <code>VARCHAR2</code> datatype needs to be given a length of characters.</p>",
                    "<p>Line 5 is the HAVING clause, which filters the grouped data based on specified conditions. It is a valid part of the SQL query and does not cause the error.</p>",
                    "Line 6 is the ORDER BY clause, which sorts the result set based on specified columns. It is a standard part of the SQL query and does not cause the error.",
                    "Line 7 is the OFFSET clause, which is used for pagination to skip a specified number of rows before returning the result set. It is a valid part of the SQL query and does not cause the error.",
                    "Line 8 is the FETCH clause, which is used for pagination to limit the number of rows returned in the result set. It is a valid part of the SQL query and does not cause the error."
                ],
                "explanation": "<p>Correct Answer:<strong> Line 4 has the error </strong>because <code>VARCHAR2</code> is used <strong>without a length</strong>, which is <strong>required</strong> in Oracle SQL. </p><p><br></p><p>Examine the SQL query line by line for any syntax or semantic errors.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees(                       -- Line 1\nemployee_number NUMBER NOT NULL,              -- Line 2\nlast_name CHAR(50) NOT NULL,                  -- Line 3\nfirst_name VARCHAR2 NOT NULL,                 -- Line 4 ❌\nsalary NUMBER,                                -- Line 5\ndept_id NUMBER,                               -- Line 6\nCONSTRAINT employees_pk PRIMARY KEY (employee_number) -- Line 7\n);                                            -- Line 8\n</pre><p>Explanation of Each Line:</p><ul><li><p><strong>Line 1</strong>: Correct syntax for beginning table creation.</p></li><li><p><strong>Line 2</strong>: Correct – defines a NOT NULL <code>NUMBER</code> column.</p></li><li><p><strong>Line 3</strong>: Correct – defines a <code>CHAR(50)</code> with NOT NULL constraint.</p></li><li><p><strong>Line 4</strong>: <strong>Incorrect</strong> – <code>VARCHAR2</code> <strong>requires a length</strong> specification. The correct syntax is something like <code>VARCHAR2(50) NOT NULL</code>.</p></li><li><p><strong>Line 5</strong>: Valid – optional <code>NUMBER</code> column.</p></li><li><p><strong>Line 6</strong>: Valid – optional <code>NUMBER</code> column.</p></li><li><p><strong>Line 7</strong>: Valid syntax for a primary key constraint.</p></li><li><p><strong>Line 8</strong>: Ends the statement properly.</p></li></ul><p>The <code>VARCHAR2</code> datatype needs to be given a length of characters. Below, we show 20 as the length of characters for <code>first_name</code></p><pre class=\"prettyprint linenums\">CREATE TABLE employees(\nemployee_number number NOT&nbsp;NULL,\nlast_name char(50) NOT&nbsp;NULL,\nfirst_name varchar2(20) NOT&nbsp;NULL,\nsalary number,\ndept_id number,\nCONSTRAINT employees_pk PRIMARY KEY (employee_number)\n);</pre><p><br></p><p>To store variable-length character strings, you use the Oracle <code>VARCHAR2</code> data type. A <code>VARCHAR2</code> column can store a value that ranges from 1 to 4000 bytes. It means that for a single-byte character set, you can store up to 4000 characters in a <code>VARCHAR2</code> column.</p><p>When you <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-create-table/\">create a table</a> with a <code>VARCHAR2</code> column, you must specify the maximum string length, either in bytes:</p><pre class=\"prettyprint linenums\">VARCHAR2(max_size BYTE)Code language: SQL (Structured Query Language) (sql)</pre><p><br></p><p>or in characters</p><pre class=\"prettyprint linenums\">VARCHAR2(max_size CHAR)Code language: SQL (Structured Query Language) (sql)</pre><p><br></p><p>By default, Oracle uses <code>BYTE</code> if you don’t explicitly specify <code>BYTE</code> or <code>CHAR</code> after the <code>max_size</code>. In other words, a <code>VARCHAR2(N)</code> column can hold up to <code>N</code> bytes of characters.</p><p>If you store a character string whose size exceeds the maximum size of the <code>VARCHAR2</code> column, Oracle issues an error.</p><p>For example, if you define a <code>VARCHAR2</code> column with a maximum size is 20. In a single-byte character set, you can store up to 20 characters. If you store 21 characters or more, Oracle returns an error.</p><p>In addition, if you store 10 characters in a <code>VARCHAR2(20)</code> column, Oracle uses only 10 bytes for storage, not 20 bytes. Therefore, using <code>VARCHAR2</code> data type helps you save spaces used by the table.</p><p>When comparing <code>VARCHAR2</code> values, Oracle uses the non-padded comparison semantics.</p>",
                "answers": [
                    "<p>Line 1</p>",
                    "<p>Line 2</p>",
                    "<p>Line 3</p>",
                    "<p>Line 4</p>",
                    "<p>Line 5</p>",
                    "<p>Line 6</p>",
                    "<p>Line 7</p>",
                    "<p>Line 8</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "VARCHAR2",
            "question_plain": "View and examine the following SQL query structure. Exhibit: 1CREATE TABLE employees(                               -- Line 1\nemployee_number NUMBER NOT NULL,                      -- Line 2\nlast_name CHAR(50) NOT NULL,                          -- Line 3\nfirst_name VARCHAR2 NOT NULL,                         -- Line 4\nsalary NUMBER,                                        -- Line 5\ndept_id NUMBER,                                       -- Line 6\nCONSTRAINT employees_pk PRIMARY KEY (employee_number) -- Line 7\n);                                                    -- Line 8\nGiven: The SQL query results in a error.Identify the line of the code which causes the error.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478845,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following image.</p><p><strong>Exhibit: 1</strong></p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-54-38-4e9b0c6f46f9a722211ecb6ce70fc489.png\"><p><br></p><p>Indicate the JOIN type best represented by the available choices.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "COMPLETE JOIN is not a standard SQL join type. It does not exist in SQL syntax and is not a valid option for representing a join type in Oracle Database SQL 1Z0-071.",
                    "INNER JOIN returns rows when there is at least one match in both tables being joined. It does not include rows that do not have matching values in both tables. The image provided does not show an INNER JOIN, as it includes rows from both tables even if there is no match.",
                    "FULL OUTER JOIN returns all rows when there is a match in either the left or right table. It includes rows from both tables even if there is no match in the other table. The image provided best represents a FULL OUTER JOIN as it includes all rows from both tables.",
                    "LEFT RIGHT JOIN is not a valid join type in SQL. The correct syntax for this type of join is LEFT JOIN or RIGHT JOIN, not a combination of both. It is not applicable in the context of the image provided."
                ],
                "explanation": "<p>A <code>FULL OUTER JOIN</code> includes everything between the 2 tables.</p><p><strong>Oracle JOINS</strong> are used to retrieve data from multiple tables. An Oracle <code>JOIN</code> is performed whenever two or more tables are joined in a SQL statement.</p><p><strong>There are 4 different types of Oracle joins:</strong></p><p>Oracle <code>INNER JOIN</code> (or sometimes called simple join)</p><p>Oracle <code>LEFT OUTER JOIN</code> (or sometimes called <code>LEFT JOIN</code>)</p><p>Oracle <code>RIGHT OUTER JOIN</code> (or sometimes called <code>RIGHT JOIN</code>)</p><p>Oracle <code>FULL OUTER JOIN</code> (or sometimes called <code>FULL JOIN</code>)</p><p><strong>FULL OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>FULL OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table and RIGHT-hand table with nulls in place where the join condition is not met.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>FULL OUTER JOIN</code> is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nFULL [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>FULL OUTER JOIN</code> keywords are replaced with FULL JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>FULL OUTER JOIN</code> returns the shaded area:</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-37-23-693a8eb7a6e48912a42bf894a4d6ab7e.png\"></p><p><br></p><p>The Oracle <code>FULL OUTER JOIN</code> would return the all records from both <em>table1</em> and <em>table2</em>.</p>",
                "answers": [
                    "<p><code>COMPLETE JOIN</code> </p>",
                    "<p><code>INNER JOIN</code> </p>",
                    "<p><code>FULL OUTER JOIN</code> </p>",
                    "<p><code>LEFT RIGHT JOIN</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following image.Exhibit: 1Indicate the JOIN type best represented by the available choices.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478847,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><pre class=\"prettyprint linenums\">SELECT *\nFROM customers C\nWHERE first_name IN (\n    SELECT first_name\n    FROM customers\n    WHERE C.customer_id != customer_id\n)\nOR 5 = 5;</pre><p><br></p><p><strong>Given: </strong>The customers table has 5025 records.</p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query does not have any condition to limit the number of records returned to 5. Therefore, it will return all 5025 records from the customers table, not just the ones with the last_name 'Smith'.",
                    "There is no syntax error or logical error in the query that would cause it to fail. As long as the customers table exists and has the specified number of records, the query should execute successfully.",
                    "The query does not have any conditions or filters applied to restrict the number of records returned from the customers table. As a result, it will return all 5025 records present in the table.",
                    "Since there are no filtering conditions in the query that would exclude all records from being returned, the query will not return an empty result set. It will return all 5025 records from the customers table.",
                    "The query structure does not contain any elements that would lead to an unexpected or different outcome than what is described in the other choices. Therefore, the correct response is that the query will return all 5025 records from the customers table."
                ],
                "explanation": "<p>Correct Answer: <strong>The query will return 5025 records.</strong></p><p>The query ends up selecting <strong>every row</strong> from the <code>customers</code> table:</p><p>Breakdown of the Query</p><pre class=\"prettyprint linenums\">SELECT *\nFROM customers C\nWHERE first_name IN (\n    SELECT first_name\n    FROM customers\n    WHERE C.customer_id != customer_id\n)\nOR 5 = 5;\n</pre><ul><li><p><strong>Table Alias</strong>: <code>customers C</code> uses alias <code>C</code>, and this alias is referenced inside the subquery. Normally, referencing an outer query's alias inside a subquery causes problems <strong>unless the subquery is correlated properly</strong>, which this query attempts to do.</p></li><li><p><strong>Subquery Logic</strong>: It's looking for <code>first_name</code> values from all other <code>customers</code> where <code>customer_id != C.customer_id</code>. So for each row in the outer query, it pulls all <code>first_name</code> values except the one with the same <code>customer_id</code>.</p></li><li><p><strong>Main Clause – OR 5 = 5</strong>:<br>This is the <strong>key</strong> to the query's behavior.</p><ul><li><p><code>OR 5 = 5</code> is always <strong>true</strong>, so even if the <code>first_name IN (...)</code> fails or has no match, the condition <code>OR 5 = 5</code> makes the entire <code>WHERE</code> clause evaluate to <strong>true for every row</strong>.</p></li></ul></li></ul><p><strong>Outcome</strong></p><p>The condition <code>OR 5 = 5</code> causes the query to ignore all filtering logic and return <strong>every record</strong> from the <code>customers</code> table. Since the table has <strong>5025 records</strong>, that’s what you get.</p>",
                "answers": [
                    "<p>The query will return a maximum of 5 records with the last_name 'Smith'.</p>",
                    "<p>The query will fail to execute and return an error.</p>",
                    "<p>The query will return 5025 records.</p>",
                    "<p>The query will return no records.</p>",
                    "<p>None of the responses listed.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "OR",
            "question_plain": "View and examine the following SQL query structure. SELECT *\nFROM customers C\nWHERE first_name IN (\n    SELECT first_name\n    FROM customers\n    WHERE C.customer_id != customer_id\n)\nOR 5 = 5;Given: The customers table has 5025 records.Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478849,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Indicate the responses which are equivalent to one another.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[IN](https://www.oracletutorial.com/oracle-basics/oracle-in/)",
                    "[BETWEEN](https://www.oracletutorial.com/oracle-basics/oracle-between/)"
                ],
                "feedbacks": [
                    "The WHERE clause with the IN operator checks for values that match any of the specified values in the list. In this case, it checks for sales_price values of 100, 101, 102, 103, 104, 105, and 106 individually.",
                    "The WHERE clause with the &gt;= (greater than or equal to) and &lt;= (less than or equal to) operators checks for values that fall within the specified range, in this case, between 100 and 106, inclusive.",
                    "The WHERE clause with the BETWEEN operator checks for values that fall within the specified range, including the boundary values. In this case, it checks for sales_price values between 99 and 106, inclusive.",
                    "<p>The WHERE clause with the BETWEEN operator checks for values that fall within the specified range, including the boundary values. In this case, it checks for sales_price values between 100 and 106, inclusive.</p>",
                    "The WHERE clause with the &gt; (greater than) and &lt; (less than) operators checks for values that fall within the specified range but excludes the boundary values. In this case, it checks for sales_price values greater than 100 and less than 106."
                ],
                "explanation": "<p>The equivalent responses are:</p><ul><li><p><code>WHERE sales_price &gt;= 100 AND sales_price &lt;= 106;</code></p></li><li><p><code>WHERE sales_price BETWEEN 100 AND 106;</code></p></li></ul><p><br></p><p>Both <code>BETWEEN</code> and the combination of <code>&gt;=</code> and <code>&lt;=</code> operators are inclusive. This means they both include the starting and ending values in the range.</p><p>The other options are not equivalent:</p><ul><li><p><code>WHERE sales_price IN (100, 101, 102, 103, 104, 105, 106);</code> This is only equivalent if <code>sales_price</code> can only take on integer values. If <code>sales_price</code> can be a decimal (e.g., 100.5), then this <code>IN</code> clause would not include it, whereas the <code>BETWEEN</code> and <code>&gt;= &lt;=</code> clauses would.</p></li><li><p><code>WHERE sales_price BETWEEN 99 AND 106;</code> This includes 99, which the first two do not.</p></li><li><p><code>WHERE sales_price &gt; 100 AND sales_price &lt; 106;</code> This is exclusive, meaning it does not include 100 or 106.</p></li></ul><p><strong>Oracle IN</strong></p><p>The Oracle <code>IN</code> operator determines whether a value matches any values in a list or a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\">subquery</a>. The <code>IN</code> is looking for specific values. There are many decimal values between 101 and 106 which the IN values (100, 101, 102, 103, 104, 105, 106) do not account for.</p><pre class=\"prettyprint linenums\">expression IN (subquery)</pre><p><br></p><p><strong>Oracle BETWEEN </strong></p><p>The <code>BETWEEN</code> operator is inclusive of the beginning and end range.&nbsp; The <code>BETWEEN</code> operator allows you to specify a range to test. When you use the <code>BETWEEN</code> operator to form a search condition for rows returned by a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement, only rows whose values are in the specified range are returned.</p><p>The following illustrates the syntax of the <code>BETWEEN</code> operator:</p><pre class=\"prettyprint linenums\">expression BETWEEN low AND high</pre>",
                "answers": [
                    "<p><code>WHERE sales_price IN (100, 101, 102, 103, 104, 105, 106);</code> </p>",
                    "<p><code>WHERE sales_price &gt;= 100 AND&nbsp; sales_price &lt;= 106;</code> </p>",
                    "<p><code>WHERE sales_price BETWEEN 99 AND 106;</code> </p>",
                    "<p><code>WHERE sales_price BETWEEN 100 AND 106;</code> </p>",
                    "<p><code>WHERE sales_price &gt; 100 AND&nbsp; sales_price &lt; 106;</code> </p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Indicate the responses which are equivalent to one another.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478851,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT product_location, AVG(sales_price)\nFROM products\nWHERE product_type = ('Cosmetic', 'Clothing', 'Jewellery')\nHAVING COUNT(*) &gt; 20\nGROUP BY product_type\nORDER BY AVG(sales_price) DESC;\n</pre><p><br></p><p><strong>Given:</strong> The above query generates and error when executed.</p><p>Indicate the syntax errors in the code from the available choices. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[GROUP BY clause](https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj32654.html)",
                    "[Oracle / PLSQL: IN Condition](https://www.techonthenet.com/oracle/in.php)"
                ],
                "feedbacks": [
                    "The HAVING operator is used to filter groups based on aggregate functions, such as COUNT, SUM, or AVG. In this case, the query is trying to filter based on sales_price, which is not an aggregate function. Therefore, the HAVING clause should be modified to filter based on aggregate functions like COUNT.",
                    "The ORDER BY clause is used to sort the result set based on specified columns. In this query, the ORDER BY clause is trying to sort based on sales_price, which is not an aggregate function. To correct this error, the ORDER BY clause should be modified to sort based on columns that are part of the SELECT statement or aggregate functions.",
                    "In SQL, when using the GROUP BY clause, all non-aggregated columns in the SELECT statement must be included in the GROUP BY clause. In this query, product_location is not listed in the GROUP BY clause, which results in a syntax error. To fix this error, product_location should be included in the GROUP BY clause.",
                    "In the WHERE clause, the equal sign (=) is used for exact matches between a single value and a column. However, if you want to check if a column value exists within a list of elements, the IN operator should be used instead. Using the IN operator allows for checking multiple values against a single column, which is not possible with the equal sign.",
                    "This option is incorrect because not all of the options provided are correct. Choices C and D point out specific syntax errors in the query that need to be addressed for the query to execute successfully."
                ],
                "explanation": "<p>Correct Answers: <strong>Two valid syntax errors:</strong></p><ul><li><p><strong>The </strong><code><strong>product_location</strong></code><strong> is not listed in the </strong><code><strong>GROUP BY</strong></code><strong> clause.</strong></p></li><li><p><strong>In the </strong><code><strong>WHERE</strong></code><strong> clause, an </strong><code><strong>IN</strong></code><strong> operator should be used to check within a list of elements rather than an equal sign.</strong></p></li></ul><p>Incorrect Choices:</p><ul><li><p>The <code>HAVING</code> and <code>ORDER BY</code> explanations are not valid SQL errors.</p></li><li><p>\"All of the options are correct.\" — <strong>False.</strong> Only two are actual errors.</p><p><br></p></li></ul><p>Examine the SQL query and identify the syntax errors.</p><p><strong>Exhibit:</strong></p><pre class=\"prettyprint linenums\">SELECT product_location, AVG(sales_price)\nFROM products\nWHERE product_type = ('Cosmetic', 'Clothing', 'Jewellery')\nHAVING COUNT(*) &gt; 20\nGROUP BY product_type\nORDER BY AVG(sales_price) DESC;\n</pre><p><strong>Identifying Issues:</strong></p><p><strong>1. WHERE clause:</strong></p><pre class=\"prettyprint linenums\">WHERE product_type = ('Cosmetic', 'Clothing', 'Jewellery')\n</pre><ul><li><p>This is <strong>invalid syntax</strong>.</p></li><li><p>To check if a value is within a list, you must use <code><strong>IN</strong></code>:</p></li><li><p>The IN operator is used to check within multiple elements.</p></li></ul><pre class=\"prettyprint linenums\">WHERE product_type IN ('Cosmetic', 'Clothing', 'Jewellery')\n</pre><p><strong>Error #1 Identified</strong></p><p><br></p><p><strong>2. SELECT clause vs GROUP BY:</strong></p><pre class=\"prettyprint linenums\">SELECT product_location, AVG(sales_price)\nGROUP BY product_type\n</pre><ul><li><p><code>product_location</code> is <strong>not</strong> part of the <code>GROUP BY</code> clause.</p></li><li><p>If you're selecting a column that is <strong>not</strong> an aggregate function (like <code>AVG()</code>) or in the <code>GROUP BY</code>, it's a syntax error in standard SQL.</p></li><li><p>When using a GROUP BY, the columns in the SELECT list must also be in the GROUP BY Clause. </p></li></ul><p><strong>Error #2 Identified</strong></p><p><strong>Not true:</strong></p><ul><li><p>\"The <code>HAVING</code> clause should filter on <code>sales_price</code> not <code>COUNT(*)</code>\" — this is <strong>incorrect</strong>. You <strong>can</strong> use <code>HAVING COUNT(*) &gt; 20</code> perfectly legally.</p></li><li><p>\"The <code>ORDER BY</code> clause should filter based on <code>sales_price</code>...\" — this makes no sense; <code>ORDER BY</code> is for sorting, not filtering.</p></li></ul>",
                "answers": [
                    "<p>The HAVING&nbsp;operator should be filtering based on sales_price and not count of records.</p>",
                    "<p>The ORDER&nbsp;BY&nbsp;clause should be filtering based on sales_price and not count of records.</p>",
                    "<p>The product_location is not listed in the GROUP&nbsp;BY clause.</p>",
                    "<p>In the WHERE&nbsp;clause, an IN operator should be used to check within a list of elements rather than an equal sign.</p>",
                    "<p>All of the options are correct.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "GROUP BY",
            "question_plain": "View and examine the following SQL query structure. Exhibit: 1SELECT product_location, AVG(sales_price)\nFROM products\nWHERE product_type = ('Cosmetic', 'Clothing', 'Jewellery')\nHAVING COUNT(*) &gt; 20\nGROUP BY product_type\nORDER BY AVG(sales_price) DESC;\nGiven: The above query generates and error when executed.Indicate the syntax errors in the code from the available choices. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478853,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses. </p><p>Indicate the query which will create a projection of the ENAME and DEPTNO columns from the EMPLOYEES table.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[https://www.answers.com/Q/What_does_projection_mean_in_Oracle](https://www.answers.com/Q/What_does_projection_mean_in_Oracle)"
                ],
                "feedbacks": [
                    "This query is incorrect because it references the table as 'emp' instead of 'employees' and may result in a table or view not found error.",
                    "This query is incorrect because it includes the 'dept_location' column in the projection, which is not specified in the question. It should only project the 'ENAME' and 'DEPTNO' columns.",
                    "This query is correct as it selects the 'ENAME' and 'DEPTNO' columns from the 'employees' table, which matches the requirement of creating a projection of those specific columns.",
                    "This query is incorrect because it has a syntax error in the column alias for 'ENAME'. The alias is missing the closing double quotation mark, which would result in a syntax error when executed."
                ],
                "explanation": "<p>Projection means a <code>SELECT</code> query.</p><p>Evaluate each query to determine <strong>which one correctly creates a projection of the </strong><code><strong>ENAME</strong></code><strong> and </strong><code><strong>DEPTNO</strong></code><strong> columns from the </strong><code><strong>EMPLOYEES</strong></code><strong> table</strong>.</p><p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT ename, deptno \nFROM employees;\n</pre><ul><li><p>This correctly selects (i.e., <strong>projects</strong>) only the <code>ename</code> and <code>deptno</code> columns from the <code><strong>employees</strong></code> table.</p></li><li><p>Syntax is valid.</p></li><li><p>Matches the question exactly.</p></li><li><p>The <strong>only correct query</strong> that produces a valid projection of the <code>ENAME</code> and <code>DEPTNO</code> columns from the <code>EMPLOYEES</code> table.</p></li></ul><p><strong>Incorrect Options:</strong></p><ol><li><pre class=\"prettyprint linenums\">SELECT ename, deptno \nFROM emp;\n</pre><ul><li><p>Table name is <code>emp</code>, <strong>not</strong> <code>employees</code>, so <strong>not correct</strong> unless <code>emp</code> is an alias (which it isn’t here).</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT ename, deptno, dept_location \nFROM employees;\n</pre><ul><li><p>This selects <strong>an extra column</strong> (<code>dept_location</code>) — <strong>not</strong> just a projection of <code>ename</code> and <code>deptno</code>.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT ename AS \"employee_name\nFROM employees;\n</pre><ul><li><p>Missing closing quote on the alias <code>\"employee_name</code>. This will cause a <strong>syntax error</strong>.</p></li></ul></li></ol>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT ename, deptno \nFROM emp;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename, deptno, dept_location \nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename, deptno \nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT ename AS \"employee_name\nFROM employees;\n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL statement",
            "question_plain": "View and examine the following available responses. Indicate the query which will create a projection of the ENAME and DEPTNO columns from the EMPLOYEES table.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478855,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses. </p><p>Indicate the statements which are true regarding subqueries. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "Subqueries can indeed have nested subqueries within them. This allows for more complex and layered querying capabilities in SQL.",
                    "A correlated subquery is a type of subquery that is linked on a common column of the outer query in which it is contained. This allows the subquery to reference values from the outer query, making it dependent on the outer query's results.",
                    "A subquery does not necessarily have to retrieve at least one row. Depending on the context and the purpose of the subquery, it can return zero, one, or multiple rows without generating an error upon execution.",
                    "A scalar comparison operator such as ' &gt; ' or ' &lt;= ' can be used to compare the result of the subquery only if the result is a single value. This is because scalar subqueries return a single value, making them suitable for comparison operations with other single values."
                ],
                "explanation": "<p>Correct Statements:</p><ul><li><p><strong>A correlated subquery is a type of subquery that is linked on a common column of the outer query in which it is contained.</strong></p></li><li><p><strong>A scalar comparison operator such as ' &gt; ' or ' &lt;= ' can be used to compare the result of the subquery only if the result is a single value.</strong></p></li></ul><p><br></p><p>Examine each statement to determine which are <strong>true</strong> regarding <strong>subqueries</strong> in SQL:</p><p><strong>1. \"A correlated subquery is a type of subquery that is linked on a common column of the outer query in which it is contained.\"</strong></p><ul><li><p><strong>True.</strong><br>A <strong>correlated subquery</strong> refers to a column from the outer query and executes <strong>once for each row</strong> of the outer query. It depends on the outer query for its values.</p></li></ul><p><strong>2. \"A scalar comparison operator such as </strong><code><strong>&gt;</strong></code><strong> or </strong><code><strong>&lt;=</strong></code><strong> can be used to compare the result of the subquery only if the result is a single value.\"</strong></p><ul><li><p><strong>True.</strong><br>This describes a <strong>scalar subquery</strong>, which must return <strong>exactly one value</strong>. If it returns multiple values, it results in an <strong>error</strong> when used with scalar operators.</p></li></ul><p><strong>3. \"Subqueries cannot have nested subqueries within them.\"</strong></p><ul><li><p><strong>False.</strong><br>Subqueries <strong>can</strong> be <strong>nested</strong> — even multiple levels deep (e.g., a subquery inside a subquery). This is valid and supported in SQL.</p></li></ul><p><strong>4. \"A subquery must retrieve at least one row otherwise an error will be generated upon execution.\"</strong></p><ul><li><p><strong>False.</strong><br>If a subquery returns <strong>no rows</strong>, it does <strong>not</strong> cause an error.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">WHERE dept_id = (SELECT dept_id FROM departments WHERE dept_name = 'XYZ')\n</pre><p>If the subquery returns no rows, the condition evaluates to <strong>FALSE or NULL</strong>, but it doesn’t throw an error unless used incorrectly (e.g., expecting one row but getting multiple).</p></li><li><p>Subqueries can return zero or more records and there is no limit to the depth of levels to which a subquery can be nested.</p></li></ul>",
                "answers": [
                    "<p>Subqueries cannot have nested subqueries within them.</p>",
                    "<p>A correlated subquery is a type of subquery that is linked on a common column of the outer query in which it is contained.</p>",
                    "<p>A subquery must retrieve at least one row otherwise an error will be generated upon execution.</p>",
                    "<p>A scalar comparison operator such as ' &gt; ' or ' &lt;= ' can be used to compare the result of the subquery only if the result is a single value.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses. Indicate the statements which are true regarding subqueries. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478857,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL query structure. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT 'Product Name: ' || prod_name\nFROM products \nWHERE store_id = 51;\n</pre><p><br></p><p>Indicate the two literal components of the preceding SELECT query from the given choices.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Literals](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Literals.html)"
                ],
                "feedbacks": [
                    "prod_name is not a literal component in the SELECT query structure provided. It is a column name or an identifier, not a literal value.",
                    "The literal value '51' is a component of the SELECT query structure provided. It is a specific value that is being selected or manipulated in the query.",
                    "The literal value 'Product Name:' is not a component of the SELECT query structure provided. It is a string or label, not a literal value.",
                    "store_id is not a literal component in the SELECT query structure provided. It is a column name or an identifier, not a literal value.",
                    "SELECT is a keyword in SQL used to retrieve data from a database, not a literal value.",
                    "FROM is a keyword in SQL used to specify the table from which data is retrieved, not a literal value.",
                    "WHERE is a keyword in SQL used to filter rows based on a specified condition, not a literal value.",
                    "|| is an operator in SQL used for concatenating strings, not a literal value in the SELECT query structure provided."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ul><li><p><code><strong>'Product Name: '</strong></code></p></li><li><p><code><strong>51</strong></code></p></li></ul><p><strong>What is a Literal in SQL?</strong></p><p>A <strong>literal</strong> is a fixed value that is written directly in the query — it is <strong>not</strong> a column name, table name, clause, or operator.</p><p>The terms <strong>literal</strong> and <strong>constant value</strong> are synonymous and refer to a fixed data value. </p><p>For example, 'Product Name:', 'BLUE ISLAND', and '101' are all character literals; 51 is a numeric literal. Character literals are enclosed in single quotation marks so that Oracle can distinguish them from schema object names.</p><p><br></p><p>Examine the query and identify the <strong>literal components</strong>:</p><p><strong>Exhibit:</strong></p><pre class=\"prettyprint linenums\">SELECT 'Product Name: ' || prod_name\nFROM products \nWHERE store_id = 51;\n</pre><p><br></p><p><strong>Literal Components in the Query:</strong></p><ol><li><p><code><strong>'Product Name: '</strong></code></p><ul><li><p>This is a <strong>string literal</strong> used in the <code>SELECT</code> clause.</p></li></ul></li><li><p><code><strong>51</strong></code></p><ul><li><p>This is a <strong>numeric literal</strong> used in the <code>WHERE</code> clause.</p></li></ul></li></ol><p><strong>Not Literals:</strong></p><ul><li><p><code>prod_name</code> → Column name</p></li><li><p><code>store_id</code> → Column name</p></li><li><p><code>SELECT</code>, <code>FROM</code>, <code>WHERE</code> → SQL <strong>keywords</strong></p></li><li><p><code>||</code> → SQL <strong>concatenation operator</strong></p></li></ul>",
                "answers": [
                    "<p><code>prod_name</code> </p>",
                    "<p><code>51</code> </p>",
                    "<p><code>Product Name:</code> </p>",
                    "<p><code>store_id</code> </p>",
                    "<p><code>SELECT</code> </p>",
                    "<p><code>FROM</code> </p>",
                    "<p><code>WHERE</code> </p>",
                    "<p><code>||</code> </p>"
                ]
            },
            "correct_response": [
                "b",
                "c"
            ],
            "section": "Literals",
            "question_plain": "View and examine the following SQL query structure. Exhibit: 1SELECT 'Product Name: ' || prod_name\nFROM products \nWHERE store_id = 51;\nIndicate the two literal components of the preceding SELECT query from the given choices.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478859,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario: </strong>You are working at a company where you have to record emergency contacts of employees with various phone numbers: work phone, home phone, and cell phone. To do it, you create a new table named <code>emergency_contacts</code> as follows:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE  TABLE emergency_contacts  (\n    contact_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,\n    employee_id  NUMBER NOT NULL,\n    first_name   VARCHAR2(100) NOT NULL,\n    last_name    VARCHAR2(100) NOT NULL,\n    relationship VARCHAR2(100),\n    home_phone   VARCHAR2(25),\n    work_phone   VARCHAR2(25),\n    cell_phone   VARCHAR2(25),\n    PRIMARY KEY (contact_id),\n    FOREIGN KEY (employee_id) \n    REFERENCES employees(employee_id) ON DELETE CASCADE\n); </pre><p><br></p><p>The following statements insert some emergency contacts into the table:</p><pre class=\"prettyprint linenums\">INSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 1,\n         'Mary',\n         'Bailey',\n         'Wife',\n         NULL,\n         '515.123.4568',\n         '515.123.4569' );\n\n\nINSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 2,\n         'John',\n         'Rivera',\n         'Husband',\n         NULL,\n         NULL,\n         '515.123.3563' );\n\n\nINSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 3,\n         'Joan',\n         'Cooper',\n         'Mother',\n         NULL,\n         NULL,\n         NULL );</pre><p><br></p><p>Some contacts have only work phone while others may have a home phone and cell phone or do not have any phone number at all.</p><p>You run the following query retrieves the employees and their emergency contacts with phone numbers:</p><pre class=\"prettyprint linenums\">SELECT\n  e.first_name  || ' '  || e.last_name employee,\n  c.first_name  || ' '  || c.last_name contact,\n  relationship,\n  COALESCE(home_phone, work_phone, cell_phone, 'N/A') phone\nFROM\n  emergency_contacts c\nINNER JOIN employees e  USING (employee_id); </pre><p><br></p><p>Which of the following will be the result of the query?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle COALESCE Function](https://www.oracletutorial.com/oracle-comparison-functions/oracle-coalesce/)"
                ],
                "feedbacks": [
                    "The COALESCE function is used to handle null values in the phone number fields. It returns the first non-null value from the list of arguments. If all phone fields are null, the function will return 'N/A', indicating that no phone number is available for that contact.",
                    "The query will not fail due to a null value in the PHONE field. The COALESCE function is designed to handle null values by returning the first non-null value from the list of arguments. If all phone number fields are null for a contact, the COALESCE function will return 'N/A', ensuring the query's successful execution.",
                    "The query will not show 0 for the PHONE field. The COALESCE function is designed to handle null values and return the first non-null value from the list of arguments. If a contact does not have any phone number, the COALESCE function will return 'N/A', not 0.",
                    "The query will not fail due to the COALESCE() function using arguments of different types. The COALESCE function is designed to handle different data types and will return the first non-null value from the list of arguments, regardless of their data types. If all phone number fields are null for a contact, the COALESCE function will return 'N/A', ensuring the query's successful execution."
                ],
                "explanation": "<p>Because the <code>COALESCE()</code> function tried to convert the character type of the third argument to a numeric type of the second argument that resulted in an error.</p><p>In this Scenario, we used the <code>COALESCE()</code> function to select home phone, work phone, or cell phone if each is available. In case no phone numbers are available, we returned <code>N/A</code> literal string which stands for not available.</p><p>The following shows the result of the query:</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/12/Oracle-coalesce-function-example.png\"></p><p><br></p><p><strong>Oracle COALESCE Function</strong></p><p>The Oracle <code>COALESCE()</code> function accepts a list of arguments and returns the first one that evaluates to a non-null value.</p><p>The following illustrates the syntax of the Oracle <code>COALESCE()</code> function:</p><pre class=\"prettyprint linenums\">COALESCE(e1, e2, ..., en)</pre><p><br></p><p>In this syntax, the <code>COALESCE()</code> function returns the first non-null expression in the list. It requires at least two expressions. In case all expressions evaluate to null, the function returns null.</p><p>The following example returns one because it is the first non-null argument:</p><pre class=\"prettyprint linenums\">SELECT\n  COALESCE(NULL,1) -- return 1\nFROM\n  dual;</pre><pre class=\"prettyprint linenums\">    RESULT\n----------\n         1</pre><p><br></p><p>The following example returns null because all arguments are null:</p><pre class=\"prettyprint linenums\">SELECT\n  COALESCE(NULL,NULL,NULL) -- return NULL\nFROM\n  dual; </pre><p><br></p><p><strong>Return type</strong></p><p>If all arguments have the same data type, the <code>COALESCE()</code> function returns a value of that data type.</p><p>If the arguments have different <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-data-types/\">data types</a>, the <code>COALESCE()</code> function implicitly converts all arguments to the data type of the first non-null argument. In case the conversion fails, then Oracle issues an error.</p><p>The following example returns a value with <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-char/\">character type</a> because all arguments are characters.</p><pre class=\"prettyprint linenums\">SELECT\n  COALESCE(NULL,'A','B') result\nFROM\n  dual;</pre><pre class=\"prettyprint linenums\">RESULT\n-------</pre><p><br></p><p>Similarly, the following example returns a value with <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-number-data-type/\">numeric type</a>:</p><pre class=\"prettyprint linenums\">SELECT\n  COALESCE(NULL,1,2) result\nFROM\n  dual;  </pre><pre class=\"prettyprint linenums\">    RESULT\n----------\n         1</pre><p><br></p><p>However, the following example uses arguments of different types for the <code>COALESCE()</code> function:</p><pre class=\"prettyprint linenums\">SELECT\n  COALESCE(NULL,1,'A')\nFROM\n  dual;  </pre><p><br></p><p>Oracle issued the following error:</p><pre class=\"prettyprint linenums\">ORA-00932: inconsistent datatypes: expected NUMBER got CHAR</pre>",
                "answers": [
                    "<p>One of the records would show N/A for the <code>PHONE</code> field</p>",
                    "<p>The query would fail due to a null value in the&nbsp; <code>PHONE</code> field</p>",
                    "<p>One of the records would show <code>0</code> for the <code>PHONE</code> field</p>",
                    "<p>The query would fail due to the query using arguments of different types for the <code>COALESCE()</code> function</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "COALESCE",
            "question_plain": "Scenario: You are working at a company where you have to record emergency contacts of employees with various phone numbers: work phone, home phone, and cell phone. To do it, you create a new table named emergency_contacts as follows:CREATE  TABLE emergency_contacts  (\n    contact_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,\n    employee_id  NUMBER NOT NULL,\n    first_name   VARCHAR2(100) NOT NULL,\n    last_name    VARCHAR2(100) NOT NULL,\n    relationship VARCHAR2(100),\n    home_phone   VARCHAR2(25),\n    work_phone   VARCHAR2(25),\n    cell_phone   VARCHAR2(25),\n    PRIMARY KEY (contact_id),\n    FOREIGN KEY (employee_id) \n    REFERENCES employees(employee_id) ON DELETE CASCADE\n); The following statements insert some emergency contacts into the table:INSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 1,\n         'Mary',\n         'Bailey',\n         'Wife',\n         NULL,\n         '515.123.4568',\n         '515.123.4569' );\n\n\nINSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 2,\n         'John',\n         'Rivera',\n         'Husband',\n         NULL,\n         NULL,\n         '515.123.3563' );\n\n\nINSERT INTO emergency_contacts ( employee_id, first_name, last_name, relationship, home_phone, work_phone, cell_phone )\nVALUES ( 3,\n         'Joan',\n         'Cooper',\n         'Mother',\n         NULL,\n         NULL,\n         NULL );Some contacts have only work phone while others may have a home phone and cell phone or do not have any phone number at all.You run the following query retrieves the employees and their emergency contacts with phone numbers:SELECT\n  e.first_name  || ' '  || e.last_name employee,\n  c.first_name  || ' '  || c.last_name contact,\n  relationship,\n  COALESCE(home_phone, work_phone, cell_phone, 'N/A') phone\nFROM\n  emergency_contacts c\nINNER JOIN employees e  USING (employee_id); Which of the following will be the result of the query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478861,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You are trying to insert a new employee record into the <code>EMPLOYEES</code> table. The <code>HIRE_DATE</code> column in the table is defined as <code>DATE</code>, but you are attempting to insert a string literal <code>'01-JAN-2025'</code> without any explicit conversion.</p><pre class=\"prettyprint linenums\">INSERT INTO EMPLOYEES (employee_id, first_name, last_name, hire_date, salary)\nVALUES (207, 'Alice', 'Smith', '01-JAN-2025', 65000);</pre><p><br></p><p><strong>Problem:</strong> The <code>INSERT</code> statement fails with an ORA error.</p><p>Which of the following is the most likely cause of the error?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Type Comparison Rules](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Data-Type-Comparison-Rules.html#GUID-1563C817-86BF-430B-99AB-322EE2E29187)"
                ],
                "feedbacks": [
                    "The most likely cause of the error is an implicit data type conversion failure for the hire_date column. When trying to insert a string literal '01-JAN-2025' into a DATE column without explicit conversion, Oracle will encounter a data type mismatch and fail the INSERT statement.",
                    "The error is not related to the employee_id already existing in the table. The primary key violation would result in a different error message, not an ORA error due to data type conversion failure.",
                    "The error is not caused by the salary value being too high for the SALARY column. Oracle would not fail the INSERT statement due to the salary value exceeding a limit, as long as it is within the defined data type range.",
                    "The error is not related to a missing primary key constraint on the EMPLOYEES table. While a primary key constraint is important for data integrity, its absence would not directly cause the ORA error in this scenario."
                ],
                "explanation": "<p>Most Likely Cause of Error: <strong>There is an implicit data type conversion failure for the </strong><code><strong>hire_date</strong></code><strong> column.</strong></p><p><br></p><p>Analyze the <strong>INSERT</strong> statement and the scenario:</p><p><strong>Statement:</strong></p><pre class=\"prettyprint linenums\">INSERT INTO EMPLOYEES (employee_id, first_name, last_name, hire_date, salary)\nVALUES (207, 'Alice', 'Smith', '01-JAN-2025', 65000);\n</pre><p><strong>Table Schema Info:</strong></p><ul><li><p><code>hire_date</code> column is of type <code>DATE</code></p></li><li><p><code>'01-JAN-2025'</code> is a <strong>string literal</strong>, not a <code>DATE</code> type</p></li></ul><p><br></p><p>Oracle attempts implicit conversion, but it's not guaranteed for all string formats to DATE. Explicit conversion using <code>TO_DATE()</code> is required for reliable inserts of string literals into <code>DATE</code> columns.</p><p>The implicit conversion of strings to <code>DATE</code> depends on the <strong>current NLS_DATE_FORMAT</strong> session setting. If the format <code>'DD-MON-YYYY'</code> doesn’t match the system’s expected date format (e.g., <code>'YYYY-MM-DD'</code>), the conversion will fail with an <strong>ORA-01861</strong> or similar error.</p><p>To avoid this, you should explicitly convert the string using <code>TO_DATE()</code>:</p><pre class=\"prettyprint linenums\">TO_DATE('01-JAN-2025', 'DD-MON-YYYY')\n</pre><p><br></p><p><strong>Why the Other Options Are Unlikely:</strong></p><ul><li><p><strong>\"The employee_id 207 already exists\"</strong><br>→ Would raise a <strong>unique constraint violation</strong>, but the question points to a <strong>data type</strong> error, not a uniqueness issue.</p></li><li><p><strong>\"The salary value (65000) is too high for the SALARY column\"</strong><br>→ No such issue is stated, and 65000 is a reasonable salary.</p></li><li><p><strong>\"The EMPLOYEES table has a missing primary key constraint\"</strong><br>→ This would <strong>not cause an error</strong> on insert. It might allow duplicates, but it wouldn't block the insert.</p></li></ul>",
                "answers": [
                    "<p>There is an implicit data type conversion failure for the <code>hire_date</code> column.</p>",
                    "<p>The <code>employee_id</code> 207 already exists.</p>",
                    "<p>The <code>salary</code> value (65000) is too high for the <code>SALARY</code> column.</p>",
                    "<p>The <code>EMPLOYEES</code> table has a missing primary key constraint.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Explicit conversion",
            "question_plain": "Scenario: You are trying to insert a new employee record into the EMPLOYEES table. The HIRE_DATE column in the table is defined as DATE, but you are attempting to insert a string literal '01-JAN-2025' without any explicit conversion.INSERT INTO EMPLOYEES (employee_id, first_name, last_name, hire_date, salary)\nVALUES (207, 'Alice', 'Smith', '01-JAN-2025', 65000);Problem: The INSERT statement fails with an ORA error.Which of the following is the most likely cause of the error?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478863,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> A junior DBA is trying to find the average salary for each department in the <code>EMPLOYEES</code> table. They execute the following query:</p><pre class=\"prettyprint linenums\">SELECT department_id, AVG(salary)\nFROM employees\nWHERE salary &gt; 5000\nORDER BY department_id;\n</pre><p><br></p><p><strong>Problem:</strong> The query returns an ORA error indicating a \"not a GROUP BY expression\".</p><p>What needs to be added to the query to resolve this error and achieve the desired result?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[GROUP BY](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/GROUPING_ID.html)"
                ],
                "feedbacks": [
                    "Adding \"GROUP BY department_id\" to the query is necessary because when using an aggregate function like AVG(), all non-aggregated columns in the SELECT statement must be included in the GROUP BY clause. In this case, department_id is a non-aggregated column and needs to be included in the GROUP BY clause to resolve the error.",
                    "Using \"HAVING AVG(salary) &gt; 7000\" is not the correct solution to the error. The HAVING clause is used to filter groups based on aggregate conditions after the GROUP BY clause has been applied. In this scenario, the error is related to the missing GROUP BY expression, not the aggregate condition.",
                    "Adding \"GROUP BY salary\" to the query is incorrect because the query is trying to find the average salary for each department, not for each individual salary. Grouping by salary would not provide the desired result and would not resolve the \"not a GROUP BY expression\" error.",
                    "Including \"WHERE department_id IS NOT NULL\" in the query is not the solution to the error. The error is related to the missing GROUP BY expression, not to the presence of NULL values in the department_id column. Adding this condition would not address the issue and would not help achieve the desired result of finding the average salary for each department."
                ],
                "explanation": "<p>Correct Answer: <code><strong>GROUP BY department_id</strong></code></p><p><br></p><p>Analyze the scenario and the query:</p><p><strong>Original Query:</strong></p><pre class=\"prettyprint linenums\">SELECT department_id, AVG(salary)\nFROM employees\nWHERE salary &gt; 5000\nORDER BY department_id;\n</pre><p><strong>Problem:</strong></p><p>The query returns an ORA error: <strong>\"not a GROUP BY expression\"</strong></p><p>This error means that you're <strong>using an aggregate function (</strong><code><strong>AVG(salary)</strong></code><strong>) without a proper </strong><code><strong>GROUP BY</strong></code><strong> clause</strong>.</p><p><br></p><p><strong>What is the query trying to do?</strong></p><p>\"Find the average salary <strong>for each department</strong>.\"</p><p>This requires <strong>grouping by </strong><code><strong>department_id</strong></code>.</p><p><strong>Correct fix:</strong></p><pre class=\"prettyprint linenums\">GROUP BY department_id\n</pre><p>This clause groups employees by department before computing the average salary.</p><p><br></p><p><strong>Why the other options are incorrect:</strong></p><ul><li><p><code><strong>HAVING AVG(salary) &gt; 7000</strong></code><br>→ A valid clause <strong>for filtering grouped results</strong>, but it doesn’t fix the missing <code>GROUP BY</code> error.</p></li><li><p><code><strong>GROUP BY salary</strong></code><br>→ Groups by salary, not department — this is <strong>incorrect</strong> for the desired result.</p></li><li><p><code><strong>WHERE department_id IS NOT NULL</strong></code><br>→ May help clean the data, but it <strong>does not fix the error</strong>.</p></li></ul>",
                "answers": [
                    "<p><code>GROUP BY department_id</code> </p>",
                    "<p><code>HAVING AVG(salary) &gt; 7000</code> </p>",
                    "<p><code>GROUP BY salary</code> </p>",
                    "<p><code>WHERE department_id IS NOT NULL</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "GROUP BY",
            "question_plain": "Scenario: A junior DBA is trying to find the average salary for each department in the EMPLOYEES table. They execute the following query:SELECT department_id, AVG(salary)\nFROM employees\nWHERE salary &gt; 5000\nORDER BY department_id;\nProblem: The query returns an ORA error indicating a \"not a GROUP BY expression\".What needs to be added to the query to resolve this error and achieve the desired result?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478865,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You need to retrieve the names of employees and their corresponding department names. You attempt to use the following query:</p><pre class=\"prettyprint linenums\">SELECT e.first_name, e.last_name, d.department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id AND e.salary &gt; 7000;\n</pre><p><br></p><p><strong>Problem:</strong> The query executes but returns a surprisingly small number of rows, and upon inspection, you realize some employees are missing from departments they should belong to.</p><p>Which of the following is the most likely reason for the unexpected result?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Outer Joins](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Joins.html#GUID-70DD48FA-BF46-4479-9C3F-146C5616E440)"
                ],
                "feedbacks": [
                    "This choice is correct because employees with NULL values in their department_id will not be included in the result set when the query is executed. This can lead to missing employees from departments they should belong to.",
                    "This choice is incorrect as the salary condition e.salary &gt; 7000 is not related to the issue of missing employees from departments. It may filter out some employees based on their salary, but it does not explain why some employees are missing from their departments.",
                    "This choice is incorrect as the issue of missing employees from departments is more likely related to NULL values in the department_id column rather than indexing. While indexing can improve query performance, it is not directly related to the issue described in the scenario.",
                    "This choice is incorrect as the join condition between the EMPLOYEES and DEPARTMENTS tables appears to be correct based on the query provided. The issue of missing employees from departments is more likely due to NULL values in the department_id column rather than data issues in the DEPARTMENTS table."
                ],
                "explanation": "<p>Most Likely Reason:<strong> There are employees with </strong><code><strong>NULL</strong></code><strong> values in their </strong><code><strong>department_id</strong></code><strong>.</strong></p><p>An <code>INNER JOIN</code> (which is implied by the comma in the <code>FROM</code> clause and the <code>WHERE</code> clause join condition) will only return rows where there is a match in <em>both</em> tables. If an employee has a <code>NULL</code> <code>department_id</code>, it won't match any <code>department_id</code> in the <code>DEPARTMENTS</code> table, and thus, those employees will be excluded from the result set. To include employees without a department, an <code>OUTER JOIN</code> would be needed.</p><p>To include such employees, you would use an <code>OUTER JOIN</code>, like:</p><pre class=\"prettyprint linenums\">SELECT e.first_name, e.last_name, d.department_name\nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.department_id\nWHERE e.salary &gt; 7000;\n</pre><p><br></p><p>Analyze the query and the scenario.</p><p><strong>Query:</strong></p><pre class=\"prettyprint linenums\">SELECT e.first_name, e.last_name, d.department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id AND e.salary &gt; 7000;\n</pre><p><strong>What the query does:</strong></p><ul><li><p>It's using an <strong>inner join</strong> (via comma + <code>WHERE</code> clause style), matching rows only where:</p><ul><li><p><code>e.department_id = d.department_id</code> (<strong>join condition</strong>)</p></li><li><p>AND <code>e.salary &gt; 7000</code> (<strong>filtering condition</strong>)</p></li></ul></li></ul><p><strong>Reported Problem:</strong></p><p><em>The query executes but returns a </em><strong><em>smaller number of rows</em></strong><em> than expected. Some employees are </em><strong><em>missing</em></strong><em> even though they belong to departments.</em></p><p><strong>Explanation:</strong></p><ul><li><p>In SQL, <strong>joins using </strong><code><strong>=</strong></code><strong> fail</strong> when either side of the condition is <code>NULL</code>.<br>So:</p><pre class=\"prettyprint linenums\">WHERE e.department_id = d.department_id\n</pre><p>will <strong>exclude</strong> any employee where <code>e.department_id IS NULL</code>, even if the employee satisfies <code>e.salary &gt; 7000</code>.</p></li><li><p>These employees are essentially <strong>unmatched</strong> and excluded from the result.</p></li></ul><p><strong>Why the other options are less likely:</strong></p><ul><li><p><strong>\"The salary condition </strong><code><strong>e.salary &gt; 7000</strong></code><strong> is too restrictive\"</strong><br>→ That would reduce results, but not explain missing employees <strong>who should be matched based on department</strong>.</p></li><li><p><strong>\"The department_id column in EMPLOYEES is not properly indexed\"</strong><br>→ Indexing affects <strong>performance</strong>, not <strong>result correctness</strong>.</p></li><li><p><strong>\"The join condition is correct, but there's an issue with data in DEPARTMENTS\"</strong><br>→ If the issue were missing department records, you might still expect a join mismatch, but <code>NULL department_id</code> on the <strong>employee side</strong> is far more common and likely.</p></li></ul>",
                "answers": [
                    "<p>There are employees with <code>NULL</code> values in their <code>department_id</code>.</p>",
                    "<p>The <code>salary</code> condition <code>e.salary &gt; 7000</code> is too restrictive.</p>",
                    "<p>The <code>department_id</code> column in the <code>EMPLOYEES</code> table is not properly indexed.</p>",
                    "<p>The join condition is correct, but there's an issue with data in the <code>DEPARTMENTS</code> table.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "JOIN",
            "question_plain": "Scenario: You need to retrieve the names of employees and their corresponding department names. You attempt to use the following query:SELECT e.first_name, e.last_name, d.department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id AND e.salary &gt; 7000;\nProblem: The query executes but returns a surprisingly small number of rows, and upon inspection, you realize some employees are missing from departments they should belong to.Which of the following is the most likely reason for the unexpected result?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478867,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You want to find all employees whose salary is equal to the minimum salary of <em>any</em> department. You write the following query:</p><pre class=\"prettyprint linenums\">SELECT first_name, last_name, salary\nFROM employees\nWHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);</pre><p><br></p><p><strong>Problem:</strong> The query fails with an ORA error indicating a \"single-row subquery returns more than one row.\"</p><p>How can you modify the query to achieve the desired outcome (find employees whose salary matches the minimum salary of any department)?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[IN Condition](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/IN-Condition.html)"
                ],
                "feedbacks": [
                    "Changing the = operator to the IN operator allows the query to return multiple rows from the subquery result, which is necessary when comparing the salary to the minimum salary of any department. This modification ensures that the query can handle multiple values and retrieve the desired outcome.",
                    "Changing the = operator to the != (not equal) operator would not resolve the issue of the subquery returning more than one row. This change would not align with the requirement of finding employees whose salary matches the minimum salary of any department.",
                    "Removing the GROUP BY department_id from the subquery would not address the error of a single-row subquery returning more than one row. The GROUP BY clause is not the cause of the issue, and removing it would not help achieve the desired outcome of finding employees with salaries equal to the minimum department salary.",
                    "Adding ROWNUM = 1 to the subquery would limit the result to only one row from the subquery, but it would not solve the problem of comparing the salary to the minimum salary of any department. This modification would restrict the subquery result to a single row, potentially leading to incorrect results in the main query."
                ],
                "explanation": "<p>Correct Answer:<strong> Change </strong><code><strong>=</strong></code><strong> to </strong><code><strong>IN</strong></code></p><p>The subquery <code>(SELECT MIN(salary) FROM employees GROUP BY department_id)</code> will return multiple minimum salaries (one for each department). The single-row comparison operator <code>=</code> cannot be used with a subquery that returns multiple rows. To compare a value against a list of values, the <code>IN</code> operator is required.</p><p><br></p><p><strong>Scenario Summary:</strong></p><p>You want to: <strong>Find all employees whose salary is equal to the minimum salary of <em>any</em> department</strong>.</p><p><strong>Original Query (with problem):</strong></p><pre class=\"prettyprint linenums\">SELECT first_name, last_name, salary\nFROM employees\nWHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);\n</pre><p><strong>Problem:</strong></p><ul><li><p>Oracle error: <strong>\"single-row subquery returns more than one row.\"</strong></p></li><li><p>Why? Because:</p><ul><li><p><code>SELECT MIN(salary) FROM employees GROUP BY department_id</code> returns <strong>multiple rows</strong> (one per department).</p></li><li><p>Using <code>=</code> expects <strong>a single value</strong>, but the subquery returns <strong>a set</strong>.</p></li></ul></li></ul><p><strong>Correct Fix:</strong></p><pre class=\"prettyprint linenums\">Change `=` to `IN`\n</pre><p><br></p><p>Corrected Query:</p><pre class=\"prettyprint linenums\">SELECT first_name, last_name, salary\nFROM employees\nWHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id);\n</pre><p>This allows the outer query to match <strong>any</strong> salary that is <strong>in the list of department-level minimums</strong>, which is what you want.</p><p><strong>Why the other options are wrong:</strong></p><ul><li><p><code><strong>Change = to !=</strong></code><br>→ Makes no logical sense for your goal (you want matches, not mismatches).</p></li><li><p><code><strong>Remove GROUP BY department_id</strong></code><br>→ Would return just <strong>one global MIN(salary)</strong>, not <strong>per department</strong> — loses the intended logic.</p></li><li><p><code><strong>Add ROWNUM = 1</strong></code><strong> to the subquery</strong><br>→ Would limit the subquery to one value (avoiding the error), but not in a meaningful or correct way for your purpose.</p></li></ul>",
                "answers": [
                    "<p>Change <code>=</code> to <code>IN</code></p>",
                    "<p>Change <code>=</code> to <code>!=</code></p>",
                    "<p>Remove the <code>GROUP BY department_id</code> from the subquery.</p>",
                    "<p>Add <code>ROWNUM = 1</code> to the subquery.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "IN",
            "question_plain": "Scenario: You want to find all employees whose salary is equal to the minimum salary of any department. You write the following query:SELECT first_name, last_name, salary\nFROM employees\nWHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);Problem: The query fails with an ORA error indicating a \"single-row subquery returns more than one row.\"How can you modify the query to achieve the desired outcome (find employees whose salary matches the minimum salary of any department)?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478869,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> A report requires calculating the number of years an employee has been with the company. The <code>HIRE_DATE</code> column is of <code>DATE</code> datatype. You try this calculation:</p><pre class=\"prettyprint linenums\">SELECT first_name, last_name, SYSDATE - hire_date AS days_worked\nFROM employees;\n</pre><p><br></p><p><strong>Problem:</strong> The <code>days_worked</code> column shows a decimal value, and you need it to be in whole years.</p><p>Which function or approach would you use to correctly calculate the number of whole years an employee has worked?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[TRUNC](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/TRUNC-date.html)"
                ],
                "feedbacks": [
                    "Using the MONTHS_BETWEEN function to calculate the number of months between the current date (SYSDATE) and the hire date, then dividing it by 12 and truncating the result will give the number of whole years an employee has worked. This approach ensures that the decimal values are removed, providing the desired output in whole years.",
                    "The ROUND function is used to round a numeric value to a specified number of decimal places. However, in this scenario, dividing the difference between SYSDATE and the hire date by 365 and rounding it will not accurately calculate the number of whole years worked by an employee. This approach may result in incorrect values due to rounding errors.",
                    "Using the TO_CHAR function with the format 'YYYY' on the difference between SYSDATE and the hire date will only return the year component of the duration. This approach does not calculate the complete number of years an employee has worked, as it only extracts the year part without considering the months and days.",
                    "The EXTRACT function is used to extract a specific component (in this case, the year) from a date or timestamp value. However, subtracting the hire date from SYSDATE and then extracting the year component will not accurately calculate the number of whole years an employee has worked. This approach does not consider the months and days, resulting in an incomplete calculation of the years worked."
                ],
                "explanation": "<p>Correct Answer:<strong> </strong><code><strong>TRUNC(MONTHS_BETWEEN(SYSDATE, hire_date) / 12)</strong></code></p><p>Calculate <strong>how many whole years</strong> an employee has worked based on the <code>HIRE_DATE</code> where the result is provided as an <strong>integer number of years</strong>.</p><p><strong>Best Option:</strong></p><pre class=\"prettyprint linenums\">TRUNC(MONTHS_BETWEEN(SYSDATE, hire_date) / 12)\n</pre><p><br></p><p>Explanation:</p><ul><li><p><code>MONTHS_BETWEEN(SYSDATE, hire_date)</code> returns the number of months (can be fractional).</p></li><li><p>Dividing by <code>12</code> gives the <strong>number of years</strong> (as a decimal).</p></li><li><p><code>TRUNC(...)</code> removes the decimal part, giving you <strong>whole years</strong> of service.</p></li></ul><p>Let's analyze the other options:</p><ol><li><p><code><strong>ROUND(SYSDATE - hire_date / 365)</strong></code></p><ul><li><p><strong>Incorrect operator precedence</strong>: it computes <code>hire_date / 365</code> first, which makes no sense.</p></li><li><p>Even if corrected to <code>ROUND((SYSDATE - hire_date) / 365)</code>, it's <strong>imprecise</strong> because:</p><ul><li><p>It ignores leap years and calendar boundaries.</p></li><li><p>It gives <strong>approximate</strong>, not accurate, year differences.</p></li></ul></li></ul></li><li><p><code><strong>TO_CHAR(SYSDATE - hire_date, 'YYYY')</strong></code></p><ul><li><p>Invalid usage.</p></li><li><p>You can't format a <strong>number of days</strong> as <code>'YYYY'</code> — <code>'YYYY'</code> is a format mask for <strong>dates</strong>, not intervals.</p></li></ul></li><li><p><code><strong>EXTRACT(YEAR FROM SYSDATE - hire_date)</strong></code></p><ul><li><p>Invalid syntax in Oracle.</p></li><li><p><code>EXTRACT(YEAR FROM ...)</code> expects a <strong>DATE or TIMESTAMP</strong>, not a date difference.</p></li></ul></li></ol>",
                "answers": [
                    "<p><code>TRUNC(MONTHS_BETWEEN(SYSDATE, hire_date) / 12)</code> </p>",
                    "<p><code>ROUND(SYSDATE - hire_date / 365)</code> </p>",
                    "<p><code>TO_CHAR(SYSDATE - hire_date, 'YYYY')</code> </p>",
                    "<p><code>EXTRACT(YEAR FROM SYSDATE - hire_date)</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "TRUNC",
            "question_plain": "Scenario: A report requires calculating the number of years an employee has been with the company. The HIRE_DATE column is of DATE datatype. You try this calculation:SELECT first_name, last_name, SYSDATE - hire_date AS days_worked\nFROM employees;\nProblem: The days_worked column shows a decimal value, and you need it to be in whole years.Which function or approach would you use to correctly calculate the number of whole years an employee has worked?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478871,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You are performing a series of DDL operations (e.g., <code>CREATE TABLE</code>, <code>ALTER TABLE</code>) and DML operations (e.g., <code>INSERT</code>). After executing a <code>CREATE TABLE</code> statement, you realize you made a mistake and try to <code>ROLLBACK</code> the entire transaction.</p><p><strong>Problem:</strong> The <code>CREATE TABLE</code> operation is not undone by the <code>ROLLBACK</code> command.</p><p>What is the reason for this behaviour in Oracle SQL?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Definition Language (DDL) Statements](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Types-of-SQL-Statements.html#GUID-FD9A8CB4-6B9A-44E5-B114-EFB8DA76FC88)"
                ],
                "feedbacks": [
                    "DDL statements, such as CREATE TABLE, automatically issue an implicit COMMIT before and after their execution. This means that the changes made by DDL statements are immediately committed to the database and cannot be rolled back using the ROLLBACK command.",
                    "ROLLBACK is not limited to DELETE statements only; it can be used to undo any changes made within a transaction. However, in the case of DDL statements like CREATE TABLE, ROLLBACK does not work because DDL statements automatically commit the changes.",
                    "FLASHBACK TABLE is used to recover a table to a previous state by using the undo data stored in the database. However, FLASHBACK TABLE is not used to undo DDL operations like CREATE TABLE. It is primarily used for DML operations.",
                    "<p>The behaviour of ROLLBACK in Oracle SQL is not dependent on whether the statement was executed in a separate session or not. The main reason the CREATE TABLE operation cannot be rolled back is due to the implicit COMMIT issued by DDL statements.</p>"
                ],
                "explanation": "<p>Correct Answer: <strong>DDL statements issue an implicit COMMIT before and after their execution.</strong></p><p><br></p><p>DDL (Data Definition Language) statements like <code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, etc., are auto-committed in Oracle. This means they are immediately and permanently saved to the database and cannot be rolled back.</p><p>DDL statements like <code>CREATE TABLE</code> perform an <strong>implicit commit</strong>, so they <strong>cannot be rolled back</strong>. This is standard Oracle behaviour.</p><p>In <strong>Oracle SQL</strong>, <strong>Data Definition Language (DDL)</strong> statements such as:</p><ul><li><p><code>CREATE TABLE</code></p></li><li><p><code>ALTER TABLE</code></p></li><li><p><code>DROP TABLE</code></p></li><li><p><code>TRUNCATE</code></p></li></ul><p>...automatically trigger an <strong>implicit COMMIT</strong>.</p><p>This means:</p><ul><li><p>Any changes <strong>before</strong> the DDL statement are <strong>committed</strong> automatically.</p></li><li><p>The DDL statement itself is <strong>committed immediately</strong>.</p></li><li><p>You <strong>cannot roll it back</strong> with <code>ROLLBACK</code>.</p></li></ul><p><strong>Why the other options are incorrect:</strong></p><ul><li><p><strong>\"ROLLBACK only works for DELETE statements\"</strong><br>→ False. <code>ROLLBACK</code> works for all <strong>DML</strong> operations: <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</p></li><li><p><strong>\"You need to use FLASHBACK TABLE for DDL operations\"</strong><br>→ Partially true in some recovery contexts, but <strong>not</strong> the reason you can't roll back a <code>CREATE TABLE</code>.</p></li><li><p><strong>\"The CREATE TABLE statement was executed in a separate session\"</strong><br>→ Unlikely, unless explicitly configured that way. Even so, it doesn’t explain the <strong>unrollbackable</strong> behaviour.</p></li></ul>",
                "answers": [
                    "<p>DDL statements issue an implicit <code>COMMIT</code> before and after their execution.</p>",
                    "<p><code>ROLLBACK</code> only works for <code>DELETE</code> statements.</p>",
                    "<p>You need to use <code>FLASHBACK TABLE</code> for DDL operations.</p>",
                    "<p>The <code>CREATE TABLE</code> statement was executed in a separate session.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Data Definition Language",
            "question_plain": "Scenario: You are performing a series of DDL operations (e.g., CREATE TABLE, ALTER TABLE) and DML operations (e.g., INSERT). After executing a CREATE TABLE statement, you realize you made a mistake and try to ROLLBACK the entire transaction.Problem: The CREATE TABLE operation is not undone by the ROLLBACK command.What is the reason for this behaviour in Oracle SQL?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478873,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You want to combine results from two tables, <code>CUSTOMERS</code> (with columns <code>customer_id</code>, <code>first_name</code>, <code>last_name</code>) and <code>VENDORS</code> (with columns <code>vendor_id</code>, <code>vendor_name</code>, <code>contact_person</code>). You attempt to use a <code>UNION</code> operator:</p><pre class=\"prettyprint linenums\">SELECT customer_id, first_name, last_name FROM customers\nUNION\nSELECT vendor_id, vendor_name FROM vendors;\n</pre><p><br></p><p><strong>Problem:</strong> The query fails with an ORA error.</p><p>What is the primary reason for this error when using the <code>UNION</code> operator?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[UNION ](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Multiset-Operators.html#GUID-793FCBB0-A97C-4884-BCAC-DD0542EA746B)"
                ],
                "feedbacks": [
                    "The UNION operator requires that the number of columns in the SELECT lists from both queries must match. In this case, the first SELECT statement retrieves three columns (customer_id, first_name, last_name) while the second SELECT statement only retrieves two columns (vendor_id, vendor_name), causing a mismatch in the number of columns.",
                    "While it is not necessary for the column names in the SELECT lists to match when using the UNION operator, the primary reason for the error in this scenario is the mismatch in the number of columns between the two SELECT statements.",
                    "The error is not due to the data types of corresponding columns being incompatible. The primary issue lies in the mismatch of the number of columns in the SELECT lists when using the UNION operator.",
                    "The error is not because UNION cannot be used with two different tables. The UNION operator can combine results from two different tables as long as the number of columns in the SELECT lists match. In this case, the error is due to the mismatch in the number of columns, not because of using two different tables."
                ],
                "explanation": "<p>Correct Answer: <strong>The number of columns in the SELECT lists do not match.</strong></p><p><br></p><p>For <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code> set operators, the number of columns in each <code>SELECT</code> statement must be identical, and the data types of corresponding columns must be compatible. In this case, <code>CUSTOMERS</code> selects three columns, while <code>VENDORS</code> selects only two.</p><p>The <code>UNION</code> operator in Oracle <strong>requires</strong> that:</p><ol><li><p>The <strong>number of columns</strong> in each <code>SELECT</code> clause <strong>must match exactly</strong>.</p></li><li><p>The <strong>data types</strong> of corresponding columns must be <strong>compatible</strong> (but not necessarily the same).</p></li><li><p><strong>Column names</strong> don’t need to match.</p></li><li><p>You <strong>can</strong> use <code>UNION</code> across different tables — as long as the structure matches.</p></li></ol><p>In the query:</p><pre class=\"prettyprint linenums\">SELECT customer_id, first_name, last_name FROM customers  -- 3 columns\nUNION\nSELECT vendor_id, vendor_name FROM vendors;               -- 2 columns ❌\n</pre><ul><li><p>The <strong>first SELECT</strong> returns <strong>3 columns</strong></p></li><li><p>The <strong>second SELECT</strong> returns <strong>2 columns</strong></p></li><li><p>This leads to an <strong>ORA error</strong> because of the <strong>column count mismatch</strong></p></li></ul><p>Why the other options are wrong:</p><ul><li><p><strong>\"The column names in the SELECT lists are different\"</strong><br>→ Not required to match.</p></li><li><p><strong>\"The data types of corresponding columns are incompatible\"</strong><br>→ Could be a problem, but <strong>not the one here</strong> — the error is due to column <strong>count</strong>, not <strong>type</strong>.</p></li><li><p><strong>\"UNION cannot be used with two different tables\"</strong><br>→ False. <code>UNION</code> can absolutely be used to combine results from different tables, as long as <strong>column count and types align</strong>.</p></li></ul>",
                "answers": [
                    "<p>The number of columns in the <code>SELECT</code> lists do not match.</p>",
                    "<p>The column names in the <code>SELECT</code> lists are different.</p>",
                    "<p>The data types of corresponding columns are incompatible.</p>",
                    "<p><code>UNION</code> cannot be used with two different tables.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "UNION",
            "question_plain": "Scenario: You want to combine results from two tables, CUSTOMERS (with columns customer_id, first_name, last_name) and VENDORS (with columns vendor_id, vendor_name, contact_person). You attempt to use a UNION operator:SELECT customer_id, first_name, last_name FROM customers\nUNION\nSELECT vendor_id, vendor_name FROM vendors;\nProblem: The query fails with an ORA error.What is the primary reason for this error when using the UNION operator?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478875,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You need to display the department ID and the count of employees for departments that have more than 10 employees. You initially write:</p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(employee_id)\nFROM employees\nWHERE COUNT(employee_id) &gt; 10\nGROUP BY department_id;\n</pre><p><br></p><p><strong>Problem:</strong> The query fails with an ORA error indicating \"group function is not allowed here.\"</p><p>How should you correct the query to achieve the desired result?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[HAVING clause](https://docs.oracle.com/javadb/10.8.2.2/ref/rrefsqlj14854.html)",
                    "[WHERE Clause](https://docs.oracle.com/en/database/other-databases/nosql-database/24.3/sqlreferencefornosql/where-clause.html)"
                ],
                "feedbacks": [
                    "The HAVING clause is used in SQL to filter groups based on aggregate functions like COUNT, SUM, AVG, etc. In this case, you should use the HAVING clause instead of the WHERE clause to filter departments with more than 10 employees after the grouping has been done.",
                    "Removing the GROUP BY clause would not be the correct approach in this scenario. The GROUP BY clause is necessary to group the results by department_id before applying the aggregate function COUNT(employee_id).",
                    "Using SUM(employee_id) in the WHERE clause is not appropriate for this scenario. The COUNT function is used to count the number of employees in each department, while SUM would add up the employee IDs, which is not the desired outcome for this query.",
                    "Adding an ORDER BY clause before the WHERE clause would not resolve the issue with the group function error. The ORDER BY clause is used to sort the results, but it does not address the problem with using aggregate functions in the WHERE clause."
                ],
                "explanation": "<p>Correct answer: <strong>Change </strong><code><strong>WHERE</strong></code><strong> to </strong><code><strong>HAVING</strong></code><strong>.</strong></p><p>The <code>WHERE</code> clause is used to filter individual rows <em>before</em> grouping. Aggregate functions (like <code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code>) cannot be used directly in a <code>WHERE</code> clause. To filter groups based on the result of an aggregate function, you must use the <code>HAVING</code> clause.</p><p>In Oracle SQL:</p><ul><li><p><code><strong>WHERE</strong></code> is used to filter <strong>rows</strong> <strong>before</strong> grouping.</p></li><li><p><code><strong>HAVING</strong></code> is used to filter <strong>groups</strong> <strong>after</strong> aggregation.</p></li></ul><p><strong>Original Query (Incorrect):</strong></p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(employee_id)\nFROM employees\nWHERE COUNT(employee_id) &gt; 10   -- ❌ Invalid use of aggregate function\nGROUP BY department_id;\n</pre><p>The error: <strong>\"group function is not allowed here\"</strong> occurs because <code>COUNT(employee_id)</code> is an <strong>aggregate function</strong>, and aggregate functions <strong>cannot</strong> be used in the <code>WHERE</code> clause.</p><p><br></p><p><strong>Corrected Query:</strong></p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(employee_id)\nFROM employees\nGROUP BY department_id\nHAVING COUNT(employee_id) &gt; 10;\n</pre><p>This properly filters groups where the <strong>count of employees</strong> is greater than 10.</p><p><br></p><p><strong>Why the other options are wrong:</strong></p><ul><li><p><strong>Remove the GROUP BY clause</strong><br>→ That would make <code>COUNT(employee_id)</code> return a single total, not per department.</p></li><li><p><strong>Replace </strong><code><strong>COUNT(employee_id)</strong></code><strong> with </strong><code><strong>SUM(employee_id)</strong></code><strong> in the WHERE clause</strong><br>→ <code>SUM(employee_id)</code> is still an aggregate function and invalid in <code>WHERE</code>.</p></li><li><p><strong>Add an ORDER BY clause before the WHERE clause</strong><br>→ <code>ORDER BY</code> comes <strong>after</strong> <code>WHERE</code>, not before — and this doesn’t solve the error.</p></li></ul>",
                "answers": [
                    "<p>Change <code>WHERE</code> to <code>HAVING</code>.</p>",
                    "<p>Remove the <code>GROUP BY</code> clause.</p>",
                    "<p>Replace <code>COUNT(employee_id)</code> with <code>SUM(employee_id)</code> in the <code>WHERE</code> clause.</p>",
                    "<p>Add an <code>ORDER BY</code> clause before the <code>WHERE</code> clause.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "HAVING",
            "question_plain": "Scenario: You need to display the department ID and the count of employees for departments that have more than 10 employees. You initially write:SELECT department_id, COUNT(employee_id)\nFROM employees\nWHERE COUNT(employee_id) &gt; 10\nGROUP BY department_id;\nProblem: The query fails with an ORA error indicating \"group function is not allowed here.\"How should you correct the query to achieve the desired result?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478877,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You have a query that identifies employees who earn more than the average salary in their own department. The current query uses a correlated subquery:</p><pre class=\"prettyprint linenums\">SELECT e.first_name, e.last_name, e.salary, e.department_id\nFROM employees e\nWHERE e.salary &gt; (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);\n</pre><p><br></p><p><strong>Problem:</strong> For a very large <code>EMPLOYEES</code> table, this query is running extremely slow.</p><p>What is a common reason for poor performance in correlated subqueries, and how might you typically optimize this type of query?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Correlated Subqueries](https://docs.oracle.com/cd/E17952_01/mysql-9.3-en/correlated-subqueries.html)"
                ],
                "feedbacks": [
                    "The main reason for poor performance in correlated subqueries is that the subquery is executed once for each row in the outer query, leading to significant performance issues, especially with large datasets. By using an analytic function like AVG() OVER (PARTITION BY department_id), you can optimize the query and avoid the need for correlated subqueries, resulting in better performance.",
                    "This statement is incorrect. Correlated subqueries are not automatically optimized by Oracle and can lead to performance issues, especially with large datasets. It is essential to optimize such queries manually to improve performance.",
                    "While adding an index on the salary column may improve performance in general, the primary reason for poor performance in correlated subqueries is not necessarily the lack of an index. The issue lies in the repeated execution of the subquery for each row in the outer query, which can be optimized using alternative methods like analytic functions.",
                    "The WHERE clause department_id = e.department_id is not causing a Cartesian join in this scenario. The primary issue with correlated subqueries is the repeated execution of the subquery for each row in the outer query, leading to poor performance. To optimize such queries, alternative approaches like using analytic functions should be considered."
                ],
                "explanation": "<p>Correct answer: <strong>The subquery executes once for each row in the outer query, leading to performance issues. An analytic function like </strong><code><strong>AVG() OVER (PARTITION BY department_id)</strong></code><strong> could optimize it.</strong></p><p>Correlated subqueries are re-executed for each row processed by the outer query, which can be very inefficient for large datasets. Using analytic functions (also known as window functions) is a common and highly effective way to optimize such queries by calculating the aggregate once per group and then applying it to the rows within that group.</p><p><strong>Correlated subqueries</strong>:</p><ul><li><p>Are subqueries that <strong>reference a column from the outer query</strong>.</p></li><li><p>In your query:</p><pre class=\"prettyprint linenums\">SELECT e.first_name, e.last_name, e.salary, e.department_id\nFROM employees e\nWHERE e.salary &gt; (\n  SELECT AVG(salary)\n  FROM employees\n  WHERE department_id = e.department_id\n);\n</pre><p>The subquery is <strong>re-evaluated once for every row</strong> in the <code>employees</code> table.</p></li></ul><p>This results in <strong>significant performance issues</strong> on large tables, especially if the same average is recalculated many times for the same department.</p><p><br></p><p><strong>Optimization Approach — Analytic Function:</strong></p><p>You can <strong>compute the average salary per department once</strong> for each row using <code>AVG() OVER (PARTITION BY department_id)</code>.</p><p><strong>Rewritten Query (Optimized):</strong></p><pre class=\"prettyprint linenums\">SELECT first_name, last_name, salary, department_id\nFROM (\n  SELECT first_name, last_name, salary, department_id,\n         AVG(salary) OVER (PARTITION BY department_id) AS dept_avg\n  FROM employees\n)\nWHERE salary &gt; dept_avg;\n</pre><p>This eliminates the correlated subquery and performs much faster, especially on large datasets.</p><p><br></p><p><strong>Why the other options are incorrect:</strong></p><ul><li><p><strong>\"Correlated subqueries are always optimized by Oracle and run fast.\"</strong><br>→ Not true. They can be slow if not handled carefully, especially with large data volumes.</p></li><li><p><strong>\"The subquery does not use an index, causing a full table scan. Adding an index on salary will fix it.\"</strong><br>→ Indexing <code>salary</code> won’t help much because you're computing an <strong>aggregate (AVG)</strong> — not searching for specific values.</p></li><li><p><strong>\"The WHERE clause </strong><code><strong>department_id = e.department_id</strong></code><strong> is causing a Cartesian join.\"</strong><br>→ This is a filter condition inside a subquery — <strong>not a join</strong>, and certainly not a Cartesian join.</p></li></ul>",
                "answers": [
                    "<p>The subquery executes once for each row in the outer query, leading to performance issues. An analytic function like <code>AVG() OVER (PARTITION BY department_id)</code> could optimize it.</p>",
                    "<p>Correlated subqueries are always optimized by Oracle and run fast.</p>",
                    "<p>The subquery does not use an index, causing a full table scan. Adding an index on <code>salary</code> will fix it.</p>",
                    "<p>The <code>WHERE</code> clause <code>department_id = e.department_id</code> is causing a Cartesian join.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Correlated Subqueries",
            "question_plain": "Scenario: You have a query that identifies employees who earn more than the average salary in their own department. The current query uses a correlated subquery:SELECT e.first_name, e.last_name, e.salary, e.department_id\nFROM employees e\nWHERE e.salary &gt; (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);\nProblem: For a very large EMPLOYEES table, this query is running extremely slow.What is a common reason for poor performance in correlated subqueries, and how might you typically optimize this type of query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 120478879,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You need to drop a table named <code>ORDERS</code> that has a foreign key constraint referencing its <code>ORDER_ID</code> in another table, <code>ORDER_ITEMS</code>.</p><p><strong>Problem:</strong> You execute <code>DROP TABLE orders;</code> and it fails with an ORA error.</p><p>What is the most likely cause of this error, and how can you resolve it?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CONSTRAINTS](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/constraint.html)",
                    "[Cascade Constraints Considerations](https://docs.oracle.com/en/middleware/goldengate/core/21.3/coredoc/prepare-cascade-constraints-considerations.html)"
                ],
                "feedbacks": [
                    "This choice is correct because the error most likely occurred due to the foreign key constraint in the ORDER_ITEMS table referencing the ORDER_ID in the ORDERS table. Using the CASCADE CONSTRAINTS option with the DROP TABLE command will drop the table along with all dependent objects, including the foreign key constraint in ORDER_ITEMS.",
                    "This choice is incorrect because the error is not likely caused by the ORDERS table being locked. Waiting for the lock to release will not resolve the issue related to the foreign key constraint.",
                    "This choice is incorrect because the error is not related to lacking the DROP TABLE privilege. If this were the case, you would receive a different error message indicating a lack of privilege.",
                    "This choice is incorrect because the error is not due to the table containing data. Truncating the table is not necessary to drop it, especially when the issue is related to the foreign key constraint. Using the CASCADE CONSTRAINTS option with the DROP TABLE command is the appropriate solution in this scenario."
                ],
                "explanation": "<p>Correct Answer: <strong>The table cannot be dropped because it is referenced by a foreign key constraint in </strong><code><strong>ORDER_ITEMS</strong></code><strong>. You need to use:</strong></p><pre class=\"prettyprint linenums\">DROP TABLE orders CASCADE CONSTRAINTS;\n</pre><p><br></p><p>By default, Oracle prevents you from dropping a table if it is referenced by a foreign key constraint from another table to maintain referential integrity. To force the drop and also drop any dependent foreign key constraints, you must use the <code>CASCADE CONSTRAINTS</code> clause.</p><p>When you attempt:</p><pre class=\"prettyprint linenums\">DROP TABLE orders;\n</pre><p>and Oracle returns an error like:</p><p><em>ORA-02449: unique/primary keys in table referenced by foreign keys</em></p><p>…it means that <strong>another table (e.g., </strong><code><strong>ORDER_ITEMS</strong></code><strong>) has a foreign key</strong> referencing <code>ORDERS.ORDER_ID</code>.</p><p><br></p><p><strong>Solution:</strong></p><p>To drop the table <strong>and automatically remove dependent constraints</strong>, use:</p><pre class=\"prettyprint linenums\">DROP TABLE orders CASCADE CONSTRAINTS;\n</pre><p>This:</p><ul><li><p>Drops the <code>ORDERS</code> table</p></li><li><p>Also drops any <strong>foreign key constraints</strong> that reference it (e.g., from <code>ORDER_ITEMS</code>)</p></li></ul><p><br></p><p><strong>Why the other options are incorrect:</strong></p><ul><li><p><strong>\"The ORDERS table is locked\"</strong><br>→ Table locks wouldn't cause a <strong>DDL (DROP) failure</strong> with a foreign key error. Locking might delay execution but not return an ORA-02449-type error.</p></li><li><p><strong>\"You lack the necessary DROP TABLE privilege\"</strong><br>→ That would raise a <strong>privilege error</strong>, such as <code>ORA-01031: insufficient privileges</code>, not a constraint-related error.</p></li><li><p><strong>\"The table contains data; you must TRUNCATE first\"</strong><br>→ Not true. <code>DROP TABLE</code> removes the <strong>entire table</strong>, including data and structure — regardless of whether it has data.</p></li></ul>",
                "answers": [
                    "<p>The table cannot be dropped because it is referenced by a foreign key constraint in <code>ORDER_ITEMS</code>. You need to use <code>DROP TABLE orders CASCADE CONSTRAINTS;</code></p>",
                    "<p>The <code>ORDERS</code> table is locked; you need to wait for the lock to release.</p>",
                    "<p>You lack the necessary <code>DROP TABLE</code> privilege.</p>",
                    "<p>The table contains data; you must <code>TRUNCATE TABLE orders;</code> first.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CONSTRAINT",
            "question_plain": "Scenario: You need to drop a table named ORDERS that has a foreign key constraint referencing its ORDER_ID in another table, ORDER_ITEMS.Problem: You execute DROP TABLE orders; and it fails with an ORA error.What is the most likely cause of this error, and how can you resolve it?",
            "related_lectures": []
        }
    ]
}