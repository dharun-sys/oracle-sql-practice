{
    "count": 80,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 119289319,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Which two statements are true about the DUAL table?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Selecting from the DUAL Table](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Selecting-from-the-DUAL-Table.html)"
                ],
                "feedbacks": [
                    "The DUAL table in Oracle Database consists of a single row and a single column. It is commonly used for performing calculations or returning a single result.",
                    "The DUAL table is a special one-row, one-column table present by default in Oracle Database. It can be accessed by any user who has the SELECT privilege in any schema, making it widely available for querying.",
                    "The DUAL table in Oracle Database consists of a single row and a single column. It does not display multiple rows and columns, as it is primarily used for single-row operations.",
                    "The DUAL table in Oracle Database consists of a single row and a single column of VARCHAR2 data type. It is commonly used for performing calculations, testing functions, and as a placeholder for single-row results.",
                    "The DUAL table in Oracle Database can be used to display only constants or pseudo columns. It is often used in SQL queries to generate constant values or to perform operations that do not require data from actual tables.",
                    "The DUAL table in Oracle Database can be accessed by any user who has the SELECT privilege, not just the SYS user. It is a common misconception that only the SYS user can access the DUAL table, but in reality, any user with the necessary privileges can query it."
                ],
                "explanation": "<p>The two <strong>true statements</strong> about the Oracle <strong>DUAL</strong> table are:</p><ol><li><p><strong>It can be accessed by any user who has the SELECT privilege in any schema.</strong><br>The DUAL table is owned by the <code>SYS</code> user but is <strong>publicly accessible</strong>—any user can query it without needing to qualify it with a schema name.</p></li><li><p><strong>It consists of a single row and single column of VARCHAR2 data type.</strong><br>DUAL has one column named <code>DUMMY</code> of type <code>VARCHAR2(1)</code> and contains exactly <strong>one row</strong> with the value <code>'X'</code>.</p></li></ol><p>Incorrect options:</p><ul><li><p><strong>It can display multiple rows but only a single column.</strong><br>False—DUAL is designed to return <strong>only one row</strong>.</p></li><li><p><strong>It can display multiple rows and columns.</strong><br>False—DUAL has <strong>one row and one column</strong>.</p></li><li><p><strong>It can be used to display only constants or pseudo columns.</strong><br>While it’s <em>commonly</em> used for constants or pseudo columns like <code>SYSDATE</code>, you can also use it to evaluate expressions or call functions—so this is too restrictive.</p></li><li><p><strong>It can be accessed only by the SYS user.</strong><br>False—DUAL is <strong>accessible to all users</strong>.</p></li></ul><p>Want to see a few clever tricks you can do with DUAL, like generating sequences or testing expressions?</p><p><strong>DUAL Table</strong></p><p><code>DUAL</code> is a table automatically created by Oracle Database along with the data dictionary. <code>DUAL</code> is in the schema of the user <code>SYS</code> but is accessible by the name <code>DUAL</code> to all users. </p><p>It has one column, <code>DUMMY</code>, defined to be <code>VARCHAR2(1)</code>, and contains one row with a value <code>X</code>. </p><p>Selecting from the <code>DUAL</code> table is useful for computing a constant expression with the <code>SELECT</code> statement. Because <code>DUAL</code> has only one row, the constant is returned only once. Alternatively, you can select a constant, pseudocolumn, or expression from any table, but the value will be returned as many times as there are rows in the table. </p>",
                "answers": [
                    "<p>It can display multiple rows but only a single column.</p>",
                    "<p>It can be accessed by any user who has the SELECT privilege in any schema.</p>",
                    "<p>It can display multiple rows and columns.</p>",
                    "<p>It consists of a single row and single column of VARCHAR2 data type.</p>",
                    "<p>It can be used to display only constants or pseudo columns.</p>",
                    "<p>It can be accessed only by the SYS user.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Which two statements are true about the DUAL table?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289461,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the <code>SESSION_PRIVS</code> dictionary view.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SESSION_PRIVS](https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/SESSION_PRIVS.html#GUID-A9837068-CDDA-4D94-BBC6-B167CE5C1FA6)"
                ],
                "feedbacks": [
                    "The SESSION_PRIVS dictionary view in Oracle Database contains the current system privileges that are available in the user session. This view shows the system privileges that have been granted directly to the user or through roles.",
                    "This statement is incorrect as the SESSION_PRIVS dictionary view does not contain the object privileges granted to other users by the current user session. Object privileges are typically stored in the DBA_TAB_PRIVS view in Oracle Database.",
                    "The SESSION_PRIVS dictionary view does not contain the system privileges granted to other users by the current user session. System privileges granted to other users can be viewed in the DBA_SYS_PRIVS view in Oracle Database.",
                    "The SESSION_PRIVS dictionary view does not contain the current object privileges available in the user session. Object privileges granted to the user can be viewed in the DBA_TAB_PRIVS view in Oracle Database."
                ],
                "explanation": "<p>Correct statement: <strong>It contains the current system privileges available in the user session.</strong></p><p>The <code>SESSION_PRIVS</code> dictionary view lists all <strong>system privileges</strong> that are currently <strong>enabled for the session</strong>—whether granted directly or through roles. It does <strong>not</strong> include object privileges or privileges granted to others.</p><p>The other options are incorrect because:</p><ul><li><p>They refer to <strong>object privileges</strong>, which are not shown in <code>SESSION_PRIVS</code>.</p></li><li><p>They mention privileges <strong>granted to others</strong>, whereas <code>SESSION_PRIVS</code> only reflects what the <strong>current session</strong> has.</p></li></ul><p><strong>SESSION_PRIVS</strong></p><p><code>SESSION_PRIVS</code> describes the privileges that are currently available to the user.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-07-17_17-35-10-2992922d4342c56f390804c9302237ec.png\"></p>",
                "answers": [
                    "<p>It contains the current system privileges available in the user session.</p>",
                    "<p>It contains the object privileges granted to other users by the current user session.</p>",
                    "<p>It contains the system privileges granted to other users by the current user session.</p>",
                    "<p>It contains the current object privileges available in the user session.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the SESSION_PRIVS dictionary view.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289351,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCT_INFORMATION table.</p><p><strong>Table: PRODUCT_INFORMATION</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPROD_ID          NOT NULL          NUMBER(2)\nPROD_NAME                          VARCHAR(10)\nLIST_PRICE                         NUMBER(6,2)\n</pre><p><br></p><p>Identify the query which retrieves the number of products with a null list price.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: COUNT Function](https://www.techonthenet.com/oracle/functions/count.php)",
                    "[Oracle / PLSQL: DISTINCT Clause](https://www.techonthenet.com/oracle/distinct.php)",
                    "[Oracle COUNT Function](https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/)"
                ],
                "feedbacks": [
                    "None of the listed queries correctly retrieves the number of products with a null list price. The correct query is missing from the choices provided.",
                    "This query retrieves the count of rows where the list price is null. The COUNT function counts the number of non-null values, so using COUNT(list_price) will not count null values. The WHERE clause correctly filters for rows where the list price is null.",
                    "This query attempts to retrieve the count of rows where the list price is null by comparing it to NULL using the equals operator. However, in SQL, NULL values cannot be compared using the equals operator. The correct way to check for NULL values is using the IS NULL syntax.",
                    "This query uses the NVL function to replace null values with 0 before counting them. While this approach can work in some cases, it is not necessary for counting null values. The WHERE clause correctly filters for rows where the list price is null.",
                    "This query retrieves the count of distinct list prices where the list price is null. However, the question asks for the number of products with a null list price, not the distinct count of null list prices."
                ],
                "explanation": "<p>The correct answer is:&nbsp; <strong>None of the listed queries meets the specified requirements.</strong></p><p>Here's why each option is <strong>incorrect</strong>:</p><p><code><strong>SELECT COUNT(NVL(list_price, 0)) FROM product_information WHERE list_price IS NULL;</strong></code></p><ul><li><p>Returns a count, but the use of <code>NVL</code> here is <strong>misleading and unnecessary</strong>, since the <code>WHERE</code> clause already filters for <code>NULL</code>.</p></li><li><p>It will <strong>still count the rows</strong>, but this is <strong>not the correct or standard way</strong> to count NULLs.</p></li></ul><p><code><strong>SELECT COUNT(DISTINCT list_price) FROM product_information WHERE list_price IS NULL;</strong></code></p><ul><li><p><code>COUNT(DISTINCT list_price)</code> <strong>ignores NULL values</strong>.</p></li><li><p>So even if rows match <code>list_price IS NULL</code>, this will <strong>return 0</strong>.</p></li></ul><p><code><strong>SELECT COUNT(list_price) FROM product_information WHERE list_price IS NULL;</strong></code></p><ul><li><p><code>COUNT(list_price)</code> counts <strong>non-NULL</strong> values.</p></li><li><p>Combined with <code>WHERE list_price IS NULL</code>, it will <strong>return 0</strong> — because <strong>list_price is NULL</strong> in all selected rows.</p></li></ul><p><code><strong>SELECT COUNT(list_price) FROM product_information WHERE list_price = NULL;</strong></code></p><ul><li><p>Invalid logic: You <strong>must use </strong><code><strong>IS NULL</strong></code>, not <code>= NULL</code>.</p></li></ul><p>Correct query (not listed):</p><pre class=\"prettyprint linenums\">SELECT COUNT(*) \nFROM product_information \nWHERE list_price IS NULL;\n</pre><p>This accurately counts rows where <code>LIST_PRICE</code> is <code>NULL</code>.</p><p><br></p><p><strong>The Oracle/PLSQL COUNT</strong> function returns the count of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>COUNT</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>COUNT</code> function when grouping the results by one or more columns is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the <code>COUNT</code> function and must be included in the <code>GROUP BY</code> clause at the end of the SQL statement. </p><p>aggregate_expression - This is the column or expression whose non-null values will be counted. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>COUNT</code> function returns a numeric value.</p><p>The <code>COUNT()</code> function accepts a clause which can be either <code>ALL</code>, <code>DISTINCT</code>, or <code>*</code>:</p><p>• <code>COUNT(*)</code> function returns the number of items in a group, including <code>NULL</code> and duplicate values.</p><p>• <code>COUNT(DISTINCT expression)</code> function returns the number of unique and non-null items in a group.</p><p>• <code>COUNT(ALL expression)</code> evaluates the expression and returns the number of non-null items in a group, including duplicate values.</p><p>• If you don’t explicitly specify <code>DISTINCT</code> or <code>ALL</code>, the <code>COUNT()</code> function uses the <code>ALL</code> by default.</p><p>• Note that, unlike other <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>, the <code>COUNT(*)</code> function does not ignore <code>NULL</code> values.</p><p><br></p><p><strong>The Oracle/PLSQL NVL </strong>function lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. replace_with The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL</code> function returns a substitute value.</p><p><a href=\"https://www.techonthenet.com/oracle/functions/nvl.php\">https://www.techonthenet.com/oracle/functions/nvl.php</a></p><p><br></p><p><strong>The Oracle DISTINCT clause</strong> is used to remove duplicates from the result set. The <code>DISTINCT</code> clause can only be used with <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>DISTINCT</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT DISTINCT expressions\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p>",
                "answers": [
                    "<p>None of the listed queries meets the specified requirements.</p>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (list_price)&nbsp; \nFROM product_information&nbsp; \nWHERE list_price IS NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (list_price) \nFROM product_information&nbsp; \nWHERE list_price = NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT(NVL(list_price, 0))&nbsp; \nFROM product_information&nbsp; \nWHERE list_price IS NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (DISTINCT list_price)&nbsp; \nFROM product_information&nbsp; \nWHERE list_price IS NULL;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "COUNT",
            "question_plain": "View and examine the structure of the PRODUCT_INFORMATION table.Table: PRODUCT_INFORMATIONName             Null??            Type\nPROD_ID          NOT NULL          NUMBER(2)\nPROD_NAME                          VARCHAR(10)\nLIST_PRICE                         NUMBER(6,2)\nIdentify the query which retrieves the number of products with a null list price.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289353,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees(\n  emp_id NUMBER(10) PRIMARY KEY,\n  ename VARCHAR2(20),\n  email NUMBER(3) UNIQUE,\n  address VARCHAR2(500),\n  phone VARCHAR2(20),\n  resume LONG,\n  hire_date DATE,\n  remarks LONG,\n  dept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments (dept_id),\n  CONSTRAINT ename_nn NOT NULL(ename)\n);\n</pre><p><br></p><p><strong>Given: </strong>The CREATE TABLE statement resulted in an error. </p><p>Identify the reasons for the error. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Overview of RAW and LONG RAW Datatypes](https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT613)",
                    "[Datatype Limits](https://docs.oracle.com/en/database/oracle/oracle-database/23/refrn/datatype-limits.html)",
                    "[Constraint](https://docs.oracle.com/cd/B12037_01/server.101/b10759/clauses002.htm)"
                ],
                "feedbacks": [
                    "The NOT NULL constraint must be defined at the column level, not at the table level. This ensures that the ENAME column cannot contain NULL values, which is a requirement for data integrity.",
                    "The FOREIGN KEY constraint must be defined at the column level, not at the table level. This constraint establishes a relationship between the DEPT_ID column in the current table and a column in another table, ensuring referential integrity.",
                    "Only one LONG column can be used per table in Oracle Database. If multiple LONG columns are attempted to be defined in a single table, it will result in an error. This limitation is specific to the LONG datatype in Oracle.",
                    "The FOREIGN KEY keyword is essential in defining a foreign key constraint in Oracle. Without the FOREIGN KEY keyword, the constraint definition will be incomplete and result in an error. This keyword specifies the column or columns that reference the primary key in another table.",
                    "The PRIMARY KEY constraint in the EMP_ID column must have a name and be defined at the column level. Naming the PRIMARY KEY constraint allows for easier identification and management of constraints. Additionally, the PRIMARY KEY constraint uniquely identifies each record in the table."
                ],
                "explanation": "<p>The provided <code>CREATE TABLE</code> statement has a couple of issues that would result in an error. Let's analyze the options:</p><p>Errors and Valid Options:</p><p><strong>1. Only one LONG column can be used per table.</strong></p><ul><li><p><strong>Correct.</strong> Oracle allows <strong>only one LONG column per table</strong>. In the statement, both <code>resume</code> and <code>remarks</code> are of type <code>LONG</code>, which is not allowed.</p></li><li><p><strong>This is a valid reason for the error.</strong></p></li></ul><p><strong>2. The NOT NULL constraint on the ENAME column must be defined at the column level.</strong></p><ul><li><p><strong>Correct.</strong> In Oracle, <code>NOT NULL</code> is a <strong>column-level constraint</strong>, not a table-level constraint. The line:</p><pre class=\"prettyprint linenums\">CONSTRAINT ename_nn NOT NULL(ename)\n</pre><p>is invalid syntax because <code>NOT NULL</code> can't be used like that at the table level.</p></li><li><p><strong>This is a valid reason for the error.</strong></p></li></ul><p>Now examining the <strong>incorrect options</strong>:</p><p><strong>FOREIGN KEY defined on the DEPT_ID column must be at the table level only.</strong></p><ul><li><p><strong>Incorrect.</strong> Foreign keys <strong>can be defined either at the column level or the table level</strong>. This is valid:</p><pre class=\"prettyprint linenums\">dept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments (dept_id)\n</pre></li></ul><p><strong>The FOREIGN KEY keyword is missing in the constraint definition.</strong></p><ul><li><p><strong>Incorrect.</strong> When using <strong>column-level</strong> syntax, <code>FOREIGN KEY</code> keyword is <strong>not required</strong>. The reference is valid.</p></li></ul><p><strong>The PRIMARY KEY constraint in the EMP_ID column must have a name and must be defined at the table level only.</strong></p><ul><li><p><strong>Incorrect.</strong> It's perfectly valid to define the primary key <strong>at the column level without a name</strong>, like this:</p><pre class=\"prettyprint linenums\">emp_id NUMBER(10) PRIMARY KEY\n</pre></li></ul><p><br></p><p>Here is the <strong>corrected version</strong> of your <code>CREATE TABLE</code> statement, addressing the two issues:</p><p>Fixes:</p><ol><li><p>Removed one of the <code>LONG</code> columns (assuming you keep <code>resume</code> and remove <code>remarks</code>).</p></li><li><p>Moved the <code>NOT NULL</code> constraint on <code>ename</code> to the column level.</p></li></ol><p><strong>Corrected SQL:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  emp_id NUMBER(10) PRIMARY KEY,\n  ename VARCHAR2(20) NOT NULL,\n  email NUMBER(3) UNIQUE,\n  address VARCHAR2(500),\n  phone VARCHAR2(20),\n  resume LONG,\n  hire_date DATE,\n  dept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments(dept_id)\n);\n</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-28_23-42-02-8f64bac795a65592ddee863200d60105.png\"></p><p><br></p><p>Optional: If you <strong>must keep both</strong> <code>resume</code> and <code>remarks</code>, consider replacing <code>LONG</code> with <code>CLOB</code> (recommended):</p><pre class=\"prettyprint linenums\">CREATE TABLE employees (\n  emp_id NUMBER(10) PRIMARY KEY,\n  ename VARCHAR2(20) NOT NULL,\n  email NUMBER(3) UNIQUE,\n  address VARCHAR2(500),\n  phone VARCHAR2(20),\n  resume CLOB,\n  remarks CLOB,\n  hire_date DATE,\n  dept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments(dept_id)\n);\n</pre><p><code>CLOB</code> is the modern alternative to <code>LONG</code> and supports multiple columns in a table.</p><p><br></p><p><strong>RAW and LONG RAW Datatypes</strong></p><p>The <code>RAW</code> and <code>LONG RAW</code> datatypes are used for data that is not to be interpreted (not converted when moving data between different systems) by Oracle Database. These datatypes are intended for binary data or byte strings. For example, <code>LONG RAW</code> can be used to store graphics, sound, documents, or arrays of binary data. The interpretation depends on the use.</p><p><code>RAW</code> is a variable-length datatype like the <code>VARCHAR2</code> character datatype, except Oracle Net Services (which connects user sessions to the instance) and the Import and Export utilities do not perform character conversion when transmitting <code>RAW</code> or <code>LONG RAW</code> data. In contrast, Oracle Net Services and Import/Export automatically convert <code>CHAR</code>, <code>VARCHAR2</code>, and <code>LONG</code> data between the database character set and the user session character set, if the two character sets are different.</p><p>When Oracle Database automatically converts <code>RAW</code> or <code>LONG RAW</code> data to and from <code>CHAR</code> data, the binary data is represented in hexadecimal form with one hexadecimal character representing every four bits of <code>RAW</code> data. For example, one byte of <code>RAW</code> data with bits 11001011 is displayed and entered as <code>'CB'</code>.</p><p><code>LONG RAW</code> data cannot be indexed, but <code>RAW</code> data can be indexed.</p><p><code>LONG</code> Maximum size: 2 GB - 1 Only one <code>LONG</code> column is allowed per table.</p><p><em>√&nbsp; Only one LONG column can be used per table.</em></p><p><strong>NOT NULL Constraints</strong></p><p>A <code>NOT NULL</code> constraint prohibits a column from containing nulls. The <code>NULL</code> keyword by itself does not actually define an integrity constraint, but you can specify it to explicitly permit a column to contain nulls. You must define <code>NOT NULL</code> and <code>NULL</code> using inline specification. If you specify neither <code>NOT NULL</code> nor <code>NULL</code>, then the default is <code>NULL</code>.</p><p><code>NOT NULL</code> constraints are the only constraints you can specify inline on <code>XMLType</code> and <code>VARRAY</code> columns.</p><p>To satisfy a <code>NOT NULL</code> constraint, every row in the table must contain a value for the column.</p><p><strong>Difference between Table level and Column level constraints</strong></p><p>A column level constraint has scope only to the column it is defined on. A table level constraint can see every column in the table.</p><p>That is the major difference between the two - that of \"scoping\".</p><p>Any column level constraint (exception: <code>NOT NULL</code>) can be expressed at the table level - but the opposite is not true.</p><p>A column level constraint is syntactically more clear - it is OBVIOUS it applies to that single column. It is more meaningful therefore.</p><p>You would use a column level constraint if your constraint is in fact a column constraint. You would use a table constraint otherwise.</p><p>Beyond that - they are pretty much the same.</p><p><em>√&nbsp; The NOT NULL constraint on the ENAME column must be defined at the column level.</em></p><p><a href=\"https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293\">https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293</a></p><p><br></p><p><strong>To make the CREATE&nbsp;TABLE&nbsp;render successfully, the following is required:</strong></p><p>• Edit the datatype for one of the columns which have <code>LONG</code> as their datatype. <code>REMARKS</code> was changed to <code>VARCHAR2(500)</code></p><p>• Put the <code>NOT&nbsp;NULL</code> constraint for <code>ENAME</code> inline. <code>ename VARCHAR2(20) NOT NULL</code></p><p>• Create a compatible table named <code>DEPARTMENTS</code> for the <code>DEPT_ID FOREIGN KEY</code> to reference.</p>",
                "answers": [
                    "<p>The NOT NULL constraint on the ENAME column must be defined at the column level.</p>",
                    "<p>FOREIGN KEY defined on the DEPT_ID column must be at the table level only.</p>",
                    "<p>Only one LONG column can be used per table.</p>",
                    "<p>The FOREIGN KEY keyword is missing in the constraint definition.</p>",
                    "<p>The PRIMARY KEY constraint in the EMP_ID column must have a name and must be defined at the table level only.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1CREATE TABLE employees(\n  emp_id NUMBER(10) PRIMARY KEY,\n  ename VARCHAR2(20),\n  email NUMBER(3) UNIQUE,\n  address VARCHAR2(500),\n  phone VARCHAR2(20),\n  resume LONG,\n  hire_date DATE,\n  remarks LONG,\n  dept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments (dept_id),\n  CONSTRAINT ename_nn NOT NULL(ename)\n);\nGiven: The CREATE TABLE statement resulted in an error. Identify the reasons for the error. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289355,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the SQL GROUP BY clause. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: GROUP BY Clause](https://www.techonthenet.com/oracle/group_by.php)",
                    "[Introduction to GROUP BY in Oracle](https://www.educba.com/group-by-in-oracle/)",
                    "[Is it possible to use Aggregate function in a Select statment without using Group By clause?](https://stackoverflow.com/questions/6467216/is-it-possible-to-use-aggregate-function-in-a-select-statment-without-using-grou)"
                ],
                "feedbacks": [
                    "You cannot use a column alias in the GROUP BY clause. The GROUP BY clause requires the actual column name to group the data properly.",
                    "Using the WHERE clause after the GROUP BY clause does not exclude rows after creating groups. The WHERE clause filters rows before grouping them.",
                    "The GROUP BY clause is not mandatory if you are using an aggregating function in the SELECT clause. However, it is required to group the results based on specific columns.",
                    "Using the WHERE clause before the GROUP BY clause excludes rows before creating groups. The WHERE clause filters rows before the data is grouped.",
                    "If the SELECT clause has an aggregating function, then columns without an aggregating function in the SELECT clause should be included in the GROUP BY clause. This ensures that the non-aggregated columns are properly grouped with the aggregated results."
                ],
                "explanation": "<p>Correct Statements:</p><p><strong>1. Using the WHERE clause before the GROUP BY clause excludes rows before creating groups.</strong></p><ul><li><p><strong>True.</strong></p><ul><li><p>The <code>WHERE</code> clause filters <strong>individual rows</strong> before they are grouped.</p></li><li><p>This affects what data goes into the groups created by <code>GROUP BY</code>.</p></li></ul></li></ul><p><strong>2. If the SELECT clause has an aggregating function, then columns without an aggregating function in the SELECT clause should be included in the GROUP BY clause.</strong></p><ul><li><p><strong>True.</strong></p><ul><li><p>In SQL, if you use <strong>aggregate functions</strong> (like <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, etc.) in the <code>SELECT</code> clause, <strong>any column that is not aggregated must be in the </strong><code><strong>GROUP BY</strong></code><strong> clause</strong>.</p></li></ul></li></ul><p>Incorrect Statements:</p><p><strong>You can use a column alias in the GROUP BY clause.</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>Most SQL dialects <strong>do not allow</strong> using a column alias (defined in the <code>SELECT</code> clause) in the <code>GROUP BY</code> clause because <code>GROUP BY</code> is evaluated <strong>before</strong> <code>SELECT</code>.</p></li></ul></li></ul><p><strong>Using the WHERE clause after the GROUP BY clause excludes rows after creating groups.</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p><code>WHERE</code> comes <strong>before</strong> <code>GROUP BY</code> in SQL query execution.</p></li><li><p>To filter <strong>after grouping</strong>, you use the <code>HAVING</code> clause, <strong>not</strong> <code>WHERE</code>.</p></li></ul></li></ul><p><strong>The GROUP BY clause is mandatory if you are using an aggregating function in the SELECT clause.</strong></p><ul><li><p><strong>False.</strong></p><ul><li><p>You can use aggregate functions <strong>without</strong> <code>GROUP BY</code> if you're aggregating <strong>all rows</strong> together (e.g., <code>SELECT COUNT(*) FROM employees;</code>).</p></li></ul></li></ul><p><br></p><p><strong>The Oracle GROUP BY clause </strong>is used in a<a href=\"https://www.techonthenet.com/oracle/select.php\"> <code>SELECT</code></a> statement to collect data across multiple records and group the results by one or more columns.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>GROUP BY</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;\n</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The expressions that are not encapsulated within an aggregate function and must be included in the <code>GROUP BY</code> clause. aggregate_function It can be a function such as<a href=\"https://www.techonthenet.com/oracle/functions/sum.php\"> <code>SUM</code></a>,<a href=\"https://www.techonthenet.com/oracle/functions/count.php\"> <code>COUNT</code></a>,<a href=\"https://www.techonthenet.com/oracle/functions/min.php\"> <code>MIN</code></a>,<a href=\"https://www.techonthenet.com/oracle/functions/max.php\"> <code>MAX</code></a>, or <a href=\"https://www.techonthenet.com/oracle/functions/avg.php\"><code>AVG</code></a> functions. </p><p>aggregate_expression - This is the column or expression that the <em>aggregate_function</em> will be used on. tables The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p><p>• If the group function is included in a <code>SELECT</code> statement then individual result column(s) cannot be used without GROUP BY clause.</p><p>• The extra non-group functional columns should be <a href=\"https://www.educba.com/tableau-group-by/\">declared in the <code>GROUP BY</code> clause</a>.</p><p>• Rows can be pre excluded before dividing them into groups by using the WHERE clause.</p><p>• Column <code>ALIAS</code> cannot be used in the <code>GROUP BY</code> clause.</p><p>• By default, rows are sorted by ascending order of the column(s) included in the <code>GROUP BY</code> list.</p><p>• The columns applied upon the <code>GROUP BY</code> clause need not be part of the <code>SELECT</code> list.</p><p>• If the group function is included with the non-group functional column in a <code>SELECT</code> statement then <code>GROUP BY</code> clause must be used.</p><p><br></p><p><strong>All columns in the SELECT clause that do not have an aggregate need to be in the GROUP BY</strong></p><p>Good:</p><pre class=\"prettyprint linenums\">SELECT col1, col2, col3, MAX(col4)\n...\nGROUP BY col1, col2, col3</pre><p><br></p><p>Also good:</p><pre class=\"prettyprint linenums\">SELECT col1, col2, col3, MAX(col4)\n...\nGROUP BY col1, col2, col3, col5, col6</pre><p><br></p><p><em>√&nbsp; If the SELECT clause has an aggregating function, then columns without an aggregating function in the SELECT clause should be included in the GROUP BY clause.</em></p><p>The <code>GROUP BY</code> clause appears after the <code>FROM</code> clause. In case <code>WHERE</code> clause is presented, the <code>GROUP BY</code> clause must be placed after the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause as shown in the following query:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT \n   column_list \nFROM \n  T \nWHERE \n   condition\nGROUP BY c1, c2, c3;</pre><p><br></p><p>The <code>GROUP BY</code> clause groups rows by values in the grouping columns such as <code>c1</code>, <code>c2</code> and <code>c3</code>. The <code>GROUP BY</code> clause must contain only aggregates or grouping columns.</p><p><em>√ Using the WHERE clause before the GROUP BY clause excludes rows before creating groups.</em></p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\">https://www.oracletutorial.com/oracle-basics/oracle-group-by/</a></p>",
                "answers": [
                    "<p>You can use a column alias in the GROUP BY clause.</p>",
                    "<p>Using the WHERE clause after the GROUP BY clause excludes rows after creating groups.</p>",
                    "<p>The GROUP BY clause is mandatory if you are using an aggregating function in the SELECT clause.</p>",
                    "<p>Using the WHERE clause before the GROUP BY clause excludes rows before creating groups.</p>",
                    "<p>If the SELECT clause has an aggregating function, then columns without an aggregating function in the SELECT clause should be included in the GROUP BY clause.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e"
            ],
            "section": "GROUP BY",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the SQL GROUP BY clause. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289357,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The CUSTOMERS table has a CUST_CREDIT_LIMIT column of data type NUMBER.&nbsp; &nbsp;</p><p>Identify the queries which execute successfully. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: NVL Function](https://www.techonthenet.com/oracle/functions/nvl.php)",
                    "[Oracle / PLSQL: NVL2 Function](https://www.techonthenet.com/oracle/functions/nvl2.php)"
                ],
                "feedbacks": [
                    "The NVL function in Oracle is used to replace NULL values with a specified default value. In this query, the multiplication operation is attempted on the cust_credit_limit column, which is of data type NUMBER. However, the multiplication operation is not valid with the 'Not Available' string value, resulting in a type mismatch error.",
                    "The TO_CHAR function in Oracle is used to convert a value to a character data type. In this query, the multiplication operation is attempted on the cust_credit_limit column, which is of data type NUMBER. However, the multiplication operation is not valid with the 'Not Available' string value, resulting in a type mismatch error.",
                    "The TO_CHAR function is applied to the result of the multiplication operation on the cust_credit_limit column, which is of data type NUMBER. The NVL function then handles any potential NULL values that may arise from the multiplication operation, providing a default value of 'Not Available' if needed. This query executes successfully as it handles data type conversions and NULL values appropriately.",
                    "The NVL2 function in Oracle is used to return one of two values based on whether a specified expression is NULL or not. In this query, the TO_CHAR function is applied to the result of the multiplication operation on the cust_credit_limit column, which is of data type NUMBER. The NVL2 function then handles any potential NULL values that may arise from the multiplication operation, providing a default value of 'Not Available' if needed. This query executes successfully as it handles data type conversions and NULL values appropriately.",
                    "The NVL2 function in Oracle requires three arguments: the expression to evaluate, the value to return if the expression is not NULL, and the value to return if the expression is NULL. In this query, the expression cust_credit_limit * 1.05 is not valid for the NVL2 function, as it does not evaluate to a NULL value. Additionally, the 'Not Available' string value does not have a corresponding condition for the NVL2 function to handle, resulting in a syntax error."
                ],
                "explanation": "<p>Correct options:</p><p>1. <code>SELECT NVL(TO_CHAR(cust_credit_limit * 1.05), 'Not Available') FROM customers;</code></p><ul><li><p><code>cust_credit_limit * 1.05</code> produces a <code>NUMBER</code>.</p></li><li><p><code>TO_CHAR(...)</code> converts it to a <code>VARCHAR2</code>.</p></li><li><p><code>NVL(..., 'Not Available')</code> is valid because both arguments are of type <code>VARCHAR2</code>.</p></li><li><p><strong>This query executes successfully.</strong></p></li></ul><p>2. <code>SELECT NVL2(cust_credit_limit, TO_CHAR(cust_credit_limit * 1.05), 'Not Available') FROM customers;</code></p><ul><li><p><code>NVL2(expr1, expr2, expr3)</code> checks if <code>expr1</code> is NOT null; returns <code>expr2</code> if true, else <code>expr3</code>.</p></li><li><p>All return types (<code>TO_CHAR(...)</code>, <code>'Not Available'</code>) are character strings → valid.</p></li><li><p><strong>This query executes successfully.</strong></p></li></ul><p>To render the query successfully, the query must be converted from <code>NUMBER</code> to produce the provided text using <code>TO_CHAR</code> where there are <code>NULL</code> values. </p><p><strong>Note: </strong>One of the values has a zero value rather than <code>NULL</code> so it was not converted to 'Not Available'. It was multiplied by the value in the formula to return a zero amount because the field was not empty, it has a value of zero.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-29_12-45-44-2e775962228a19cd789e6604dab0ae34.png\"></p><p><br></p><p>Incorrect options:</p><ul><li><p> <code>SELECT NVL(cust_credit_limit * 1.05, 'Not Available') FROM customers;</code></p><ul><li><p><code>cust_credit_limit * 1.05</code> is <code>NUMBER</code>, <code>'Not Available'</code> is <code>VARCHAR2</code>.</p></li><li><p><code>NVL</code> requires both arguments to be of the <strong>same data type</strong>.</p></li><li><p><strong>This will cause a datatype mismatch error.</strong></p></li></ul></li></ul><ul><li><p> <code>SELECT TO_CHAR(NVL(cust_credit_limit * 1.05, 'Not Available')) FROM customers;</code></p><ul><li><p>Same issue as above: <code>NVL(..., 'Not Available')</code> tries to return either <code>NUMBER</code> or <code>VARCHAR2</code> → incompatible types.</p></li><li><p>Even though <code>TO_CHAR(...)</code> is used on the result, <code>NVL</code> evaluates first and fails.</p></li><li><p><strong>This will result in an error.</strong></p></li></ul></li></ul><ul><li><p> <code>SELECT NVL2(cust_credit_limit * 1.05, 'Not Available') FROM customers;</code></p><ul><li><p><code>NVL2</code> <strong>requires 3 arguments</strong>, but only 2 are provided here.</p></li><li><p><strong>This is a syntax error.</strong></p></li></ul></li></ul><p><br></p><p><strong>The Oracle/PLSQL NVL function</strong> lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. </p><p>replace_with - The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL</code> function returns a substitute value.</p><p><br></p><p><strong>The Oracle/PLSQL NVL2</strong> function extends the functionality found in the <a href=\"https://www.techonthenet.com/oracle/functions/nvl.php\">NVL function</a>. It lets you substitutes a value when a null value is encountered as well as when a non-null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL2</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">NVL2( string1, value_if_not_null, value_if_null )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. </p><p>value_if_not_null - The value returned if <em>string1</em> is <strong>not</strong> null. </p><p>value_if_null - The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL2</code> function returns a substitute value.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT NVL (cust_credit_limit * 1.05, 'Not Available')&nbsp; \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(NVL(cust_credit_limit * 1.05, 'Not Available'))&nbsp; \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(cust_credit_limit * 1.05), 'Not Available')&nbsp; \nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL2(cust_credit_limit,TO_CHAR(cust_credit_limit * 1.05), 'Not Available')\nFROM customers;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL2 (cust_credit_limit * 1.05, 'Not Available')&nbsp; \nFROM customers;\n</pre>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "NVL Function",
            "question_plain": "View and examine the following available responses.Given: The CUSTOMERS table has a CUST_CREDIT_LIMIT column of data type NUMBER.&nbsp; &nbsp;Identify the queries which execute successfully. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289359,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PROMOTIONS table and the exhibit.</p><p><strong>Table: PROMOTIONS </strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nPROMO_ID                      NOT NULL          NUMBER(6)\nPROMO_NAME                    NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY             NOT NULL          VARCHAR2(30)\nPROMO)SUBCATEGORY_ID          NOT NULL          NUMBER\nPROMO_CATEGORY                NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY_ID             NOT NULL          NUMBER\nPROMO_COST                    NOT NULL          NUMBER(10,2)\nPROMO_BEGIN_DATE              NOT NULL          DATE\nPROMO_END_DATE                NOT NULL          DATE\n</pre><p><br></p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1&nbsp; &nbsp;</strong></p><pre class=\"prettyprint linenums\">SELECT promo_name, \n       promo_cost,\n       (\n         SELECT AVG(promo_cost)\n         FROM promotions\n         WHERE promo_category = 'TV'\n       ) AS \"Average TV Cost\",\n       CASE\n         WHEN promo_cost &gt;= (\n           SELECT AVG(promo_cost)\n           FROM promotions\n           WHERE promo_category = 'TV'\n         )\n         THEN 'HIGH'\n         ELSE 'LOW'\n       END AS COST_REMARK\nFROM promotions;\n</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: AVG Function](https://www.techonthenet.com/oracle/functions/avg.php)",
                    "[Oracle / PLSQL: CASE Statement](https://www.techonthenet.com/oracle/functions/case.php)"
                ],
                "feedbacks": [
                    "This choice is incorrect because subqueries can be used with the CASE expression in SQL. The query provided in the exhibit is valid and will not produce an error due to the presence of a subquery.",
                    "This choice is incorrect because the query in the exhibit does not filter the results based on the promo category 'TV'. It simply adds a new column called COST_REMARK to all the promotions in the table, regardless of their category.",
                    "This choice is correct because the SQL statement in the exhibit adds a new column called COST_REMARK to all the promotions in the PROMOTIONS table. It does not filter the results based on any specific criteria, but rather adds the new column to all rows.",
                    "This choice is incorrect because the presence of a subquery in the SQL statement does not automatically result in an error. The query provided in the exhibit is syntactically correct and will not produce an error due to the subquery."
                ],
                "explanation": "<p>The correct outcome is: <strong>It shows a column called COST_REMARK for all the promotions in the table.</strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-29_16-38-02-91fb38d5e52fb6c024c15a59c0bbfbd5.png\"></p><p><br></p><p>Here’s why:</p><ul><li><p>The subquery used inside both the <code>SELECT</code> list and the <code>CASE</code> expression calculates the average <code>promo_cost</code> where <code>promo_category = 'TV'</code>. It's a <strong>scalar subquery</strong>—returning a single value—which is perfectly valid in both places.</p></li><li><p>Even though this average pertains to 'TV' promotions, there’s no <code>WHERE</code> clause in the outer query to limit results to that category. So, <strong>all promotions</strong> are returned, each with:</p><ul><li><p>Its own name and cost,</p></li><li><p>The average TV promo cost (same value repeated in every row),</p></li><li><p>A <code>COST_REMARK</code> of <code>'HIGH'</code> or <code>'LOW'</code> depending on how that promo's cost compares to the average TV cost.</p></li></ul></li></ul><p>To optimize the given SQL query, we want to <strong>avoid repeated execution</strong> of the same subquery and improve readability. The average TV promo cost is calculated twice—once in the select list and once in the <code>CASE</code> expression—which can be costly depending on the dataset size.</p><p>Here’s a streamlined version using a <strong>common table expression (CTE)</strong> or an <strong>inline subquery</strong> to compute the average once and reuse it:</p><pre class=\"prettyprint linenums\">WITH tv_avg AS (\n  SELECT AVG(promo_cost) AS avg_tv_cost\n  FROM promotions\n  WHERE promo_category = 'TV'\n)\nSELECT \n  promo_name, \n  promo_cost,\n  tv_avg.avg_tv_cost AS \"Average TV Cost\",\n  CASE\n    WHEN promo_cost &gt;= tv_avg.avg_tv_cost THEN 'HIGH'\n    ELSE 'LOW'\n  END AS cost_remark\nFROM promotions, tv_avg;\n</pre><p>This version:</p><ul><li><p><strong>Calculates the average once</strong> and reuses it.</p></li><li><p>Is <strong>more readable and maintainable</strong>—especially helpful if the logic ever needs tweaking.</p></li><li><p>Avoids hitting the <code>promotions</code> table multiple times unnecessarily.</p></li></ul><p><br></p><p><strong>The Oracle/PLSQL AVG function</strong> returns the average value of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>AVG</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT AVG(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>AVG</code> function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       AVG(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the <code>AVG</code> function and must be included in the <code>GROUP BY</code> clause at the end of the SQL statement. aggregate_expression This is the column or expression that will be averaged. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><code>WHERE</code> conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>AVG</code> function returns a numeric value.</p><p><br></p><p><strong>The Oracle/PLSQL CASE statement</strong> has the functionality of an <code>IF-THEN-ELSE</code> statement. Starting in Oracle 9i, you can use the <code>CASE</code> statement within a SQL statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>CASE</code> statement in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CASE [ expression ]\n\n   WHEN condition_1 THEN result_1\n   WHEN condition_2 THEN result_2\n   ...\n   WHEN condition_n THEN result_n\n\n   ELSE result\n\nEND</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression Optional. - It is the value that you are comparing to the list of conditions. (ie: condition_1, condition_2, ... condition_n) </p><p>condition_1, condition_2, ... condition_n - The conditions that must all be the same datatype. The conditions are evaluated in the order listed. Once a <em>condition</em> is found to be true, the <code>CASE</code> statement will return the result and not evaluate the conditions any further. </p><p>result_1, result_2, ... result_n - Results that must all be the same datatype. This is the value returned once a <em>condition</em> is found to be true.</p><p><strong>Returns</strong></p><p>The <code>CASE</code> statement returns any datatype such as a string, numeric, date, etc. (BUT all results must be the same datatype in the <code>CASE</code> statement.)<br>If all conditions are not the same datatype, an <a href=\"https://www.techonthenet.com/oracle/errors/ora00932.php\">ORA-00932</a> error will be returned.<br>If all results are not the same datatype, an <a href=\"https://www.techonthenet.com/oracle/errors/ora00932.php\">ORA-00932</a> error will be returned.<br>If no <em>condition</em> is found to be true, then the <code>CASE</code> statement will return the value in the <code>ELSE</code> clause.<br>If the <code>ELSE</code> clause is omitted and no <em>condition</em> is found to be true, then the <code>CASE</code> statement will return <code>NULL</code>.</p><p><strong>Note</strong></p><p>You can have up to 255 comparisons in a <code>CASE</code> statement. Each <code>WHEN ... THEN</code> clause is considered 2 comparisons.</p>",
                "answers": [
                    "<p>It produces an error because subqueries cannot be used with the CASE expression.</p>",
                    "<p>It shows COST_REMARK for all the promos in the promo category 'TV'.</p>",
                    "<p>It shows a column called COST_REMARK for all the promotions in the table.</p>",
                    "<p>It produces an error because a subquery gives an error.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "AVG ",
            "question_plain": "View and examine the structure of the PROMOTIONS table and the exhibit.Table: PROMOTIONS Name                          Null??            Type\nPROMO_ID                      NOT NULL          NUMBER(6)\nPROMO_NAME                    NOT NULL          VARCHAR2(30)\nPROMO_SUBCATEGORY             NOT NULL          VARCHAR2(30)\nPROMO)SUBCATEGORY_ID          NOT NULL          NUMBER\nPROMO_CATEGORY                NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY_ID             NOT NULL          NUMBER\nPROMO_COST                    NOT NULL          NUMBER(10,2)\nPROMO_BEGIN_DATE              NOT NULL          DATE\nPROMO_END_DATE                NOT NULL          DATE\nEvaluate the following SQL statement.Exhibit: 1&nbsp; &nbsp;SELECT promo_name, \n       promo_cost,\n       (\n         SELECT AVG(promo_cost)\n         FROM promotions\n         WHERE promo_category = 'TV'\n       ) AS \"Average TV Cost\",\n       CASE\n         WHEN promo_cost &gt;= (\n           SELECT AVG(promo_cost)\n           FROM promotions\n           WHERE promo_category = 'TV'\n         )\n         THEN 'HIGH'\n         ELSE 'LOW'\n       END AS COST_REMARK\nFROM promotions;\nIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289361,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The EMPLOYEES table has 100 rows of data.</p><p><strong>Required: </strong>Add a column called SALARY to the EMPLOYEES which cannot contain null.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ALTER TABLE Statement](https://www.techonthenet.com/oracle/tables/alter_table.php)"
                ],
                "feedbacks": [
                    "This SQL query correctly adds a column called SALARY to the EMPLOYEES table with the data type NUMBER(8,2), a default value of 0, and the constraint NOT NULL. This ensures that the SALARY column cannot contain null values, meeting the required condition.",
                    "This SQL query attempts to add a column called SALARY to the EMPLOYEES table with the data type NUMBER(8,2), a default value, and a constraint named p_nn. However, it is missing the NOT NULL constraint directly after the DEFAULT keyword, which is necessary to prevent null values in the SALARY column.",
                    "This SQL query tries to add a column called SALARY to the EMPLOYEES table with the data type NUMBER(8,2), a default value, but it is missing the NOT NULL constraint. Without the NOT NULL constraint, the SALARY column could still contain null values, which does not meet the required condition.",
                    "This SQL query attempts to add a column called SALARY to the EMPLOYEES table with the data type NUMBER(8,2) and the NOT NULL constraint. However, it is missing the DEFAULT keyword, which means that the SALARY column would not have a default value specified. This does not fully meet the required condition of adding a non-null column with a default value."
                ],
                "explanation": "<p>To solve this, let's break down the requirement and evaluate the SQL options:</p><p><strong>Requirement:</strong></p><ul><li><p>Add a column <code>SALARY</code> to the <code>EMPLOYEES</code> table.</p></li><li><p>The column <strong>must not allow NULLs</strong>.</p></li><li><p>There are <strong>already 100 rows</strong> in the table.</p></li><li><p>So, when adding a <code>NOT NULL</code> column to an existing table with rows, <strong>a default value is required</strong>, or the statement will fail.</p></li></ul><p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE EMPLOYEES \nADD SALARY NUMBER(8,2) DEFAULT 0 NOT NULL;\n</pre><ul><li><p>Adds the <code>SALARY</code> column.</p></li><li><p>Sets a default value of <code>0</code>, which is required to populate existing rows.</p></li><li><p>Enforces <code>NOT NULL</code>.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-29_18-04-56-9a2934fd00db1a39a99dc320030d3f1b.png\"></p><p><br></p><p><strong>Incorrect Options:</strong></p><ol><li><p><code><strong>ADD SALARY NUMBER(8,2) DEFAULT CONSTRAINT p_nn NOT NULL;</strong></code></p><ul><li><p>Invalid syntax: <code>DEFAULT CONSTRAINT</code> is not a valid clause.</p></li></ul></li><li><p><code><strong>ADD SALARY NUMBER(8,2) DEFAULT NOT NULL;</strong></code></p><ul><li><p>Invalid syntax: <code>DEFAULT</code> needs a value (e.g., <code>DEFAULT 0</code>), and placing <code>NOT NULL</code> right after <code>DEFAULT</code> without a value is incorrect.</p></li></ul></li><li><p><code><strong>ADD SALARY NUMBER(8,2) NOT NULL;</strong></code></p><ul><li><p>This will fail if there are existing rows (100 in this case) because Oracle cannot apply <code>NOT NULL</code> to a column with NULLs unless a default is provided.</p></li></ul></li></ol><p><br></p><p><strong>The Oracle ALTER TABLE</strong> statement is used to add, modify, or drop/delete columns in a table. The Oracle ALTER TABLE statement is also used to rename a table.</p><p><strong>Add column in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD A COLUMN</code> in a table, the Oracle <code>ALTER TABLE</code> syntax is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name column_definition;</pre><p><br></p><p><strong>Add multiple columns in table</strong></p><p><strong>Syntax</strong></p><p>To <code>ADD MULTIPLE COLUMNS</code> to an existing table, the Oracle <code>ALTER TABLE</code> syntax is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD (column_1 column_definition,\n       column_2 column_definition,\n       ...\n       column_n column_definition);</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table_name - The name of the table that you wish to create.</p><p>column1, column2, ... column_n - The columns that you wish to create in the table. Each column must have a datatype. The column should either be defined as \"null\" or \"not null\" and if this value is left blank, the database assumes \"null\" as the default.</p><p><br></p><p><strong>Add column in table with a default value with constraint</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\n  ADD column_name data_type DEFAULT default_value constraint ;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table_name - The name of the table that you wish to create.</p><p>data_type - Specify the data type to be used in the column.</p><p>default_value - Indicate the default value for the column.</p><p>constraint - List any constraints for the column.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">ALTER TABLE EMPLOYEES \nADD SALARY NUMBER(8,2) DEFAULT 0 NOT NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">ALTER TABLE EMPLOYEES \nADD SALARY NUMBER(8,2) DEFAULT CONSTRAINT p_nn NOT NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">ALTER TABLE EMPLOYEES \nADD SALARY NUMBER(8,2) DEFAULT NOT NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">ALTER TABLE EMPLOYEES \nADD SALARY NUMBER(8,2) NOT NULL\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ALTER TABLE",
            "question_plain": "View and examine the following available responses.Given: The EMPLOYEES table has 100 rows of data.Required: Add a column called SALARY to the EMPLOYEES which cannot contain null.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289363,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>A non-correlated subquery can be defined as [____]. (Choose the best answer.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Noncorrelated and Correlated Subqueries](https://www.vertica.com/docs/9.2.x/HTML/Content/Authoring/AnalyzingData/Queries/Subqueries/NoncorrelatedAndCorrelatedSubqueries.htm)"
                ],
                "feedbacks": [
                    "A non-correlated subquery is a set of one or more sequential queries where the result of the inner query is used as the search value in the outer query. This type of subquery does not depend on the outer query for its results and can be executed independently.",
                    "This definition does not accurately describe a non-correlated subquery. A non-correlated subquery does not necessarily have to return values from the same table in all sequential queries.",
                    "A non-correlated subquery does not have the restriction of always returning a single value. It can return multiple values or even a set of results, which are then used in the outer query.",
                    "This definition is incorrect as a non-correlated subquery can exist independently of another SELECT statement. It does not have to be embedded in a clause of another SELECT statement."
                ],
                "explanation": "<p>The best answer is: <strong>A set of one or more sequential queries in which generally the result of the inner query is used as the search value in the outer query.</strong></p><p>A <strong>non-correlated subquery</strong> is a subquery that:</p><ul><li><p>Can be <strong>executed independently</strong> of the outer query.</p></li><li><p>Is typically evaluated <strong>once</strong>, and its result is used by the outer query.</p></li><li><p>The <strong>inner query does not reference columns from the outer query</strong>.</p></li></ul><p>Why the other options are incorrect:</p><ol><li><p><strong>\"A set of sequential queries, all of which must return values from the same table.\"</strong></p><ul><li><p>Subqueries can access <strong>different tables</strong>, not just one.</p></li></ul></li><li><p><strong>\"A set of sequential queries, all of which must always return a single value.\"</strong></p><ul><li><p>Non-correlated subqueries can return <strong>multiple rows</strong>, depending on how they're used (e.g., with <code>IN</code>, <code>EXISTS</code>, etc.).</p></li></ul></li><li><p><strong>\"A SELECT statement that can be embedded in a clause of another SELECT statement only.\"</strong></p><ul><li><p>Subqueries can also be used in <strong>INSERT</strong>, <strong>UPDATE</strong>, <strong>DELETE</strong>, not just <code>SELECT</code>.</p></li></ul></li></ol><p><br></p><p><strong>Noncorrelated and Correlated Subqueries</strong></p><p>Subqueries can be categorized into two types:</p><p>• A <em>noncorrelated</em> (simple) subquery obtains its results independently of its containing (outer) statement.</p><p>• A <em>correlated</em> subquery requires values from its outer query in order to execute.</p><p><strong>Noncorrelated Subqueries</strong></p><p>A noncorrelated subquery executes independently of the outer query. The subquery executes first, and then passes its results to the outer query, For example:</p><pre class=\"prettyprint linenums\">SELECT name, street, city, state FROM addresses WHERE state IN (SELECT state FROM states);</pre><p><br></p><p>The section <code>(SELECT state FROM states)</code> is a noncorrelated subquery; the remainder of the query is relies on the subquery to filter the records.</p><p><em>√&nbsp; A set of one or more sequential queries in which generally the result of the inner query is used as the search value in the outer query.</em></p><p><br></p><p><strong>Correlated Subqueries</strong></p><p>A correlated subquery typically obtains values from its outer query before it executes. When the subquery returns, it passes its results to the outer query.</p><p>In the following example, the subquery needs values from the <code>addresses.state</code> column in the outer query:</p><pre class=\"prettyprint linenums\">SELECT name, street, city, state FROM addresses\n     WHERE EXISTS (SELECT * FROM states WHERE states.state = addresses.state);</pre><p><br></p><p>The main difference between Correlated and Noncorrelated subquery is that Correlated subquery depends upon Outer query and can not execute by its own while in Noncorrelated subquery both outer query and inner query are independent to each other.</p>",
                "answers": [
                    "<p>A set of one or more sequential queries in which generally the result of the inner query is used as the search value in the outer query.</p>",
                    "<p>A set of sequential queries, all of which must return values from the same table.</p>",
                    "<p>A set of sequential queries, all of which must always return a single value.</p>",
                    "<p>A SELECT statement that can be embedded in a clause of another SELECT statement only.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.A non-correlated subquery can be defined as [____]. (Choose the best answer.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289365,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given:</strong> There is a customer with the name 'Howard Stark' who's registered city is 'New York'. </p><p>The following query has been successfully executed.</p><p><strong>Exhibit: 1</strong> </p><pre class=\"prettyprint linenums\">SELECT INITCAP(\n  cust_first_name || ' ' || \n  UPPER(SUBSTR(cust_city, -LENGTH(cust_city), 2))\n)\nFROM customers\nWHERE cust_first_name = 'Howard';\n</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: INITCAP Function](https://www.techonthenet.com/oracle/functions/initcap.php)",
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)",
                    "[Oracle / PLSQL: UPPER Function](https://www.techonthenet.com/oracle/functions/upper.php)"
                ],
                "feedbacks": [
                    "The query is using the SUBSTR function to extract a substring from the 'Howard Stark' string. The function is set to start at position 1 and extract 10 characters, which results in 'Howard Ne'.",
                    "The query is using the SUBSTR function to extract a substring from the 'Howard Stark' string. The function is set to start at position 1 and extract 9 characters, which results in 'Howard NE'.",
                    "The query is using the SUBSTR function to extract a substring from the 'Howard Stark' string. The function is set to start at position 1 and extract 8 characters, which results in 'Howard SN'.",
                    "If there was an error in the execution of the query, it would have resulted in an error message being displayed. However, since the query has been successfully executed, this choice is incorrect.",
                    "The output of the query is not available in the list of options provided. This choice is incorrect as the result of the query is one of the options listed."
                ],
                "explanation": "<p>Correct Answer:<strong> Howard Ne</strong></p><p>Let's break down the SQL query and analyze its components:</p><p><strong>Given Data:</strong></p><ul><li><p><code>cust_first_name = 'Howard'</code></p></li><li><p><code>cust_city = 'New York'</code></p></li></ul><p><strong>Query (from Exhibit 1):</strong></p><pre class=\"prettyprint linenums\">SELECT INITCAP(\n  cust_first_name || ' ' || \n  UPPER(SUBSTR(cust_city, -LENGTH(cust_city), 2))\n)\nFROM customers\nWHERE cust_first_name = 'Howard';\n</pre><p><strong>Step-by-step Breakdown:</strong></p><ol><li><p><code><strong>cust_first_name || ' '</strong></code> → <code>'Howard '</code> (a space is added)</p></li><li><p><code><strong>SUBSTR(cust_city, -LENGTH(cust_city), 2)</strong></code></p><ul><li><p><code>cust_city = 'New York'</code> (length = 8)</p></li><li><p><code>SUBSTR('New York', -8, 2)</code><br>→ In Oracle, <code>SUBSTR(string, negative_start, length)</code> starts from the end.</p><p>So:</p><ul><li><p><code>SUBSTR('New York', -8, 2)</code> = <code>SUBSTR('New York', 1, 2)</code> = <code>'Ne'</code></p></li></ul></li></ul></li><li><p><code><strong>UPPER('Ne')</strong></code><strong> = </strong><code><strong>'NE'</strong></code></p></li><li><p><strong>Concatenated Result:</strong><br><code>'Howard ' || 'NE'</code> = <code>'Howard NE'</code></p></li><li><p><code><strong>INITCAP('Howard NE')</strong></code> → Capitalizes each word → Result is: <code><strong>Howard Ne</strong></code></p></li></ol><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-29_20-10-18-2efb58fb97f7c37faa1238a8a3c7ee33.png\"></p><p><br></p><p><strong>The Oracle/PLSQL INITCAP</strong> function sets the first character in each word to uppercase and the rest to lowercase.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INITCAP</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">INITCAP( string1 )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 The string argument whose first character in each word will be converted to uppercase and all remaining characters converted to lowercase.</p><p><strong>Returns</strong></p><p>The <code>INITCAP</code> function returns a string value.</p><p><br></p><p><strong>The Oracle/PLSQL UPPER function</strong> converts all letters in the specified string to uppercase. If there are characters in the string that are not letters, they are unaffected by this function.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>UPPER</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">UPPER( string1 )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to convert to uppercase.</p><p><strong>Returns</strong></p><p>The <code>UPPER</code> function returns a string value.</p><p><br></p><p><strong>The Oracle/PLSQL SUBSTR </strong>functions allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string The source string. start_position The starting position for extraction. The first position in the string is always 1. length Optional. It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a NULL value.</p><p><strong>Note</strong></p><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p>",
                "answers": [
                    "<p>Howard Ne</p>",
                    "<p>Howard NE</p>",
                    "<p>Howard SN</p>",
                    "<p>An error message</p>",
                    "<p>The output is not available in the list of options.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "INITCAP ",
            "question_plain": "View and examine the following scenario.Given: There is a customer with the name 'Howard Stark' who's registered city is 'New York'. The following query has been successfully executed.Exhibit: 1 SELECT INITCAP(\n  cust_first_name || ' ' || \n  UPPER(SUBSTR(cust_city, -LENGTH(cust_city), 2))\n)\nFROM customers\nWHERE cust_first_name = 'Howard';\nIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289367,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>A subquery is called a single-row subquery when [____]. (Select the best answer)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Single Row Subquery](https://www.tutorialspoint.com/What-are-single-row-and-multiple-row-subqueries)"
                ],
                "feedbacks": [
                    "This choice does not accurately define a single-row subquery. A single-row subquery occurs when the inner query returns a single value to the outer query, not when there is only one subquery in the outer query.",
                    "This choice correctly defines a single-row subquery. In this scenario, the inner query returns a single value to the outer query, making it a single-row subquery.",
                    "This choice incorrectly describes a single-row subquery. A single-row subquery is defined by the inner query returning a single value, not by using an aggregating function and returning one or more values.",
                    "This choice does not accurately define a single-row subquery. A single-row subquery occurs when the inner query returns a single value, not when the outer query returns a single value."
                ],
                "explanation": "<p>Correct Answer: <strong>The inner query returns a single value to the outer query.</strong></p><p>A <strong>single-row subquery</strong> is defined as:</p><ul><li><p>A subquery that returns <strong>exactly one row</strong> and <strong>one column</strong>.</p></li><li><p>It is typically used with <strong>single-row comparison operators</strong> such as <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, or <code>&lt;&gt;</code>.</p></li></ul><p><strong>Why the other options are incorrect:</strong></p><ol><li><p><strong>\"There is only one subquery in the outer query and the inner query returns one or more values.\"</strong></p><ul><li><p>Having only one subquery doesn't define whether it's single-row or multi-row. Also, \"one or more values\" implies it may return multiple rows, which contradicts the definition.</p></li></ul></li><li><p><strong>\"The inner query uses an aggregating function and returns one or more values.\"</strong></p><ul><li><p>Aggregate functions <strong>can</strong> return a single value, but not always — and this doesn’t define a <strong>single-row subquery</strong> unless it always guarantees one row.</p></li></ul></li><li><p><strong>\"The inner query returns one or more values and the outer query returns a single value.\"</strong></p><ul><li><p>The number of rows returned by the <strong>outer query</strong> doesn't define the type of subquery.</p></li></ul><p><br></p></li></ol><p><strong>Single Row Sub Query</strong></p><p>A single-row subquery is used when the outer query's results are based on a single, unknown value. </p><p>Although this query type is formally called \"single-row,\" the name implies that the query returns multiple columns-but only one row of results. However, a single-row subquery can return only one row of results consisting of only one column to the outer query.</p><p><em>√&nbsp; The inner query returns a single value to the outer query.</em></p><p><br></p><p>In the below <code>SELECT</code> query returns only one row i.e. the minimum salary for the company. It, in turn, uses this value to compare the salary of all the employees and displays only those, whose salary is equal to minimum salary.</p><pre class=\"prettyprint linenums\">SELECT first_name, salary, department_id\nFROM employees\nWHERE salary = (SELECT MIN (salary)\nFROM employees);\n</pre><p><br></p><p>A <code>HAVING</code> clause is used when the group results of a query need to be restricted based on some condition. If a subquery's result must be compared with a group function, you must nest the inner query in the outer query's HAVING clause.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT department_id, MIN (salary)\nFROM employees\nGROUP BY department_id\nHAVING MIN (salary) &lt; (SELECT AVG (salary)\nFROM employees);\n</pre><p><br></p><p><strong>Multiple Row Sub Query</strong></p><p>Multiple-row subqueries are nested queries that can return more than one row of results to the parent query. </p><p>Multiple-row subqueries are used most commonly in <code>WHERE</code> and <code>HAVING</code> clauses. Since it returns multiple rows, it must be handled by set comparison operators (<code>IN</code>, <code>ALL</code>, <code>ANY</code>). While IN operator holds the same meaning as discussed in the earlier chapter, <code>ANY</code> operator compares a specified value to each value returned by the subquery while <code>ALL</code> compares a value to every value returned by a subquery. Below query will show the error because single row subquery returns multiple rows.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT first_name, department_id \nFROM employees \nWHERE department_id = (\n     SELECT department_id \n     FROM employees \n     WHERE LOCATION_ID = 100);\n</pre>",
                "answers": [
                    "<p>There is only one subquery in the outer query and the inner query returns one or more values.</p>",
                    "<p>The inner query returns a single value to the outer query.</p>",
                    "<p>The inner query uses an aggregating function and returns one or more values.</p>",
                    "<p>The inner query returns one or more values and the outer query returns a single value.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.A subquery is called a single-row subquery when [____]. (Select the best answer)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289321,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Scenario:</strong> You are creating a query using substitution variables. You want this query to return employees who earn the value a user enters, or the double of that value, but you notice that SQL Developer asks for the value twice (once for each time the variable is used).</p><p><strong>Required:</strong> Edit the statement so that it asks for it only once.</p><p>Which of the below statements will request the variable only once?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Literals, Substitution Variables and Bind Variables](https://oracle-base.com/articles/misc/literals-substitution-variables-and-bind-variables)",
                    "[Substitution Variables in Oracle](http://sql.standout-dev.com/learn-oracle-sql/operators/substitution-variables/)"
                ],
                "feedbacks": [
                    "Using a double ampersand (&amp;&amp;) before the variable name ensures that the value is only prompted for once. In this statement, the variable is prompted for once and used in both conditions, allowing the user to enter the value only once.",
                    "Using a single ampersand (&amp;) before the variable name prompts the user for the value each time it is encountered in the query. In this statement, the user will be prompted for the value twice, once for each occurrence of the variable.",
                    "The ELSE keyword is not valid in SQL for this context. It does not serve the purpose of prompting the user for the variable only once. This statement will not work as intended.",
                    "Using multiple WHERE clauses is not valid in SQL for this context. It does not serve the purpose of prompting the user for the variable only once. This statement will not work as intended.",
                    "Mixing single ampersand (&amp;) and double ampersand (&amp;&amp;) before the variable names will result in the user being prompted for the value multiple times. In this statement, the user will be prompted for the value twice, once for each type of variable declaration."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;&amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre><p><br></p><p>Oracle <strong>substitution variables</strong> work like this:</p><ul><li><p><code>&amp;variable</code> — Prompts the user <strong>every time</strong> the variable is referenced.</p></li><li><p><code>&amp;&amp;variable</code> — Prompts the user <strong>only once</strong>, and <strong>stores it</strong> for reuse in that session.</p></li></ul><p><strong>Why this works:</strong></p><pre class=\"prettyprint linenums\">WHERE tuition = &amp;&amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre><ul><li><p><code>&amp;&amp;tuit</code> prompts <strong>once</strong>, then defines the variable.</p></li><li><p><code>&amp;tuit</code> uses the <strong>already-defined</strong> value without prompting again.</p></li></ul><p>SQL Developer will only <strong>prompt the user once</strong>, and use that value for both conditions.</p><p><strong>Why other options are incorrect:</strong></p><ol><li><p><code><strong>WHERE tuition = &amp;tuit OR tuition = &amp;tuit * 2;</strong></code></p><ul><li><p>Prompts <strong>twice</strong> — once for each use of <code>&amp;tuit</code>.</p></li></ul></li><li><p><code><strong>WHERE tuition = &amp;&amp;tuit ELSE tuition = &amp;tuit * 2;</strong></code></p><ul><li><p><code>ELSE</code> is invalid in a <code>WHERE</code> clause.</p></li></ul></li><li><p><code><strong>WHERE tuition = &amp;&amp;tuit WHERE tuition = &amp;tuit * 2;</strong></code></p><ul><li><p>Two <code>WHERE</code> clauses in the same <code>SELECT</code> are invalid.</p></li></ul></li><li><p><code><strong>WHERE tuition = &amp;tuit OR tuition = &amp;&amp;tuit * 2;</strong></code></p><ul><li><p><code>&amp;tuit</code> (first usage) will prompt; <code>&amp;&amp;tuit</code> (second) won’t reuse — this may behave inconsistently or prompt twice depending on session state.</p></li></ul></li></ol><p>Use <code>&amp;&amp;tuit</code> the <strong>first time</strong> to define it, then <code>&amp;tuit</code> afterward to <strong>reuse without prompting</strong>.</p><p><br></p><p><strong>Substitution Variables</strong></p><p>Substitution variables are a feature of the SQL*Plus tool. They have nothing to do with the way SQL is processed by the database server. When a substitution variable is used in a statement, SQL*Plus requests an input value and rewrites the statement to include it. The rewritten statement is passed to the database. As a result, the database server knows nothing of the substitution variable.</p><p><strong>Parameterizing a Query by Adding Substitution Variables</strong></p><p><strong>Using Substitution Variables for Numeric Values</strong></p><p>To set Oracle to prompt for user input on a field, write an ampersand (&amp;), and then the name of the variable I want to use in the WHERE clause as shown. In this case, we are setting up to be prompted for the Department.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM employee\nWHERE department_id = &amp;Department;</pre><p><br></p><p>Each time this query is ran, it will prompt for the Department</p><p>Keep in mind that this substitution is done by the client tool (SQL Developer in this case) before sending the statement to the database, so, the database doesn’t even know that a substitution variable was used, because it is sent by SQL Developer as if&nbsp; we had used the department_id as a literal.</p><p><strong>Using Substitution Variables for Strings and Dates</strong></p><p>If you want to use a substitution variable for a string (<code>VARCHAR</code>), I have to make sure the value is enclosed inside 'single quotes'.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM employee\nWHERE department_id = Department'&amp;Department';\n</pre><pre class=\"prettyprint linenums\">SELECT *\nFROM employee\nWHERE hire_date &gt;= DATE '&amp;date';\n</pre><p><br></p><p><strong>Saving Substitution Variables’ Values</strong></p><p>If you want to save the value you provided, so that you are not asked to provide it twice if the variable appears twice, use a double ampersand, instead of a single one.</p><pre class=\"prettyprint linenums\">SELECT *\nFROM employee\nWHERE salary = &amp;&amp;sal\nOR salary = &amp;sal * 2;\n</pre><p><br></p><p>You need only add the additional ampersand to the first appearance of the variable. You may add it to the other appearances if you wish, but it is not required.</p><p>When you run the query now, SQL Developer would only ask for the value once, and the same value would be used in any other part of the statement where the same variable is used.</p><p><strong>Making SQL Developer Forget the Saved Value of a Substitution Variable</strong></p><p>This happens because once you define a variable with a double ampersand, the value is stored for the duration of the session. If you want to get prompted again, you have to explicitly undefine the variable, which is done precisely with a command called “<em>UNDEFINE</em>”.</p><p>It is usually advised to run the <em>UNDEFINE</em> command immediately after the SQL statement to clear the memory to avoid carrying the value to an unwanted placement.</p><p><em>√&nbsp; The below query meets the requirement as it asks for the variable only once.</em></p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;&amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre><p><br></p><p>&amp;&amp; is prompted only once per session and &amp; is prompted each time the query is run during the session unless proceeded by the same field being prompted for with a &amp;&amp; prefix and <code>UNDEFINE</code> was not executed.</p><p>The following statement will request the value twice (once for each time the variable is used).</p><pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;&amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;tuit\nOR tuition = &amp;tuit * 2;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;&amp;tuit\nELSE tuition = &amp;tuit * 2;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;&amp;tuit\nWHERE tuition = &amp;tuit * 2;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *\nFROM students\nWHERE tuition = &amp;tuit\nOR tuition = &amp;&amp;tuit * 2;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Substitution Variables",
            "question_plain": "Scenario: You are creating a query using substitution variables. You want this query to return employees who earn the value a user enters, or the double of that value, but you notice that SQL Developer asks for the value twice (once for each time the variable is used).Required: Edit the statement so that it asks for it only once.Which of the below statements will request the variable only once?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289323,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding indexes. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Indexes](https://www.techonthenet.com/oracle/indexes.php)"
                ],
                "feedbacks": [
                    "By default, Oracle creates B-tree indexes, which are the most commonly used type of index in Oracle databases. B-tree indexes are efficient for range queries and equality searches.",
                    "If you forgot to collect statistics on the index when you first created it or you want to update the statistics, you can always use the ALTER INDEX command to collect statistics at a later date. This helps the query optimizer make better decisions when generating execution plans.",
                    "You can drop or create an index without physically affecting the indexed table. Dropping an index does not delete the data in the table, and creating an index does not modify the table's data.",
                    "An Index is an optional structure, associated with a table or table cluster which can improve the speed of data access. While indexes can enhance query performance, they are not always necessary and should be carefully considered based on the specific use case.",
                    "Indexes do occupy physical disk space. Indexes are stored on disk to allow for efficient data retrieval. The size of an index can vary based on the number of indexed columns and the type of index.",
                    "When an item is indexed, the database needs to update the index when DML (Data Manipulation Language) operations occur on the indexed data. This ensures that the index remains consistent with the underlying table data and supports efficient data retrieval."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ol><li><p><strong>By default, Oracle creates B-tree indexes.</strong></p><ul><li><p><strong>Correct</strong>. Oracle's default indexing method is a <strong>B-tree (balanced tree)</strong> structure.</p></li><li><p>Unless specified otherwise (like bitmap), Oracle creates <strong>B-tree indexes</strong>.</p></li></ul></li><li><p><strong>If you forgot to collect statistics on the index when you first created it or you want to update the statistics, you can always use the ALTER INDEX command to collect statistics at a later date.</strong></p><ul><li><p><strong>Correct</strong>. You can collect statistics using:</p><pre class=\"prettyprint linenums\">ALTER INDEX index_name COMPUTE STATISTICS;\n</pre><p>or better, use:</p><pre class=\"prettyprint linenums\">EXEC DBMS_STATS.GATHER_INDEX_STATS(...);\n</pre></li></ul></li><li><p><strong>You can drop or create an index without physically affecting the indexed table.</strong></p><ul><li><p><strong>Correct</strong>. Indexes are <strong>separate schema objects</strong>.</p></li><li><p>Dropping/creating an index does <strong>not change</strong> the data in the table.</p></li></ul></li></ol><p><strong>False Statements:</strong></p><ul><li><p><strong>An Index is an optional structure, associated with a table or table cluster which always improves the speed of data access.</strong></p><ul><li><p><strong>Incorrect</strong> because of the word \"<strong>always</strong>\".</p></li><li><p>While indexes <strong>usually</strong> improve read performance, they can <strong>degrade performance</strong> for:</p><ul><li><p>Inserts, updates, deletes (due to extra maintenance)</p></li><li><p>Queries on small tables or non-selective columns</p></li></ul></li></ul></li><li><p><strong>Indexes do not occupy physical disk space.</strong></p><ul><li><p><strong>Incorrect</strong>. Indexes <strong>do consume disk space</strong>, as they are stored separately from the table.</p></li></ul></li><li><p><strong>When an item is indexed, the database need not update the index when DML occurs on the indexed data.</strong></p><ul><li><p><strong>Incorrect</strong>. On any <strong>DML (INSERT, UPDATE, DELETE)</strong> affecting an indexed column, <strong>the index must be updated</strong> to maintain accuracy.</p></li></ul><p><br></p></li></ul><p>An <strong>Index </strong>is an optional structure, associated with a table or <strong>table cluster</strong>, that can sometimes speed data access.</p><p>Indexes are schema objects that are logically and physically independent of the data in the objects with which they are associated. Thus, you can drop or create an index without physically affecting the indexed table.</p><p>The absence or presence of an index does not require a change in the wording of any SQL statement.</p><p>An index is a fast access path to a single row of data. It affects only the speed of execution. Given a data value that has been indexed, the index points directly to the location of the rows containing that value.</p><p>When an index exists on one or more columns of a table, the database can in some cases retrieve a small set of randomly distributed rows from the table. Indexes are one of many means of reducing disk I/O. If a heap-organized table has no indexes, then the database must perform a <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/20/cncpt/glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D\">full table scan</a> to find a value.</p><p><em>√&nbsp; You can drop or create an index without physically affecting the indexed table.</em></p><p><br></p><p><strong>Disadvantages of indexes</strong></p><p>• Creating indexes manually often requires deep knowledge of the data model, application, and data distribution.</p><p>• As the data changes, you must revisit previous decisions about indexes. An index might stop being useful, or new indexes might be required.</p><p>• Indexes occupy disk space.</p><p>• The database must update the index when DML occurs on the indexed data, which creates performance overhead.</p><p><strong>Consider creating an index in the following situations:</strong></p><p>• The indexed columns are queried frequently and return a small percentage of the total number of rows in the table.</p><p>• A referential <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/20/cncpt/glossary.html#GUID-67F8FE8C-EBA5-4796-820A-8919982A1411\">integrity constraint</a> exists on the indexed column or columns. The index is a means to avoid a full table <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/20/cncpt/glossary.html#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C\">lock</a> that would otherwise be required if you update the parent table <a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/20/cncpt/glossary.html#GUID-8640EFA5-276C-4812-A078-1F21F55F4200\">primary key</a>, merge into the parent table, or delete from the parent table.</p><p>• A unique key constraint will be placed on the table and you want to manually specify the index and all index options.</p><p><br></p><p><strong>Oracle Index</strong></p><p>An <code>INDEX</code> is a performance-tuning method of allowing faster retrieval of records. An index creates an entry for each value that appears in the indexed columns. By default, Oracle creates B-tree indexes.</p><p><strong>Create an Index</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating an <code>INDEX</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE [UNIQUE] INDEX index_name\n  ON table_name (column1, column2, ... column_n)\n  [ COMPUTE STATISTICS ];</pre><p><br></p><p>UNIQUE - It indicates that the combination of values in the indexed columns must be unique. </p><p>index_name - The name to assign to the index. </p><p>table_name - The name of the table in which to create the index. </p><p>column1, column2, ... column_n - The columns to use in the index. </p><p>COMPUTE STATISTICS - It tells Oracle to collect statistics during the creation of the index. The statistics are then used by the optimizer to choose a \"plan of execution\" when SQL statements are executed.</p><p><em>√&nbsp; By default, Oracle creates B-tree indexes.</em></p><p><br></p><p><strong>Rename an Index</strong></p><p><strong>Syntax</strong></p><p>The syntax for renaming an <code>INDEX</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ALTER INDEX index_name\n  RENAME TO new_index_name;</pre><p><br></p><p>index_name - The name of the index that you wish to rename. new_index_name The new name to assign to the index.</p><p><br></p><p><strong>Collect Statistics on an Index</strong></p><p>If you forgot to collect statistics on the index when you first created it or you want to update the statistics, you can always use the <code>ALTER INDEX</code> command to collect statistics at a later date.</p><p><strong>Syntax</strong></p><p>The syntax for collecting statistics on an <code>INDEX</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ALTER INDEX index_name\n  REBUILD COMPUTE STATISTICS;</pre><p><br></p><p>index_name - The index in which to collect statistics.</p><p><em>√&nbsp; If you forgot to collect statistics on the index when you first created it or you want to update the statistics, you can always use the ALTER INDEX command to collect statistics at a later date.</em></p><p><strong>Drop an Index</strong></p><p><strong>Syntax</strong></p><p>The syntax for dropping an <code>INDEX</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">DROP INDEX index_name;</pre><p><br></p><p>index_name - The name of the index to drop.</p>",
                "answers": [
                    "<p>By default, Oracle creates B-tree indexes.</p>",
                    "<p>If you forgot to collect statistics on the index when you first created it or you want to update the statistics, you can always use the ALTER INDEX command to collect statistics at a later date.</p>",
                    "<p>You can drop or create an index without physically affecting the indexed table.</p>",
                    "<p>An Index is an optional structure, associated with a table or table cluster which always improves the speed of data access.</p>",
                    "<p>Indexes do not occupy physical disk space.</p>",
                    "<p>When an item is indexed, the database need not update the index when DML occurs on the indexed data.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "Indexes",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding indexes. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289325,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT 2\nFROM dual d1\nCROSS JOIN dual d2\nCROSS JOIN dual d3;\n</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CROSS JOIN operation](https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqljcrossjoin.html)"
                ],
                "feedbacks": [
                    "The query in the SQL exhibit returns a single row based on the data and conditions provided. Therefore, the result of the query is not 2 rows.",
                    "The query in the SQL exhibit is structured to return a single row of data. The query does not contain any conditions or joins that would result in multiple rows being returned.",
                    "The query in the SQL exhibit does not involve any aggregation functions or grouping that would result in the output being 6 rows. Therefore, the result is not 6 rows.",
                    "The query in the SQL exhibit is not designed to return 3 rows of data. The query does not include any logic that would generate 3 rows as the output.",
                    "If the query in the SQL exhibit does not match any data in the database based on the conditions provided, it would result in 0 rows being returned. However, based on the structure of the query, it is expected to return a row of data.",
                    "The query in the SQL exhibit is well-structured and does not contain any syntax errors or logical issues that would result in an error being thrown. Therefore, the result is not an error."
                ],
                "explanation": "<p>Correct Answer: <strong>1 row</strong></p><p>Let's analyze the SQL query provided in <strong>Exhibit 1</strong>:<strong>SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT 2\nFROM dual d1\nCROSS JOIN dual d2\nCROSS JOIN dual d3;\n</pre><p><strong>Understanding what's happening:</strong></p><ul><li><p><code>DUAL</code> is a special Oracle table that contains exactly <strong>1 row</strong>.</p></li><li><p><code>CROSS JOIN</code> returns the <strong>Cartesian product</strong> of two tables.</p></li><li><p>So:</p><ul><li><p><code>dual d1</code> → 1 row</p></li><li><p><code>CROSS JOIN dual d2</code> → 1 × 1 = 1 row</p></li><li><p><code>CROSS JOIN dual d3</code> → 1 × 1 × 1 = <strong>1 row</strong></p></li></ul><p><br></p></li></ul><p>Each <code>DUAL</code> is treated as a <strong>separate instance</strong>, so:</p><ul><li><p><code>dual d1</code> → 1 row</p></li><li><p><code>dual d2</code> → 1 row</p></li><li><p><code>dual d3</code> → 1 row</p></li></ul><p>Then:</p><ul><li><p><code>d1 × d2 × d3</code> = <strong>1 × 1 × 1 = 1 row</strong></p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-30_11-56-25-ddf67a28f6ca7701621b61cd8d129b2c.png\"></p><p><br></p><p>If we were doing something like:</p><pre class=\"prettyprint linenums\">SELECT 2 FROM dual d1 CROSS JOIN dual d2;\n</pre><p>→ 1 × 1 = <strong>1 row</strong></p><p>But if the query was:</p><pre class=\"prettyprint linenums\">SELECT 2\nFROM dual d1\nCROSS JOIN dual d2\nCROSS JOIN dual d3;\n</pre><p>→ 1 × 1 × 1 = <strong>1 row</strong></p><p><br></p><p><strong>CROSS JOIN operation</strong></p><p>A <code>CROSS JOIN</code> is a <a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj29840.html#rrefsqlj29840\"><code>JOIN</code></a> operation that produces the Cartesian product of two tables. Unlike other <code>JOIN</code> operators, it does not let you specify a join clause. You may, however, specify a <code>WHERE</code> clause in the <code>SELECT</code> statement.</p><p>The following <code>SELECT</code> statements are equivalent:</p><p>Simple.</p><pre class=\"prettyprint linenums\">SELECT * FROM CITIES CROSS JOIN FLIGHTS</pre><pre class=\"prettyprint linenums\">SELECT * FROM CITIES, FLIGHTS</pre><p><br></p><p>A little more complicated.</p><pre class=\"prettyprint linenums\">SELECT * FROM CITIES CROSS JOIN FLIGHTS\n    WHERE CITIES.AIRPORT = FLIGHTS.ORIG_AIRPORT</pre><pre class=\"prettyprint linenums\">SELECT * FROM CITIES INNER JOIN FLIGHTS\n    ON CITIES.AIRPORT = FLIGHTS.ORIG_AIRPORT</pre><p><br></p><p>A <code>CROSS JOIN</code> operation can be replaced with an <code>INNER JOIN</code> where the join clause always evaluates to true (for example, 1=1). It can also be replaced with a sub-query.</p>",
                "answers": [
                    "<p>2 rows</p>",
                    "<p>1 row</p>",
                    "<p>6 rows</p>",
                    "<p>3 rows</p>",
                    "<p>0 rows</p>",
                    "<p>An error</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT 2\nFROM dual d1\nCROSS JOIN dual d2\nCROSS JOIN dual d3;\nIdentify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289327,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the structure of the EMPLOYEES table.&nbsp; </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-45-08-33349c597be111fb86ec8294899dec97.png\"></p><p><br></p><p><strong>Given: </strong>The entry in the manager id field for an employee is the manager's employee id.</p><p><strong>Required:</strong> Select all employees who report to the Manager who has employee id 9. The output is to be in two columns: the first column should have the employee's manager's LAST_NAME and the second column should have the employee's LAST_NAME.&nbsp; </p><p>Identify the best SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)",
                    "[What is Self Join in Oracle?](https://www.w3resource.com/oracle/joins/oracle-self-join.php)"
                ],
                "feedbacks": [
                    "This query joins the EMPLOYEES table with itself using aliases 'm' and 'e' to represent the manager and employee respectively. It then filters the results based on the manager_id being equal to 9. However, the condition should be based on the employee's manager_id, not the manager's employee_id.",
                    "This query correctly joins the EMPLOYEES table with itself using aliases 'm' and 'e' to represent the manager and employee respectively. It filters the results based on the employee's manager_id being equal to 9, which is the correct approach to select all employees who report to the Manager with employee id 9.",
                    "This query attempts to join the EMPLOYEES table without specifying the join condition, which would result in a Cartesian product. It then filters the results based on the employee_id being equal to the manager's manager_id, which is not the correct condition to select employees who report to the Manager with employee id 9.",
                    "This query attempts to join the EMPLOYEES table without specifying the join condition, which would result in a Cartesian product. It then filters the results based on the employee_id being equal to the manager's employee_id, which is not the correct condition to select employees who report to the Manager with employee id 9."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\"\nFROM employees m\nJOIN employees e ON m.employee_id = e.manager_id\nWHERE e.manager_id = 9;\n</pre><p><br></p><p>Required:</p><ul><li><p><strong>Select employees who report to manager with </strong><code><strong>employee_id = 9</strong></code></p></li><li><p>Show:</p><ul><li><p><code>Manager</code>'s <code>last_name</code></p></li><li><p><code>Employee</code>'s <code>last_name</code></p></li></ul></li></ul><p>This is a classic <strong>self-join</strong> scenario, where:</p><ul><li><p>The <strong>employee</strong> has a <code>manager_id</code> column</p></li><li><p>That <code>manager_id</code> refers to the <code>employee_id</code> of another employee (i.e., the manager)</p></li></ul><p><strong>Correct logic:</strong></p><pre class=\"prettyprint linenums\">FROM employees m\nJOIN employees e ON m.employee_id = e.manager_id\nWHERE e.manager_id = 9;\n</pre><ul><li><p><code>m</code> = the <strong>manager</strong></p></li><li><p><code>e</code> = the <strong>employee</strong></p></li><li><p><code>m.employee_id = e.manager_id</code> = links employees to their manager</p></li><li><p><code>WHERE e.manager_id = 9</code> = filters employees <strong>who report to manager #9</strong></p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-30_13-52-58-fa9e4c5e503977cc64fb5f6a3fdbd291.png\"></p><p><br></p><p><strong>Why the other options are wrong:</strong></p><ol><li><p><code><strong>WHERE m.manager_id = 9</strong></code></p><ul><li><p>This filters <strong>managers</strong> who report to <strong>another manager with ID 9</strong>, not the employees reporting <strong>to</strong> manager 9.</p></li></ul></li><li><p><code><strong>WHERE e.employee_id = m.manager_id AND m.manager_id = 9</strong></code></p><ul><li><p>The join condition is reversed, and the filter is on the manager’s manager, not correct in this context.</p></li></ul></li><li><p><code><strong>WHERE m.employee_id = e.manager_id AND e.manager_id = 9</strong></code></p><ul><li><p>The condition is correct, but it's missing an explicit <code>ON</code> clause in the <code>JOIN</code> — although it may work syntactically in Oracle, <strong>the first option is clearer and more appropriate</strong>.</p></li></ul></li></ol><p><br></p><p><strong>Oracle JOINS</strong> are used to retrieve data from multiple tables. An Oracle <code>JOIN</code> is performed whenever two or more tables are joined in a SQL statement.</p><p><strong>There are 4 different types of Oracle joins:</strong></p><ol><li><p>Oracle <code>INNER JOIN</code> (or sometimes called simple join)</p></li><li><p>Oracle <code>LEFT OUTER JOIN</code> (or sometimes called <code>LEFT JOIN</code>)</p></li><li><p>Oracle <code>RIGHT OUTER JOIN</code> (or sometimes called <code>RIGHT JOIN</code>)</p></li><li><p>Oracle <code>FULL OUTER JOIN</code> (or sometimes called <code>FULL JOIN</code>)</p></li></ol><p><br></p><p><strong>INNER JOIN (simple join)</strong></p><p>Oracle <code>INNER JOIN</code> is the most common type of join.They return all rows from multiple tables where the join condition is met.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INNER JOIN</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1 \nINNER JOIN table2\nON table1.column = table2.column;\n</pre><p><br></p><p>In this visual diagram, the Oracle <code>INNER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-30_12-33-42-27f24b79227146600a1663c2a0debb51.png\"></p><p>The Oracle <code>INNER JOIN</code> would return the records where <em>table1</em> and <em>table2</em> intersect.</p><p>You cannot use <code>JOIN</code> keyword with a <code>WHERE</code> clause providing the <code>JOIN</code> condition.&nbsp; </p><p>If you want to do a <code>SELF&nbsp;JOIN</code> without using a <code>JOIN</code> clause, it can be done as follows.</p><pre class=\"prettyprint linenums\">SELECT a.column_name, b.column_name... \nFROM table1 a, table1 b \nWHERE a.common_field = b.common_field;\n</pre><p><br></p><p>This format was not presented as an option, so the correct syntax for the solution is:</p><pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\"\nFROM employees m\nJOIN employees e ON m.employee_id = e.manager_id\nWHERE e.manager_id = 9;</pre><p><br></p><p>The above query meets the requirements because it is joining the employee name field to employee's manager field and filtering for the required manager identifier.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\" \nFROM employees m \nJOIN employees e \nON m.employee_id = e.manager_id \nWHERE m.manager_id = 9;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\"\nFROM employees m\nJOIN employees e ON m.employee_id = e.manager_id\nWHERE e.manager_id = 9;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\" \nFROM employees m \nJOIN employees e \nWHERE e.employee_id = m.manager_id \nAND m.manager_id = 9;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name \"Manager\", e.last_name \"Employee\" \nFROM employees m&nbsp; \nJOIN employees e \nWHERE m.employee_id = e.manager_id&nbsp; AND e.manager_id = 9\n</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "JOIN",
            "question_plain": "View the exhibit and examine the structure of the EMPLOYEES table.&nbsp; Given: The entry in the manager id field for an employee is the manager's employee id.Required: Select all employees who report to the Manager who has employee id 9. The output is to be in two columns: the first column should have the employee's manager's LAST_NAME and the second column should have the employee's LAST_NAME.&nbsp; Identify the best SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289329,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding subqueries. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Subqueries](https://www.techonthenet.com/oracle/subqueries.php)",
                    "[ORDER BY clause](http://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj13658.html)"
                ],
                "feedbacks": [
                    "This statement is correct as subqueries allow for comparisons of multiple columns or expressions between the main query and the subquery, providing flexibility in filtering and retrieving data.",
                    "This statement is incorrect as subqueries can indeed contain the ORDER BY clause, which is used to sort the results of the subquery. However, the GROUP BY clause is not typically used in subqueries.",
                    "This statement is true as subqueries can retrieve data from different tables than the main query, allowing for complex data retrieval and filtering operations across multiple tables.",
                    "This statement is correct as subqueries can include both GROUP BY and ORDER BY clauses to perform aggregation and sorting operations within the subquery, enhancing the flexibility of data manipulation.",
                    "This statement is incorrect as subqueries do not require the main query and subquery to retrieve data from the same tables. In fact, subqueries are often used to retrieve related data from different tables in a database.",
                    "This statement is incorrect as subqueries allow for comparisons of multiple columns or expressions between the main query and the subquery, not just limited to one column or expression. This flexibility in comparison criteria enhances the power of subqueries in data retrieval and filtering."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ol><li><p><strong>Multiple columns or expressions can be compared between the main query and subquery.</strong></p><ul><li><p>Correct. You can use <strong>tuple comparison</strong>:</p><pre class=\"prettyprint linenums\">WHERE (col1, col2) IN (SELECT col1, col2 FROM ...)\n</pre></li><li><p>Multiple columns or expressions can be matched.</p></li></ul></li><li><p><strong>Main query and subquery can get data from different tables.</strong></p><ul><li><p>Correct. Subqueries often get data from <strong>different tables</strong> to compare or retrieve data not available in the main query's table.</p></li></ul></li><li><p><strong>Subqueries can contain GROUP BY and ORDER BY clauses.</strong></p><ul><li><p>Correct.</p><ul><li><p><code>GROUP BY</code> is commonly used in subqueries, especially with aggregates.</p></li><li><p><code>ORDER BY</code> can also be used, but <strong>only in correlated subqueries with ROWNUM/FETCH</strong>, or when used with <code>TOP-N</code> queries inside subqueries.</p></li></ul></li></ul></li></ol><p><strong>False Statements:</strong></p><ul><li><p><strong>Subqueries can contain ORDER BY but not the GROUP BY clause.</strong></p><ul><li><p>Incorrect. They <strong>can</strong> contain both. In fact, <code>GROUP BY</code> is <strong>more common</strong> in subqueries.</p></li></ul></li><li><p><strong>Main query and subquery must get data from the same tables.</strong></p><ul><li><p>Incorrect. Subqueries are <strong>often</strong> used to pull data from <strong>different tables</strong>.</p></li></ul></li><li><p><strong>Only one column or expression can be compared between the main query and subquery.</strong></p><ul><li><p>Incorrect. You can compare <strong>multiple columns</strong> as shown above in tuple comparison.</p></li></ul></li></ul><p><strong>In Oracle, a subquery is a query within a query.</strong> You can create subqueries within your SQL statements. These subqueries can reside in the <code>WHERE</code> clause, the <code>FROM</code> clause, or the <code>SELECT</code> clause.</p><p><strong>WHERE clause</strong></p><p>Most often, the subquery will be found in the <code>WHERE</code> clause. These subqueries are also called nested subqueries.</p><p>For example:</p><pre class=\"prettyprint linenums\">SELECT * \nFROM all_tables tabs\nWHERE tabs.table_name IN (SELECT cols.table_name\n                          FROM all_tab_columns cols\n                          WHERE cols.column_name = 'SUPPLIER_ID');\n</pre><p><br></p><p><strong>Limitation:</strong> Oracle allows up to 255 levels of subqueries in the <code>WHERE</code> clause.</p><p><br></p><p><strong>FROM clause</strong></p><p>A subquery can also be found in the <code>FROM</code> clause. These are called <strong>inline views</strong>.</p><p>For example:</p><pre class=\"prettyprint linenums\">SELECT suppliers.name, subquery1.total_amt\nFROM suppliers,\n (SELECT supplier_id, SUM(orders.amount) AS total_amt\n  FROM orders\n  GROUP BY supplier_id) subquery1\nWHERE subquery1.supplier_id = suppliers.supplier_id;\n</pre><p><br></p><p>In this example, we've created a subquery in the <code>FROM</code> clause as follows:</p><pre class=\"prettyprint linenums\">(SELECT supplier_id, SUM(orders.amount) AS total_amt\n FROM orders\n GROUP BY supplier_id) subquery1\n</pre><p><br></p><p>This subquery has been aliased with the name <em>subquery1</em>. This will be the name used to reference this subquery or any of its fields.</p><p><strong>Limitations</strong></p><p>Oracle allows an unlimited number of subqueries in the FROM clause.</p><p><br></p><p><strong>SELECT clause</strong></p><p>A subquery can also be found in the <code>SELECT</code> clause.</p><p>For example:</p><pre class=\"prettyprint linenums\">SELECT tbls.owner, tbls.table_name,\n  (SELECT COUNT(column_name) AS total_columns\n   FROM all_tab_columns cols\n   WHERE cols.owner = tbls.owner\n   AND cols.table_name = tbls.table_name) subquery2\nFROM all_tables tbls;\n</pre><p><br></p><p>In this example, we've created a subquery in the <code>SELECT</code> clause as follows:</p><pre class=\"prettyprint linenums\">(SELECT COUNT(column_name) AS total_columns\n FROM all_tab_columns cols\n WHERE cols.owner = tbls.owner\n AND cols.table_name = tbls.table_name) subquery2\n</pre><p><br></p><p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p><p>The trick to placing a subquery in the select clause is that the subquery must return a single value. This is why an aggregate function such as <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\">SUM function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\">COUNT function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\">MIN function</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/max.php\">MAX function</a> is commonly used in the subquery.</p><p><em>√&nbsp; Main query and subquery can get data from different tables.</em></p><p><em>√&nbsp; Multiple columns or expressions can be compared between the main query and subquery.</em></p><p><strong>ORDER BY clause</strong></p><p>The <code>ORDER BY</code> clause is an optional element of the following: </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a> </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefselectexpression.html#rrefselectexpression\"><em>SelectExpression</em></a> </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj11277.html#rrefsqlj11277\">VALUES expression</a> </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefscalarsubquery.html#rrefscalarsubquery\"><em>ScalarSubquery</em></a> </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreftablesubquery.html#rreftablesubquery\"><em>TableSubquery</em></a></p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj40774.html#rrefsqlj40774\">INSERT statement</a> </p><p>• <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15446.html#rrefsqlj15446\">CREATE VIEW statement</a>.</p><p>An <code>ORDER BY</code> clause allows you to specify the order in which rows appear in the result set. In subqueries, the <code>ORDER BY</code> clause is meaningless unless it is accompanied by one or both of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqljoffsetfetch.html#rrefsqljoffsetfetch\">result offset and fetch first clauses</a> or in conjunction with the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreffuncrownumber.html#rreffuncrownumber\">ROW_NUMBER function</a>, since there is no guarantee that the order is retained in the outer result set. </p><p><em>√&nbsp; Subqueries can contain GROUP BY and ORDER BY clauses.</em></p><p>It is permissible to combine <code>ORDER BY</code> on the outer query with <code>ORDER BY</code> in subqueries.</p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">ORDER BY { column-Name | ColumnPosition | Expression }\n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    [ , column-Name | ColumnPosition | Expression \n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    ] * \n</pre><p><br></p><p>column-Name - Refers to the names visible from the Select Items in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. The column-Name that you specify in the ORDER BY clause does not need to be the SELECT list. </p><p>ColumnPosition - An integer that identifies the number of the column in the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. ColumnPosition must be greater than 0 and not greater than the number of columns in the result table. In other words, if you want to order by a column, that column must be specified in the SELECT list. </p><p>Expression - A sort key expression, such as numeric, string, and datetime expressions. <em>Expression</em> can also be a row value expression such as a scalar subquery or case expression. </p><p>ASC - Specifies that the results should be returned in ascending order. If the order is not specified, ASC is the default. </p><p>DESC - Specifies that the results should be returned in descending order. </p><p>NULLS FIRST - Specifies that NULL values should be returned before non-NULL values. </p><p>NULLS LAST - Specifies that NULL values should be returned after non-NULL values.</p><p><strong>Notes</strong></p><p>If <code>SELECT DISTINCT</code> is specified or if the <code>SELECT</code> statement contains a <code>GROUP BY</code> clause, the <code>ORDER BY</code> columns must be in the <code>SELECT</code> list.</p><p>An <code>ORDER BY</code> clause prevents a <code>SELECT</code> statement from being an updatable cursor. For more information, see <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360__sqlj15384\">Requirements for updatable cursors and updatable ResultSets</a>.</p><p><br></p><p>If the null ordering is not specified then the handling of the null values is: <code>NULLS LAST</code> if the sort is <code>ASC NULLS FIRST</code> if the sort is <code>DESC</code></p><p>If neither ascending nor descending order is specified, and the null ordering is also not specified, then both defaults are used and thus the order will be ascending with <code>NULLS LAST</code>.</p>",
                "answers": [
                    "<p>Multiple columns or expressions can be compared between the main query and subquery.</p>",
                    "<p>Subqueries can contain ORDER BY but not the GROUP BY clause.</p>",
                    "<p>Main query and subquery can get data from different tables.</p>",
                    "<p>Subqueries can contain GROUP BY and ORDER BY clauses.</p>",
                    "<p>Main query and subquery must get data from the same tables.</p>",
                    "<p>Only one column or expression can be compared between the main query and subquery.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding subqueries. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289331,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement about the Oracle SQL, DELETE and TRUNCATE statements.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: TRUNCATE TABLE Statement](https://www.techonthenet.com/oracle/truncate.php)",
                    "[Oracle / PLSQL: DELETE Statement](https://www.techonthenet.com/oracle/delete.php)"
                ],
                "feedbacks": [
                    "DELETE statements can be rolled back to restore data that has been deleted, but TRUNCATE statements cannot be rolled back. TRUNCATE is a DDL (Data Definition Language) command that removes all rows from a table, whereas DELETE is a DML (Data Manipulation Language) command that removes specific rows based on a condition.",
                    "DELETE statements do not remove indexes associated with the table, only the rows that meet the specified condition. TRUNCATE statements, on the other hand, remove all rows from the table and reset the high water mark, but they do not remove the table's indexes.",
                    "DELETE statements can be used to selectively remove rows from a table based on a condition specified in the WHERE clause. TRUNCATE, however, removes all rows from the table without any conditions, making it a faster operation but less selective.",
                    "DELETE statements allow for the selective removal of rows from a table based on specified conditions, making it a useful tool for targeted data removal. TRUNCATE, on the other hand, removes all rows from a table without any conditions, making it a faster but less selective operation compared to DELETE."
                ],
                "explanation": "<p>Correct Answer: <strong>DELETE but not TRUNCATE statement can be used to selectively remove rows from a table.</strong></p><ul><li><p><code>DELETE</code> can have a <code>WHERE</code> clause (e.g., <code>DELETE FROM employees WHERE department_id = 50;</code>)</p></li><li><p><code>TRUNCATE</code> removes <strong>all rows</strong> — no <code>WHERE</code> clause allowed.</p></li></ul><p>Incorrect statements:</p><ul><li><p><strong>DELETE and TRUNCATE statements can have a rollback done to restore data into a table.</strong> </p><ul><li><p><code>DELETE</code> <strong>can</strong> be rolled back if not committed.</p></li><li><p><code>TRUNCATE</code> is <strong>DDL</strong>, not DML — it's <strong>auto-committed</strong> and <strong>cannot be rolled back</strong>.</p></li></ul></li><li><p><strong>DELETE and TRUNCATE statements remove all indexes for the tables on which they are performed.</strong></p><ul><li><p>Neither command removes indexes.</p></li><li><p><strong>Indexes remain intact</strong> after both <code>DELETE</code> and <code>TRUNCATE</code>.</p></li></ul></li><li><p><strong>DELETE but not TRUNCATE statement can be used to remove data from selective columns and rows of a table.</strong></p><ul><li><p>You cannot use <code>DELETE</code> to remove data from <strong>specific columns</strong> — it removes <strong>entire rows</strong>.</p></li><li><p>To remove (null out) column values, you'd use <code>UPDATE</code>, not <code>DELETE</code>.</p></li></ul></li></ul><p><br></p><p><strong>The TRUNCATE TABLE statement</strong> is used to remove all records from a table in Oracle. It performs the same function as a <code>DELETE</code> statement without a <code>WHERE</code> clause.</p><p><strong>Warning</strong>: If you truncate a table, the <code>TRUNCATE TABLE</code> statement can not be rolled back.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TRUNCATE TABLE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TRUNCATE TABLE [schema_name.]table_name\n  [ PRESERVE MATERIALIZED VIEW LOG | PURGE MATERIALIZED VIEW LOG ]\n  [ DROP STORAGE | REUSE STORAGE ] ;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>schema_name Optional. - If specified, it is the name of the schema that the table belongs to. </p><p>table_name - The table that you wish to truncate. </p><p>PRESERVE MATERIALIZED VIEW LOG Optional. - If specified, the materialized view log will be preserved when the table is truncated. This is the default behaviour. </p><p>PURGE MATERIALIZED VIEW LOG Optional. - If specified, the materialized view log will be purged when the table is truncated. </p><p>DROP STORAGE Optional. - If specified, all storage for the truncated rows will be deallocated, except the space that has been allocated by MINEXTENTS. This is the default behaviour. </p><p>REUSE STORAGE Optional. - If specified, all storage for the truncated rows will remain allocated to the table.</p><p><strong>The Oracle DELETE statement</strong> is used to delete a single record or multiple records from a table in Oracle.</p><p><em>√&nbsp; DELETE but not TRUNCATE statement can be used to selectively remove rows from a table</em></p><p><br></p><p><strong>Syntax</strong></p><p>The syntax for the <code>DELETE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">DELETE FROM table\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>table - The table that you wish to delete records from. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be deleted. If no conditions are provided, then all records from the table will be deleted.</p><p><strong>Note</strong></p><p>You do not need to list fields in the Oracle <code>DELETE</code> statement since you are deleting the entire row from the table.</p>",
                "answers": [
                    "<p>DELETE and TRUNCATE statements can have a rollback done to restore data into a table.</p>",
                    "<p>DELETE and TRUNCATE statements remove all indexes for the tables on which they are performed.</p>",
                    "<p>DELETE but not TRUNCATE statement can be used to remove data from selective columns and rows of a table.</p>",
                    "<p>DELETE but not TRUNCATE statement can be used to selectively remove rows from a table.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "TRUNCATE TABLE",
            "question_plain": "View and examine the following available responses.Identify the true statement about the Oracle SQL, DELETE and TRUNCATE statements.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289333,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description of the EMPLOYEES table.&nbsp; </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-45-37-37409bda498b2b551091ca48beaccb51.png\"></p><p><br></p><p><strong>Required:</strong> Calculate the total compensation paid to each employee. </p><p><strong>Given:</strong> Total compensation is the sum of the annual salary plus the commission earned for a year. Only a few employees earn commission.&nbsp; </p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL query correctly calculates the total compensation for each employee by summing the annual salary with the commission earned for a year. It uses the NVL2 function to handle cases where an employee does not earn commission, ensuring accurate calculation of total compensation.",
                    "This SQL query incorrectly calculates the total compensation for each employee by adding the annual salary multiplied by 12 with the commission percentage multiplied by the salary. It does not handle cases where an employee does not earn commission, leading to inaccurate total compensation calculations.",
                    "This SQL query incorrectly calculates the total compensation for each employee by multiplying the commission percentage with the salary and then multiplying it by 12. It does not correctly handle cases where an employee does not earn commission, resulting in inaccurate total compensation calculations.",
                    "This SQL query incorrectly calculates the total compensation for each employee by adding the annual salary multiplied by 12 with the product of the salary and commission percentage. It does not handle cases where an employee does not earn commission, leading to inaccurate total compensation calculations."
                ],
                "explanation": "<p><strong>Objective:</strong></p><p>Calculate <strong>total compensation</strong> as: <strong>Annual Salary + Annual Commission</strong><br>Where:</p><ul><li><p><code>salary</code> = monthly salary</p></li><li><p><code>commission_pct</code> = percentage of salary earned as <strong>monthly commission</strong></p></li><li><p>Annual total = <code>(salary + commission)*12</code></p></li></ul><p>Only <strong>some employees</strong> have a non-null <code>commission_pct</code>.</p><p><strong>Analysis of Each Option:</strong></p><pre class=\"prettyprint linenums\">SELECT first_name, salary, \n       ((salary + NVL2(commission_pct, (commission_pct * salary), 0)) * 12) \"Total\"\nFROM employees;\n</pre><ul><li><p><code>NVL2(commission_pct, commission_pct * salary, 0)</code> gives <strong>monthly commission</strong> if present, else 0.</p></li><li><p>Adds that to salary → total monthly income.</p></li><li><p>Multiplies by 12 → <strong>annual total compensation</strong>.</p></li><li><p><strong>Correct and efficient.</strong></p></li><li><p>This query correctly:</p><ul><li><p>Handles null commissions.</p></li><li><p>Computes monthly total.</p></li><li><p>Scales to yearly total.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT first_name, salary, \n       ((salary * 12) + NVL2(commission_pct, ((1 + commission_pct) * salary), 0)) \"Total\"\nFROM employees;\n</pre><ul><li><p>Incorrect logic: <code>(1 + commission_pct) * salary</code> includes <strong>salary again</strong>, which is already included in <code>salary * 12</code>.</p></li><li><p>Double-counts base salary if commission is present.</p></li><li><p><strong>Overstates total compensation</strong>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT first_name, salary, \n       NVL(commission_pct, 0) * salary) * 12 \"Total\"\nFROM employees;\n</pre><ul><li><p>Syntax error: Extra closing parenthesis.</p></li><li><p>Even if fixed: <code>commission_pct * salary * 12</code> = only annual commission.</p></li><li><p><strong>Does not include base salary.</strong></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT first_name, salary, \n       salary * 12 + NVL(salary, 0) * commission_pct, \"Total\"\nFROM employees;\n</pre><ul><li><p>Syntax error: Comma before <code>\"Total\"</code> alias is incorrect.</p></li><li><p>Also, <code>NVL(salary, 0) * commission_pct</code> assumes commission always exists — no <code>NVL</code> for <code>commission_pct</code>.</p></li><li><p>Incorrect calculation &amp; syntax.</p></li></ul><p>This problem requires you to calculate the compensation amount from the commission percentage and then add that amount to the salary of each employee. </p><p><strong>Steps:</strong></p><ul><li><p>determine the commission amount paid to each employee by multiplying the commission percentage by the salary amount for a single month.</p><p><code>NVL2 (commission_pct,( commission_pct * salary),0)</code></p></li><li><p>add that amount to the monthly salary</p><p><code>(salary +&nbsp; NVL2 (commission_pct,( commission_pct * salary),0)) </code></p></li><li><p>multiply that by the number of months in a year (12)</p><p><code>((salary +&nbsp; NVL2 (commission_pct,( commission_pct * salary),0)) * 12) </code></p></li><li><p>render that amount along with the name field to show the total compensation to each employee in the database.</p><pre class=\"prettyprint linenums\">SELECT first_name, salary, ((salary +  NVL2 (commission_pct,( commission_pct * salary),0)) * 12) \"Total\"\nFROM employees;</pre></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-30_22-57-17-1935aa65e11136bb46268bff1ea30d3d.png\"></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT first_name, salary, ((salary +&nbsp; NVL2 (commission_pct,( commission_pct * salary),0)) * 12) \"Total\" \nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, salary, ((salary * 12) +&nbsp; NVL2 (commission_pct,((1 + commission_pct) * salary),0)) \"Total\" \nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, salary, NVL (commission_pct, 0)*salary)*12 \"Total\" \nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT first_name, salary, salary*12 + NVL(salary,0)*commission_pct, \"Total\" \nFROM EMPLOYEES;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the description of the EMPLOYEES table.&nbsp; Required: Calculate the total compensation paid to each employee. Given: Total compensation is the sum of the annual salary plus the commission earned for a year. Only a few employees earn commission.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289335,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement about SQL query processing in an Oracle database instance. (Select best answer.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Memory Structures](https://docs.oracle.com/cd/A58617_01/server.804/a58227/ch_mem.htm)"
                ],
                "feedbacks": [
                    "This statement is incorrect. During parsing, a SQL statement containing literals in the WHERE clause is not always reused for the current execution, even if it is cached in memory. The reuse of cached SQL statements depends on various factors such as bind variable usage and cursor sharing settings.",
                    "This statement is correct. During execution, if the required data is not already in memory, the Oracle server may read data from storage. This process ensures that the necessary data is available for processing the SQL query.",
                    "This statement is incorrect. During row source generation, rows that satisfy the query are not retrieved from the database and stored in memory. Row source generation involves creating an execution plan to access and retrieve the required data from the database.",
                    "This statement is incorrect. During optimization, execution plans are formulated based on statistics gathered by the database instance, but the selection of the execution plan is not solely based on the lowest cost. The optimizer considers various factors such as indexes, join methods, and access paths to determine the most efficient plan for query execution."
                ],
                "explanation": "<p>Correct Answer: <strong>During execution, the Oracle server may read data from storage if the required data is not already in memory.</strong></p><ul><li><p>Oracle maintains a memory cache called the <strong>buffer cache</strong>.</p></li><li><p>If the needed data blocks <strong>are not in the buffer cache</strong>, they are <strong>read from disk (storage)</strong> during <strong>execution phase</strong>.</p></li><li><p>This is fundamental to Oracle’s memory and I/O management.</p></li></ul><p>Incorrect options:</p><p><strong>During parsing, a SQL statement containing literals in the WHERE clause that has been executed by any session and which is cached in memory, is always reused for the current execution.</strong></p><ul><li><p><strong>False.</strong></p></li><li><p>SQL statements <strong>with literals</strong> often result in <strong>new</strong> cursor entries due to differences in literal values.</p></li><li><p>Only <strong>identical statements</strong> (with bind variables) are reused.</p></li><li><p>Literal-based SQL is <strong>not always reused</strong>, unless <strong>cursor sharing</strong> is enabled or rewritten.</p></li></ul><p><strong>During row source generation, rows that satisfy the query are retrieved from the database and stored in memory.</strong></p><ul><li><p><strong>False.</strong></p></li><li><p><strong>Row source generation</strong> is a <strong>logical step</strong> that produces the execution plan operators — it doesn’t <strong>retrieve</strong> actual data yet.</p></li><li><p>Actual data retrieval happens during the <strong>execution phase</strong>.</p></li></ul><p><strong>During optimization, execution plans are formulated based on the statistics gathered by the database instance, and the lowest cost plan is selected for execution.</strong></p><ul><li><p><strong>Mostly true but misleading.</strong></p></li><li><p>Oracle uses the <strong>cost-based optimizer</strong>, but it doesn’t <strong>always</strong> choose the lowest-cost plan — it chooses the plan that is <strong>estimated to be most efficient</strong>.</p></li><li><p>Also, statistics may not be up-to-date or available, and <strong>hints</strong> or <strong>adaptive plans</strong> may influence the decision.</p></li><li><p>So this statement is <strong>oversimplified and not entirely accurate</strong>.</p></li></ul><p><br></p><p><strong>The Database Buffer Cache</strong></p><p>The database buffer cache is the portion of the SGA that holds copies of data blocks read from datafiles. All user processes concurrently connected to the instance share access to the database buffer cache.</p><p>The database buffer cache and the shared SQL cache are logically segmented into multiple sets. This organization into multiple sets reduces contention on multiprocessor systems.</p><p> <strong>Organization of the Database Buffer Cache</strong></p><p>The buffers in the cache are organized in two lists: the dirty list and the least recently used (LRU) list. The <em>dirty list</em> holds <em>dirty buffers,</em> which contain data that has been modified but has not yet been written to disk. The<em> least recently used (LRU) list</em> holds free buffers, pinned buffers, and dirty buffers that have not yet been moved to the dirty list. Free buffers have not been modified and are available for use. Pinned buffers are currently being accessed.</p><p>When an Oracle process accesses a buffer, the process moves the buffer to the most recently used (MRU) end of the LRU list. As more buffers are continually moved to the MRU end of the LRU list, dirty buffers \"age\" towards the LRU end of the LRU list.</p><p>The first time an Oracle user process requires a particular piece of data, it searches for the data in the database buffer cache. If the process finds the data already in the cache (a <em>cache hit</em>), it can read the data directly from memory. If the process cannot find the data in the cache (a <em>cache miss</em>), it must copy the data block from a datafile on disk into a buffer in the cache before accessing the data. Accessing data through a cache hit is faster than data access through a cache miss.</p><p><em>√&nbsp; During execution, the Oracle server may read data from storage if the required data is not already in memory.</em></p><p>Before reading a data block into the cache, the process must first find a free buffer. The process searches the LRU list, starting at the least recently used end of the list. The process searches either until it finds a free buffer or until it has searched the threshold limit of buffers.</p><p>If the user process finds a dirty buffer as it searches the LRU list, it moves that buffer to the dirty list and continues to search. When the process finds a free buffer, it reads the data block from disk into the buffer and moves the buffer to the MRU end of the LRU list.</p><p>If an Oracle user process searches the threshold limit of buffers without finding a free buffer, the process stops searching the LRU list and signals the DBW0 background process to write some of the dirty buffers to disk.</p>",
                "answers": [
                    "<p>During parsing, a SQL statement containing literals in the WHERE clause that has been executed by any session and which is cached in memory, is always reused for the current execution.</p>",
                    "<p>During execution, the Oracle server may read data from storage if the required data is not already in memory.</p>",
                    "<p>During row source generation, rows that satisfy the query are retrieved from the database and stored in memory.</p>",
                    "<p>During optimization, execution plans are formulated based on the statistics gathered by the database instance, and the lowest cost plan is selected for execution.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "Memory Structures",
            "question_plain": "View and examine the following available responses.Identify the true statement about SQL query processing in an Oracle database instance. (Select best answer.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289337,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT cust_id, cust_last_name \"Last name\"\nFROM customers\nWHERE country_ID = 5\nUNION\nSELECT cust_id, cust_last_name\nFROM customers\nWHERE cust_gender = 'M'\n</pre><p><br></p><p>Identify the ORDER BY clauses which can complete the query. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ORDER BY Clause](https://www.techonthenet.com/oracle/order_by.php)"
                ],
                "feedbacks": [
                    "This choice is correct because it orders the result set by the \"Last name\" column in ascending order, as specified in the query. It follows the correct syntax for ordering by a specific column name.",
                    "This choice is correct because it orders the result set first by the second column in the SELECT statement (which is cust_id) and then by the first column. This syntax is valid for ordering by multiple columns in a query.",
                    "This choice is incorrect because there is no column named \"CUST_NO\" specified in the SELECT statement. The ORDER BY clause must reference columns that are present in the SELECT statement to be valid.",
                    "This choice is correct because it orders the result set first by the second column in the SELECT statement and then by the first column, as specified in the query. The syntax \"ORDER BY 2,1\" is valid for ordering by column positions in the SELECT statement.",
                    "This choice is incorrect because there is no column named \"cust_gender\" specified in the SELECT statement. The ORDER BY clause must reference columns that are present in the SELECT statement to be valid."
                ],
                "explanation": "<p>The <code>SELECT</code> statements return two Output Columns:</p><ol><li><p><code>cust_id</code></p></li><li><p><code>\"Last name\"</code> (alias for <code>cust_last_name</code>)</p></li></ol><p><strong>Correct </strong><code><strong>ORDER BY</strong></code><strong> options:</strong></p><p><code>ORDER BY \"Last name\"</code></p><ul><li><p>Uses the column alias <code>\"Last name\"</code> from the first <code>SELECT</code>.</p></li></ul><p><code>ORDER BY 2, cust_id</code></p><ul><li><p><code>2</code> refers to the second column (<code>\"Last name\"</code>)</p></li><li><p><code>cust_id</code> is also present in the output.</p></li></ul><p><code>ORDER BY 2,1</code></p><ul><li><p>Refers to column positions:</p><ul><li><p><code>2</code> → <code>\"Last name\"</code></p></li><li><p><code>1</code> → <code>cust_id</code></p></li></ul></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-01_23-49-36-0e0bae6e49df0fc0d5fb08bb46e902d4.png\"></p><p><br></p><p><strong>Incorrect </strong><code><strong>ORDER BY</strong></code><strong> options:</strong></p><p><code>ORDER BY CUST_NO</code></p><ul><li><p><code>CUST_NO</code> is <strong>not</strong> part of the final <code>SELECT</code> output.</p><p><br></p></li></ul><p><code>ORDER BY cust_gender</code></p><ul><li><p><code>cust_gender</code> is not included in the final output columns, so it can’t be used in <code>ORDER BY</code>.</p></li></ul><p><br></p><p><strong>The Oracle ORDER BY </strong>clause is used to sort the records in your result set. The ORDER BY clause can only be used in<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>ORDER BY</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expressions\nFROM tables\n[WHERE conditions]\nORDER BY expression [ ASC | DESC ];\n</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p>WHERE conditions Optional. - The conditions that must be met for the records to be selected. </p><p>ASC Optional. - It sorts the result set in ascending order by <em>expression</em> (default, if no modifier is provider). </p><p>DESC Optional. - It sorts the result set in descending order by <em>expression</em>.</p><p><strong>Note: </strong>If the <code>ASC</code> or <code>DESC</code> modifier is not provided in the ORDER BY clause, the results will be sorted by <em>expression</em> in ascending order (which is equivalent to <code>ORDER BY <em>expression</em> ASC</code>.</p><p>The <code>ORDER BY</code> Clause in Set Operations can appear only once at the end of the compound query. </p><ul><li><p>Component queries cannot have individual <code>ORDER BY</code> clauses. </p></li><li><p>The <code>ORDER BY</code> clause recognizes only the columns of the first <code>SELECT</code> query. </p></li><li><p>By default, the first column of the first <code>SELECT</code> query is used to sort the output in an ascending order.</p></li></ul>",
                "answers": [
                    "<p><code>ORDER BY \"Last name\"</code> </p>",
                    "<p><code>ORDER BY 2, cust_id</code> </p>",
                    "<p><code>ORDER BY CUST_NO</code> </p>",
                    "<p><code>ORDER BY 2,1</code> </p>",
                    "<p><code>ORDER BY cust_gender</code> </p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "d"
            ],
            "section": "ORDER BY",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT cust_id, cust_last_name \"Last name\"\nFROM customers\nWHERE country_ID = 5\nUNION\nSELECT cust_id, cust_last_name\nFROM customers\nWHERE cust_gender = 'M'\nIdentify the ORDER BY clauses which can complete the query. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289339,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Identify the missing word(s) in the following sentence.</p><p>[____] results in a relation with no multivalued attributes.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Understanding Database Normal Forms](https://blog.udemy.com/database-normal-forms/)"
                ],
                "feedbacks": [
                    "Second normal form (2NF) deals with removing partial dependencies in a relation, not multivalued attributes. It does not directly address the issue of multivalued attributes in a relation.",
                    "First normal form (1NF) is the initial step in database normalization and ensures that each attribute contains only atomic values. It eliminates the possibility of multivalued attributes in a relation, making it the correct choice for the given sentence.",
                    "Third normal form (3NF) focuses on eliminating transitive dependencies in a relation, not multivalued attributes. While it helps in reducing data redundancy, it does not specifically address the issue of multivalued attributes.",
                    "Fourth normal form (4NF) further refines the normalization process by addressing multi-valued dependencies, not multivalued attributes. It does not directly relate to the sentence's context of having a relation with no multivalued attributes."
                ],
                "explanation": "<p>The correct answer is: <strong>First normal form </strong>results in a relation with no multivalued attributes.</p><ul><li><p><strong>First Normal Form (1NF):</strong></p><ul><li><p>Requires that <strong>each attribute</strong> in a table contains <strong>only atomic (indivisible) values</strong>.</p></li><li><p><strong>Eliminates multivalued attributes</strong>.</p></li><li><p>Ensures that each field holds a <strong>single value</strong>, not a list or set.</p></li></ul></li><li><p><strong>Second Normal Form (2NF):</strong></p><ul><li><p>Builds on 1NF.</p></li><li><p>Removes <strong>partial dependencies</strong> (in composite keys).</p></li></ul></li><li><p><strong>Third Normal Form (3NF):</strong></p><ul><li><p>Removes <strong>transitive dependencies</strong>.</p></li></ul></li><li><p><strong>Fourth Normal Form (4NF):</strong></p><ul><li><p>Eliminates <strong>multivalued dependencies</strong>, which is <strong>different</strong> from multivalued attributes.</p></li></ul></li></ul><p>Theoretically, Database ‘Normal Forms’ (NF) is a process of defining database relations in such a way that they are invulnerable to logical inconsistencies and anomalies like insertion, edits and deletion. Each relation has the Highest Normal Form, but this does not mean that it is the maximum level of ‘Normal Form’. The ‘Normal Form’ is associated with each relation; therefore to achieve the entire Database Normal Form it is necessary that each relation attains the highest normal form.</p><p>A <strong>‘Normal Form’</strong> is a simplified state of a relation on which rules concerning functional dependencies (relationship between attributes) are applied. The following are the rules or different levels of ‘Normal Forms’.</p><ul><li><p>‘First Normal Form’ (1NF) results in a relation with no multivalued attributes.</p></li><li><p>‘Second Normal Form’ (2NF) results in a relation with no partial functional dependencies.</p></li><li><p>‘Third Normal Form’ (3NF) results in a relation with no transitive functional dependencies (functional dependency between two non-keys attributes).</p></li><li><p>‘Boyce-Codd Normal Form’ is achieved by removing the remaining function dependencies after 3NF.</p></li><li><p>‘Fourth Normal Form’ results in a relation with no multivalued dependencies.</p></li><li><p>‘Fifth Normal Form’ is achieved with removing of all the remaining anomalies.</p></li></ul>",
                "answers": [
                    "<p>Second normal form</p>",
                    "<p>First normal form</p>",
                    "<p>Third normal form</p>",
                    "<p>Fourth normal form</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "Database Normal Forms",
            "question_plain": "Identify the missing word(s) in the following sentence.[____] results in a relation with no multivalued attributes.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289341,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">GRANT ALL\nON orders, order_items\nTO&nbsp;PUBLIC;\n</pre><p><br></p><p><strong>Given:</strong> The owner of ORDERS and ORDER_ITEMS tables issues the above GRANT command which did not execute as desired.</p><p><strong>Required:</strong> Correct the SQL statement.</p><p>Identify the response which would meet the requirement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Grant/Revoke Privileges](https://www.techonthenet.com/oracle/grant_revoke.php)",
                    "[Grant SELECT on multiple tables oracle](https://stackoverflow.com/questions/15451325/grant-select-on-multiple-tables-oracle)"
                ],
                "feedbacks": [
                    "Granting access to specific usernames instead of using PUBLIC allows for more control over who can access the tables. This ensures that only the intended users have the necessary privileges.",
                    "Instead of granting all privileges with the keyword ALL, specifying a list of specific privileges provides a more granular level of access control. This helps in restricting access to only the required privileges.",
                    "Adding the WITH GRANT OPTION clause allows the users who receive the privileges to further grant those privileges to other users. This can be useful in scenarios where the users need to delegate access to additional users.",
                    "Separate GRANT statements are required for the ORDERS and ORDER_ITEMS tables because each table may have different access requirements. By issuing separate statements, the owner can specify the exact privileges needed for each table individually."
                ],
                "explanation": "<p>Correct Answer<strong>: Separate GRANT statements are required for the ORDERS and ORDER_ITEMS tables.</strong></p><p>Original SQL:</p><pre class=\"prettyprint linenums\">GRANT ALL\nON orders, order_items\nTO PUBLIC;\n</pre><ul><li><p><strong>Invalid syntax</strong> in Oracle SQL.</p></li><li><p>You <strong>cannot</strong> grant privileges on <strong>multiple tables</strong> in a <strong>single </strong><code><strong>GRANT</strong></code><strong> statement</strong>.</p></li></ul><p><strong>Correct Usage in Oracle:</strong></p><p>You must issue <strong>separate GRANT statements</strong> for each object:</p><pre class=\"prettyprint linenums\">GRANT ALL ON orders TO PUBLIC;\nGRANT ALL ON order_items TO PUBLIC;\n</pre><p><br></p><p>Incorrect options:</p><ul><li><p><strong>PUBLIC should be replaced with specific usernames</strong></p><ul><li><p>Not necessary.</p></li><li><p><code>PUBLIC</code> is valid and means <strong>all users</strong>.</p></li></ul></li><li><p><strong>ALL should be replaced with a list of specific privileges</strong></p><ul><li><p>Not required.</p></li><li><p><code>ALL</code> is shorthand for <strong>all applicable privileges</strong> on the object.</p></li></ul></li><li><p><strong>WITH GRANT OPTION should be added to the statement</strong></p><ul><li><p>Optional.</p></li><li><p>Not relevant to fixing the syntax error.</p></li><li><p>It simply allows the recipient to pass privileges to others.</p></li></ul></li></ul><p><br></p><p>You can <strong>GRANT and REVOKE privileges</strong> on various database objects in Oracle. We'll first look at how to grant and revoke privileges on tables and then how to grant and revoke privileges on functions and procedures in Oracle.</p><p><strong>Grant Privileges on Table</strong></p><p>You can grant users various privileges to tables. These privileges can be any combination of <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>REFERENCES</code>, <code>ALTER</code>, <code>INDEX</code>, or <code>ALL</code>.</p><p><strong>Syntax</strong></p><p>The syntax to <code>GRANT</code> privileges on a table in Oracle is:</p><pre class=\"prettyprint linenums\">GRANT privileges ON object TO user;</pre><p><br></p><p>privileges - The privileges to assign. It can be any of the following values:</p><ul><li><p><code>SELECT </code>- Ability to perform SELECT statements on the table. </p></li><li><p><code>INSERT </code>- Ability to perform INSERT statements on the table. </p></li><li><p><code>UPDATE </code>- Ability to perform UPDATE statements on the table. </p></li><li><p><code>DELETE </code>- Ability to perform DELETE statements on the table. </p></li><li><p><code>REFERENCES </code>- Ability to create a constraint that refers to the table. </p></li><li><p><code>ALTER </code>- Ability to perform ALTER TABLE statements to change the table definition. </p></li><li><p><code>INDEX </code>- Ability to create an index on the table with the create index statement. </p></li><li><p><code>ALL </code>- All privileges on table.</p></li></ul><p>object - The name of the database object that you are granting privileges for. In the case of granting privileges on a table, this would be the table name. </p><p>user - The name of the user that will be granted these privileges.</p><p>It is only possible to grant access to one object at a time. Granting access to multiple objects in the same statement is not allowed.</p><p><em>√&nbsp; Separate GRANT statements are required for the ORDERS and ORDER_ITEMS tables.</em></p>",
                "answers": [
                    "<p>PUBLIC should be replaced with specific usernames.</p>",
                    "<p>ALL should be replaced with a list of specific privileges.</p>",
                    "<p>WITH GRANT OPTION should be added to the statement.</p>",
                    "<p>Separate GRANT statements are required for the ORDERS and ORDER_ITEMS tables.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "Grant/Revoke Privileges",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1GRANT ALL\nON orders, order_items\nTO&nbsp;PUBLIC;\nGiven: The owner of ORDERS and ORDER_ITEMS tables issues the above GRANT command which did not execute as desired.Required: Correct the SQL statement.Identify the response which would meet the requirement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289343,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about INNER and OUTER JOIN. (Choose four.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "A full outer join does not necessarily have to use Oracle syntax. Full outer joins can be implemented in various SQL databases, not just Oracle.",
                    "An inner join returns only the rows that have matching values in both tables being joined. It excludes unmatched rows.",
                    "A left or right outer join returns all matched rows from the joined tables, as well as any unmatched rows from the specified side of the join.",
                    "A full outer join returns all matched rows from the joined tables, as well as any unmatched rows from both sides of the join.",
                    "Outer joins can be used between two tables, not necessarily two queries. They allow for the inclusion of unmatched rows from one or both tables in the result set.",
                    "Outer joins can be used when there are multiple join conditions on two tables. This allows for more flexibility in specifying the relationship between the tables in the join operation."
                ],
                "explanation": "<p>Correct options:</p><p>1. <strong>An inner join returns matched rows</strong></p><ul><li><p><strong>True</strong></p></li><li><p>An <strong>INNER JOIN</strong> returns rows <strong>only when there is a match</strong> between the join columns in both tables.</p></li></ul><p>2. <strong>A left or right outer join returns matched and unmatched rows</strong></p><ul><li><p><strong>True</strong></p></li><li><p>A <strong>LEFT OUTER JOIN</strong> returns:</p><ul><li><p>All matched rows + all unmatched rows from the <strong>left</strong> table</p></li></ul></li><li><p>A <strong>RIGHT OUTER JOIN</strong> returns:</p><ul><li><p>All matched rows + all unmatched rows from the <strong>right</strong> table</p></li></ul></li></ul><p>3. <strong>A full outer join returns matched and unmatched rows</strong></p><ul><li><p><strong>True</strong></p></li><li><p>A <strong>FULL OUTER JOIN</strong> returns:</p><ul><li><p>All matched rows</p></li><li><p>All unmatched rows from <strong>both</strong> tables</p></li></ul></li></ul><p>4. <strong>Outer joins can be used when there are multiple join conditions on two tables</strong></p><ul><li><p><strong>True</strong></p></li><li><p>You can apply <strong>multiple join conditions</strong> using <strong>OUTER JOINS</strong>, just like with INNER JOINS.</p></li></ul><p>Incorrect options:</p><ul><li><p><strong>A full outer join must use Oracle syntax</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Oracle <strong>supports ANSI SQL syntax</strong>, which is <strong>recommended</strong>:</p><pre class=\"prettyprint linenums\">SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id;\n</pre></li><li><p>The <strong>Oracle (+)</strong> syntax <strong>does not support FULL OUTER JOINs</strong>.</p></li><li><p>So ANSI syntax is required, but not exclusive to Oracle — <strong>other databases use it too</strong>.</p></li></ul></li></ul><ul><li><p><strong>Outer joins can only be used between two queries</strong></p><ul><li><p><strong>False</strong></p></li><li><p>OUTER JOINS are used to <strong>combine tables</strong>, not queries.</p></li><li><p>You can also perform joins between <strong>more than two tables</strong>.</p></li></ul></li></ul><p><br></p><p><strong>Oracle JOINS are used to retrieve data from multiple tables.</strong> An Oracle <code>JOIN</code> is performed whenever two or more tables are joined in a SQL statement.</p><p><strong>There are 4 different types of Oracle joins:</strong></p><ol><li><p>Oracle <code>INNER JOIN</code> (or sometimes called simple join)</p></li><li><p>Oracle <code>LEFT OUTER JOIN</code> (or sometimes called <code>LEFT JOIN</code>)</p></li><li><p>Oracle <code>RIGHT OUTER JOIN</code> (or sometimes called <code>RIGHT JOIN</code>)</p></li><li><p>Oracle <code>FULL OUTER JOIN</code> (or sometimes called <code>FULL JOIN</code>)</p></li></ol><p><br></p><p><strong>INNER JOIN (simple join)</strong></p><p>Chances are, you've already written a statement that uses an Oracle <code>INNER JOIN</code>. It is the most common type of join. Oracle <code>INNER JOIN</code> return all rows from multiple tables where the join condition is met.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INNER JOIN</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1 \nINNER JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>INNER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-35-43-24928132deb29a86ae282a2d5d4b4e6d.png\"></p><p>The Oracle <code>INNER JOIN</code> would return the records where <em>table1</em> and <em>table2</em> intersect.</p><p><em>√&nbsp; An inner join returns matched rows</em></p><p><br></p><p><strong>LEFT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>LEFT OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p>Syntax</p><p>The syntax for the Oracle <code>LEFT OUTER JOIN</code> is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nLEFT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>LEFT OUTER JOIN</code> keywords are replaced with LEFT JOIN.</p><p>Visual Illustration</p><p>In this visual diagram, the Oracle <code>LEFT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-17-2ee387b09bb38b1b8dc835df5f025fa0.png\"></p><p>The Oracle <code>LEFT OUTER JOIN</code> would return the all records from <em>table1</em> and only those records from <em>table2</em> that intersect with <em>table1</em>.</p><p><br></p><p><strong>RIGHT OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>RIGHT OUTER JOIN</code>. This type of join returns all rows from the RIGHT-hand table specified in the ON condition and <strong>only</strong> those rows from the other table where the joined fields are equal (join condition is met).</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>RIGHT OUTER JOIN</code> is:</p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nRIGHT [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>RIGHT OUTER JOIN</code> keywords are replaced with RIGHT JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>RIGHT OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-36-48-1112abda363494f4f4674610d4a5828b.png\"></p><p>The Oracle <code>RIGHT OUTER JOIN</code> would return the all records from <em>table2</em> and only those records from <em>table1</em> that intersect with <em>table2</em>.</p><p>With a RIGHT&nbsp;OUTER&nbsp;JOIN, all the records of table2, whether they match table1 or not, some of the records in table2 may match records in table1 but matches are not necessary for successful execution.</p><p><em>√&nbsp; A left or right outer join returns matched and unmatched rows</em></p><p><br></p><p><strong>FULL OUTER JOIN</strong></p><p>Another type of join is called an Oracle <code>FULL OUTER JOIN</code>. This type of join returns all rows from the LEFT-hand table and RIGHT-hand table with nulls in place where the join condition is not met.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <code>FULL OUTER JOIN</code> is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT columns\nFROM table1\nFULL [OUTER] JOIN table2\nON table1.column = table2.column;</pre><p><br></p><p>In some databases, the <code>FULL OUTER JOIN</code> keywords are replaced with FULL JOIN.</p><p><strong>Visual Illustration</strong></p><p>In this visual diagram, the Oracle <code>FULL OUTER JOIN</code> returns the shaded area:</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-21_19-37-23-693a8eb7a6e48912a42bf894a4d6ab7e.png\"></p><p>The Oracle <code>FULL OUTER JOIN</code> would return the all records from both <em>table1</em> and <em>table2</em>.</p><p><em>√&nbsp; A full outer join returns matched and unmatched rows</em></p>",
                "answers": [
                    "<p>A full outer join must use Oracle syntax</p>",
                    "<p>An inner join returns matched rows</p>",
                    "<p>A left or right outer join returns matched and unmatched rows</p>",
                    "<p>A full outer join returns matched and unmatched rows</p>",
                    "<p>Outer joins can only be used between two queries</p>",
                    "<p>Outer joins can be used when there are multiple join conditions on two tables</p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "d",
                "f"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following available responses.Identify the true statements about INNER and OUTER JOIN. (Choose four.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289345,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>In the PROMOTIONS table, the PROMO_BEGIN_DATE column is DATE data type and the default date format is DD-MON-RR.</p><p>Identify the true statements about expressions using PROMO_BEGIN_DATE contained a query. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[How to get the difference between datetimes in days, hours, minutes, and/or seconds in Oracle Database](https://blogs.oracle.com/sql/post/difference-between-datetimes-in-days-hours-minutes-seconds-in-oracle-database)"
                ],
                "feedbacks": [
                    "Subtracting a number from a date in Oracle Database will result in a new date. In this case, subtracting 5 from the PROMO_BEGIN_DATE will return a date.",
                    "When subtracting two dates in Oracle Database, the result will be a number representing the difference in days between the two dates. Therefore, subtracting SYSDATE from PROMO_BEGIN_DATE will return a number.",
                    "Using the TO_NUMBER function on a date column like PROMO_BEGIN_DATE will result in an error because Oracle Database cannot convert a date directly to a number without specifying a date format.",
                    "Multiplying a date by a number and then trying to convert it back to a date using TO_DATE will result in an error because the multiplication operation is not valid for date data types in Oracle Database.",
                    "Subtracting SYSDATE from a date column like PROMO_BEGIN_DATE will not return an error. It will return a number representing the difference in days between the two dates."
                ],
                "explanation": "<p>Evaluate each statement carefully to determine which are <strong>true</strong> about expressions using the <code>PROMO_BEGIN_DATE</code> column (of <strong>DATE</strong> datatype), with the default format <code>DD-MON-RR</code>.</p><p>Correct options:</p><p>1. <strong>PROMO_BEGIN_DATE - 5 will return a date</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Subtracting a <strong>number</strong> from a <strong>DATE</strong> subtracts that many <strong>days</strong>.</p></li><li><p>Result is another <strong>DATE</strong> value.</p><pre class=\"prettyprint linenums\">SELECT PROMO_BEGIN_DATE - 5 FROM promotions;\n</pre></li></ul><p>2. <strong>PROMO_BEGIN_DATE - SYSDATE will return a number</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Subtracting one <strong>DATE</strong> from another returns a <strong>NUMBER</strong> (difference in days, possibly with decimals).</p><pre class=\"prettyprint linenums\">SELECT PROMO_BEGIN_DATE - SYSDATE FROM promotions;\n</pre></li></ul><p><br></p><p>Incorrect options:</p><ul><li><p><strong>TO_NUMBER(PROMO_BEGIN_DATE) - 5 will return a number</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>TO_NUMBER(PROMO_BEGIN_DATE)</code> is <strong>invalid unless PROMO_BEGIN_DATE is already a VARCHAR</strong> or cast as such.</p></li><li><p>You can't convert a DATE directly to a number this way — will result in an error unless an explicit format model is used (and even then, result is unpredictable).</p></li></ul></li></ul><ul><li><p><strong>TO_DATE(PROMO_BEGIN_DATE * 5) will return a date</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>PROMO_BEGIN_DATE * 5</code> is invalid — you <strong>cannot multiply a DATE by a number</strong>.</p></li><li><p>This expression results in an <strong>error</strong>.</p></li></ul></li></ul><ul><li><p><strong>PROMO_BEGIN_DATE - SYSDATE will return an error</strong></p><ul><li><p><strong>False</strong></p></li><li><p>As explained above, subtracting two DATEs returns a <strong>NUMBER</strong>, not an error.</p></li></ul></li></ul>",
                "answers": [
                    "<p><code>PROMO_BEGIN_DATE - 5</code> will return a date.</p>",
                    "<p><code>PROMO_BEGIN_DATE - SYSDATE</code> will return a number.</p>",
                    "<p><code>TO_NUMBER(PROMO_BEGIN_DATE) - 5</code> will return a number.</p>",
                    "<p><code>TO_DATE(PROMO_BEGIN_DATE * 5)</code> will return a date</p>",
                    "<p><code>PROMO_BEGIN_DATE - SYSDATE</code> will return an error.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Given: In the PROMOTIONS table, the PROMO_BEGIN_DATE column is DATE data type and the default date format is DD-MON-RR.Identify the true statements about expressions using PROMO_BEGIN_DATE contained a query. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289349,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding single-row functions. (Choose four.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Using Single-Row Functions](https://www.tutorialspoint.com/sql_certificate/using_single_row_functions.htm)"
                ],
                "feedbacks": [
                    "Single-row functions in Oracle Database SQL can indeed be categorized into character functions, numeric functions, date functions, and conversion functions. These functions operate on single rows of data and return a single result per row.",
                    "Single-row case conversion functions, such as UPPER, LOWER, and INITCAP, are examples of character functions that accept character input and return a character value. These functions are used to convert the case of characters in a string.",
                    "Single-row character functions in Oracle Database SQL accept character input and can return either character or numeric values. Examples of such functions include CONCAT, SUBSTR, LPAD, RPAD, TRIM, and REPLACE, which manipulate character data in various ways.",
                    "Single-row date arithmetic operations in Oracle Database SQL typically return date values, but can also return character or numeric values depending on the function. Examples of such functions include MONTHS_BETWEEN, ADD_MONTHS, NEXT_DAY, LAST_DAY, ROUND, REPLACE, and TRUNC.",
                    "Single-row numeric operations in Oracle Database SQL return numeric values. Functions like SUM, SUBTRACT, ROUND, TRUNC, and MOD are examples of numeric functions that perform calculations on numeric data in a single row.",
                    "Single-row functions in Oracle Database SQL can indeed include character functions, numeric functions, date functions, conversion functions, and even audit functions. These functions are designed to operate on individual rows of data and can perform a variety of operations on different data types."
                ],
                "explanation": "<p>Correct options:</p><p>1. <strong>Single row functions can be character functions, numeric functions, date functions, and conversion functions.</strong></p><p><strong>True</strong></p><ul><li><p>This is a correct general classification of single-row functions in Oracle.</p></li></ul><p>2. <strong>Single row case conversion functions accept character input and returns a character value. Functions under the category are UPPER, LOWER and INITCAP.</strong></p><p><strong>True</strong></p><ul><li><p>These functions operate on character data and return character results.</p></li></ul><p>3. <strong>Single-row character functions accept character input and return either character or numeric values. Examples include CONCAT, SUBSTR, LPAD, RPAD, TRIM, and REPLACE.</strong></p><p><strong>True</strong></p><ul><li><p>Mostly character functions returning characters, but some related functions like LENGTH or INSTR (not listed here) return numeric values. The statement is essentially accurate.</p></li></ul><p>4. <strong>Single row functions can be character functions, numeric functions, date functions, conversion and audit functions.</strong></p><p><strong>True</strong></p><ul><li><p>Oracle includes audit functions like <code>USER</code>, <code>SYSDATE</code>, etc., classified as single-row functions.</p></li></ul><p>Incorrect options:</p><ul><li><p><strong>Single row date arithmetic operations return date, character or numeric values. Functions under the category are MONTHS_BETWEEN, ADD_MONTHS, NEXT_DAY, LAST_DAY, ROUND, REPLACE and TRUNC.</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>REPLACE</code> is a <strong>character</strong> function and does not belong here.</p></li><li><p>Date functions generally return <strong>date</strong> or <strong>numeric</strong> values, but not character.</p></li><li><p>So this statement is incorrect due to inclusion of <code>REPLACE</code>.</p></li></ul></li></ul><ul><li><p> <strong>Single row numeric operations return numeric values. Functions under the category are SUM, SUBTRACT, ROUND, TRUNC, and MOD.</strong></p><ul><li><p><strong>False</strong></p></li><li><p><code>SUM</code> is an <strong>aggregate</strong> function, not a single-row function.</p></li><li><p><code>SUBTRACT</code> is not a valid SQL function.</p></li><li><p>ROUND, TRUNC, MOD are valid single-row numeric functions.</p></li><li><p>Overall, this statement is inaccurate.</p></li></ul></li></ul><p><br></p><p><strong>Using Single-Row Functions</strong></p><p>Oracle SQL supplies a rich library of in-built functions which can be employed for various tasks. The essential capabilities of a functions can be the case conversion of strings, in-string or substring operations, mathematical computations on numeric data, and date operations on date type values. SQL Functions optionally take arguments from the user and mandatorily return a value.</p><p>On a broader category, there are two types of functions :-</p><p><strong>Single Row functions</strong> - Single row functions are the one who work on single row and return one output per row. For example, length and case conversion functions are single row functions.</p><p><strong>Multiple Row functions </strong>- Multiple row functions work upon group of rows and return one result for the complete set of rows. They are also known as Group Functions.</p><p>Single row functions</p><p>Single row functions can be character functions, numeric functions, date functions, and conversion functions. Note that these functions are used to manipulate data items. These functions require one or more input arguments and operate on each row, thereby returning one output value for each row. Argument can be a column, literal or an expression. Single row functions can be used in <code>SELECT</code> statement, <code>WHERE</code> and <code>ORDER BY</code> clause. </p><p><em>√&nbsp; Single row functions can be character functions, numeric functions, date functions, and conversion functions. </em></p><p><em>√&nbsp; Single row functions can be character functions, numeric functions, date functions, conversion and audit functions.</em></p><p><br></p><p>Single row functions can be -</p><p><strong>General functions</strong> - Usually contains <code>NULL</code> handling functions. The functions under the category are <code>NVL</code>, <code>NVL2</code>, <code>NULLIF</code>, <code>COALESCE</code>, <code>CASE</code>, <code>DECODE</code>.</p><p><strong>Case Conversion functions</strong> - Accepts character input and returns a character value. Functions under the category are <code>UPPER</code>, <code>LOWER</code> and <code>INITCAP</code>.</p><p><code>UPPER</code> function converts a string to upper case.</p><p><code>LOWER</code> function converts a string to lower case.</p><p><code>INITCAP</code> function converts only the initial alphabets of a string to upper case.</p><p><em>√&nbsp; Single row case conversion functions accept character input and returns a character value. Functions under the category are UPPER, LOWER and INITCAP.</em></p><p><br></p><p><strong>Character functions</strong> - Accepts character input and returns number or character value. Functions under the category are <code>CONCAT</code>, <code>LENGTH</code>, <code>SUBSTR</code>, <code>INSTR</code>, <code>LPAD</code>, <code>RPAD</code>, <code>TRIM</code> and <code>REPLACE</code>.</p><p><code>CONCAT</code> function concatenates two string values.</p><p><code>LENGTH</code> function returns the length of the input string.</p><p><code>SUBSTR</code> function returns a portion of a string from a given start point to an end point.</p><p><code>INSTR</code> function returns numeric position of a character or a string in a given string.</p><p><code>LPAD</code> and <code>RPAD</code> functions pad the given string upto a specific length with a given character.</p><p><code>TRIM</code> function trims the string input from the start or end.</p><p><code>REPLACE</code> function replaces characters from the input string with a given character.</p><p><em>√&nbsp; Single row character input and returns number or character value. Functions under the category are CONCAT, LENGTH, SUBSTR, INSTR, LPAD, RPAD, TRIM and REPLACE.</em></p><p><br></p><p><strong>Date functions</strong> - Date arithmetic operations return date or numeric values. Functions under the category are <code>MONTHS_BETWEEN</code>, <code>ADD_MONTHS</code>, <code>NEXT_DAY</code>, <code>LAST_DAY</code>, <code>ROUND</code> and <code>TRUNC</code>.</p><p><code>MONTHS_BETWEEN</code> function returns the count of months between the two dates.</p><p><code>ADD_MONTHS</code> function add 'n' number of months to an input date.</p><p><code>NEXT_DAY</code> function returns the next day of the date specified.</p><p><code>LAST_DAY</code> function returns last day of the month of the input date.</p><p><code>ROUND</code> and <code>TRUNC</code> functions are used to round and truncates the date value.</p><p><br></p><p><strong>Number functions</strong> - Accepts numeric input and returns numeric values. Functions under the category are <code>ROUND</code>, <code>TRUNC</code>, and <code>MOD</code>.</p><p><code>ROUND</code> and <code>TRUNC</code> functions are used to round and truncate the number value.</p><p><code>MOD</code> is used to return the remainder of the division operation between two numbers.</p>",
                "answers": [
                    "<p>Single row functions can be character functions, numeric functions, date functions, and conversion functions. </p>",
                    "<p>Single row case conversion functions accept character input and returns a character value. Functions under the category are UPPER, LOWER and INITCAP.</p>",
                    "<p>Single-row character functions accept character input and return either character or numeric values. Examples include CONCAT, SUBSTR, LPAD, RPAD, TRIM, and REPLACE.</p>",
                    "<p>Single row date arithmetic operations return date, character or numeric values. Functions under the category are MONTHS_BETWEEN, ADD_MONTHS, NEXT_DAY, LAST_DAY, ROUND, REPLACE and TRUNC.</p>",
                    "<p>Single row numeric operations return numeric values. Functions under the category are SUM, SUBTRACT, ROUND, TRUNC, and MOD.</p>",
                    "<p>Single row functions can be character functions, numeric functions, date functions, conversion and audit functions.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c",
                "f"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding single-row functions. (Choose four.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289369,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about performing Data Manipulation Language (DML) operations on a view in an Oracle Database. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle View](https://www.oracletutorial.com/oracle-view/)"
                ],
                "feedbacks": [
                    "Views are commonly used to simplify data retrieval by presenting a subset of data from one or more tables. They also help maintain logical data independence by abstracting the underlying table structure and implementing data security by restricting access to specific columns or rows.",
                    "Views allow data from underlying tables to be exposed to external applications without exposing the underlying table structure. This helps in controlling the data that external applications can access and manipulate.",
                    "Views provide the ability to hide certain columns or rows from the underlying tables, allowing users to work with a subset of data without directly accessing the tables themselves.",
                    "Views do not expose underlying table access to external applications; instead, they provide a controlled and secure way to interact with the data without directly accessing the tables.",
                    "Users must have the necessary permissions to access the underlying tables in order to view the data through a view. This ensures that users can only see the data they are authorized to access based on their permissions on the source tables.",
                    "A view is a virtual table that is created by a SQL query and does not physically store data. It is a logical representation of the data and is not physically stored separately from the underlying tables."
                ],
                "explanation": "<p><strong>True Statements</strong>:</p><ol><li><p><strong>The most common uses of views are to simplify data retrieval, maintain logical data independence, and implement data security.</strong><br>This is a textbook reason for using views. Views abstract the underlying complexity of tables, allow applications to continue functioning even if the underlying schema changes, and can restrict access to sensitive data by exposing only certain columns or rows.</p></li><li><p><strong>Data from underlying tables can be exposed to external applications via views.</strong><br>Views can be granted to users or applications, allowing them to query data from base tables without accessing the tables directly. This provides a level of abstraction and control.</p></li><li><p><strong>Views help you allow for hiding columns and rows from the underlying tables.</strong><br>Views can be designed to return only specific columns or include <code>WHERE</code> clauses to filter out specific rows, thereby controlling what data is visible.</p></li></ol><p><strong>False Statements</strong>:</p><ol><li><p><strong>Underlying table access can be exposed to external applications via views.</strong><br><strong>False / Misleading</strong><br>While views do allow access to the <strong>data</strong>, they do <strong>not</strong> expose the underlying <strong>table definitions or structures</strong> directly. Also, applications don't get access to <strong>tables</strong>—they get access to the <strong>view</strong>, which provides a controlled interface.</p></li><li><p><strong>For a user to see a view, the user must have at least read only access to the source tables which populate a view.</strong><br><strong>False</strong><br>Users <strong>do not need direct access</strong> to the base tables to query a view. If the view owner grants <code>SELECT</code> on the view, the user can query it <strong>even without any privileges on the underlying tables</strong>.</p></li><li><p><strong>A view is simply the representation of a SQL statement that is physically stored and is available to all users.</strong><br><strong>False</strong><br>A view is <strong>logically stored</strong> as a SQL query, not as physical data (unless it's a <strong>materialized view</strong>). Also, it is <strong>not automatically available to all users</strong>—access depends on <strong>grants</strong> and <strong>privileges</strong>.</p></li></ol><p><strong>Inside Oracle Views</strong></p><p>A view is simply the representation of a SQL statement that is stored in memory so that it can easily be re-used.</p><p><strong>When to use the Oracle view</strong></p><p>You can use views in many cases for different purposes. The most common uses of views are as follows:</p><p>• Simplifying data retrieval.</p><p>• Maintaining logical data independence.</p><p>• Implementing data security.</p><p><em>√&nbsp; The most common uses of views are to simplify data retrieval, maintain logical data independence, and implement data security.</em></p><p><br></p><p><strong>Simplifying data retrieval</strong></p><p>Views help simplify data retrieval significantly. First, you build a complex query, test it carefully, and encapsulate the query in a view. Then, you can access the data of the underlying tables through the view instead of rewriting the whole query again and again.</p><p><strong>Maintaining logical data independence</strong></p><p>You can expose the data from underlying tables to the external applications via views. Whenever the structures of the base tables change, you just need to update the view. The interface between the database and the external applications remains intact. The beauty is that you don’t have to change a single line of code to keep the external applications up and running.</p><p>For example, some reporting systems may need only customer sales data for composing strategic reports. Hence, you can give the application owners the <code>customer_sales</code> view.</p><p><em>√&nbsp; Data from underlying tables can be exposed to external applications via views.</em></p><p><br></p><p><strong>Implementing data security</strong></p><p>Views allow you to implement an additional security layer. They help you hide certain columns and rows from the underlying tables and expose only needed data to the appropriate users.</p><p><em>√&nbsp; Views help you allow for hiding columns and rows from the underlying tables.</em></p><p><br></p><p>Oracle provides you the with <code>GRANT</code> and <code>REVOKE</code> commands on views so that you can specify which actions a user can perform against the view. Note that in this case, you don’t grant any privileges on the underlying tables because you may not want the user to bypass the views and access the base tables directly.</p>",
                "answers": [
                    "<p>The most common uses of views are to simplify data retrieval, maintain logical data independence, and implement data security.</p>",
                    "<p>Data from underlying tables can be exposed to external applications via views.</p>",
                    "<p>Views help you allow for hiding columns and rows from the underlying tables.</p>",
                    "<p>Underlying table access can be exposed to external applications via views.</p>",
                    "<p>For a user to see a view, the user must have at least read only access to the source tables which populate a view.</p>",
                    "<p>A view is simply the representation of a SQL statement that is physically stored and is available to all users.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "View",
            "question_plain": "View and examine the following available responses.Identify the true statements about performing Data Manipulation Language (DML) operations on a view in an Oracle Database. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289457,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given: </strong></p><ul><li><p>The EMPLOYEES table contains columns EMP_ID of data type NUMBER and HIRE_DATE of data type DATE.</p></li><li><p>The NLS_TERRITORY parameter is set to AMERICA in the session and, therefore, Sunday is the first day of the week.</p></li></ul><p><strong>Required:</strong> Display the date of the first Monday after the completion of six month since hiring.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ADD_MONTHS](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/ADD_MONTHS.html)",
                    "[NEXT_DAY](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/NEXT_DAY.html)"
                ],
                "feedbacks": [
                    "The query uses the NEXT_DAY function with MONTHS_BETWEEN to calculate the date of the first Monday after six months since hiring. However, the NEXT_DAY function is not used correctly in this query, and the calculation logic is incorrect.",
                    "This query correctly uses the ADD_MONTHS function to calculate the date six months after hiring and then uses the NEXT_DAY function to find the following Monday. It considers the NLS_TERRITORY parameter setting to determine the first day of the week, which is Sunday in this case.",
                    "The query uses the ADD_MONTHS function to calculate the date six months after hiring but incorrectly uses the NEXT_DAY function without specifying the day of the week. This will not give the correct result for finding the first Monday after the completion of six months since hiring.",
                    "This query incorrectly combines the NEXT_DAY and ADD_MONTHS functions, leading to incorrect date calculations. The syntax of the functions is incorrect, and the logic used to find the first Monday after six months since hiring is flawed."
                ],
                "explanation": "<p><strong>Requirement Recap:</strong></p><ul><li><p>The goal is to <strong>find the first Monday</strong> <strong>after six months have passed</strong> since each employee's <code>hire_date</code>.</p></li><li><p>The <code>NLS_TERRITORY = 'AMERICA'</code>, so <strong>Sunday is the first day of the week</strong>, but this doesn't affect the logic of <code>NEXT_DAY(date, 'MONDAY')</code>.</p></li></ul><p>We will use:</p><ul><li><p><code>ADD_MONTHS(hire_date, 6)</code> → Gets the date 6 months after hiring.</p></li><li><p><code>NEXT_DAY(date, 'MONDAY')</code> → Returns the <strong>first Monday after</strong> the given <code>date</code>.</p></li></ul><p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       ADD_MONTHS(hire_date, 6) \"6 MONTH ANNIVERSARY\", \n       NEXT_DAY(ADD_MONTHS(hire_date, 6), 'MONDAY') \"FOLLOWING MONDAY\"\nFROM employees;\n</pre><ul><li><p>This correctly adds 6 months to the hire date, then finds the next Monday.</p></li><li><p>Syntax is correct.</p></li><li><p>Output includes hire date, 6-month anniversary, and the following Monday.</p></li></ul><p><strong>Incorrect Options:</strong></p><pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       NEXT_DAY(MONTHS_BETWEEN(hire_date, SYSDATE), 6) \"MONDAY FOLLOWING 6 MONTH ANNIVERSARY\"\nFROM employees;\n</pre><ul><li><p><code>MONTHS_BETWEEN(hire_date, SYSDATE)</code> returns a <strong>number</strong> (not a date).</p></li><li><p>Passing a <strong>number</strong> to <code>NEXT_DAY()</code> causes an error (expects a <strong>date</strong> as first argument).</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       ADD_MONTHS(hire_date, 6), \n       NEXT_DAY('MONDAY') \"MONDAY FOLLOWING 6 MONTH ANNIVERSARY\"\nFROM employees;\n</pre><ul><li><p><code>NEXT_DAY('MONDAY')</code> is missing a <strong>date argument</strong>.</p></li><li><p><code>'MONDAY'</code> is a string, but <code>NEXT_DAY()</code> requires a <strong>date as the first argument</strong>, e.g., <code>NEXT_DAY(SOME_DATE, 'MONDAY')</code>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       NEXT_DAY(ADD_MONTHS(hire_date, 6) \"6 MONTH ANNIVERSARY\", 1) \"FOLLOWING MONDAY\"\nFROM employees;\n</pre><ul><li><p>Syntax error: Misplaced alias <code>\"6 MONTH ANNIVERSARY\"</code> inside <code>NEXT_DAY()</code> function.</p></li><li><p>Also, passing <code>1</code> as the second argument is unclear (should be a <strong>day name</strong> or number according to Oracle's documented day format, and usually <code>'MONDAY'</code> is safer/more readable).</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       NEXT_DAY (MONTHS_BETWEEN (hire_date, SYSDATE), 6) \"MONDAY FOLLOWING 6 MONTH ANNIVERSARY\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT emp_id, hire_date, \n       ADD_MONTHS(hire_date, 6) \"6 MONTH ANNIVERSARY\", \n       NEXT_DAY(ADD_MONTHS(hire_date, 6), 'MONDAY') \"FOLLOWING MONDAY\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT emp_id, \n       hire_date,ADD_MONTHS(hire_date, 6), \n       NEXT_DAY('MONDAY') \"MONDAY FOLLOWING 6 MONTH ANNIVERSARY\"\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT emp_id, \n       hire_date,  \n       NEXT_DAY(ADD_MONTHS(hire_date, 6) \"6 MONTH ANNIVERSARY\", 1) \"FOLLOWING MONDAY\"\nFROM employees;\n</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario.Given: The EMPLOYEES table contains columns EMP_ID of data type NUMBER and HIRE_DATE of data type DATE.The NLS_TERRITORY parameter is set to AMERICA in the session and, therefore, Sunday is the first day of the week.Required: Display the date of the first Monday after the completion of six month since hiring.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289373,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES table.</p><p><strong>Table: EMPLOYEES </strong></p><pre class=\"prettyprint linenums\">Name                      Null??            Type\nEMPLOYEE_ID               NOT NULL          NUMBER(6)\nFIRST_NAME                                  VARCHAR2(20)\nLAST_NAME                 NOT NULL          VARCHAR2(25)\nEMAIL                     NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                                VARCHAR2(20)\nHIRE_DATE                 NOT NULL          DATE\nJOB_ID                    NOT NULL          VARCHAR2(10)\nSALARY                                      NUMBER(8,2)\nCOMMMISSION_PCT                             NUMBER(2,2)\nMANAGER_ID                                  NUMBER(6)\nDEPARTMENT_ID                               NUMBER(4)\n</pre><p> </p><p><strong>Given:</strong> There is a parent-child relationship between EMPLOYEE_ID and MANAGER_ID. </p><p><strong>Required:</strong> Display the last names and manager IDs of employees who work for the same manager as the employee whose EMPLOYEE_ID is 5.&nbsp; </p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Joins](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html)"
                ],
                "feedbacks": [
                    "This query is incorrect because it uses the same alias \"e\" for both instances of the employees table in the LEFT OUTER JOIN, which causes a conflict in the query. Additionally, the condition in the WHERE clause should be based on the manager_id, not the employee_id.",
                    "This query is incorrect because it does not specify the table alias for the employees table in the SELECT clause, causing ambiguity. The condition in the WHERE clause should be based on the manager_id, not the employee_id.",
                    "This query is incorrect because it uses the table alias \"m\" for the employees table in the LEFT OUTER JOIN, but then references \"m\" in the WHERE clause instead of \"e\". The condition in the WHERE clause should be based on the manager_id, not the employee_id.",
                    "This query is correct because it selects the last name, employee ID, and manager ID from the employees table using the appropriate aliases \"e\" and \"m\". It performs a LEFT OUTER JOIN on the employees table to match the manager IDs and filters the results based on the employee ID being 5, which retrieves the last names and manager IDs of employees who work for the same manager as the employee with EMPLOYEE_ID 5."
                ],
                "explanation": "<p>We are given:</p><ul><li><p>A table <code>EMPLOYEES</code> with a <strong>self-referential relationship</strong>:<br><code>MANAGER_ID</code> (child) → <code>EMPLOYEE_ID</code> (parent)</p></li></ul><p><strong>Requirement:</strong></p><p><strong>Display the last names and manager IDs of employees who work for the same manager as the employee whose </strong><code><strong>EMPLOYEE_ID</strong></code><strong> is 5.</strong></p><p>This means:</p><ol><li><p>Find the <strong>manager_id of employee 5</strong></p></li><li><p>Find <strong>other employees</strong> (including or excluding 5 depending on design) <strong>who have that same manager_id</strong></p></li><li><p>Display their <strong>last_name</strong> and <strong>manager_id</strong></p></li></ol><p>Step-by-Step Breakdown:</p><p>To solve this:</p><pre class=\"prettyprint linenums\">SELECT last_name, manager_id\nFROM employees\nWHERE manager_id = (\n    SELECT manager_id FROM employees WHERE employee_id = 5\n);\n</pre><p>Or using a self-join if needed.</p><p><br></p><p><strong>Options:</strong></p><pre class=\"prettyprint linenums\">SELECT e.last_name, e.employee_id, m.manager_id\nFROM employees m\nLEFT OUTER JOIN employees e ON (e.manager_id = m.manager_id)\nWHERE m.employee_id = 5;\n</pre><ul><li><p><strong>Correct logic:</strong></p></li><li><p><code>m</code> is the employee with <code>employee_id = 5</code></p></li><li><p><code>e</code> is anyone whose <code>manager_id = m.manager_id</code> — meaning they share the same manager</p></li><li><p>Output: <code>e.last_name</code>, <code>e.employee_id</code>, and <code>m.manager_id</code></p></li><li><p>Matches requirement</p></li><li><p>Returns employees who <strong>share the same manager</strong> as employee 5</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT m.last_name, e.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees e ON (e.manager_id = m.manager_id)\nWHERE e.employee_id = 5;\n</pre><ul><li><p><strong>Invalid alias reuse:</strong> <code>employees e</code> is defined twice</p></li><li><p>Confusing and broken aliasing</p></li><li><p>Will cause a SQL error</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT m.last_name, m.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees ON (e.manager_id = m.manager_id)\nWHERE employee_id = 5;\n</pre><ul><li><p><strong>Invalid alias usage:</strong> <code>m</code> is not defined anywhere</p></li><li><p>Will fail at runtime due to missing alias</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT m.last_name, m.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees m ON (e.manager_id = m.manager_id)\nWHERE m.employee_id = 5;\n</pre><ul><li><p><strong>Wrong direction of join</strong></p></li><li><p>This finds all employees <code>e</code> whose <strong>manager_id matches someone (</strong><code><strong>m</strong></code><strong>) whose employee_id is 5</strong>, but in reality, employee 5 is <strong>not</strong> a manager — they are a subordinate</p></li><li><p><strong>Flawed logic</strong> — you’re joining based on employee 5's <strong>subordinates</strong>, not peers</p></li></ul><p>Some of the queries provided will execute successfully, but the correct one divides the table into these two parts.</p><p>1. The first part is to find the manager_id where the employee_id equals 5.</p><pre class=\"prettyprint linenums\">SELECT employee_id, manager_id\nFROM employees\nWHERE employee_id = 5</pre><p><br></p><p>This table shows the manager_id = 9 for employee_id 5.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-02_22-47-52-84918e7f4e018bf0f4eb46c6474b3c1b.png\"></p><p><br></p><p>2. Next we find the employee_ids that share manager_id 9 in the employees table.</p><pre class=\"prettyprint linenums\">SELECT employee_id, manager_id\nFROM employees\nWHERE manager_id = 9</pre><p><br></p><p>This shows that manager_id 9 is shared by employee_ids 4 and 5.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-02_23-15-32-7b7eece8c3f9a31a7e9429390f71743d.png\"></p><p><br></p><p>Now, the task is to put these tables together to show the required elements. One way to do this is with a UNION.</p><pre class=\"prettyprint linenums\">SELECT last_name, employee_id, manager_id\nFROM employees\nWHERE manager_id = 9\nUNION\nSELECT last_name, employee_id, manager_id\nFROM employees\nWHERE employee_id = 5;</pre><p><br></p><p>Another option is with a subquery.</p><pre class=\"prettyprint linenums\">SELECT last_name, employee_id, manager_id\nFROM employees\nWHERE manager_id = (\n    SELECT manager_id\n    FROM employees\n    WHERE employee_id = 5);</pre><p><br></p><p>This problem solutions offers JOIN queries to be used.</p><pre class=\"prettyprint linenums\">SELECT m.last_name, m.employee_id, e.manager_id\nFROM employees e\nLEFT JOIN employees m ON (e.manager_id = m.manager_id)\nWHERE e.employee_id = 5;</pre><p><br></p><p>What's happening with this join is that Table 'e' it shows the manager_id and employee_id where employee_id = 5. </p><p>Next all the records on Table 'm' show the last_name, employee_id and their manager_id.</p><p>Finally table 'm' is presented after being filtered for the manager_id that is rendered on Table 'e'. The result shows all the employees that report to the same manager as the employee with employee_id 5. </p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-02_23-46-21-dc922e6509929fe90ebb197003507263.png\"><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-02_23-38-17-793bcc97e2a53caccb7720278a487a7e.png\"></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-02_22-25-31-0e3548175fb368fe5061d4a54f9fa79b.png\"></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name, e.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees e ON (e.manager_id = m.manager_id)\nWHERE e.employee_id = 5;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name, m.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees ON (e.manager_id = m.manager_id)\nWHERE employee_id = 5;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT m.last_name, m.employee_id, e.manager_id\nFROM employees e\nLEFT OUTER JOIN employees m ON (e.manager_id = m.manager_id)\nWHERE m.employee_id = 5;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT e.last_name, e.employee_id, m.manager_id\nFROM employees m\nLEFT OUTER JOIN employees e ON (e.manager_id = m.manager_id)\nWHERE m.employee_id = 5;\n</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the structure of the EMPLOYEES table.Table: EMPLOYEES Name                      Null??            Type\nEMPLOYEE_ID               NOT NULL          NUMBER(6)\nFIRST_NAME                                  VARCHAR2(20)\nLAST_NAME                 NOT NULL          VARCHAR2(25)\nEMAIL                     NOT NULL          VARCHAR2(25)\nPHONE_NUMBER                                VARCHAR2(20)\nHIRE_DATE                 NOT NULL          DATE\nJOB_ID                    NOT NULL          VARCHAR2(10)\nSALARY                                      NUMBER(8,2)\nCOMMMISSION_PCT                             NUMBER(2,2)\nMANAGER_ID                                  NUMBER(6)\nDEPARTMENT_ID                               NUMBER(4)\n Given: There is a parent-child relationship between EMPLOYEE_ID and MANAGER_ID. Required: Display the last names and manager IDs of employees who work for the same manager as the employee whose EMPLOYEE_ID is 5.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289375,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the data in EMP and DEPT tables and the exhibit.</p><p><strong>Table: DEPT</strong></p><pre class=\"prettyprint linenums\">DEPTNO                           DEPTNAME\n10                               IT\n20                               HR\n</pre><p><br></p><p><strong>Table: EMP</strong></p><pre class=\"prettyprint linenums\">EMPNO                           ENAME                    DEPTNO\n1                               KING                     10\n2                               HARI                     20\n</pre><p><br></p><p><strong>Given:</strong> </p><ul><li><p>DEPTNO is the PRIMARY KEY in the DEPT table. </p></li><li><p>EMPNO is the PRIMARY KEY in the EMP table.</p></li><li><p>DEPTNO is the FOREIGN KEY referencing the DEPTNO column in the DEPT table.&nbsp; </p></li></ul><p>The following SQL sequence has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP TABLE emp;\nFLASHBACK TABLE emp TO BEFORE&nbsp;DROP;\nINSERT INTO emp VALUES (2, 'SCOTT', 10);\nINSERT INTO emp VALUES (3, 'KING', 55);\n</pre><p><br></p><p>Indicate the statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DROP TABLE Statement](https://www.techonthenet.com/oracle/tables/drop_table.php)",
                    "[Flashback Table to Before Drop (Recycle Bin)](https://oracle-base.com/articles/10g/flashback-table-to-before-drop-10g)"
                ],
                "feedbacks": [
                    "This statement is incorrect because constraints are not automatically retrieved when a table is flashed back. Flashed back tables retain their original constraints, so the INSERT statements would not fail due to constraint retrieval.",
                    "This statement is incorrect because constraints are retained when a table is flashed back. The constraints on the table, including primary key and foreign key constraints, are not automatically removed, so the INSERT statements would not succeed without adhering to these constraints.",
                    "This statement is incorrect because all constraints, including primary key constraints, are automatically retrieved after a table is flashed back. Therefore, both INSERT statements would succeed as long as they adhere to the constraints defined on the tables.",
                    "This statement is correct because after a table is flashed back, all constraints except referential integrity constraints that reference other tables are automatically retrieved. In this scenario, the second INSERT statement would succeed because it does not violate any constraints on the table."
                ],
                "explanation": "<p>Let's break down the execution of the SQL sequence step by step, considering Oracle's behaviour with <code>FLASHBACK TABLE</code>.</p><p><strong>Initial State:</strong></p><ul><li><p><strong>DEPT Table:</strong></p><ul><li><p><code>DEPTNO</code> (PK): 10, 20</p></li><li><p><code>DEPTNAME</code>: IT, HR</p></li></ul></li><li><p><strong>EMP Table:</strong></p><ul><li><p><code>EMPNO</code> (PK): 1, 2</p></li><li><p><code>ENAME</code>: KING, HARI</p></li><li><p><code>DEPTNO</code> (FK referencing <code>DEPT.DEPTNO</code>): 10, 20</p></li></ul></li></ul><p><strong>SQL Sequence Execution:</strong></p><ol><li><p><code><strong>DROP TABLE emp;</strong></code></p><ul><li><p>The <code>EMP</code> table is completely removed from the database, including its data, structure, and all associated constraints (Primary Key on <code>EMPNO</code>, Foreign Key on <code>DEPTNO</code>).</p></li></ul></li><li><p><code><strong>FLASHBACK TABLE emp TO BEFORE DROP;</strong></code></p><ul><li><p>This command restores the <code>EMP</code> table to its state just before it was dropped. This means:</p><ul><li><p>The table structure is restored.</p></li><li><p>The original data in the <code>EMP</code> table (1, 'KING', 10) and (2, 'HARI', 20) is restored.</p></li><li><p><strong>Important detail regarding constraints:</strong></p><ul><li><p><strong>Primary Key (PK) constraints</strong> are generally restored with <code>FLASHBACK TABLE</code>.</p></li><li><p><strong>Referential Integrity (Foreign Key - FK) constraints</strong> that reference <em>other</em> tables are <strong>NOT automatically restored</strong> by <code>FLASHBACK TABLE TO BEFORE DROP</code>. They become disabled or need to be manually re-created/re-enabled.</p></li></ul></li></ul></li></ul></li><li><p><code><strong>INSERT INTO emp VALUES (2, 'SCOTT', 10);</strong></code></p><ul><li><p><strong>Check Primary Key:</strong> The restored <code>EMP</code> table already contains a row with <code>EMPNO = 2</code> (HARI). Since the primary key constraint on <code>EMPNO</code> is restored and active, attempting to insert another row with the same <code>EMPNO</code> will violate the primary key uniqueness.</p></li><li><p><strong>Result: This </strong><code><strong>INSERT</strong></code><strong> statement will fail due to a primary key violation.</strong></p></li></ul></li><li><p><code><strong>INSERT INTO emp VALUES (3, 'KING', 55);</strong></code></p><ul><li><p><strong>Check Primary Key:</strong> <code>EMPNO = 3</code> does not exist in the restored <code>EMP</code> table, so there is no primary key violation.</p></li><li><p><strong>Check Foreign Key:</strong> <code>DEPTNO = 55</code> does not exist in the <code>DEPT</code> table. Normally, this would violate the foreign key constraint. However, as established in step 2, the foreign key constraint on <code>DEPTNO</code> was <em>not</em> automatically restored by <code>FLASHBACK TABLE</code>. Since the foreign key constraint is not active, this insertion is not checked against the <code>DEPT</code> table's <code>DEPTNO</code> values.</p></li><li><p><strong>Result: This </strong><code><strong>INSERT</strong></code><strong> statement will succeed.</strong></p></li></ul></li></ol><p><strong>Conclusion based on the analysis:</strong></p><ul><li><p>The first <code>INSERT</code> statement fails due to a primary key violation.</p></li><li><p>The second <code>INSERT</code> statement succeeds because the foreign key constraint is not automatically restored.</p></li></ul><p>the statement that accurately describes the result is:</p><p><strong>Only the SECOND INSERT statement would succeed because all the constraints except referential integrity constraints that reference other tables are retrieved automatically after the table is flashed back.</strong></p><p><br></p><p>The syntax for the Oracle <strong>DROP TABLE statement</strong> is:</p><pre class=\"prettyprint linenums\">DROP TABLE [schema_name].table_name\n[ CASCADE CONSTRAINTS ]\n[ PURGE ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>schema_name - The name of the schema that owns the table. table_name The name of the table to remove from the Oracle database. </p><p>CASCADE CONSTRAINTS Optional. - If specified, all referential integrity constraints will be dropped as well. </p><p>PURGE Optional. - If specified, the table and its dependent objects will be purged from the recycle bin and you will not be able to recover the table. If not specified, the table and its dependent objects are placed in the recycle bin and can be recovered later, if needed.</p><p><strong><em>Note: </em></strong><em>If there are referential integrity constraints on table_name and you do not specify the CASCADE CONSTRAINTS option, the DROP TABLE statement will return an error and Oracle will not drop the table.</em></p><p><strong>Drop Table Mechanics</strong></p><p>The default action of a <code>DROP TABLE</code> command is to logically move the table to the recycle bin by renaming it, rather than actually dropping it.</p><p><strong>Flashback Table to Before Drop (Recycle Bin)</strong></p><p>The recycle bin is a logical collection of previously dropped objects. This feature doesn't use flashback logs or undo, so it is distinct from the other flashback technologies.</p><p>The recycle bin is a logical collection of previously dropped objects, with access tied to the <code>DROP</code> privilege. The contents of the recycle bin can be shown using the <code>SHOW RECYCLEBIN</code> command and purged using the <code>PURGE TABLE</code> command. As a result, a previously dropped table can be recovered from the recycle bin.</p><p>Drop the table without the <code>PURGE</code> keyword, and check the contents of the recycle bin using the <code>SHOW RECYCLEBIN</code> command.</p><p>Restore the dropped table using the <code>FLASHBACK TABLE</code> command.</p><pre class=\"prettyprint linenums\">FLASHBACK TABLE table_name TO BEFORE DROP;</pre><p><br></p><p><strong>Restrictions</strong></p><p>Several restrictions apply relating to the recycle bin.</p><p>• Only available for non-system, locally managed tablespaces.</p><p>• There is no fixed size for the recycle bin. The time an object remains in the recycle bin can vary.</p><p>• The objects in the recycle bin are restricted to query operations only (no DDL or DML).</p><p>• Flashback query operations must reference the recycle bin name.</p><p>• Tables and all dependent objects are placed into, recovered and purged from the recycle bin at the same time.</p><p>• Tables with Fine Grained Access policies aer not protected by the recycle bin.</p><p>• Partitioned index-organized tables are not protected by the recycle bin.</p><p>• The recycle bin does not preserve referential integrity.</p><p><em>√&nbsp; Only the SECOND INSERT statement would succeed because all the constraints except referential integrity constraints that reference other tables are retrieved automatically after the table is flashed back.</em></p><p><br></p><p>What we have is a set of 2 tables, where the tables are linked with a foreign key from the departments table to the employees table. After following the path indicated in the problem, the final result is that foreign key constraints are lost, but the primary key is restored which disallows duplicates in the department number column due to the primary key constraint requiring unique entries.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_13-55-41-b1bfc3f876749666eab611c148de88b2.png\"></p>",
                "answers": [
                    "<p>Both the INSERT statements would fail because the constraints are automatically retrieved when the table is flashed back.</p>",
                    "<p>Both the INSERT statements would succeed because none of the constraints on the table are automatically retrieved when the table is flashed back.</p>",
                    "<p>Only the first INSERT statement would succeed because all constraints except the primary key constraint are automatically retrieved after a table is flashed back.</p>",
                    "<p>Only the SECOND INSERT statement would succeed because all the constraints except referential integrity constraints that reference other tables are retrieved automatically after the table is flashed back.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "DROP TABLE",
            "question_plain": "View and examine the data in EMP and DEPT tables and the exhibit.Table: DEPTDEPTNO                           DEPTNAME\n10                               IT\n20                               HR\nTable: EMPEMPNO                           ENAME                    DEPTNO\n1                               KING                     10\n2                               HARI                     20\nGiven: DEPTNO is the PRIMARY KEY in the DEPT table. EMPNO is the PRIMARY KEY in the EMP table.DEPTNO is the FOREIGN KEY referencing the DEPTNO column in the DEPT table.&nbsp; The following SQL sequence has been executed.Exhibit: 1DROP TABLE emp;\nFLASHBACK TABLE emp TO BEFORE&nbsp;DROP;\nINSERT INTO emp VALUES (2, 'SCOTT', 10);\nINSERT INTO emp VALUES (3, 'KING', 55);\nIndicate the statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289377,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the WHERE and HAVING clauses in a SQL statement. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: WHERE Clause](https://www.techonthenet.com/oracle/where.php)",
                    "[Oracle / PLSQL: HAVING Clause](https://www.techonthenet.com/oracle/having.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect. WHERE and HAVING clauses can be used together in a SQL statement. The WHERE clause is used to filter rows before any groupings are made, while the HAVING clause is used to filter groups after the grouping has been done.",
                    "This statement is correct. The HAVING clause conditions can make use of aggregate functions like SUM, AVG, COUNT, etc. to filter groups based on the result of the aggregate functions.",
                    "This statement is incorrect. The HAVING clause cannot use aliases for the columns. Aliases can only be used in the SELECT statement to rename columns or expressions.",
                    "This statement is correct. The WHERE clause is used to filter rows before any groupings are made, and it can be used in conjunction with the GROUP BY clause to further filter the grouped data.",
                    "This statement is correct. The HAVING clause allows for referencing more than one table in the FROM clause, making it useful for complex queries involving multiple tables and aggregate functions."
                ],
                "explanation": "<p>True Statements:</p><p>1. <strong>The HAVING clause conditions can make use of the SUM function.</strong></p><ul><li><p><code>HAVING</code> is evaluated <strong>after grouping</strong>, so it can use <strong>aggregate functions</strong> like <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, etc.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT department_id, SUM(salary)\nFROM employees\nGROUP BY department_id\nHAVING SUM(salary) &gt; 100000;\n</pre></li></ul><p>2. <strong>The WHERE may be used in conjunction with the GROUP BY clause.</strong></p><ul><li><p><code>WHERE</code> filters rows <strong>before</strong> grouping, so it can be used <strong>together with GROUP BY</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(*)\nFROM employees\nWHERE job_id = 'SA_REP'\nGROUP BY department_id;\n</pre></li></ul><p>3. <strong>The HAVING clause allows for referencing more than one table in the FROM clause.</strong></p><ul><li><p>You can perform a <strong>JOIN</strong> involving multiple tables, and use <code>HAVING</code> on the result.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT d.department_name, COUNT(e.employee_id)\nFROM departments d\nJOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name\nHAVING COUNT(e.employee_id) &gt; 5;\n</pre></li></ul><p>False Statements:</p><ul><li><p><strong>WHERE and HAVING clauses cannot be used together in a SQL statement.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>They <strong>can</strong> be used together:</p><ul><li><p><code>WHERE</code> filters <strong>rows before grouping</strong></p></li><li><p><code>HAVING</code> filters <strong>groups after aggregation</strong></p></li></ul></li></ul></li></ul><ul><li><p><strong>The HAVING clause conditions can use aliases for the columns.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Unlike <code>ORDER BY</code>, the <code>HAVING</code> clause <strong>cannot</strong> reliably reference column <strong>aliases</strong> defined in the <code>SELECT</code> list.</p></li><li><p>Instead, you must <strong>repeat the expression</strong>, e.g., <code>HAVING SUM(salary) &gt; 50000</code> (not <code>HAVING total_salary &gt; 50000</code>)</p></li></ul><p><br></p></li></ul><p><strong>The Oracle WHERE clause</strong> is used to filter the results from a <a href=\"https://www.techonthenet.com/oracle/select.php\"><code>SELECT</code></a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\"><code>INSERT</code></a>, <a href=\"https://www.techonthenet.com/oracle/update.php\"><code>UPDATE</code></a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\"><code>DELETE</code></a> statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>WHERE</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">WHERE conditions;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>conditions - The conditions that must be met for records to be selected.</p><p><strong>The Oracle HAVING clause</strong> is used in combination with the<a href=\"https://www.techonthenet.com/oracle/group_by.php\"> <code>GROUP BY</code></a> clause to restrict the groups of returned rows to only those whose the condition is <code>TRUE</code>.</p><p><em>√&nbsp; The WHERE may be used in conjunction with the GROUP&nbsp;BY clause.</em></p><p><strong>Syntax</strong></p><p>The syntax for the <code>HAVING</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n\nHAVING having_condition;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause. </p><p>aggregate_function - It can be a function such as <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\"><code>SUM</code></a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\"><code>COUNT</code></a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\"><code>MIN</code></a>, <a href=\"https://www.techonthenet.com/oracle/functions/max.php\"><code>MAX</code></a>, or <a href=\"https://www.techonthenet.com/oracle/functions/avg.php\"><code>AVG</code></a> functions. </p><p><em>√&nbsp; The HAVING clause conditions can make use of the SUM function.</em></p><p>aggregate_expression - This is the column or expression that the <em>aggregate_function</em> will be used against. tables The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. </p><p><em>√&nbsp; The HAVING clause allows for referencing more than one table in the FROM clause.</em></p><p>WHERE conditions Optional. - These are the conditions for the records to be selected. having_condition This is a further condition applied only to the aggregated results to restrict the groups of returned rows. Only those groups whose condition evaluates to TRUE will be included in the result set.</p>",
                "answers": [
                    "<p>WHERE and HAVING clauses cannot be used together in a SQL statement.</p>",
                    "<p>The HAVING clause conditions can make use of the SUM function.</p>",
                    "<p>The HAVING clause conditions can use aliases for the columns.</p>",
                    "<p>The WHERE may be used in conjunction with the GROUP&nbsp;BY clause.</p>",
                    "<p>The HAVING clause allows for referencing more than one table in the FROM clause.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d",
                "e"
            ],
            "section": "WHERE",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the WHERE and HAVING clauses in a SQL statement. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289379,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">ALTER TABLE books_transactions\nADD&nbsp;CONSTRAINT fk_book_id FOREIGN KEY (book_id)\nREFERENCES&nbsp;books (book_id) ON&nbsp;DELETE&nbsp;CASCADE;\n</pre><p><br></p><p>Indicate the implication of the ON DELETE CASCADE command.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Foreign Keys with Cascade Delete](https://www.techonthenet.com/oracle/foreign_keys/foreign_delete.php)"
                ],
                "feedbacks": [
                    "The ON DELETE CASCADE command does not automatically drop the related table when the parent table is dropped. It only affects the rows in the related table.",
                    "The ON DELETE CASCADE command does not retain the table structure of the related table when the parent table is dropped. It only deletes the rows in the related table.",
                    "The ON DELETE CASCADE command ensures that when a row in the parent table (BOOKS) is deleted, the corresponding rows in the child table (BOOK_TRANSACTIONS) with matching foreign key values are also deleted. This maintains referential integrity in the database.",
                    "The ON DELETE CASCADE command does not update values in the related table. It only deletes the rows in the related table when the corresponding row in the parent table is deleted."
                ],
                "explanation": "<p>Let's break down what the following SQL command does:</p><pre class=\"prettyprint linenums\">ALTER TABLE books_transactions\nADD CONSTRAINT fk_book_id FOREIGN KEY (book_id)\nREFERENCES books (book_id) ON DELETE CASCADE;\n</pre><p><strong>Understanding </strong><code><strong>ON DELETE CASCADE</strong></code></p><ul><li><p>This sets up a <strong>foreign key</strong> from <code>books_transactions.book_id</code> → <code>books.book_id</code></p></li><li><p>The <code>ON DELETE CASCADE</code> clause means:</p><p><strong>If a row is deleted from the parent table (</strong><code><strong>BOOKS</strong></code><strong>), then all child rows in </strong><code><strong>BOOK_TRANSACTIONS</strong></code><strong> that reference the deleted </strong><code><strong>BOOK_ID</strong></code><strong> will also be deleted automatically.</strong></p></li></ul><p>Correct option:</p><ul><li><p>When a row in the BOOKS table is deleted, the rows in the BOOK_TRANSACTIONS table whose BOOK_ID matches that of the deleted row in the BOOKS table are also deleted.</p><ul><li><p><strong>Correct</strong> — This is the exact behavior of <code>ON DELETE CASCADE</code>.</p></li></ul></li></ul><p>Incorrect options:</p><ul><li><p>When the BOOKS table is dropped, the BOOK_TRANSACTIONS table is dropped.</p><ul><li><p><strong>Incorrect</strong> — Dropping a table does <strong>not cascade</strong> to drop other tables. You would need to <strong>explicitly drop</strong> both.</p></li></ul></li><li><p>When the BOOKS table is dropped, all the rows in the BOOK_TRANSACTIONS table are deleted but the table structure is retained.</p><ul><li><p><strong>Incorrect</strong> — Dropping a table does <strong>not trigger </strong><code><strong>ON DELETE CASCADE</strong></code>. It just removes the table. The foreign key constraint must be dropped first if it's enforced.</p></li></ul></li><li><p>When a value in the BOOKS.BOOK_ID column is deleted, the corresponding value is updated in the BOOKS_TRANSACTIONS.BOOK_ID column.</p><ul><li><p><strong>Incorrect</strong> — That describes <strong>ON DELETE SET NULL</strong> or <strong>ON UPDATE CASCADE</strong>, not <code>ON DELETE CASCADE</code>.</p></li></ul></li></ul><p><strong>A foreign key with cascade delete </strong>means that if a record in the parent table is deleted, then the corresponding records in the child table will automatically be deleted. This is called a cascade delete in Oracle.</p><p>A foreign key with a cascade delete can be defined in either a <code>CREATE TABLE</code> statement or an <code>ALTER TABLE</code> statement.</p><p><strong>Using a CREATE TABLE statement</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating a foreign key with cascade delete using a <code>CREATE TABLE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE TABLE table_name\n(\n  column1 datatype null/not null,\n  column2 datatype null/not null,\n  ...\n\n  CONSTRAINT fk_column\n     FOREIGN KEY (column1, column2, ... column_n)\n     REFERENCES parent_table (column1, column2, ... column_n)\n     ON DELETE CASCADE\n);</pre><p><br></p><p><strong>Using an ALTER TABLE statement</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating a foreign key with cascade delete in an <code>ALTER TABLE</code> statement in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ALTER TABLE table_name\nADD CONSTRAINT constraint_name\n   FOREIGN KEY (column1, column2, ... column_n)\n   REFERENCES parent_table (column1, column2, ... column_n)\n   ON DELETE CASCADE;</pre><p><br></p><p><em>√&nbsp; When a row in the BOOKS table is deleted, the rows in the BOOK_TRANSACTIONS table whose BOOK_ID matches that of the deleted row in the BOOKS table are also deleted.</em></p>",
                "answers": [
                    "<p>When the BOOKS table is dropped, the BOOK_TRANSACTIONS table is dropped.</p>",
                    "<p>When the BOOKS table is dropped, all the rows in the BOOK_TRANSACTIONS table are deleted but the table structure is retained.</p>",
                    "<p>When a row in the BOOKS table is deleted, the rows in the BOOK_TRANSACTIONS table whose BOOK_ID matches that of the deleted row in the BOOKS table are also deleted.</p>",
                    "<p>When a value in the BOOKS.BOOK_ID column is deleted, the corresponding value is updated in the BOOKS_TRANSACTIONS.BOOK_ID column.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Foreign Keys",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1 ALTER TABLE books_transactions\nADD&nbsp;CONSTRAINT fk_book_id FOREIGN KEY (book_id)\nREFERENCES&nbsp;books (book_id) ON&nbsp;DELETE&nbsp;CASCADE;\nIndicate the implication of the ON DELETE CASCADE command.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289381,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the task which cannot be performed by using a Data Manipulation Language (DML) statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[About the UPDATE Statement](https://docs.oracle.com/database/121/TDDDG/tdddg_dml.htm#TDDDG23200)",
                    "[Data Manipulation Language](https://www.educba.com/data-manipulation-language/)",
                    "[Types of SQL Statements](https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm)"
                ],
                "feedbacks": [
                    "The SELECT statement is used to retrieve data from a database table based on specified criteria. It is a query language statement and falls under the Data Query Language (DQL) category, not Data Manipulation Language (DML).",
                    "The INSERT statement is used to add new rows of data into a database table. It is a DML statement that allows for the insertion of data into a table.",
                    "The DELETE statement is used to remove rows of data from a database table based on specified conditions. It is a DML statement that allows for the deletion of data from a table.",
                    "The UPDATE statement is used to modify existing data in a database table based on specified conditions. It is a DML statement that allows for the updating of data in a table.",
                    "The MERGE statement is used to perform insert, update, or delete operations on a target table based on the results of a join with a source table. It is a DML statement that allows for the merging of data from two tables.",
                    "The DROP TABLE statement is used to remove an entire table from the database. It is a Data Definition Language (DDL) statement and cannot be performed using a Data Manipulation Language (DML) statement."
                ],
                "explanation": "<p><strong>Correct Answer: </strong><code><strong><em>DROP TABLE [table_name]</em></strong></code></p><ul><li><p>It is a <strong>DDL</strong>, not a <strong>DML</strong>, operation.</p></li></ul><p>To answer this question, we need to distinguish between <strong>DML (Data Manipulation Language)</strong> and <strong>other types of SQL statements</strong>, such as <strong>DDL (Data Definition Language)</strong>.</p><p><strong>DML Statements (What They Do):</strong></p><p>DML is used to <strong>manipulate data</strong> in existing tables. Common DML statements include:</p><ul><li><p><code>SELECT</code> – retrieves data</p></li><li><p><code>INSERT</code> – adds new rows</p></li><li><p><code>UPDATE</code> – modifies existing rows</p></li><li><p><code>DELETE</code> – removes existing rows</p></li><li><p><code>MERGE</code> – conditionally inserts, updates, or deletes data</p></li></ul><p><strong>Not a DML Statement:</strong></p><ul><li><p><code>DROP TABLE [table_name]</code><br><strong>This is a DDL (Data Definition Language)</strong> statement.<br>It modifies the <strong>structure</strong> of the database by removing the table itself — not data <strong>within</strong> the table.</p></li></ul><p>Other Statements (Are DML):</p><ul><li><p><code>SELECT [column_name(s)] FROM [table_name] WHERE [condition]</code> –&nbsp; DML (data retrieval)</p></li><li><p><code>INSERT INTO [table_name] VALUES (...)</code> –&nbsp; DML (insert data)</p></li><li><p><code>DELETE FROM [table_name]</code> –&nbsp; DML (delete data)</p></li><li><p><code>UPDATE [table_name] SET ... WHERE ...</code> –&nbsp; DML (update data)</p></li><li><p><code>MERGE INTO ... USING ... ON (...)</code> –&nbsp; DML (merge/update/insert/delete in one go)</p></li></ul><p><br></p><p><strong>Data manipulation language (DML) statements</strong> access and manipulate data in existing tables.</p><p><strong>Some of the commonly used DML commands</strong></p><p>1. <code>SELECT</code></p><p><code>SELECT</code> Command is used to retrieve the records from the table. It is one of the most commonly used commands while working with the databases because at the end-user wants to retrieve the results after any operation be it update, delete or modify.</p><p><strong>Syntax:</strong> <code>SELECT [column_name(s)] from [table_name] where [condition]</code></p><p>2. <code>INSERT</code></p><p><code>INSERT</code> command is used for the insertion of one or more records in the table.</p><p><strong>Syntax:</strong> <code>INSERT into [table_name] values (val1, val2, val3, …)</code></p><p>If we want to insert the data on particular columns, column names need to be specified in the SQL command.</p><p><strong>Syntax:</strong> <code>INSERT into [table_name] (col1, col2, col3, …) values (val1, val2, val3, …)</code></p><p>3. <code>DELETE</code></p><p><code>DELETE</code> command is used to delete one or more records from the table on the basis of the where condition specified in the command.</p><p><strong>Syntax:</strong> <code>DELETE from [table_name] where [condition to be specified]</code></p><p>If where the condition is not specified in the SQL command with DELETE, the whole table will get deleted.</p><p><strong>Syntax:</strong> <code>DELETE from [table_name]</code></p><p>4. <code>UPDATE</code></p><p><code>UPDATE</code> command is used for the modification of one or more records in the existing table.</p><p><strong>Syntax:</strong> <code>UPDATE [table_name] SET [col1 = val1, col2 = val2,...] where [condition to be specified]</code></p><p>5. <code>MERGE</code></p><p><code>MERGE</code> command is a combination of <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>. When two tables (source table and the target table) need to be merged then all the above mentioned three operations are performed all together using the MERGE command.</p><p><strong>Data definition language (DDL) statements</strong> let you to perform these tasks:</p><p>• Create, alter, and drop schema objects</p><p>• Grant and revoke privileges and roles</p><p>• Analyze information on a table, index, or cluster</p><p>• Establish auditing options</p><p>• Add comments to the data dictionary</p><p><em>√ DROP TABLE [table_name] - this is a DDL statement, not DML</em></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_15-41-38-21e4e2cf1a93d1195c456022e261e08b.png\"></p>",
                "answers": [
                    "<p><code>SELECT [column_name(s)] from [table_name] where [condition]</code> </p>",
                    "<p><code>INSERT into [table_name] values (val1, val2, val3, …)</code> </p>",
                    "<p><code>DELETE from [table_name]</code> </p>",
                    "<p><code>UPDATE [table_name] SET [col1 = val1, col2 = val2,...] where [condition to be specified]</code> </p>",
                    "<p><code>MERGE INTO [table_name1] USING [table_name2] ON (col1 = val1)</code> </p>",
                    "<p><code>DROP TABLE [table_name]</code> </p>"
                ]
            },
            "correct_response": [
                "f"
            ],
            "section": "Data Manipulation Language",
            "question_plain": "View and examine the following available responses.Identify the task which cannot be performed by using a Data Manipulation Language (DML) statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289383,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Given: </strong>The following command has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE&nbsp;hr.employees;\n</pre><p><br></p><p>Indicate the true statements regarding the result. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: DROP TABLE Statement](https://www.techonthenet.com/oracle/tables/drop_table.php)",
                    "[DROP TABLE](https://docs.oracle.com/cd/B28359_01/server.111/b28310/tables010.htm#ADMIN01505)"
                ],
                "feedbacks": [
                    "All constraints defined on the HR.EMPLOYEES table are dropped because dropping a table also drops all associated constraints, such as primary key, foreign key, unique, and check constraints.",
                    "The HR.EMPLOYEES table may be moved to the recycle bin, which is a logical container for objects that have been dropped. The table can be recovered from the recycle bin if needed.",
                    "All indexes defined on the HR.EMPLOYEES table are dropped when the table is dropped. Indexes are dependent objects of a table and are automatically removed when the table is dropped.",
                    "Views referencing the HR.EMPLOYEES table are not automatically dropped when the table is dropped. Views are separate database objects and must be explicitly dropped if they are no longer needed.",
                    "Sequences used to populate columns in the HR.EMPLOYEES table are not automatically dropped when the table is dropped. Sequences are independent objects and must be explicitly dropped if they are no longer needed.",
                    "Synonyms for the HR.EMPLOYEES table are not automatically dropped when the table is dropped. Synonyms are separate database objects and must be explicitly dropped if they are no longer needed."
                ],
                "explanation": "<p>Let's break down the effects of the following command:</p><pre class=\"prettyprint linenums\">DROP TABLE hr.employees;\n</pre><p>This command <strong>drops the HR.EMPLOYEES table</strong>, and we are asked to identify <strong>three true statements</strong> about what happens as a result.</p><p><strong>True Statements:</strong></p><p>1. <strong>All constraints defined on HR.EMPLOYEES are dropped.</strong></p><ul><li><p>Constraints (primary key, foreign keys, check constraints, etc.) defined <strong>on</strong> the table are part of the table’s metadata and are dropped when the table is dropped.</p></li></ul><p>2. <strong>The HR.EMPLOYEES table may be moved to the recycle bin.</strong></p><ul><li><p>In Oracle, when a table is dropped, it's <strong>logically moved to the recycle bin</strong> (if enabled), unless:</p><ul><li><p>The table is in a <strong>tablespace with </strong><code><strong>RECYCLEBIN = OFF</strong></code></p></li><li><p>The user issues <code>DROP TABLE ... PURGE</code></p></li><li><p>The recycle bin is disabled entirely</p></li></ul></li></ul><p>3. <strong>All indexes defined on HR.EMPLOYEES are dropped.</strong></p><ul><li><p>Indexes defined on the table are <strong>automatically dropped</strong> when the table is dropped, because they are dependent on it.</p></li></ul><p><strong>False Statements:</strong></p><ul><li><p><strong>Views referencing HR.EMPLOYEES are dropped.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Views <strong>are not dropped</strong>, but they become <strong>invalid</strong>. They remain in the database and must be recompiled if the underlying table is recreated.</p></li></ul></li></ul><ul><li><p><strong>Sequences used to populate columns in the HR.EMPLOYEES table are dropped.</strong></p><ul><li><p> <strong>False</strong></p></li><li><p>Sequences are <strong>independent schema objects</strong>. Dropping the table does <strong>not</strong> affect sequences, even if they were used with the table.</p></li></ul></li></ul><ul><li><p><strong>Synonyms for HR.EMPLOYEES are dropped.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Synonyms are also <strong>independent</strong> objects. Dropping the base table does <strong>not drop</strong> the synonym, but it will become <strong>invalid</strong>.</p></li></ul></li></ul><p><br></p><p>The Oracle <strong>DROP TABLE statement</strong> allows you to remove or delete a table from the Oracle database.</p><p><strong>Syntax</strong></p><p>The syntax for the Oracle <strong>DROP TABLE statement</strong> is:</p><pre class=\"prettyprint linenums\">DROP TABLE [schema_name].table_name\n[ CASCADE CONSTRAINTS ]\n[ PURGE ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>schema_name - The name of the schema that owns the table. </p><p>table_name - The name of the table to remove from the Oracle database. </p><p>CASCADE CONSTRAINTS Optional. - If specified, all referential integrity constraints will be dropped as well. </p><p>PURGE Optional. - If specified, the table and its dependent objects will be purged from the recycle bin and you will not be able to recover the table. If not specified, the table and its dependent objects are placed in the recycle bin and can be recovered later, if needed.</p><p><strong><em>Note: </em></strong><em>If there are referential integrity constraints on table_name and you do not specify the </em><code><em>CASCADE CONSTRAINTS</em></code><em> option, the </em><code><em>DROP TABLE</em></code><em> statement will return an error and Oracle will not drop the table.</em></p><p>Dropping a table invalidates dependent objects and removes object privileges on the table. If you want to re-create the table, then you must regrant object privileges on the table, re-create the indexes, integrity constraints, and triggers for the table, and respecify its storage parameters. Truncating has none of these effects. Therefore, removing rows with the <code>TRUNCATE</code> statement can be more efficient than dropping and re-creating a table.</p><p><em>√&nbsp; All constraints defined on HR.EMPLOYEES are dropped.</em></p><p><em>√&nbsp; All indexes defined on HR.EMPLOYEES are dropped.</em></p><p>When you drop a table, normally the database does not immediately release the space associated with the table. Rather, the database renames the table and places it in a recycle bin, where it can later be recovered with the <code>FLASHBACK TABLE</code> statement.</p><p><em>√ The HR.EMPLOYEES table may be moved to the recycle bin.</em></p>",
                "answers": [
                    "<p>Views referencing HR.EMPLOYEES are dropped.</p>",
                    "<p>All constraints defined on HR.EMPLOYEES are dropped.</p>",
                    "<p>Sequences used to populate columns in the HR.EMPLOYEES table are dropped.</p>",
                    "<p>The HR.EMPLOYEES table may be moved to the recycle bin.</p>",
                    "<p>All indexes defined on HR.EMPLOYEES are dropped.</p>",
                    "<p>Synonyms for HR.EMPLOYEES are dropped.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d",
                "e"
            ],
            "section": "DROP TABLE",
            "question_plain": "View and examine the following SQL exhibit.Given: The following command has been executed.Exhibit: 1DROP&nbsp;TABLE&nbsp;hr.employees;\nIndicate the true statements regarding the result. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289385,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the EMPLOYEES table. </p><p><strong>Table: EMPLOYEES </strong></p><pre class=\"prettyprint linenums\">Name                      Null??            Type\nEMP_ID                    NOT NULL          NUMBER\nEMP_NAME                                    VARCHAR2(40)\nDEPT_ID                                     NUMBER(2)\nSALARY                                      NUMBER(8,2)\nJOIN_DATE                                   DATE\n</pre><p><br></p><p>Identify the valid SQL query.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[GROUPING](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/GROUPING.html)",
                    "[Aggregate Functions](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Aggregate-Functions.html)"
                ],
                "feedbacks": [
                    "This query correctly selects the department ID and the sum of salaries from the EMPLOYEES table, groups the results by department ID, filters the results by the sum of salaries being greater than or equal to 100, and then orders the results by salary in descending order. The HAVING clause is used to filter aggregated results.",
                    "This query includes the department ID, join date, and sum of salaries in the SELECT statement, but it incorrectly uses the HAVING clause to filter based on the SALARY alias instead of the SUM(salary) aggregate function. This will result in a syntax error as the SALARY alias is not recognized in the HAVING clause.",
                    "This query includes the department ID, join date, and sum of salaries in the SELECT statement, groups the results by department ID, filters the results by the sum of salaries being greater than or equal to 100, and then orders the results by salary in descending order. The HAVING clause correctly filters aggregated results.",
                    "This query correctly selects the department ID and the sum of salaries from the EMPLOYEES table, groups the results by department ID, orders the results by salary in descending order, and then filters the results by the sum of salaries being greater than or equal to 100. The HAVING clause is used to filter aggregated results, but it should be placed before the ORDER BY clause.",
                    "This query attempts to group the results by the condition SUM(salary) &gt;= 100, which is not a valid grouping expression. The GROUP BY clause should specify the columns used for grouping, not a condition. This query will result in a syntax error."
                ],
                "explanation": "<p>Correct query:</p><pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;\n</pre><ul><li><p><strong>Valid</strong> – This query:</p><ul><li><p>Selects the total salary per <code>dept_id</code></p></li><li><p>Uses <code>GROUP BY dept_id</code></p></li><li><p>Uses <code>HAVING SUM(salary) &gt;= 100</code> (correct usage of aggregate function in <code>HAVING</code>)</p></li><li><p>Orders the result by the alias <code>SALARY</code> in descending order</p></li></ul></li><li><p><strong>This is syntactically and logically correct.</strong></p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_18-22-41-d9a0cb664b0e037dca617c7b88d1dcb9.png\"></p><p><br></p><p>The correct query order is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\n[GROUP BY expression1, expression2, ... expression_n]\n[HAVING having_conditions]\n[ORDER BY expression1, expression2, ... expression_n [ ASC | DESC ];</pre><p><br></p><p><strong>Invalid Queries:</strong></p><pre class=\"prettyprint linenums\">SELECT dept_id, join_date, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SALARY &gt;= 100 \nORDER BY SALARY DESC;\n</pre><ul><li><p><strong>Invalid</strong> – <code>join_date</code> is <strong>not included</strong> in the <code>GROUP BY</code> clause. Also, <code>SALARY</code> alias in <code>HAVING</code> is <strong>not recognized</strong>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT dept_id, join_date, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;\n</pre><ul><li><p><strong>Invalid</strong> – Again, <code>join_date</code> is selected but <strong>not grouped</strong>, causing an error. All <strong>non-aggregated columns</strong> in the <code>SELECT</code> must appear in the <code>GROUP BY</code>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nORDER BY SALARY DESC\nHAVING SUM(salary) &gt;= 100;\n</pre><ul><li><p><strong>Invalid</strong> – <code>HAVING</code> <strong>must come before</strong> <code>ORDER BY</code> in SQL syntax. The clause order is wrong.</p></li></ul><pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;\n</pre><ul><li><p><strong>Invalid</strong> – <code>GROUP BY</code> must use <strong>column names</strong>, <strong>not aggregate functions</strong> like <code>SUM()</code>.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT dept_id, join_date, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SALARY &gt;= 100 \nORDER BY SALARY DESC;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT dept_id, join_date, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nHAVING SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY dept_id\nORDER BY SALARY DESC\nHAVING SUM(salary) &gt;= 100;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT dept_id, SUM(salary) SALARY\nFROM employees\nGROUP BY SUM(salary) &gt;= 100 \nORDER BY SALARY DESC;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "GROUPING",
            "question_plain": "View and examine the structure of the EMPLOYEES table. Table: EMPLOYEES Name                      Null??            Type\nEMP_ID                    NOT NULL          NUMBER\nEMP_NAME                                    VARCHAR2(40)\nDEPT_ID                                     NUMBER(2)\nSALARY                                      NUMBER(8,2)\nJOIN_DATE                                   DATE\nIdentify the valid SQL query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289387,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement about Data Manipulation Language (DML).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[About the UPDATE Statement](https://docs.oracle.com/database/121/TDDDG/tdddg_dml.htm#TDDDG23200)",
                    "[Data Manipulation Language](https://www.educba.com/data-manipulation-language/)",
                    "[Types of SQL Statements](https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm)"
                ],
                "feedbacks": [
                    "This statement is incorrect. DML operations do not automatically disable foreign key constraints when modifying primary key values in the parent table. Foreign key constraints are typically enforced to maintain referential integrity in the database.",
                    "By default, each DML statement forms a transaction in Oracle Database. This means that each DML operation is treated as a single unit of work that is either fully completed or fully rolled back in case of an error or failure.",
                    "This statement is correct. A transaction in Oracle Database can consist of one or more DML statements. This allows multiple DML operations to be grouped together as a single logical unit of work that is either committed or rolled back as a whole.",
                    "This statement is incorrect. DML operations do not automatically disable foreign key constraints when deleting primary key values in the parent table, even when the ON DELETE CASCADE option is set for the foreign key constraint. Foreign key constraints are enforced to maintain data integrity and are not automatically disabled during DML operations."
                ],
                "explanation": "<p>Correct Statement:&nbsp; <strong>\"A transaction can consist of one or more DML statements.\"</strong></p><ul><li><p>In Oracle (and most RDBMS), a <strong>transaction</strong> is a logical unit of work that can include <strong>one or more DML statements</strong> (e.g., multiple <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements).</p></li><li><p>A transaction ends with a <code>COMMIT</code> or <code>ROLLBACK</code>.</p></li></ul><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>DML automatically disables foreign key constraints when modifying primary key values in the parent table.</strong></p><ul><li><p><strong>False</strong></p></li><li><p><strong>Foreign key constraints are not automatically disabled.</strong></p></li><li><p>Trying to update or delete a <strong>referenced primary key</strong> without handling constraints properly will result in an <strong>error</strong> unless:</p><ul><li><p><code>ON DELETE CASCADE</code> or</p></li><li><p><code>ON DELETE SET NULL</code> is explicitly defined.</p></li></ul></li></ul></li></ul><ul><li><p><strong>Each DML statement forms a transaction by default.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>A <strong>DML statement does not automatically commit.</strong></p></li><li><p>Multiple DML statements can be part of <strong>one transaction</strong> until an explicit <code>COMMIT</code> or <code>ROLLBACK</code> is issued.</p></li></ul></li></ul><ul><li><p><strong>DML disables foreign key constraints when deleting primary key values in the parent table, only when the ON DELETE CASCADE option is set for the foreign key constraint.</strong></p><ul><li><p><strong>False</strong></p></li><li><p>DML <strong>does not disable</strong> constraints.</p></li><li><p><code>ON DELETE CASCADE</code> ensures <strong>dependent rows are deleted</strong>, but the constraint itself remains <strong>active</strong>. It simply defines the <strong>behavior</strong> of the constraint.</p></li></ul></li></ul><p><br></p><p><strong>Data manipulation language (DML) statements</strong> access and manipulate data in existing tables.</p><p><strong>Some of the commonly used DML commands</strong></p><p>1. <code>SELECT</code></p><p><code>SELECT</code> Command is used to retrieve the records from the table. It is one of the most commonly used commands while working with the databases because at the end-user wants to retrieve the results after any operation be it update, delete or modify.</p><p><strong>Syntax:</strong> <code>SELECT [column_name(s)] from [table_name] where [condition]</code></p><p>2. <code>INSERT</code></p><p><code>INSERT</code> command is used for the insertion of one or more records in the table.</p><p><strong>Syntax:</strong> <code>INSERT into [table_name] values (val1, val2, val3, …)</code></p><p>If we want to insert the data on particular columns, column names need to be specified in the SQL command.</p><p><strong>Syntax:</strong> <code>INSERT into [table_name] (col1, col2, col3, …) values (val1, val2, val3, …)</code></p><p>3. <code>DELETE</code></p><p><code>DELETE</code> command is used to delete one or more records from the table on the basis of the where condition specified in the command.</p><p><strong>Syntax:</strong> <code>DELETE from [table_name] where [condition to be specified]</code></p><p>If where the condition is not specified in the SQL command with DELETE, the whole table will get deleted.</p><p><strong>Syntax:</strong> <code>DELETE from [table_name]</code></p><p>4. <code>UPDATE</code></p><p><code>UPDATE</code> command is used for the modification of one or more records in the existing table.</p><p><strong>Syntax:</strong> <code>UPDATE [table_name] SET [col1 = val1, col2 = val2,...] where [condition to be specified]</code></p><p>5. <code>MERGE</code></p><p><code>MERGE</code> command is a combination of <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>. When two tables (source table and the target table) need to be merged then all the above mentioned three operations are performed all together using the <code>MERGE</code> command.</p><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. Typically, you can use a subquery anywhere that you use an expression.</p><p><em>√&nbsp; A transaction can consist of one or more DML statements.</em></p><p><strong>Oracle evaluates the whole query above in two steps:</strong></p><p>• First, execute the subquery.</p><p>• Second, use the result of the subquery in the outer query.</p><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>.</p><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\">https://www.oracletutorial.com/oracle-basics/oracle-subquery/</a></p><p><br></p><p><strong>Data definition language (DDL) statements</strong> let you to perform these tasks:</p><p>• Create, alter, and drop schema objects</p><p>• Grant and revoke privileges and roles</p><p>• Analyze information on a table, index, or cluster</p><p>• Establish auditing options</p><p>• Add comments to the data dictionary</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_15-41-38-21e4e2cf1a93d1195c456022e261e08b.png\"></p><p><br></p><p><strong>Data definition language (DDL) statements that define or modify database objects.</strong></p><p><code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Syntax\"><code>ALTER EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-procedure.html\" title=\"13.1.5&nbsp;ALTER PROCEDURE Syntax\"><code>ALTER PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-server.html\" title=\"13.1.6&nbsp;ALTER SERVER Syntax\"><code>ALTER SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/alter-table.html\" title=\"13.1.7&nbsp;ALTER TABLE Syntax\"><code>ALTER TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-database.html\" title=\"13.1.10&nbsp;CREATE DATABASE Syntax\"><code>CREATE DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-event.html\" title=\"13.1.11&nbsp;CREATE EVENT Syntax\"><code>CREATE EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-index.html\" title=\"13.1.13&nbsp;CREATE INDEX Syntax\"><code>CREATE INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-procedure.html\" title=\"13.1.15&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax\"><code>CREATE PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-server.html\" title=\"13.1.16&nbsp;CREATE SERVER Syntax\"><code>CREATE SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/create-table.html\" title=\"13.1.17&nbsp;CREATE TABLE Syntax\"><code>CREATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-database.html\" title=\"13.1.21&nbsp;DROP DATABASE Syntax\"><code>DROP DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-event.html\" title=\"13.1.22&nbsp;DROP EVENT Syntax\"><code>DROP EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-index.html\" title=\"13.1.24&nbsp;DROP INDEX Syntax\"><code>DROP INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-procedure.html\" title=\"13.1.26&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax\"><code>DROP PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-server.html\" title=\"13.1.27&nbsp;DROP SERVER Syntax\"><code>DROP SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/drop-table.html\" title=\"13.1.28&nbsp;DROP TABLE Syntax\"><code>DROP TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/rename-table.html\" title=\"13.1.33&nbsp;RENAME TABLE Syntax\"><code>RENAME TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/truncate-table.html\" title=\"13.1.34&nbsp;TRUNCATE TABLE Syntax\"><code>TRUNCATE TABLE</code></a>.</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/implicit-commit.html\">https://docs.oracle.com/cd/E17952_01/mysql-5.1-en/implicit-commit.html</a></p>",
                "answers": [
                    "<p>DML automatically disables foreign ley constraints when modifying primary key values in the parent table.</p>",
                    "<p>Each DML statement forms a transaction by default.</p>",
                    "<p>A transaction can consist of one or more DML statements.</p>",
                    "<p>DML disables foreign key constraints when deleting primary key values in the parent table, only when the ON DELETE CASCADE option is set for the foreign key constraint.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Data Manipulation Language",
            "question_plain": "View and examine the following available responses.Identify the true statement about Data Manipulation Language (DML).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289389,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given:</strong> The columns PROD_ID and QUANTITY_SOLD in the SALES table are NUMBER data type. </p><p>Identify the valid SQL queries. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: COUNT Function](https://www.techonthenet.com/oracle/functions/count.php)",
                    "[Oracle / PLSQL: BETWEEN Condition](https://www.techonthenet.com/oracle/between.php)",
                    "[Oracle / PLSQL: GROUP BY Clause](https://www.techonthenet.com/oracle/group_by.php)"
                ],
                "feedbacks": [
                    "This query selects the columns prod_id, quantity_sold, and cust_id from the SALES table where the quantity_sold is between 10000 and 75000. It then orders the results by quantity_sold in descending order. The syntax and conditions used in the query are valid and applicable for the given scenario.",
                    "This query selects the columns prod_id, quantity_sold, and also calculates the count of quantity_sold within the range of 10000 and 75000 from the SALES table. It groups the results by prod_id and quantity_sold. The syntax and aggregation function used in the query are valid for the given scenario.",
                    "This query selects the columns prod_id, quantity_sold, and calculates the count of quantity_sold within the range of 10000 and 75000 from the SALES table. It groups the results by prod_id only. The syntax is correct, but the grouping by quantity_sold without an aggregation function is not valid.",
                    "This query selects the columns prod_id, quantity_sold, and cust_id from the SALES table where the quantity_sold is between 10000 and 75000. The syntax used for the BETWEEN clause is correct, but the usage of IS BETWEEN is invalid in SQL syntax.",
                    "This query selects the columns prod_id, quantity_sold, and cust_id from the SALES table where the quantity_sold is greater than 10000 and less than 75000. The syntax used for the WHERE clause is incorrect as it should specify the column name after each comparison operator.",
                    "This query selects the columns prod_id and quantity_sold, and renames quantity_sold as \"IN RANGE\" from the SALES table where the quantity_sold is between 10000 and 75000. It then groups the results by prod_id and the count of quantity_sold. The syntax is partially correct, but the grouping by COUNT(quantity_sold) is not valid in this context."
                ],
                "explanation": "<p><strong>Correct Queries</strong></p><p><strong>1.</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nORDER BY quantity_sold DESC;\n</pre><ul><li><p><code>BETWEEN</code> is used correctly.</p></li><li><p>Columns in <code>SELECT</code> are either grouped or not aggregated — and this is a plain <code>SELECT</code>, so it's fine.</p></li><li><p><code>ORDER BY</code> clause is valid.</p></li></ul><p><strong>2.</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, COUNT(quantity_sold) AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id, quantity_sold;\n</pre><ul><li><p><code>GROUP BY</code> includes all non-aggregated selected columns.</p></li><li><p><code>COUNT(quantity_sold)</code> is a valid aggregate function.</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_19-53-39-347d241495429c0a061bab121353887d.png\"></p><p><br></p><p><strong>Incorrect Queries</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, COUNT(quantity_sold) AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id;\n</pre><ul><li><p><code>quantity_sold</code> is in the <code>SELECT</code> list but <strong>not in the </strong><code><strong>GROUP BY</strong></code><strong> clause</strong> and <strong>not an aggregate function</strong>.</p></li><li><p>This will cause <strong>ORA-00979: not a GROUP BY expression</strong>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold IS BETWEEN 10000 AND 75000\nORDER BY quantity_sold DESC;\n</pre><ul><li><p>Syntax error: <code>IS BETWEEN</code> is <strong>invalid</strong>.</p></li><li><p>Correct syntax: <code>quantity_sold BETWEEN 10000 AND 75000</code>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold &gt; 10000 AND &lt; 75000\nORDER BY quantity_sold DESC;\n</pre><ul><li><p>Invalid condition: <code>AND &lt; 75000</code> is incorrect.</p></li><li><p>Must be: <code>quantity_sold &gt; 10000 AND quantity_sold &lt; 75000</code>.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id, COUNT(quantity_sold);\n</pre><ul><li><p>Invalid <code>GROUP BY</code>: can't use <code>COUNT()</code> in <code>GROUP BY</code>.</p></li><li><p>Aggregate functions are <strong>not allowed</strong> in <code>GROUP BY</code>.</p></li></ul><p><br></p><p><strong>The Oracle BETWEEN condition</strong> is used to retrieve values within a range in a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>BETWEEN</code> condition in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">expression BETWEEN value1 AND value2;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - A column or calculation. value1 and value2 Two values that create an inclusive range that <em>expression</em> is compared to.</p><p><strong>Note</strong></p><p>The Oracle <code>BETWEEN</code> condition will return the records where <em>expression</em> is within the range of <em>value1</em> and <em>value2</em> (inclusive).</p><p><br></p><p><br></p><p><strong>The Oracle/PLSQL COUNT function</strong> returns the count of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>COUNT</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>COUNT</code> function when grouping the results by one or more columns is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the <code>COUNT</code> function and must be included in the <code>GROUP BY</code> clause at the end of the SQL statement. </p><p>aggregate_expression - This is the column or expression whose non-null values will be counted. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>COUNT</code> function returns a numeric value.</p><p><br></p><p><br></p><p><strong>The Oracle GROUP BY clause</strong> is used in a<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statement</a> to collect data across multiple records and group the results by one or more columns.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>GROUP BY</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - The expressions that are not encapsulated within an aggregate function and must be included in the <code>GROUP BY</code> clause. aggregate_function It can be a function such as <code>SUM</code>, <code>COUNT</code>, <code>MIN</code>, <code>MAX</code>, or <code>AVG</code> functions. aggregate_expression This is the column or expression that the <em>aggregate_function</em> will be used on. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected.</p><p><br></p><p>The correct query order is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n, \n       aggregate_function (aggregate_expression)\nFROM tables\n[WHERE conditions]\n[GROUP BY expression1, expression2, ... expression_n]\n[HAVING having_conditions]\n[ORDER BY expression1, expression2, ... expression_n [ ASC | DESC ]];</pre>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nORDER BY quantity_sold DESC;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, COUNT(quantity_sold) AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id, quantity_sold;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, COUNT(quantity_sold) AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold IS BETWEEN 10000 AND 75000\nORDER BY quantity_sold DESC;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold, cust_id\nFROM sales\nWHERE quantity_sold &gt; 10000 AND &lt; 75000\nORDER BY quantity_sold DESC;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, quantity_sold AS \"IN RANGE\"\nFROM sales\nWHERE quantity_sold BETWEEN 10000 AND 75000\nGROUP BY prod_id, COUNT(quantity_sold);</pre>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "COUNT",
            "question_plain": "View and examine the following available responses.Given: The columns PROD_ID and QUANTITY_SOLD in the SALES table are NUMBER data type. Identify the valid SQL queries. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289371,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine PRODUCTS and SALES tables as well as the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_16-50-42-2f48ce5b4a42461922afcd500c3cdacf.png\"></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_16-50-22-448fd9d87f4771a7b495144972c5a306.png\"></p><p><br></p><p><strong>Given: </strong>The following query is intended to to display product name the number of times the product has been sold.</p><p><strong>Exhibit: 1 &nbsp;</strong></p><pre class=\"prettyprint linenums\">SELECT p.prod_name, i.quantity_sold\nFROM (\n  SELECT prod_id, COUNT(*) quantity_sold\n  FROM sales\n  GROUP BY prod_id\n) i\nRIGHT OUTER JOIN products p\nON i.prod_id = p.prod_id;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: COUNT Function](https://www.techonthenet.com/oracle/functions/count.php)",
                    "[What is Encapsulation in Java?](http://ecomputernotes.com/java/what-is-java/encapsulation-in-java)"
                ],
                "feedbacks": [
                    "The statement executes successfully and produces the required output because the subquery in the FROM clause is valid and the outer query correctly uses the GROUP BY clause to display the product name and the number of times it has been sold.",
                    "This statement is incorrect because there is no issue with using a subquery in the FROM clause and outer-joins together. The query can still execute successfully with this combination.",
                    "This statement is incorrect as the GROUP BY clause can be used in a subquery in the FROM clause. It is a valid SQL syntax and does not cause an error in this context.",
                    "This statement is incorrect because QUANTITY_SOLD can be displayed in the outer query. There is no restriction on displaying this column in the result set based on the provided information.",
                    "This statement is incorrect because if the query executes successfully, it should produce the required output as intended. If the output is not as expected, there may be a different issue causing the discrepancy."
                ],
                "explanation": "<p>The correct answer is:&nbsp; <strong>The statement executes successfully and produces the required output.</strong></p><p>Query break down and the logic behind it:</p><p><strong>Exhibit: 1 &nbsp;</strong></p><pre class=\"prettyprint linenums\">SELECT p.prod_name, i.quantity_sold\nFROM (\n  SELECT prod_id, COUNT(*) quantity_sold\n  FROM sales\n  GROUP BY prod_id\n) i\nRIGHT OUTER JOIN products p\nON i.prod_id = p.prod_id;\n</pre><p>Step-by-step explanation:</p><ul><li><p>The <strong>inner subquery (</strong><code><strong>i</strong></code><strong>)</strong>:</p><pre class=\"prettyprint linenums\">SELECT prod_id, COUNT(*) quantity_sold\nFROM sales\nGROUP BY prod_id\n</pre><p>This groups the <code>sales</code> table by <code>prod_id</code> and counts how many times each product was sold. This gives you one row per product that was sold.</p></li><li><p>The <strong>RIGHT OUTER JOIN</strong>:</p><pre class=\"prettyprint linenums\">RIGHT OUTER JOIN products p ON i.prod_id = p.prod_id\n</pre><p>This ensures <strong>all products</strong> are returned, even if they weren't sold (i.e., no matching entry in <code>sales</code>).</p></li><li><p>The <strong>main SELECT</strong>:</p><pre class=\"prettyprint linenums\">SELECT p.prod_name, i.quantity_sold\n</pre><p>This selects the product name and how many times it was sold. If a product wasn’t sold at all, <code>i.quantity_sold</code> will be <code>NULL</code>.</p></li></ul><p>Result:</p><ul><li><p>The query will return <strong>all products</strong> and the <strong>number of times each was sold</strong> (or <code>NULL</code> if never sold).</p></li><li><p>So, <strong>it executes successfully and produces the required output.</strong></p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-04_11-54-07-c38faff35123facee872e0d43234e192.png\"></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_20-55-54-0b5203cc648abf19310b01ba575da9b1.png\"></p><p><br></p><p>Other Options - Why They Are Wrong:</p><ul><li><p><em>\"The statement produces an error because a subquery in the FROM clause and outer-joins cannot be used together.\"</em><br>→ Not true. Subqueries in the <code>FROM</code> clause (inline views) are commonly used with joins, including outer joins.</p></li><li><p><em>\"The statement produces an error because the GROUP BY clause cannot be used in a subquery in the FROM clause.\"</em><br>→ Also false. Using <code>GROUP BY</code> in a subquery is perfectly valid.</p></li><li><p><em>\"The statement produces an error because QUANTITY_SOLD cannot be displayed in the outer query.\"</em><br>→ Incorrect. <code>quantity_sold</code> is a valid alias from the subquery and can be used in the outer query.</p></li><li><p><em>\"The statement executes successfully but does not produce the required output.\"</em><br>→ Not true. The output matches the requirement: product name and number of times sold.</p></li></ul><p><strong>The Oracle/PLSQL COUNT</strong> function returns the count of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>COUNT</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>COUNT</code> function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       COUNT(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - <strong>Expressions that are not encapsulated within the COUNT function and must be included in the GROUP BY clause at the end of the SQL statement.</strong> </p><p>aggregate_expression - This is the column or expression whose non-null values will be counted. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The COUNT function returns a numeric value.</p><p><strong>Encapsulation</strong> refers to the ability to package related behaviour in an object bundle and control or restrict their access in both function and data from other objects. It necessarily is all about packaging related stuff together and keeping them away from external elements.</p><p>Encapsulation binds fields and its associated methods into a single unit. It is achieved using concept of class. When you assign a class in object-oriented programming, it is said that the first principle you should consider is encapsulation. Group the associated data and its behaviour in a bucket. The main benefit of encapsulation is maintainability.</p>",
                "answers": [
                    "<p>The statement executes successfully and produces the required output.</p>",
                    "<p>The statement produces an error because a subquery in the FROM clause and outer-joins cannot be used together.</p>",
                    "<p>The statement produces an error because the GROUP BY clause cannot be used in a subquery in the FROM clause.</p>",
                    "<p>The statement produces an error because QUANTITY_SOLD cannot be displayed in the outer query.</p>",
                    "<p>The statement executes successfully but does not produce the required output.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "COUNT",
            "question_plain": "View and examine PRODUCTS and SALES tables as well as the exhibit.Given: The following query is intended to to display product name the number of times the product has been sold.Exhibit: 1 &nbsp;SELECT p.prod_name, i.quantity_sold\nFROM (\n  SELECT prod_id, COUNT(*) quantity_sold\n  FROM sales\n  GROUP BY prod_id\n) i\nRIGHT OUTER JOIN products p\nON i.prod_id = p.prod_id;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289391,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required:</strong> Display the first names of all customers from the CUSTOMERS table that contain the character 'e' and have the character 's' in the second last position.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: INSTR Function](https://www.techonthenet.com/oracle/functions/instr.php)",
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)"
                ],
                "feedbacks": [
                    "This query correctly uses the INSTR function to check if the 'e' character exists in the cust_first_name column. It also correctly uses the SUBSTR function to extract the second last character from the cust_first_name column and check if it equals 's', meeting the required conditions for the output.",
                    "This query incorrectly uses the comparison operator &lt;&gt; with a space character, which is not valid for checking the presence of 'e' in the cust_first_name column. Additionally, the SUBSTR function is incorrectly used to extract the second last character from the cust_first_name column.",
                    "This query incorrectly uses the IS NOT NULL condition to check for the presence of 'e' in the cust_first_name column, which does not meet the required condition. The SUBSTR function is also incorrectly used to extract characters from the cust_first_name column.",
                    "This query correctly uses the INSTR function to check if the 'e' character exists in the cust_first_name column. However, the usage of the LENGTH function within the SUBSTR function is incorrect, as it should be used to specify the starting position and length of the substring to extract."
                ],
                "explanation": "<p>The correct SQL query is:</p><pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers\nWHERE INSTR(cust_first_name, 'e') &lt;&gt; 0\nAND SUBSTR(cust_first_name, -2, 1) = 's';\n</pre><p><br></p><p>We are looking for customer first names that meet <strong>both</strong> of the following conditions:</p><ol><li><p><strong>Contain the letter </strong><code><strong>'e'</strong></code> anywhere.</p></li><li><p><strong>Have </strong><code><strong>'s'</strong></code><strong> in the second last position</strong>.</p></li></ol><p>Breakdown of the correct query:</p><pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers\nWHERE INSTR(cust_first_name, 'e') &lt;&gt; 0 \n  AND SUBSTR(cust_first_name, -2, 1) = 's';\n</pre><ul><li><p><code>INSTR(cust_first_name, 'e') &lt;&gt; 0</code>:</p><ul><li><p><code>INSTR</code> returns the <strong>position</strong> of <code>'e'</code> in the string.</p></li><li><p>If <code>'e'</code> is <strong>not found</strong>, it returns <code>0</code>.</p></li><li><p>So this condition ensures <code>'e'</code> <strong>exists somewhere</strong> in the name.</p></li></ul></li><li><p><code>SUBSTR(cust_first_name, -2, 1) = 's'</code>:</p><ul><li><p><code>SUBSTR</code> with a negative start index counts from the <strong>end</strong> of the string.</p></li><li><p>So <code>-2</code> gets the <strong>second last character</strong>.</p></li><li><p>This checks that it's <code>'s'</code>.</p></li></ul></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-03_21-56-58-71145637e86a81a9c20e9926e0979df4.png\"></p><p><br></p><p>Why the other options are incorrect:</p><ol><li><p><code><strong>INSTR(cust_first_name, 'e') &lt;&gt; ' '</strong></code><br>→ <code>' '</code> is a space character, not a valid test. <code>INSTR</code> returns a number, not a string.</p></li><li><p><code><strong>INSTR(cust_first_name, 'e') IS NOT NULL</strong></code><br>→ <code>INSTR</code> never returns <code>NULL</code>; it returns <code>0</code> if the character is not found.</p></li><li><p><code><strong>SUBSTR(cust_first_name, 1, -2) = 's'</strong></code><br>→ Invalid usage. A negative <strong>length</strong> in <code>SUBSTR</code> is not valid in Oracle SQL.</p></li><li><p><code><strong>SUBSTR(cust_first_name, LENGTH(cust_first_name), -2)</strong></code><br>→ This syntax is incorrect. Negative length again is not valid and the function will return <code>NULL</code>.</p></li></ol><p><strong>The Oracle/PLSQL INSTR function</strong> returns the location of a substring in a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>INSTR</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">INSTR( string, substring [, start_position [, th_appearance ] ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The string to search. <em>string</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. substring The substring to search for in <em>string</em>. <em>substring</em> can be <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. </p><p>start_position Optional. - The position in <em>string</em> where the search will start. If omitted, it defaults to 1. The first position in the string is 1. If the <em>start_position</em> is negative, the INSTR function counts back <em>start_position</em> number of characters from the end of <em>string</em> and then searches towards the beginning of <em>string</em>. </p><p>nth_appearance Optional. - The nth appearance of <em>substring</em>. If omitted, it defaults to 1.</p><p><strong>Returns</strong></p><p>The <code>INSTR</code> function returns a numeric value. The first position in the string is 1.<br>If <em>substring</em> is not found in <em>string</em>, then the <code>INSTR</code> function will return 0.</p><p><br></p><p><strong>The Oracle/PLSQL SUBSTR</strong> functions allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The source string. </p><p>start_position - The starting position for extraction. The first position in the string is always 1. </p><p>length Optional. - It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a NULL value.</p><p><strong>Note</strong></p><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers\nWHERE INSTR(cust_first_name, 'e') &lt;&gt; 0 \nAND SUBSTR(cust_first_name, -2, 1) = 's';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers\nWHERE INSTR(cust_first_name, 'e') &lt;&gt; ' ' \nAND SUBSTR(cust_first_name, -2, 1)='s';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers\nWHERE INSTR(cust_first_name, 'e') IS NOT NULL \nAND SUBSTR(cust_first_name, 1, -2) = 's';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name\nFROM customers WHERE INSTR(cust_first_name, 'e') &lt;&gt; 0 \nAND SUBSTR(cust_first_name, LENGTH(cust_first_name), -2)='s';\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "INSTR",
            "question_plain": "View and examine the following available responses.Required: Display the first names of all customers from the CUSTOMERS table that contain the character 'e' and have the character 's' in the second last position.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289393,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nCUSTNO                        NOT NULL          NUMBER(3)\nCUSTNAME                      NOT NULL          VARCHAR2(25)\nCUSTADDRESS                                     VARCHAR2(35)\nCUST_CREDIT_LIMIT                               NUMBER(5)\n</pre><p><br></p><p><strong>Given: </strong>CUSTNO is the PRIMARY KEY.</p><p><strong>Required:</strong> Determine if any customers' details have been entered more than once using a different CUSTNO, by listing all duplicate names.</p><p>Identify the SQL queries which would give you the required output. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[How to Find Duplicate Records in Oracle](https://www.oracletutorial.com/advanced-oracle-sql/find-duplicate-records-oracle/)",
                    "[Oracle Self Join](https://www.oracletutorial.com/oracle-basics/oracle-self-join/)"
                ],
                "feedbacks": [
                    "LEFT OUTER JOIN with SELF JOIN would not be the correct choice for this scenario as it would not effectively identify duplicate customer names by listing all duplicate names. It would result in a join that includes all records from the left table (CUSTOMERS) and the matching records from the right table (itself), which may not accurately identify duplicates.",
                    "SELF JOIN is the correct choice for this scenario as it allows the CUSTOMERS table to be joined with itself based on a common column (in this case, customer names). By using a SELF JOIN, you can effectively identify any customers' details that have been entered more than once using a different CUSTNO, and list all duplicate names.",
                    "RIGHT OUTER JOIN with SELF JOIN would not be the correct choice for this scenario as it would not effectively identify duplicate customer names by listing all duplicate names. A RIGHT OUTER JOIN would result in a join that includes all records from the right table (CUSTOMERS) and the matching records from the left table (itself), which may not accurately identify duplicates.",
                    "FULL OUTER JOIN with SELF JOIN would not be the correct choice for this scenario as it would not effectively identify duplicate customer names by listing all duplicate names. A FULL OUTER JOIN would result in a join that includes all records when there is a match in either the left or right table, which may not accurately identify duplicates.",
                    "Using a Subquery is the correct choice for this scenario as it allows you to write a query that retrieves data from the CUSTOMERS table based on the condition of having duplicate names. By using a Subquery, you can effectively identify any customers' details that have been entered more than once using a different CUSTNO, and list all duplicate names."
                ],
                "explanation": "<p>To <strong>find customers entered more than once using different </strong><code><strong>CUSTNO</strong></code><strong>s</strong>, we need to identify rows with the <strong>same </strong><code><strong>CUSTNAME</strong></code><strong> but different </strong><code><strong>CUSTNO</strong></code><strong> values</strong>. This is a classic case of detecting <strong>duplicate names with different primary keys</strong>.</p><p>Correct Answers:</p><ol><li><p><strong>SELF JOIN</strong></p></li><li><p><strong>Subquery</strong></p></li></ol><p>These are both valid methods to solve this problem.</p><p><strong>1. SELF JOIN method</strong></p><p>Join the table to itself on <code>CUSTNAME</code>, but ensure that the <code>CUSTNO</code>s are different.</p><pre class=\"prettyprint linenums\">SELECT DISTINCT c1.custname\nFROM customers c1\nJOIN customers c2\n  ON c1.custname = c2.custname\n AND c1.custno &lt;&gt; c2.custno;\n</pre><ul><li><p>This checks for <strong>same name, different CUSTNO</strong>.</p></li><li><p><code>DISTINCT</code> ensures each duplicate name appears only once.</p></li></ul><p><strong>2. Subquery method</strong></p><p>Use a <code>GROUP BY</code> and <code>HAVING</code> clause to find names that appear more than once.</p><pre class=\"prettyprint linenums\">SELECT custname\nFROM customers\nGROUP BY custname\nHAVING COUNT(DISTINCT custno) &gt; 1;\n</pre><ul><li><p>This groups by name and checks how many <strong>distinct CUSTNOs</strong> are associated with it.</p></li><li><p>If more than one, it’s a duplicate name with different IDs.</p></li></ul><p>Incorrect Options:</p><ul><li><p>LEFT OUTER JOIN with SELF JOIN</p></li><li><p>RIGHT OUTER JOIN with SELF JOIN</p></li><li><p>FULL OUTER JOIN with SELF JOIN</p></li></ul><p>These are unnecessarily complex for this task and not typically used to detect duplicates in this way. Additionally, outer joins introduce <code>NULL</code>s for unmatched rows, which are not relevant here because we are only interested in <strong>matching names with different keys</strong>, not unmatched ones.</p><p><br></p><p><strong>How to Find Duplicate Records in Oracle</strong></p><p><strong>Finding duplicate rows using the aggregate function</strong></p><p>To find duplicate rows from the <code>fruits</code> table, you first list the fruit name and colour columns in both <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\"><code>GROUP BY</code></a> clauses. Then you count the number of appearances each combination appears with the <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/\"><code>COUNT(*)</code></a> function as shown below:</p><pre class=\"prettyprint linenums\">SELECT \n    fruit_name,\n    color,\n    COUNT(*)\nFROM \n    fruits\nGROUP BY \n    fruit_name,\n    color;</pre><p><br></p><p><strong>Finding duplicate rows using the aggregate function in a subquery</strong></p><pre class=\"prettyprint linenums\">SELECT f.*,\n    COUNT(*) OVER (PARTITION BY fruit_name, color) c\nFROM fruits f\nWITH fruit_counts AS (\n    SELECT f.*,\n        COUNT(*) OVER (PARTITION BY fruit_name, color) c\n    FROM fruits f\n)\nSELECT *\nFROM fruit_counts\nWHERE c &gt; 1 ;</pre><p><br></p><p>or</p><pre class=\"prettyprint linenums\">SELECT *\nFROM\n        (SELECT f.*,\n            COUNT(*) OVER (PARTITION BY fruit_name, color) c\n        FROM fruits f\n        )\nWHERE c &gt; 1;\n</pre><p><em>√&nbsp; Subquery</em></p><p><br></p><p><strong>Oracle Self Join</strong></p><p>A self join is a join that joins a table with itself. A self join is useful for comparing rows within a table or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\">querying</a> hierarchical data.</p><p>A self join uses other <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-joins/\">joins</a> such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">inner join</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-left-join/\">left join</a>. In addition, it uses the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-alias/\">table alias</a> to assign the table different names in the same query.</p><p>Using Oracle self join to compare rows within the same table example</p><p>The following statement finds all employees who have the same employee number. This can be extended to employee name or any other field you wish to match on.</p><pre class=\"prettyprint linenums\">SELECT e1.employee_id,\nFROM employees e1\nINNER JOIN employees e2 ON\n    e1.employee_id = e2.employee_id\nORDER BY  \n   e1.employee_id DESC;\n</pre><p><br></p><p>Using this method, duplicate employee numbers, names or other duplicate fields can be identified.</p><p><em>√&nbsp; SELF JOIN</em></p>",
                "answers": [
                    "<p>LEFT OUTER JOIN with SELF JOIN</p>",
                    "<p>SELF JOIN</p>",
                    "<p>RIGHT OUTER JOIN with SELF JOIN</p>",
                    "<p>FULL OUTER JOIN with SELF JOIN</p>",
                    "<p>Subquery</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Table: CUSTOMERS Name                          Null??            Type\nCUSTNO                        NOT NULL          NUMBER(3)\nCUSTNAME                      NOT NULL          VARCHAR2(25)\nCUSTADDRESS                                     VARCHAR2(35)\nCUST_CREDIT_LIMIT                               NUMBER(5)\nGiven: CUSTNO is the PRIMARY KEY.Required: Determine if any customers' details have been entered more than once using a different CUSTNO, by listing all duplicate names.Identify the SQL queries which would give you the required output. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289395,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify tHE true statements regarding the EXISTS operator used in the correlated subqueries. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle EXISTS vs. IN](https://www.oracletutorial.com/oracle-basics/oracle-exists/#:~:text=The%2520EXISTS%2520operator%2520stops%2520scanning,subquery%2520to%2520conclude%2520the%2520result.)"
                ],
                "feedbacks": [
                    "<p>The <code>EXISTS</code> operator stops scanning rows once the subquery returns the first row because it can determine the result whereas the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-in/\" rel=\"noopener noreferrer\" target=\"_blank\"><code>IN</code></a> operator must scan all rows returned by the subquery to conclude the result.</p>",
                    "<p>The Oracle <code>EXISTS</code> operator is a Boolean operator that returns either true or false. The <code>EXISTS</code> operator is often used with a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\" rel=\"noopener noreferrer\" target=\"_blank\">subquery</a> to test for the existence of rows:</p>",
                    "<p>The <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-in/\" rel=\"noopener noreferrer\" target=\"_blank\"><code>IN</code></a> operator must scan all rows returned by the subquery to conclude the result.</p>",
                    "<p>Typically, the <code>EXISTS</code> operator is faster than <code>IN</code> operator when the result set of the subquery is large. By contrast, the <code>IN</code> operator is faster than <code>EXISTS</code> operator when the result set of the subquery is small.</p>"
                ],
                "explanation": "<p><strong>True Statements</strong></p><ol><li><p><strong>The Oracle </strong><code><strong>EXISTS</strong></code><strong> operator stops scanning rows once the subquery returns the first row</strong></p><ul><li><p>This is a key performance feature. As soon as the subquery finds a match, <code>EXISTS</code> returns <code>TRUE</code> and halts further scanning.</p></li></ul></li><li><p><strong>The Oracle </strong><code><strong>EXISTS</strong></code><strong> operator is a Boolean operator</strong></p><ul><li><p>Yep! It returns <code>TRUE</code> if the subquery yields at least one row, and <code>FALSE</code> otherwise.</p></li></ul></li></ol><p><strong>False Statements</strong></p><ul><li><p><strong>\"The Oracle </strong><code><strong>EXISTS</strong></code><strong> operator must scan all rows returned by the subquery to conclude the result\"</strong></p><ul><li><p>Incorrect. That’s how <code>IN</code> behaves. <code>EXISTS</code> short-circuits after the first match.</p></li></ul></li><li><p><strong>\"The Oracle </strong><code><strong>EXISTS</strong></code><strong> operator is typically slower than </strong><code><strong>IN</strong></code><strong> when the result set of the subquery is large\"</strong></p><ul><li><p>Actually, it’s often the opposite. <code>EXISTS</code> can outperform <code>IN</code> with large subquery results because it stops early, while <code>IN</code> evaluates the entire result set.</p></li></ul></li></ul><p><strong>The Oracle EXISTS condition</strong> is used in combination with a subquery and is considered \"to be met\" if the subquery returns at least one row. It can be used in a <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> statement.</p><p>The Oracle <code>EXISTS</code> operator is a Boolean operator that returns either true or false. The <code>EXISTS</code> operator is often used with a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-subquery/\">subquery</a> to test for the existence of rows:</p><pre class=\"prettyprint linenums\">SELECT\n    *\nFROM\n    table_name\n    WHERE\n        EXISTS(subquery);</pre><p><br></p><p>The <code>EXISTS</code> operator returns true if the subquery returns any rows, otherwise, it returns false. In addition, the <code>EXISTS</code> operator terminates the processing of the subquery once the subquery returns the first row.</p><p><br></p><p><strong>Oracle EXISTS vs. IN</strong></p><p>The <code>EXISTS</code> operator stops scanning rows once the subquery returns the first row because it can determine the result whereas the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-in/\"><code>IN</code></a> operator must scan all rows returned by the subquery to conclude the result.</p><p>In addition, the <code>IN</code> clause can’t compare anything with <code>NULL</code> values, but the <code>EXISTS</code> clause can compare everything with NULL values. For example, the first statement returns no row while the second one returns all rows from the <code>customers</code> table:</p><pre class=\"prettyprint linenums\">SELECT\n    *\nFROM\n    customers\nWHERE\n    customer_id IN(NULL);\n\n\nSELECT\n    *\nFROM\n    customers\nWHERE\n    EXISTS (\n        SELECT\n            NULL\n        FROM\n            dual\n    );</pre><p><br></p><p>Typically, the <code>EXISTS</code> operator is faster than <code>IN</code> operator when the result set of the subquery is large. By contrast, the <code>IN</code> operator is faster than <code>EXISTS</code> operator when the result set of the subquery is small.</p>",
                "answers": [
                    "<p>The Oracle <code>EXISTS</code> operator stops scanning rows once the subquery returns the first row.</p>",
                    "<p>The Oracle <code>EXISTS</code> operator is a Boolean operator.</p>",
                    "<p>The Oracle <code>EXISTS</code> operator must scan all rows returned by the subquery to conclude the result.</p>",
                    "<p>The Oracle <code>EXISTS</code> operator is typically slower than&nbsp; <code>IN</code> operator when the result set of the subquery is large.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify tHE true statements regarding the EXISTS operator used in the correlated subqueries. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289397,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required: </strong>Display today's date in words if the format 'Fourth of May Two Thousand Twenty'.</p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Date to Spell](https://community.oracle.com/thread/2402056)"
                ],
                "feedbacks": [
                    "None of the provided SQL queries are correct for displaying today's date in words in the format 'Fourth of May Two Thousand Twenty'. Each query has syntax errors or incorrect date format elements that do not match the required output format.",
                    "This SQL query uses the TO_CHAR function with the SYSDATE function to format today's date. The format elements 'fmddthsp \"of\" month yyyysp' are correctly used to display the date in words as 'Fourth of May Two Thousand Twenty'.",
                    "This SQL query has syntax errors in the date format string. The incorrect usage of single quotes around 'of' and 'Month' will cause a syntax error. The correct format elements should be enclosed in double quotes for the desired output.",
                    "This SQL query has a syntax error in the date format string. The missing double quotes around 'of' and 'month' will cause a syntax error. The correct format elements should be enclosed in double quotes for the desired output.",
                    "This SQL query has incorrect format elements in the date format string. The format 'fmDdthsp \"of\" Month Yyyyth' does not match the required output format of 'Fourth of May Two Thousand Twenty'. The format elements are not correctly aligned with the desired date representation.",
                    "This SQL query has incorrect format elements in the date format string. The format 'fmDdth \"of\" Month Yyyy' does not match the required output format of 'Fourth of May Two Thousand Twenty'. The format elements are not correctly aligned with the desired date representation."
                ],
                "explanation": "<p><em>√&nbsp; None are correct.</em></p><p>Some of the queries presented will execute, but none will render the output in the required format.</p><p>The correct format of the query is:</p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdthsp \"of\" Month Yyyysp') \nFROM dual;</pre><p><br></p><p>To display today’s date in <strong>words</strong> in the format like:</p><p><strong>\"Fourth of May Two Thousand Twenty\"</strong></p><p>—we need to use Oracle’s <code>TO_CHAR</code> function with <strong>date format model modifiers</strong> like:</p><ul><li><p><code>fm</code> → removes leading spaces/zeros.</p></li><li><p><code>ddthsp</code> → day in ordinal words (<code>4th</code> with spelling and a space).</p></li><li><p><code>\"of\"</code> → literal string.</p></li><li><p><code>month</code> → full lowercase month name.</p></li><li><p><code>yyyysP</code> → year spelled out.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-04_14-23-51-08d210bbcf8525b64b57a389242ab41c.png\"></p><p><br></p><p>Option Review:</p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmddthsp \"of\" month yyyysp') \nFROM dual;</pre><ul><li><p><code>yyyysp</code> is <strong>incorrect</strong> — Oracle does not recognize <code>yyyysp</code>.</p></li><li><p>Oracle uses <code>yyyYsp</code> for <strong>year spelled out</strong>.</p></li><li><p>So this option is <strong>invalid</strong>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdthsp 'of' Month Yyyysp') \nFROM dual;</pre><ul><li><p>Invalid due to incorrect <strong>quotation marks around 'of'</strong> (should use double quotes <code>\"</code> in Oracle).</p></li><li><p><code>'of'</code> (single quotes) is treated as a string literal, causing a <strong>syntax error</strong>.</p></li><li><p><strong>Also uses </strong><code><strong>Yyyysp</strong></code><strong>, which is invalid.</strong></p></li><li><p>So this option is <strong>invalid</strong>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmddthsp 'of' month yyyysp') \nFROM dual;</pre><ul><li><p>Same issue as above: <code>'of'</code> is incorrectly quoted (single quotes).</p></li><li><p><code>yyyysp</code> is not valid.</p></li><li><p><strong>Invalid syntax.</strong></p></li></ul><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdthsp \"of\" Month Yyyyth') \nFROM dual;</pre><ul><li><p>Uses <code>yyyyth</code> — this is <strong>not a valid Oracle format</strong> for spelling out the year.</p></li><li><p>So this is also <strong>invalid</strong>.</p></li></ul><pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdth \"of\" Month Yyyy') \nFROM dual;</pre><ul><li><p>Looks close, but <code>Yyyy</code> will return <strong>numeric year</strong>, not <strong>spelled-out words</strong>.</p></li><li><p>So it would display: <code>\"Third of July 2025\"</code>, not <code>\"Third of July Two Thousand Twenty-Five\"</code>.</p></li></ul>",
                "answers": [
                    "<p>None are correct.</p>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmddthsp \"of\" month yyyysp') \nFROM dual; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdthsp 'of' Month Yyyysp') \nFROM dual; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmddthsp 'of' month yyyysp') \nFROM dual; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdthsp \"of\" Month Yyyyth') \nFROM dual; \n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR(SYSDATE, 'fmDdth \"of\" Month Yyyy') \nFROM dual; \n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "TO_CHAR",
            "question_plain": "View and examine the following available responses.Required: Display today's date in words if the format 'Fourth of May Two Thousand Twenty'.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289399,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about selecting related rows from two tables based on an Entity Relationship Diagram (ERD). (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What is an Entity Relationship Diagram (ERD)?](https://www.lucidchart.com/pages/er-diagrams)"
                ],
                "feedbacks": [
                    "Implementing a relationship between two tables in an ERD often involves joining additional tables to establish the connection between the related data. This is a common practice in database design to ensure data integrity and consistency.",
                    "Relating data from a table with data from the same table is achieved through a self join. This allows for querying related data within the same table by creating a virtual relationship between different rows of the same table.",
                    "Rows from unrelated tables can still be joined using different types of joins, such as cross joins or Cartesian products. However, the join may not yield meaningful results if there is no logical relationship between the data in the tables.",
                    "While it is common to implement relationships between tables using join conditions, not every relationship between two tables must be explicitly defined in a join condition. Some relationships may be implied or enforced through constraints or foreign keys.",
                    "An inner join is a type of join operation that relates rows from two tables based on a specified condition. It does not relate rows within the same table; instead, it combines rows from two different tables based on a common column or key."
                ],
                "explanation": "<p>Correct statements:</p><p>1. <strong>\"Implementing a relationship between two tables might require joining additional tables.\"</strong></p><ul><li><p><strong>True</strong>.<br>In <strong>many-to-many</strong> relationships, an <strong>intersection (junction) table</strong> is often used.<br>For example:</p><ul><li><p><code>students</code>, <code>courses</code>, and <code>student_courses</code></p></li><li><p>To relate <code>students</code> and <code>courses</code>, you must join through <code>student_courses</code>.</p></li></ul></li></ul><p>2. <strong>\"Relating data from a table with data from the same table is implemented with a self join.\"</strong></p><ul><li><p><strong>True</strong>.<br>A <strong>self join</strong> is used when rows in the same table are related.</p><ul><li><p>Example: In an <code>employees</code> table, relating each employee to their <strong>manager</strong> (also in <code>employees</code>).</p></li></ul></li></ul><p>Incorrect Statements:</p><p>\"Rows from unrelated tables cannot be joined.\"</p><ul><li><p><strong>False</strong>.<br>Any two tables can be joined using a Cartesian product or artificial condition. It may not be <strong>meaningful</strong>, but <strong>it is possible</strong>.</p></li></ul><p>\"Every relationship between the two tables must be implemented in a join condition.\"</p><ul><li><p><strong>False</strong>.<br>While it’s <strong>best practice</strong> to join related tables using <strong>foreign keys</strong>, it's <strong>not mandatory</strong> in SQL.<br>Also, in <strong>outer joins</strong>, not all rows must match.</p></li></ul><p>\"An inner join relates rows within the same table.\"</p><ul><li><p><strong>False</strong>.<br>An <strong>inner join</strong> can be between:</p><ul><li><p>Two different tables</p></li><li><p>A table and itself (in case of self join)</p></li><li><p>But the definition of <strong>inner join</strong> is <strong>not limited to the same table</strong>.</p></li></ul></li></ul><p><br></p><p><strong>Entity relationship diagrams (ERDs) </strong>help you understand relationships between entities within a system, such as customers, products, or order IDs. An entity relationship diagram <a href=\"https://www.lucidchart.com/pages/landing/erd_tool?utm_source=bing&amp;utm_medium=cpc&amp;utm_campaign=en_tier1_desktop_nb_x_bmm&amp;km_CPC_CampaignId=369422526&amp;km_CPC_AdGroupID=1225955639383297&amp;km_CPC_Keyword=%2Berd%20%2Bonline&amp;km_CPC_MatchType=p&amp;km_CPC_Bid_MatchType=bb&amp;km_CPC_ExtensionID=&amp;km_CPC_Network=s&amp;km_CPC_Creative=76622316899154&amp;km_CPC_TargetID=kwd-76622369230134:loc-32&amp;km_CPC_Country=124419&amp;km_CPC_Device=c&amp;mkwid=QJbnFpVL_pcrid_76622316899154_pkw_%2Berd%20%2Bonline_pmt_bb_pdv_c_slid__pgrid_1225955639383297_ptaid_kwd-76622369230134:loc-32_&amp;msclkid=71f210f17e5319dedca14e408b1f6328\">tool</a> helps you conceptualize your database design before you build it, including the overall structure and the ways different types of data interact, if at all. So, if you’re designing, patching, or debugging relational databases for software engineering, business information systems, or another industry, create ER diagrams online to better visualize your schemas, while spotting and correcting flaws early on.</p><p><br></p><p><img src=\"https://d2slcw3kip6qmk.cloudfront.net/marketing/pages/consideration-page/ERD/ERD-entity-relationship-modeling-tool.png\"></p><p><br></p><p>An inner join includes the common values within the same tables. It can be from a single table or multiple tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-02-02_13-43-25-c94b97802c76d6b15bf23e7974dc3fdd.png\"></p><p><em>√&nbsp; Implementing a relationship between two tables might require joining additional tables</em></p><p><em>√&nbsp;Relating data from a table with data from the same table is implemented with a self join</em></p><p><em>X&nbsp; An inner join relates rows within the same table </em>would be true when describing a self-join but not all inner joins.</p>",
                "answers": [
                    "<p>Implementing a relationship between two tables might require joining additional tables.</p>",
                    "<p>Relating data from a table with data from the same table is implemented with a self join.</p>",
                    "<p>Rows from unrelated tables cannot be joined.</p>",
                    "<p>Every relationship between the two tables must be implemented in a join condition.</p>",
                    "<p>An inner join relates rows within the same table.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following available responses.Identify the true statements about selecting related rows from two tables based on an Entity Relationship Diagram (ERD). (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289401,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT TRUNC(ROUND(156.00, -1), -1)\nFROM DUAL;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: TRUNC Function (with dates)](https://www.techonthenet.com/oracle/functions/trunc_date.php)",
                    "[Oracle / PLSQL: TRUNC Function (with numbers)](https://www.techonthenet.com/oracle/functions/trunc_nbr.php)",
                    "[Oracle / PLSQL: ROUND Function (with dates)](https://www.techonthenet.com/oracle/functions/round_date.php)"
                ],
                "feedbacks": [
                    "The query in the exhibit is performing a multiplication operation between two numbers, which results in 10 * 16 = 160. Therefore, the correct result of the query execution is not 16.",
                    "The query in the exhibit is performing a multiplication operation between two numbers, which results in 10 * 16 = 160. Therefore, the correct result of the query execution is not 100.",
                    "The query in the exhibit is performing a multiplication operation between two numbers, which results in 10 * 16 = 160. Therefore, the correct result of the query execution is not 150.",
                    "The query in the exhibit is performing a multiplication operation between two numbers, which results in 10 * 16 = 160. Therefore, the correct result of the query execution is 160.",
                    "The query in the exhibit is performing a multiplication operation between two numbers, which results in 10 * 16 = 160. Therefore, the correct result of the query execution is not 200."
                ],
                "explanation": "<p>Step-by-step Evaluation:</p><p>1. <strong>ROUND(156.00, -1)</strong></p><ul><li><p>The <code>ROUND</code> function with a <strong>negative precision</strong> rounds to the <strong>nearest 10</strong>.</p></li><li><p><code>ROUND(156.00, -1)</code> → Rounds 156 to the nearest multiple of 10.</p><ul><li><p>156 is closer to 160 than 150.</p></li><li><p>Result: <strong>160</strong></p></li></ul></li></ul><p>2. <strong>TRUNC(160, -1)</strong></p><ul><li><p>The <code>TRUNC</code> function with a <strong>negative precision</strong> truncates to the <strong>lower multiple of 10</strong>.</p></li><li><p><code>TRUNC(160, -1)</code> → Truncates 160 down to the nearest 10 (removes units).</p><ul><li><p>Result: <strong>160</strong> (already a multiple of 10)</p></li></ul></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-26_22-19-40-1dfde823621c7e5731b54890b9fef388.png\"></p><p><br></p><p><strong>The Oracle/PLSQL TRUNC </strong>function returns a date truncated to a specific unit of measure.</p><p><strong>Syntax (with dates)</strong></p><p>The syntax for the <code>TRUNC</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TRUNC ( date [, format ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>date The date to truncate. </p><p>format - Optional. The unit of measure to apply for truncating. If the <em>format</em> parameter is omitted, the TRUNC function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off.</p><p><strong>Returns</strong></p><p>The <code>TRUNC</code> function (as it applies to dates) returns a date value.</p><p><br></p><p><strong>The Oracle/PLSQL TRUNC</strong> function returns a number truncated to a certain number of decimal places.</p><p><strong>Syntax (with numbers)</strong></p><p>The syntax for the <code>TRUNC</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TRUNC( number [, decimal_places] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>number - The number to truncate. decimal_places Optional. The number of decimal places to truncate to. This value must be an integer. If this parameter is omitted, the TRUNC function will truncate the number to 0 decimal places.</p><p><strong>Returns</strong></p><p>The <code>TRUNC</code> function (as it applies to numbers) returns a numeric value.</p><p><br></p><p><strong>The Oracle/PLSQL ROUND</strong> function returns a date rounded to a specific unit of measure.</p><p><code>ROUND</code> Function Syntax (with dates)</p><p>The syntax for the <code>ROUND</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ROUND( date [, format] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>date - The date to round. </p><p>format - Optional. The unit of measure to apply for rounding. If the <em>format</em> parameter is omitted, the ROUND function will round to the nearest day.</p><p><strong>Returns</strong></p><p>The <code>ROUND</code> function (as it applies to dates) returns a date value.</p><p><br></p><p><strong>The Oracle/PLSQL ROUND</strong> function returns a number rounded to a certain number of decimal places.</p><p><strong>Syntax (with numbers)</strong></p><p>The syntax for the <code>ROUND</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ROUND( number [, decimal_places] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>number - The number to round. decimal_places Optional. The number of decimal places rounded to. This value must be an integer. If this parameter is omitted, the ROUND function will round the number to 0 decimal places.</p><p><strong>Returns</strong></p><p>The <code>ROUND</code> function (as it applies to numbers) returns a numeric value.</p><p><a href=\"https://www.techonthenet.com/oracle/functions/round_nbr.php\">https://www.techonthenet.com/oracle/functions/round_nbr.php</a></p>",
                "answers": [
                    "<p>16</p>",
                    "<p>100</p>",
                    "<p>150</p>",
                    "<p>160</p>",
                    "<p>200</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "TRUNC",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT TRUNC(ROUND(156.00, -1), -1)\nFROM DUAL;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289403,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the BOOKS_TRANSACTIONS table.</p><p><strong>Table: BOOKS_TRANSACTIONS</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nTRANSACTION_ID                NOT NULL          VARCHAR2(6)\nBORROWED_DATE                                   DATE\nDUE_DATE                                        DATE\nBOOK_ID                                         VARCHAR2(8)\nMEMBER_ID                                       VARCHAR(6)\n</pre><p><br></p><p><strong>Given: </strong>The late fee is $2 for all overdue books.</p><p><strong>Required:</strong> Display the member IDs, due date, and late fees.</p><p>Identify the SQL queries which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Use double quotes in column alias](https://forums.oracle.com/ords/apexds/post/use-double-quotes-in-column-alias-6395)"
                ],
                "feedbacks": [
                    "This query correctly selects the member_id and due_date columns from the BOOKS_TRANSACTIONS table. However, the syntax used to assign a constant value to the LATE_FEE column is incorrect. The dollar sign should not be used as a prefix for the constant value.",
                    "This query correctly selects the member_id and due_date columns from the BOOKS_TRANSACTIONS table. However, the syntax used to assign a constant value to the LATE_FEE column is incorrect. The constant value should be enclosed in single quotes without the dollar sign.",
                    "This query correctly selects the member_id and due_date columns from the BOOKS_TRANSACTIONS table. It also assigns a constant value of $2 to the LATE_FEE column using single quotes. The column aliases are enclosed in double quotes, which is the correct syntax for column aliases with spaces.",
                    "This query correctly selects the member_id and due_date columns from the BOOKS_TRANSACTIONS table. However, the syntax used to assign a constant value to the LATE_FEE column is incorrect. The constant value should be enclosed in single quotes without the dollar sign."
                ],
                "explanation": "<p>The trick to this question is to create the column \"LATE&nbsp;FEE\" and insert the '$2' amount each row.</p><p>In the statement, we are assigning a value of '$2' for the entries in the \"LATE FEE\" column.</p><pre class=\"prettyprint linenums\">SELECT member_id AS \"MEMBER ID\", due_date AS \"DUE DATE\", '$2' AS \"LATE FEE\" \nFROM BOOKS_TRANSACTIONS;\n</pre><p>Why it’s correct:</p><ul><li><p>Uses <strong>aliasing with double quotes</strong> for column labels (valid in Oracle).</p></li><li><p>Uses <code><strong>'$2'</strong></code> as a string literal, which is correct to display a <strong>constant value</strong> (<code>$2</code>) in every row.</p></li><li><p>No syntax errors.</p></li></ul><p>We can switch out the values for any string desired.</p><pre class=\"prettyprint linenums\">SELECT member_id AS \"MEMBER ID\", due_date AS \"DUE DATE\", 'ANY VALUE' AS \"ANY COLUMN NAME\" \nFROM BOOKS_TRANSACTIONS;\n</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-06_00-38-47-bc3c10d4a2c63ad1ed518f9ec7a69c9d.png\"></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-06_00-41-22-2b005c6d6368ce13eb57710e304fa765.png\"></p><p><br></p><p>Let’s break down the incorrect options:</p><pre class=\"prettyprint linenums\">SELECT member_id AS MEMBER_ID, due_date AS DUE_DATE, $2 AS LATE_FEE\nFROM BOOKS_TRANSACTIONS</pre><ul><li><p><strong>Error:</strong> <code>$2</code> is <strong>not valid syntax</strong> in Oracle SQL — this will cause an error.</p></li><li><p><code>$</code> is not used to reference numeric constants like this.</p></li></ul><pre class=\"prettyprint linenums\">SELECT member_id 'MEMBER ID', due_date 'DUE DATE', '$2 AS LATE FEE' \nFROM BOOKS_TRANSACTIONS</pre><ul><li><p><strong>Error:</strong> <code>'MEMBER ID'</code> and <code>'DUE DATE'</code> are treated as <strong>string literals</strong>, not column aliases.</p></li><li><p>Also, <code>'$2 AS LATE FEE'</code> is a string literal, so it will just print the exact string.</p></li><li><p>Result would not be labeled or structured as intended.</p></li></ul><pre class=\"prettyprint linenums\">SELECT member_id AS \"MEMBER ID\", due_date AS \"DUE DATE\", $2 AS \"LATE FEE\" \nFROM BOOKS_TRANSACTIONS</pre><ul><li><p><strong>Error:</strong> <code>$2</code> is invalid syntax — same as above.</p></li><li><p>Will cause a <strong>syntax error</strong>.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT member_id AS MEMBER_ID, due_date AS DUE_DATE, $2 AS LATE_FEE \nFROM BOOKS_TRANSACTIONS;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT member_id 'MEMBER ID', due_date 'DUE DATE', '$2 AS LATE FEE' \nFROM BOOKS_TRANSACTIONS;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT member_id AS \"MEMBER ID\", due_date AS \"DUE DATE\", '$2' AS \"LATE FEE\" \nFROM BOOKS_TRANSACTIONS;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT member_id AS \"MEMBER ID\", due_date AS \"DUE DATE\", $2 AS \"LATE FEE\" \nFROM BOOKS_TRANSACTIONS;\n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the BOOKS_TRANSACTIONS table.Table: BOOKS_TRANSACTIONSName                          Null??            Type\nTRANSACTION_ID                NOT NULL          VARCHAR2(6)\nBORROWED_DATE                                   DATE\nDUE_DATE                                        DATE\nBOOK_ID                                         VARCHAR2(8)\nMEMBER_ID                                       VARCHAR(6)\nGiven: The late fee is $2 for all overdue books.Required: Display the member IDs, due date, and late fees.Identify the SQL queries which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289405,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT promo_name || q'{'s start date was \\}' || promo_begin_date AS \"Promotion Launches\"\nFROM promotions;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What Is a String Literal?](https://download.oracle.com/oll/tutorials/SQLInjection/html/lesson1/les01_tm_ovw0.htm)",
                    "[Alternative Quoting Mechanism (''Q'') for String Literals](https://livesql.oracle.com/apex/livesql/file/content_CIREYU9EA54EOKQ7LAMZKRF6P.html)"
                ],
                "feedbacks": [
                    "The query executes successfully as it correctly uses single quotes to enclose the literal text and escapes the double quote character within the string by using a backslash. This results in the phrase \"'s start date was \\\" being appended to each promo_name in the output.",
                    "This choice is incorrect because it does not accurately represent the result of the query execution. The use of the phrase \" {'s start date was \\&gt; \" is not consistent with the SQL query provided in the exhibit.",
                    "This choice is incorrect because the query does not produce an error due to the use of flower braces. The query uses single quotes and backslashes to escape characters, which is valid in SQL syntax.",
                    "This choice is incorrect because the query does not produce an error based on data type mismatch. The query is focused on concatenating a string literal with the promo_name column values, and data type matching is not a concern in this scenario."
                ],
                "explanation": "<p>What’s happening in the SQL query:</p><pre class=\"prettyprint linenums\">SELECT promo_name || q'{'s start date was \\}' || promo_begin_date AS \"Promotion Launches\"\nFROM promotions;\n</pre><p><code>q'{ ... }'</code> – Quoted String Literal</p><ul><li><p>Oracle supports <strong>alternative quoting mechanism</strong> using <code>q'[...]'</code>, <code>q'{...}'</code>, etc.</p></li><li><p>It’s useful when your string contains <strong>single quotes, backslashes, or other special characters</strong>.</p></li><li><p>In this case:</p><pre class=\"prettyprint linenums\">q'{'s start date was \\}'\n</pre><p>is treated as a <strong>string literal</strong>:</p><pre class=\"prettyprint linenums\">'s start date was \\'\n</pre></li><li><p>This is then concatenated with:</p><ul><li><p><code>promo_name</code> (likely a string/varchar2)</p></li><li><p>and <code>promo_begin_date</code> (a date, which will be implicitly converted to string using NLS date format)</p></li></ul></li></ul><p>Expected Output</p><p>The result of the expression:</p><pre class=\"prettyprint linenums\">promo_name || q'{'s start date was \\}' || promo_begin_date\n</pre><p>would look like (for example):</p><pre class=\"prettyprint linenums\">Super Sale's start date was \\01-JUL-25\n</pre><p>Assuming <code>promo_name = 'Super Sale'</code> and <code>promo_begin_date = 01-JUL-25</code>.</p><p>❗ Data types?</p><ul><li><p>No data type mismatch occurs.</p></li><li><p>Oracle will <strong>implicitly convert</strong> <code>promo_begin_date</code> to a string during concatenation.</p></li><li><p><code>q'{}'</code> is a valid syntax and does not cause an error.</p></li></ul><p>Correct Answer: <strong>It executes successfully and introduces the phrase \"'s start date was \\ \" at the end of each promo_name in the output.</strong></p><p>(Note: The <code>\\\\</code> is not escaped — it will literally show one backslash <code>\\</code> in the result.)</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-06_11-39-39-f3145d335cae0de61d7b2e8b474779cb.png\"></p><p><br></p><p><strong>A String Literal </strong>is a sequence of zero or more characters enclosed within single quotation marks.</p><p><strong>The following are examples of string literals:</strong></p><p>'Hello, world!'<br>'10-NOV-91'<br>'He said, \"Take it or leave it.\"'<br>'$1,000,000'</p><p>PL/SQL is case-sensitive within string literals. For example, PL/SQL considers the following literals to be different:</p><p>'baker'<br>'Baker'</p><p>To represent an apostrophe within a string, you can use two single quotation marks, which is not the same as writing one double quotation mark:</p><p>v := 'I<strong>''</strong>m a string, you<strong>''</strong>re a string.'</p><p>The two consecutive quotation marks are then interpreted as an individual single quotation mark when processed by the SQL parser.</p><p>As of Oracle Database 10.2, you can also use the following notation to define your own delimiter characters for the literal. You choose a character (such as ! in the example below), prefix it with<strong> q' </strong>and then do not need to escape other single quotation marks inside the pair of literals:</p><p>v := <strong>q'!</strong>I'm a string, you're a string.<strong>!'</strong>;</p><p><strong>Do not use alternative delimiters (q' quotes) when you form literals concatenated with dynamic SQL</strong>.</p><p><br></p><p><strong>Alternative Quoting Mechanism (''Q'') for String Literals</strong></p><p>Oracle Database offers the ability, in both SQL and PL/SQL, to specify our own user-defined delimiters for string literals. Here's how it works: you prefix your literal with the letter \"q\". Then you type a single quote, followed by your starting delimiter for the literal. Then you type your literal string without having to double up on your single quote characters. </p><p>When you have typed in your full literal, terminate it with your ending delimiter, followed by a single quote. In other words, you will follow this general format: q'[your string here]' where \"[\" represents (and certainly could be used for) the starting delimiter, and \"]\" represents the ending delimiter. Oracle automatically recognizes \"paired\" delimiters, such as [], {}, (), and &lt;&gt;. </p><p>If you want to use some other character as your start delimiter and it doesn't have a \"natural\" partner for termination, you must use the same character for start and end delimiters. Finally, if you choose a character for a delimiter and it appears in your string immediately before a single quotation mark, Oracle will be unhappy and raise an error.</p><p><strong>Traditional \"Doubling-Up\" of Single Quotes</strong></p><pre class=\"prettyprint linenums\">BEGIN  \n   DBMS_OUTPUT.put_line ('That''s a really funny ''joke''.');  \nEND; </pre><p>That's a really funny 'joke'.</p><p><br></p><p><strong>Using Paired Symbols</strong></p><pre class=\"prettyprint linenums\">BEGIN  \n    DBMS_OUTPUT.PUT_LINE (  \n       q'[What's a quote among friends?]');  \nEND; </pre><p>What's a quote among friends?</p><p><br></p><p><strong>Replacement for Single Quote</strong></p><pre class=\"prettyprint linenums\">BEGIN  \n    DBMS_OUTPUT.PUT_LINE (  \n       q'!What's a quote among friends?!');  \nEND; </pre><p>What's a quote among friends?</p><p><br></p><pre class=\"prettyprint linenums\">BEGIN \n   DBMS_OUTPUT.put_line (q'(That's a really funny 'joke'.)'); \nEND; </pre><p>That's a really funny 'joke'.</p>",
                "answers": [
                    "<p>It executes successfully and introduces the phrase \"'s start date was \\\" at the end of each promo_name in the output.</p>",
                    "<p>It executes successfully and displays the literal \" {'s start date was \\&gt; \" for each row in the output.</p>",
                    "<p>It produces an error because flower braces have been used.</p>",
                    "<p>It produces an error because the data types are not matching.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "String Literals",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT promo_name || q'{'s start date was \\}' || promo_begin_date AS \"Promotion Launches\"\nFROM promotions;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289407,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the false selection about Oracle ALIASES.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ALIASES](https://www.techonthenet.com/oracle/alias.php)",
                    "[How does table alias names affect performance?](https://stackoverflow.com/questions/8363108/how-does-table-alias-names-affect-performance)"
                ],
                "feedbacks": [
                    "Oracle ALIASES do not negatively impact system performance. In fact, they can improve readability and simplify queries by providing temporary names for columns or tables.",
                    "Oracle ALIASES can indeed be used to create a temporary name for columns or tables. This can be particularly useful when dealing with complex queries or when renaming columns for better understanding.",
                    "If the alias name contains spaces, you must enclose the alias name in quotes. This is necessary to differentiate the alias from the actual column or table name and ensure that the query is executed correctly.",
                    "It is acceptable to use spaces when you are aliasing a column name. This can help make the query more readable and understandable, especially when dealing with multiple columns or complex joins.",
                    "<p>An alias is not mandatory in all views. While aliases can be used in views to simplify queries, improve readability, and provide temporary names, they are a requirement for schema bound views.</p>"
                ],
                "explanation": "<p>In this question we are looking for the <strong>False Statement:</strong></p><p><strong> \"Oracle ALIASES negatively impact system performance.\"</strong></p><ul><li><p><strong>False</strong>.<br>Aliases are just <strong>syntactic labels</strong> used at query runtime.<br>They <strong>do not affect</strong> how Oracle executes the query or its performance.<br>They exist only in the context of the SQL query output or query parsing.</p></li></ul><p><br></p><p>The following are <strong>True Statements</strong>, not what the question is asking for:</p><p><strong>\"Oracle ALIASES can be used to create a temporary name for columns or tables.\"</strong></p><ul><li><p><strong>True</strong>.<br>Aliases temporarily rename columns or tables in a query, usually for readability or clarity.</p></li></ul><p><strong>\"If the alias name contains spaces, you must enclose the alias name in quotes.\"</strong></p><ul><li><p><strong>True</strong>.<br>For example:</p><pre class=\"prettyprint linenums\">SELECT first_name AS \"Employee Name\" FROM employees;\n</pre></li></ul><p><strong>\"It is acceptable to use spaces when you are aliasing a column name.\"</strong></p><ul><li><p><strong>True</strong>, <strong>if enclosed in double quotes</strong>.<br>Spaces are <strong>not allowed</strong> in unquoted identifiers.</p></li></ul><p><strong>\"An alias is mandatory in schema bound views.\"</strong></p><ul><li><p><strong>True</strong>.<br>In <strong>schema-bound views</strong>, every derived column must have a name (alias). This is a requirement.</p></li></ul><p><strong>Oracle ALIASES</strong> can be used to create a temporary name for columns or tables.</p><p><code>COLUMN ALIASES</code> are used to make column headings in your result set easier to read.</p><p><code>TABLE ALIASES</code> are used to shorten your SQL to make it easier to read or when you are performing a self join (ie: listing the same table more than once in the FROM clause).</p><p><strong>Syntax</strong></p><p>The syntax to <code>ALIAS A COLUMN</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">column_name AS alias_name</pre><p><br></p><p>OR</p><p>The syntax to <code>ALIAS A TABLE</code> in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">table_name alias_name</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>column_name - The original name of the column that you wish to alias. </p><p>table_name - The original name of the table that you wish to alias. alias_name The temporary name to assign.</p><p><strong>Note</strong></p><p>If the <em>alias_name</em> contains spaces, you must enclose the <em>alias_name</em> in quotes.</p><p>It is acceptable to use spaces when you are aliasing a column name. However, it is not generally good practice to use spaces when you are aliasing a table name.</p><p>The <em>alias_name</em> is only valid within the scope of the SQL statement.</p><p><br></p><p><strong>The alias doesn't affect performance <em>in any practical or measurable way</em> at all. That is, it would add a barely (if it all) measurable delay to query compilation. Once compiled (and re-used), it has no effect.</strong></p><p>An alias removes ambiguity when you have more than one table because you know which table it comes from. It also prevents future table changes from breaking a query. Say, you add an audit column to one table where it already exists in another table. Queries without aliases using both tables will break.</p><p>An alias is also mandatory in some cases e.g. schema bound views.</p><p>The SQL parsing engine (that reads all queries before executing them, and uses the information to cache the compiled queries in the future for faster execution) is the only thing that looks at the aliases, and uses it to help remove ambiguities in symbol lookups. The system would already produce symbols, just like any other compilable statement in any other language, when it's being parsed prior to execution-storage.</p><p><em>✗&nbsp; Oracle ALIASES negatively impact system performance.</em></p>",
                "answers": [
                    "<p>Oracle ALIASES negatively impact system performance.</p>",
                    "<p>Oracle ALIASES can be used to create a temporary name for columns or tables.</p>",
                    "<p>If the alias name contains spaces, you must enclose the alias name in quotes.</p>",
                    "<p>It is acceptable to use spaces when you are aliasing a column name.</p>",
                    "<p>An alias is mandatory in schema bound views.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ALIAS",
            "question_plain": "View and examine the following available responses.Identify the false selection about Oracle ALIASES.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289409,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of ORDERS and CUSTOMERS tables.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-47-45-a683c55f983ec897ea58234ffe31f44b.png\"></p><p><br></p><p><strong>Given:</strong> This UPDATE statement has been executed.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">1 UPDATE (\n2 &nbsp; SELECT order_date, order_total, customer_id\n3 &nbsp; FROM orders\n4 )\n5 SET order_date = 22-MAR-2019\n6 WHERE customer_id IN (\n7 &nbsp; SELECT customer_id\n8 &nbsp; FROM customers\n9 &nbsp; WHERE cust_last_name = 'Roberts'\n10 &nbsp; AND credit_limit = 600\n11 );\n</pre><p><br></p><p>Indicate the statement which is true regarding the result? (Choose the best answer.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: TO_DATE Function](https://www.techonthenet.com/oracle/functions/to_date.php)"
                ],
                "feedbacks": [
                    "The UPDATE statement would not execute because line 4 does not have the proper syntax. The SET keyword is missing before the column name and value assignment, which is essential for updating the data in the table.",
                    "It would not execute because line 8 does not have the proper syntax. The WHERE clause is missing, which is necessary to specify the condition for updating the data in the table. Without the WHERE clause, all rows in the table would be affected.",
                    "It would not execute because line 9 does not have the proper syntax. The column name in the SET clause is missing the table alias or table name, which is required to identify the specific column to be updated in the ORDERS table.",
                    "It would not execute because a SELECT statement cannot be used in place of a table name. The UPDATE statement requires a table name to specify the target table for updating the data, and a SELECT statement cannot be used in this context.",
                    "It would not execute because two tables cannot be referenced in a single UPDATE statement. The UPDATE statement can only update data in one table at a time, so referencing two tables in the same statement is not allowed.",
                    "It would not execute because the UPDATE statement has syntax errors that prevent it from executing successfully. The missing SET keyword, WHERE clause, and incorrect table references would cause the statement to fail during execution."
                ],
                "explanation": "<p>The most direct and definite reason for the statement to fail is the incorrect syntax for the date literal on line 5.</p><ul><li><p><strong>It would not execute because line 5 does not have the proper syntax.</strong> This is <strong>TRUE</strong> and directly addresses the error with the date literal.</p></li></ul><p>Line 5 must be corrected. The below statement will run successfully and update the order date field to 22-MAR-2019. Using the <code>TO_DATE</code> function for more explicit date conversion is often preferred for robustness:</p><p><br></p><pre class=\"prettyprint linenums\">1 UPDATE (\n2 &nbsp; SELECT order_date, order_total, customer_id\n3 &nbsp; FROM orders\n4 )\n5 SET order_date = TO_DATE('22-MAR-2019', 'DD-MON-YYYY') -- Using TO_DATE function\n6 WHERE customer_id IN (\n7 &nbsp; SELECT customer_id\n8 &nbsp; FROM customers\n9 &nbsp; WHERE cust_last_name = 'Roberts'\n10 &nbsp; AND credit_limit = 600\n11 );\n</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-06_23-15-50-b6af43d17f7ca2dbfa222471e9f22723.png\"></p><p><br></p><ol><li><p><strong>Lines 1-4: </strong><code><strong>UPDATE (SELECT ... FROM orders)</strong></code>: This syntax, where an <code>UPDATE</code> statement targets a subquery (or an inline view), is valid in databases like Oracle. It allows you to update columns from the underlying table(s) that are exposed in the subquery. So, the claim that \"a SELECT statement cannot be used in place of a table name\" is generally false for this context.</p></li><li><p><strong>Line 5: </strong><code><strong>SET order_date = 22-MAR-2019</strong></code>: This is the problematic line. In SQL, date literals <em>must</em> be enclosed in single quotes. Without quotes, <code>22-MAR-2019</code> is interpreted as an arithmetic expression: <code>22</code> minus the string <code>'MAR'</code> (which would cause an error as 'MAR' is not a valid numeric operand for subtraction) minus <code>2019</code>.</p><p><strong>Correct Syntax would be:</strong> <code>SET order_date = '22-MAR-2019'</code> OR <code>SET order_date = TO_DATE('22-MAR-2019', 'DD-MON-YYYY')</code></p><p>Because of this, the statement <strong>would not execute successfully</strong>.</p></li><li><p><strong>Lines 6-11: </strong><code><strong>WHERE customer_id IN (SELECT customer_id FROM customers WHERE cust_last_name = 'Roberts' AND credit_limit = 600)</strong></code>: This subquery is syntactically correct and references the <code>customers</code> table. The presence of two tables being referenced (implicitly <code>orders</code> via the inline view and <code>customers</code> in the subquery) is also valid. The clauses <code>WHERE cust_last_name = 'Roberts'</code> (line 9) and <code>AND credit_limit = 600</code> (line 10) are both standard and correct SQL syntax.</p></li></ol><p>Other options:</p><ul><li><p><strong>It would not execute because line 9 does not have the proper syntax.</strong> This is <strong>FALSE</strong>; line 9 (<code>WHERE cust_last_name = 'Roberts'</code>) is syntactically correct.</p></li><li><p><strong>It would not execute because line 10 does not have the proper syntax.</strong> This is <strong>FALSE</strong>; line 10 (<code>AND credit_limit = 600</code>) is syntactically correct.</p></li><li><p><strong>It would not execute because a SELECT statement cannot be used in place of a table name.</strong> This is <strong>FALSE</strong>; in many SQL dialects (like Oracle), this is a valid way to update through an inline view.</p></li><li><p><strong>It would not execute because two tables cannot be referenced in a single UPDATE statement.</strong> This is <strong>FALSE</strong>; referencing multiple tables via subqueries in <code>WHERE</code> clauses is common and valid.</p></li><li><p><strong>It would execute successfully.</strong> This is <strong>FALSE</strong> due to the syntax error on line 5.</p></li></ul><p><br></p><p><strong>The Oracle/PLSQL TO_DATE </strong>function converts a string to a date.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>TO_DATE</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TO_DATE( string1 [, format_mask] [, nls_language] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string that will be converted to a date. </p><p>format_mask Optional. - This is the format that will be used to convert <em>string1</em> to a date.</p><p>nls_language Optional. - This is the nls language used to convert <em>string1</em> to a date.</p><p><strong>Returns</strong></p><p>The <code>TO_DATE</code> function returns a date value.</p>",
                "answers": [
                    "<p>It would not execute because line 5 does not have the proper syntax.</p>",
                    "<p>It would not execute because line 9 does not have the proper syntax.</p>",
                    "<p>It would not execute because line 10 does not have the proper syntax.</p>",
                    "<p>It would not execute because a SELECT statement cannot be used in place of a table name.</p>",
                    "<p>It would not execute because two tables cannot be referenced in a single UPDATE statement.</p>",
                    "<p>It would execute successfully.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "TO_DATE",
            "question_plain": "View and examine the structure of ORDERS and CUSTOMERS tables.Given: This UPDATE statement has been executed.Exhibit 1:1 UPDATE (\n2 &nbsp; SELECT order_date, order_total, customer_id\n3 &nbsp; FROM orders\n4 )\n5 SET order_date = 22-MAR-2019\n6 WHERE customer_id IN (\n7 &nbsp; SELECT customer_id\n8 &nbsp; FROM customers\n9 &nbsp; WHERE cust_last_name = 'Roberts'\n10 &nbsp; AND credit_limit = 600\n11 );\nIndicate the statement which is true regarding the result? (Choose the best answer.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289411,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following CREATE TABLE commands.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE orders (\n  ord_no NUMBER(2) CONSTRAINT ord_pk PRIMARY KEY,\n  ord_date DATE,\n  cust_id NUMBER(4)\n);\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE orders (\n  ord_no NUMBER(2),\n  items_no NUMBER(3),\n  qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n  expiry_date DATE CHECK (expiry_date &gt; SYSDATE),\n  CONSTRAINT it_pk PRIMARY KEY (ord_no, items_no),\n  CONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (ord_no)\n);\n</pre><p><br></p><p><strong>Given: </strong>The sequence was executed but the ORD_ITEMS table was not get created.</p><p>Indicate the statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Sysdate in check constraints](https://asktom.oracle.com/pls/apex/asktom.search?tag=sysdate-in-check-constraints)",
                    "[Restrictions on Check Constraints ](https://docs.oracle.com/database/121/SQLRF/clauses002.htm#SQLRF52205)"
                ],
                "feedbacks": [
                    "The use of SYSDATE with the CHECK constraint is valid in Oracle SQL. SYSDATE is a built-in function that returns the current date and time, and it can be used in constraints to enforce specific conditions on data values.",
                    "The BETWEEN clause can be used multiple times for the same table in Oracle SQL. It is a comparison operator that allows you to specify a range of values for a column, and it can be used in various conditions within a query or constraint.",
                    "The CHECK constraint can be placed on columns with the DATE data type in Oracle SQL. The CHECK constraint allows you to define conditions that must be met for data values in a column, regardless of the data type of the column.",
                    "ORD_NO and ITEM_NO can be used as a composite primary key in Oracle SQL, even if ORD_NO is also a FOREIGN KEY. In a composite primary key, multiple columns together form a unique identifier for each row in a table, and it is possible to have a column that is both a primary key and a foreign key in Oracle SQL."
                ],
                "explanation": "<p>The correct and <strong>true</strong> statement is: <strong>SYSDATE cannot be used with the CHECK constraint.</strong></p><p><br></p><p>The issue lies in this line from <strong>Exhibit 2</strong>:</p><pre class=\"prettyprint linenums\">expiry_date DATE CHECK (expiry_date &gt; SYSDATE)\n</pre><p>Oracle <strong>does not allow non-deterministic functions like </strong><code><strong>SYSDATE</strong></code> in a <code>CHECK</code> constraint, because these functions return different results each time they are called. A <code>CHECK</code> constraint must be based on <strong>static, deterministic expressions</strong> to ensure data consistency.</p><p>Therefore, <strong>this causes the CREATE TABLE statement to fail</strong>, and <code>ORD_ITEMS</code> (or <code>orders</code> in Exhibit 2) table is <strong>not created</strong>.</p><p>Corrected <strong>Exhibit 2</strong> query:</p><pre class=\"prettyprint linenums\">CREATE TABLE ord_items (\n  ord_no NUMBER(2),\n  items_no NUMBER(3),\n  qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n  expiry_date DATE,  -- Removed invalid CHECK constraint\n  CONSTRAINT it_pk PRIMARY KEY (ord_no, items_no),\n  CONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (ord_no)\n);\n</pre><p><br></p><p>The other statements are <strong>incorrect</strong>:</p><ul><li><p><strong>\"The BETWEEN clause cannot be used twice for the same table\"</strong><br>→ Not true. You can use <code>BETWEEN</code> multiple times in any number of constraints.</p></li><li><p><strong>\"The CHECK constraint cannot be placed on columns having the DATE data type\"</strong><br>→ Incorrect. You <em>can</em> apply a CHECK on a DATE column <strong>as long as it doesn’t use non-deterministic functions</strong> (like <code>SYSDATE</code>, <code>CURRENT_DATE</code>, etc.).</p></li><li><p><strong>\"ORD_NO and ITEM_NO cannot be used as a composite primary key because ORD_NO is also the FOREIGN KEY\"</strong><br>→ Not true. A column can be part of both a <strong>primary key</strong> and a <strong>foreign key</strong> simultaneously. This is allowed in Oracle.</p></li></ul>",
                "answers": [
                    "<p>SYSDATE cannot be used with the CHECK constraint.</p>",
                    "<p>The BETWEEN clause cannot be used twice for the same table.</p>",
                    "<p>The CHECK constraint cannot be placed on columns having the DATE data type.</p>",
                    "<p>ORD_NO and ITEM_NO cannot be used as a composite primary key because ORD_NO is also the FOREIGN KEY.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CHECK",
            "question_plain": "View and examine the following CREATE TABLE commands.Exhibit 1:CREATE TABLE orders (\n  ord_no NUMBER(2) CONSTRAINT ord_pk PRIMARY KEY,\n  ord_date DATE,\n  cust_id NUMBER(4)\n);\nExhibit 2:CREATE TABLE orders (\n  ord_no NUMBER(2),\n  items_no NUMBER(3),\n  qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),\n  expiry_date DATE CHECK (expiry_date &gt; SYSDATE),\n  CONSTRAINT it_pk PRIMARY KEY (ord_no, items_no),\n  CONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (ord_no)\n);\nGiven: The sequence was executed but the ORD_ITEMS table was not get created.Indicate the statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289413,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about time zones, date data types, and timestamp data types in an Oracle database. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[DBTIMEZONE](https://docs.oracle.com/database/121/SQLRF/functions056.htm#SQLRF00630)",
                    "[CURRENT_TIMESTAMP](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CURRENT_TIMESTAMP.html)",
                    "[SESSIONTIMEZONE](https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions143.htm)"
                ],
                "feedbacks": [
                    "The DBTIMEZONE function in Oracle can indeed return the offset from Universal Coordinated Time (UTC), providing information about the time zone setting of the database itself.",
                    "A TIMESTAMP data type column in Oracle contains information about year, month, day, hour, minute, second, and fractional seconds. It includes both date and time information, not just year, month, and day.",
                    "The CURRENT_TIMESTAMP function in Oracle returns the current date and time with time zone information, providing details about the time zone in which the data was retrieved.",
                    "A TIMESTAMP WITH LOCAL TIMEZONE data type column in Oracle is stored in the database using the time zone of the database session that inserted the row, not the time zone of the session.",
                    "The SESSIONTIMEZONE function in Oracle can return the time zone offset or the time zone region name of the current session, allowing users to retrieve information about the time zone setting of their current session."
                ],
                "explanation": "<p>Correct statements:</p><p><strong>1. The </strong><code><strong>DBTIMEZONE</strong></code><strong> function can return an offset from Universal Coordinated Time (UTC).</strong></p><p><strong>True</strong></p><ul><li><p><code>DBTIMEZONE</code> returns the database time zone, and its output can be in:</p><ul><li><p><strong>Offset format</strong>: e.g., <code>+00:00</code>, <code>-05:00</code>, etc.</p></li><li><p><strong>Or a time zone region name</strong> if set that way.</p></li></ul></li><li><p>This is often an <strong>offset from UTC</strong>.</p></li><li><p><code>DBTIMEZONE</code> - Returns the value of the database time zone. The return type is a time zone offset (a character type in the format <code>'[+|-]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the database time zone value in the most recent <code>CREATE DATABASE</code> or <code>ALTER DATABASE</code> statement.</p></li></ul><p><strong>2. The </strong><code><strong>CURRENT_TIMESTAMP</strong></code><strong> function returns data with time zone information.</strong></p><p><strong>True</strong></p><ul><li><p><code>CURRENT_TIMESTAMP</code> returns a <strong>TIMESTAMP WITH TIME ZONE</strong> value.</p></li><li><p>This includes <strong>date + time + fractional seconds + time zone information</strong>.</p></li><li><p><code>CURRENT_TIMESTAMP</code> - Returns the current date and time in the session time zone, in a value of data type <code>TIMESTAMP WITH TIME ZONE</code>. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and <code>LOCALTIMESTAMP</code> is that <code>CURRENT_TIMESTAMP</code> returns a <code>TIMESTAMP WITH TIME ZONE</code> value while <code>LOCALTIMESTAMP</code> returns a <code>TIMESTAMP</code> value.</p></li></ul><p><strong>3. The </strong><code><strong>SESSIONTIMEZONE</strong></code><strong> function can return a time zone offset or a time zone region name.</strong></p><p><strong>True</strong></p><ul><li><p><code>SESSIONTIMEZONE</code> reflects the time zone of the current session.</p></li><li><p>Can return either:</p><ul><li><p><strong>Offset format</strong>: e.g., <code>+05:30</code></p></li><li><p><strong>Time zone region</strong>: e.g., <code>'Asia/Kolkata'</code></p></li><li><p><code>SESSIONTIMEZONE</code> - Returns the time zone of the current session. The return type is a time zone offset (a character type in the format <code>'[+|]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the session time zone value in the most recent <code>ALTER SESSION</code> statement.</p></li></ul></li></ul><p>Incorrect statements:</p><p><strong>A </strong><code><strong>TIMESTAMP</strong></code><strong> data type column only contains information about year, month, and day.</strong></p><p><strong>False</strong></p><ul><li><p><code>TIMESTAMP</code> includes:</p><ul><li><p><strong>Date + time</strong> — that is: <strong>year, month, day, hour, minute, second, and fractional seconds</strong></p></li></ul></li><li><p>So this statement is <strong>incorrect</strong>.</p></li><li><p>The <code>TIMESTAMP</code> datatype is an extension of the <code>DATE</code> datatype. It stores year, month, day, hour, minute, and second values. It also stores fractional seconds, which are not stored by the <code>DATE</code> datatype.</p><p>To specify <code>TIMESTAMP</code> literals, you use the following format:</p><pre class=\"prettyprint linenums\">TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'</pre><p><br></p><p>The following example illustrates a <code>TIMESTAMP</code> literal:&nbsp; &nbsp; &nbsp;</p><pre class=\"prettyprint linenums\">TIMESTAMP '1999-12-31 23:59:59.10'</pre></li></ul><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/23/nlspg/datetime-data-types-and-time-zone-support.html\">https://docs.oracle.com/en/database/oracle/oracle-database/23/nlspg/datetime-data-types-and-time-zone-support.html</a></p><p><br></p><p><strong>A </strong><code><strong>TIMESTAMP WITH LOCAL TIMEZONE</strong></code><strong> data type column is stored in the database using the time zone of the session that inserted the row.</strong></p><p><strong>False</strong></p><ul><li><p>The <strong>value is normalized to the database time zone</strong> when stored.</p></li><li><p>However, when queried, it is <strong>converted to the session time zone</strong>.</p></li><li><p>So it is <strong>not stored</strong> in the session's time zone — it’s stored in <strong>database time zone</strong>, which makes this statement incorrect.</p></li><li><p><code>TIMESTAMP WITH LOCAL TIME ZONE</code> is another variant of <code>TIMESTAMP</code>. It differs from <code>TIMESTAMP WITH TIME ZONE</code> as follows: data stored in the database is normalized to the database time zone, and the time zone offset is not stored as part of the column data. When users retrieve the data, Oracle returns it in the users' local session time zone. The time zone offset is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time, formerly Greenwich Mean Time).</p></li></ul><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/23/nlspg/datetime-data-types-and-time-zone-support.html\">https://docs.oracle.com/en/database/oracle/oracle-database/23/nlspg/datetime-data-types-and-time-zone-support.html</a></p>",
                "answers": [
                    "<p>The DBTIMEZONE function can return an offset from Universal Coordinated Time (UTC).</p>",
                    "<p>A TIMESTAMP data type column only contains information about year, month, and day.</p>",
                    "<p>The CURRENT_TIMESTAMP function returns data with time zone information.</p>",
                    "<p>A TIMESTAMP WITH LOCAL TIMEZONE data type column is stored in the database using the time zone of the session that inserted the row.</p>",
                    "<p>The SESSIONTIMEZONE function can return a time zone offset or a time zone region name.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "e"
            ],
            "section": "TIMEZONE",
            "question_plain": "View and examine the following available responses.Identify the true statements about time zones, date data types, and timestamp data types in an Oracle database. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289415,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following CREATE SEQUENCE statement and exhibits.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE SEQUENCE seq1\n  START WITH 100\n  INCREMENT BY 10\n  MAXVALUE 200\n  CYCLE\n  NOCACHE;\n</pre><p><br></p><p><strong>Exhibit: 2 (Output)</strong></p><pre class=\"prettyprint linenums\">Sequence created.\n</pre><p><br></p><p>The following SQL statement has been executed.</p><p><strong>Exhibit: 3</strong></p><pre class=\"prettyprint linenums\">SELECT seq1.NEXTVAL \nFROM dual;\n</pre><p><br></p><p>Identify the result of the final query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Sequences (Autonumber)](https://www.techonthenet.com/oracle/sequences.php)"
                ],
                "feedbacks": [
                    "The sequence starts at 1 and increments by 1 for each call to NEXTVAL. The final query execution will return the next value in the sequence after the initial value of 1.",
                    "The sequence does not increment by 10, but by 1 for each call to NEXTVAL. The final query execution will return the next value in the sequence after the initial value of 1.",
                    "The sequence starts at 100 and increments by 1 for each call to NEXTVAL. The final query execution will return the next value in the sequence after the initial value of 100.",
                    "The sequence does not start at 200, but at 1. The final query execution will return the next value in the sequence after the initial value of 1.",
                    "The sequence does not start at 210, but at 1. The final query execution will return the next value in the sequence after the initial value of 1.",
                    "There is no error in the sequence or the query execution. The final query will return the next value in the sequence after the initial value of 1."
                ],
                "explanation": "<p><strong>Exhibit 1 – Sequence Definition</strong></p><pre class=\"prettyprint linenums\">CREATE SEQUENCE seq1\n  START WITH 100\n  INCREMENT BY 10\n  MAXVALUE 200\n  CYCLE\n  NOCACHE;\n</pre><p>Key properties:</p><ul><li><p><code>START WITH 100</code>: The first call to <code>NEXTVAL</code> will return <strong>100</strong>.</p></li><li><p><code>INCREMENT BY 10</code>: Each subsequent call to <code>NEXTVAL</code> will increase by 10.</p></li><li><p><code>MAXVALUE 200</code>: The highest value the sequence can generate is <strong>200</strong>.</p></li><li><p><code>CYCLE</code>: After reaching <code>MAXVALUE</code>, it will <strong>wrap around and start again from </strong><code><strong>MINVALUE</strong></code> or <code>START WITH</code>.</p></li><li><p><code>NOCACHE</code>: No sequence values are preallocated — has no impact on this result.</p></li></ul><p><strong>Exhibit 2 – Output</strong></p><pre class=\"prettyprint linenums\">Sequence created.\n</pre><p>Means the <code>CREATE SEQUENCE</code> statement was successful.</p><p><strong>Exhibit 3 – Query</strong></p><pre class=\"prettyprint linenums\">SELECT seq1.NEXTVAL \nFROM dual;\n</pre><p><strong>Expected Result</strong></p><ul><li><p>This is the <strong>first</strong> call to <code>NEXTVAL</code>.</p></li><li><p>So it will return the <strong>START WITH</strong> value: <code><strong>100</strong></code></p></li></ul><p><strong>Correct Answer: </strong><code><strong>100</strong></code></p><p><em>√ Since no numbers have been run in the current session the first value output is 100.</em> Each time the query is run, the number increases by the increment value of 10 per the <code>CREATE SEQUENCE</code> criteria.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-07_23-53-11-8082a53e622f5899e00d49a08673d60a.png\"></p><p><br></p><p><strong>Why Other Options Are Incorrect</strong></p><ul><li><p><strong>1 / 10 / 200 / 210</strong>: These are future values that will be generated by later calls.</p></li><li><p><strong>An error</strong>: No error occurs because all definitions are valid and this is a proper first use of the sequence.</p></li></ul><p><strong>In Oracle, you can create an autonumber field by using sequences.</strong> A sequence is an object in Oracle that is used to generate a number sequence. This can be useful when you need to create a unique number to act as a primary key.</p><p><strong>Create Sequence</strong></p><p>You may wish to create a sequence in Oracle to handle an <code>autonumber</code> field.</p><p><strong>Syntax</strong></p><p>The syntax to create a sequence in Oracle is:</p><pre class=\"prettyprint linenums\">CREATE SEQUENCE sequence_name\n  MINVALUE value\n  MAXVALUE value\n  START WITH value\n  INCREMENT BY value\n  CACHE value;</pre><p><br></p><p>sequence_name - The name of the sequence that you wish to create.</p><p>The <em>cache</em> option specifies how many sequence values will be stored in memory for faster access.</p><p>The downside of creating a sequence with a cache is that if a system failure occurs, all cached sequence values that have <strong>not</strong> be used, will be \"lost\". This results in a \"gap\" in the assigned sequence values. When the system comes back up, Oracle will cache new numbers from where it left off in the sequence, ignoring the so called \"lost\" sequence values.</p><p><em>Nocache</em> means that none of the sequence values are stored in memory. This option may sacrifice some performance, however, you should not encounter a gap in the assigned sequence values.</p>",
                "answers": [
                    "<p>1</p>",
                    "<p>10</p>",
                    "<p>100</p>",
                    "<p>200</p>",
                    "<p>210</p>",
                    "<p>An error.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Sequences",
            "question_plain": "View and examine the following CREATE SEQUENCE statement and exhibits.Exhibit: 1CREATE SEQUENCE seq1\n  START WITH 100\n  INCREMENT BY 10\n  MAXVALUE 200\n  CYCLE\n  NOCACHE;\nExhibit: 2 (Output)Sequence created.\nThe following SQL statement has been executed.Exhibit: 3SELECT seq1.NEXTVAL \nFROM dual;\nIdentify the result of the final query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289417,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS ONLY;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Row Limiting Clause for Top-N Queries in Oracle Database](https://oracle-base.com/articles/12c/row-limiting-clause-for-top-n-queries-12cr1)"
                ],
                "feedbacks": [
                    "This choice is incorrect because the query is using the ORDER BY clause with the ASC keyword, which means it will sort the data in ascending order. Therefore, it will display the products with the lowest amount sold, not the highest.",
                    "This choice is incorrect because the query is using the ORDER BY clause with the ASC keyword, which means it will sort the data in ascending order. Therefore, it will display the products with the lowest amount sold, not the first 5 percent of the rows.",
                    "This choice is correct because the query is using the ORDER BY clause with the ASC keyword, which means it will sort the data in ascending order. By using the FETCH FIRST 5 PERCENT ROWS ONLY clause, it will display 5 percent of the products with the lowest amount sold.",
                    "This choice is incorrect because the ORDER BY clause is valid in the query and does not need to be the last clause. The query will execute successfully and display the specified result."
                ],
                "explanation": "<p>Correct option:<strong> It displays 5 percent of the products with the lowest amount sold.</strong></p><p><strong>Exhibit 1 – SQL Query:</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS ONLY;\n</pre><ul><li><p><code>ORDER BY amount_sold</code> — sorts the results in <strong>ascending</strong> order (default).</p></li><li><p><code>FETCH FIRST 5 PERCENT ROWS ONLY</code> — returns only the <strong>first 5% of the sorted rows</strong>.</p></li></ul><p>Since the rows are sorted <strong>ascending by </strong><code><strong>amount_sold</strong></code>, the <strong>lowest amount_sold values</strong> come first.</p><p>The query:</p><ul><li><p><strong>sorts by amount_sold in ascending order</strong></p></li><li><p><strong>fetches the first 5% of those rows</strong></p></li></ul><p><br></p><p>Incorrect options:</p><ul><li><p><strong>“It displays 5 percent of the products with the highest amount sold.”</strong><br>→ Incorrect: highest would require <code>ORDER BY amount_sold DESC</code>.</p></li><li><p><strong>“It displays the first 5 percent of the rows from the SALES table.”</strong><br>→ Misleading: it fetches 5% <strong>after sorting</strong>, not the first 5% of <strong>unsorted</strong> data.</p></li><li><p><strong>“It results in an error because the ORDER BY clause should be the last clause.”</strong><br>→ Incorrect: <code>ORDER BY</code> <strong>is correctly placed before</strong> <code>FETCH</code>.</p></li></ul><p><strong>A Top-N query</strong> is used to retrieve the top or bottom N rows from an ordered set. Combining two Top-N queries gives you the ability to page through an ordered set.</p><p>The <code>Top-N</code> Queries <a href=\"http://docs.oracle.com/cd/E16655_01/server.121/e17209/statements_10002.htm#SQLRF55631\">syntax</a> for the row limiting clause looks a little complicated at first glance.</p><p><strong>Syntax</strong></p><pre class=\"prettyprint linenums\">[ OFFSET offset { ROW | ROWS } ]\n[ FETCH { FIRST | NEXT } [ { rowcount | percent PERCENT } ]\n    { ROW | ROWS } { ONLY | WITH TIES } ]</pre><p><br></p><p>Actually, for the classic Top-N query it is very simple. The example below returns the 5 largest values from an ordered set. Using the <code>ONLY</code> clause limits the number of rows returned to the exact number requested.</p><pre class=\"prettyprint linenums\">SELECT val\nFROM   rownum_order_test\nORDER BY val DESC\nFETCH FIRST 5 ROWS ONLY;\n\n       VAL\n----------\n        10\n        10\n         9\n         9\n         8\n\n5 rows selected.</pre><p><br></p><ul><li><p>The keywords <code>ROW</code> and <code>ROWS</code> can be used interchangeably, as can the <code>FIRST</code> and <code>NEXT</code> keywords. Pick the ones that scan best when reading the SQL like a sentence.</p></li><li><p>If the offset is not specified it is assumed to be 0.</p></li><li><p>Negative values for the offset, rowcount or percent are treated as 0.</p></li><li><p>Null values for offset, rowcount or percent result in no rows being returned.</p></li><li><p>Fractional portions of offset, rowcount or percent are truncated.</p></li><li><p>If the offset is greater than or equal to the total number of rows in the set, no rows are returned.</p></li><li><p>If the rowcount or percent are greater than the total number of rows after the offset, all rows are returned.</p></li><li><p>The row limiting clause can not be used with the <code>FOR UPDATE</code> clause, <code>CURRVAL</code> and <code>NEXTVAL</code> sequence pseudocolumns or in an fast refresh materialized view.</p></li></ul>",
                "answers": [
                    "<p>It displays 5 percent of the products with the highest amount sold.</p>",
                    "<p>It displays the first 5 percent of the rows from the SALES table.</p>",
                    "<p>It displays 5 percent of the products with the lowest amount sold.</p>",
                    "<p>It results in an error because the ORDER BY clause should be the last clause.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Top-N Queries",
            "question_plain": "View and examine the following SQL exhibit.Exhibit 1:SELECT prod_id, amount_sold\nFROM sales\nORDER BY amount_sold\nFETCH FIRST 5 PERCENT ROWS ONLY;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289419,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the MARKS table.</p><p><strong>Table: MARKS</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nSTUDENT_ID                    NOT NULL          VARCHAR2(4)\nSTUDENT_NAME                                    VARCHAR2(25)\nSUBJECT1                                        NUMBER(3)\nSUBJECT2                                        NUMBER(3)\nSUBJECT3                                        NUMBER(3)\n</pre><p><br></p><p>Identify the queries which execute successfully. (Choose two.) </p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Aggregate Functions](https://www.oracletutorial.com/oracle-aggregate-functions/)",
                    "[Oracle / PLSQL: AVG Function](https://www.techonthenet.com/oracle/functions/avg.php)",
                    "[Oracle / PLSQL: SUM Function](https://www.techonthenet.com/oracle/functions/sum.php)"
                ],
                "feedbacks": [
                    "This query successfully executes as it calculates the sum of distinct non-null values in subject1 and the maximum value in subject1 from the MARKS table where subject1 is greater than subject2. The NVL function is used to replace null values with 0 in the sum calculation.",
                    "This query will not execute successfully as the AVG function cannot be used directly in the WHERE clause. The AVG function should be used in a subquery or a separate query to compare the average value with subject1.",
                    "This query successfully executes as it calculates the sum of subject1, subject2, and subject3 for all rows in the MARKS table where the student_name is NULL. The SUM function is used to calculate the total sum of the specified columns.",
                    "This query will not execute successfully as it tries to select the student_name and the sum of subject1 for rows where the student_name starts with 'P'. The GROUP BY clause is missing in the query, which is required when using aggregate functions like SUM."
                ],
                "explanation": "<p><strong>Correct Answers (Will execute successfully):</strong></p><pre class=\"prettyprint linenums\">SELECT SUM(DISTINCT NVL(subject1,0)), MAX(subject1)\nFROM marks\nWHERE subject1 &gt; subject2;\n</pre><pre class=\"prettyprint linenums\">SELECT SUM(subject1+subject2+subject3)\nFROM marks\nWHERE student_name IS NULL;</pre><p><br></p><p>Evaluate each of the provided SQL queries based on the <code>MARKS</code> table structure.</p><p><strong>Table Structure Summary:</strong></p><pre class=\"prettyprint linenums\">MARKS (\n  STUDENT_ID    VARCHAR2(4)     NOT NULL,\n  STUDENT_NAME  VARCHAR2(25),\n  SUBJECT1      NUMBER(3),\n  SUBJECT2      NUMBER(3),\n  SUBJECT3      NUMBER(3)\n)\n</pre><p><strong>Query 1:</strong></p><pre class=\"prettyprint linenums\">SELECT SUM(DISTINCT NVL(subject1,0)), MAX(subject1)\nFROM marks\nWHERE subject1 &gt; subject2;\n</pre><ul><li><p><code>NVL(subject1, 0)</code> is valid.</p></li><li><p><code>SUM(DISTINCT ...)</code> is allowed.</p></li><li><p>WHERE clause uses valid column comparison.</p></li><li><p><code>MAX(subject1)</code> is a valid aggregate.</p></li><li><p><strong>Conclusion</strong>: <strong>This query will execute successfully.</strong></p></li></ul><p><strong>Query 2:</strong></p><pre class=\"prettyprint linenums\">SELECT SUM(subject1+subject2+subject3)\nFROM marks\nWHERE student_name IS NULL;\n</pre><ul><li><p>The sum of expressions is valid in Oracle.</p></li><li><p><code>WHERE student_name IS NULL</code> is valid.</p></li><li><p><strong>Conclusion</strong>: <strong>This query will also execute successfully.</strong></p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-08_11-56-59-772dcce8fffeae5231245a51ea772217.png\"></p><p><strong>Query 3:</strong></p><pre class=\"prettyprint linenums\">SELECT student_name, subject1\nFROM marks\nWHERE subject1 &gt; AVG(subject1);\n</pre><ul><li><p><code>AVG(subject1)</code> is an <strong>aggregate function</strong>, and it <strong>cannot</strong> be used directly in a <code>WHERE</code> clause (which is row-level logic).</p></li><li><p>Fails because it has an Aggregate Function in the WHERE clause.</p></li><li><p>You would need to use a <strong>subquery or HAVING clause</strong> to do this properly.</p></li><li><p><strong>Conclusion</strong>: <strong>This query will result in an error.</strong></p></li></ul><p><strong>Query 4:</strong></p><pre class=\"prettyprint linenums\">SELECT student_name, SUM(subject1)\nFROM marks\nWHERE student_name LIKE 'P%';\n</pre><ul><li><p>This query uses an <strong>aggregate function (</strong><code><strong>SUM</strong></code><strong>)</strong> with a <strong>non-aggregated column (</strong><code><strong>student_name</strong></code><strong>)</strong>.</p></li><li><p>It is <strong>missing a GROUP BY clause</strong>, which is required when mixing aggregated and non-aggregated columns in the SELECT clause.</p></li><li><p>Fails because it has a single column and an Aggregate Function in the SELECT clause but then it does not include a GROUP BY clause on the single column.</p></li><li><p><strong>Conclusion</strong>: <strong>This query will result in an error.</strong></p></li></ul><p><br></p><p><strong>Oracle aggregate functions</strong> calculate on a group of rows and return a single value for each group.</p><p>We commonly use the aggregate functions together with the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\"><code>GROUP BY</code></a> clause. The <code>GROUP BY</code> clause divides the rows into groups and an aggregate function calculates and returns a single result for each group.</p><p>If you use aggregate functions without a <code>GROUP BY</code> clause, then the aggregate functions apply to all rows of the queried tables or <a href=\"https://www.oracletutorial.com/oracle-view/\">views</a>.</p><p>We also use the aggregate functions in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-having/\"><code>HAVING</code></a> clause to filter groups from the output based on the results of the aggregate functions.</p><p>Oracle aggregate functions can appear in <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> lists and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code>ORDER BY</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\"><code>GROUP BY</code></a>, and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-having/\"><code>HAVING</code></a> clauses</p><p><br></p><p><strong>The Oracle/PLSQL AVG function</strong> returns the average value of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>AVG</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT AVG(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>AVG</code> function when grouping the results by one or more columns is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       AVG(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the AVG function and must be included in the GROUP BY clause at the end of the SQL statement. </p><p>aggregate_expression - This is the column or expression that will be averaged. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p>WHERE conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>AVG</code> function returns a numeric value.</p><p><br></p><p><strong>The Oracle/PLSQL SUM function</strong> returns the summed value of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUM</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT SUM(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p>OR the syntax for the <code>SUM</code> function when grouping the results by one or more columns is:</p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       SUM(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n - Expressions that are not encapsulated within the SUM function and must be included in the GROUP BY clause at the end of the SQL statement. </p><p>aggregate_expression - This is the column or expression that will be summed. </p><p>tables -The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p>WHERE conditions Optional. - These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>SUM</code> function returns a numeric value.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT SUM(DISTINCT NVL(subject1,0)), MAX(subject1)\nFROM marks\nWHERE subject1 &gt; subject2;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT student_name, subject1\nFROM marks\nWHERE subject1 &gt; AVG(subject1);\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT SUM(subject1+subject2+subject3)\nFROM marks\nWHERE student_name IS NULL;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT student_name,SUM(subject1)\nFROM marks\nWHERE student_name LIKE 'P%';\n</pre>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "Aggregate Function",
            "question_plain": "View and examine the structure of the MARKS table.Table: MARKSName                          Null??            Type\nSTUDENT_ID                    NOT NULL          VARCHAR2(4)\nSTUDENT_NAME                                    VARCHAR2(25)\nSUBJECT1                                        NUMBER(3)\nSUBJECT2                                        NUMBER(3)\nSUBJECT3                                        NUMBER(3)\nIdentify the queries which execute successfully. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289421,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the details of the PRODUCT_INFORMATION table.</p><p><strong>Table: PRODUCT_INFORMATION </strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-13_15-41-54-daa46e880646e54d6575615b59fb674e.png\"></p><p><br></p><p>The following SQL statement has been executed.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT product_name\nFROM product_information\nWHERE (category_id = 12 AND category_id = 13)\nAND supplier_id = 102088;\n</pre><p><br></p><p><strong>Required:</strong> Display PRODUCT_NAME from the table where the CATEGORY_ID column has values 12 or 13, and the SUPPLIER_ID column has the value 102088.</p><p>Indicate the statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The WHERE clause in SQL does not require parentheses to enclose the entire condition. Each condition can be connected using logical operators like AND or OR without the need for additional parentheses.",
                    "This statement would execute successfully but return no rows because the condition specified in the WHERE clause requires both the CATEGORY_ID to be 12 or 13 and the SUPPLIER_ID to be 102088 simultaneously, which may not exist in the table.",
                    "Using the same column multiple times with different conditions connected by logical operators like AND is a valid SQL syntax. It does not prevent the query from executing. However, in this specific case, the conditions specified may not match any rows in the table.",
                    "This statement would execute successfully and return the desired result if there are rows in the PRODUCT_INFORMATION table where the CATEGORY_ID is either 12 or 13 and the SUPPLIER_ID is 102088."
                ],
                "explanation": "<p>Correct Answer: <strong>It would execute but would return no rows.</strong></p><p>Analyze the SQL statement and identify the issue based on the requirement.</p><p><strong>Exhibit 1 – SQL Statement:</strong></p><pre class=\"prettyprint linenums\">SELECT product_name\nFROM product_information\nWHERE (category_id = 12 AND category_id = 13)\nAND supplier_id = 102088;\n</pre><p><strong>What this query is doing:</strong></p><ul><li><p>The <code>WHERE</code> clause:</p><pre class=\"prettyprint linenums\">(category_id = 12 AND category_id = 13)\n</pre><p>is logically <strong>impossible</strong> — a single row <strong>cannot have both values</strong> (<code>12 AND 13</code>) for the same column <code>category_id</code>.</p></li><li><p>This is the same as saying <code>WHERE 1 = 2</code>; it can never be <code>TRUE</code>.</p></li><li><p>Therefore, this query will <strong>always return no rows</strong>, even though it <strong>will execute successfully</strong>.</p></li></ul><p><strong>What the requirement says:</strong></p><p>Display <code>PRODUCT_NAME</code> where the <code>CATEGORY_ID</code> is <strong>12 or 13</strong>, and <code>SUPPLIER_ID</code> is <code>102088</code>.</p><p>To meet this requirement, the correct condition should be:</p><pre class=\"prettyprint linenums\">WHERE (category_id = 12 OR category_id = 13)\nAND supplier_id = 102088;\n</pre><p>Or more simply:</p><pre class=\"prettyprint linenums\">WHERE category_id IN (12, 13)\nAND supplier_id = 102088;\n</pre><p><strong>Incorrect Options Explained:</strong></p><ul><li><p><strong>\"It would not execute because the entire WHERE clause is not enclosed within parentheses\"</strong><br>→ False. Parentheses are only needed for <strong>logical grouping</strong>, not mandatory around the full clause.</p></li><li><p><strong>\"It would not execute because the same column has been used twice with the AND logical operator\"</strong><br>→ False. It's syntactically valid, just <strong>logically flawed</strong>.</p></li><li><p><strong>\"It would execute and return the desired result\"</strong><br>→ False. It <strong>does not match the requirement</strong> because it uses <code>AND</code> instead of <code>OR</code>.</p></li></ul>",
                "answers": [
                    "<p>It would not execute because the entire WHERE clause is not enclosed within parentheses.</p>",
                    "<p>It would execute but would return no rows.</p>",
                    "<p>It would not execute because the same column has been used twice with the AND logical operator.</p>",
                    "<p>It would execute and return the desired result.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "WHERE",
            "question_plain": "View and examine the details of the PRODUCT_INFORMATION table.Table: PRODUCT_INFORMATION The following SQL statement has been executed.Exhibit 1:SELECT product_name\nFROM product_information\nWHERE (category_id = 12 AND category_id = 13)\nAND supplier_id = 102088;\nRequired: Display PRODUCT_NAME from the table where the CATEGORY_ID column has values 12 or 13, and the SUPPLIER_ID column has the value 102088.Indicate the statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289423,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT 1 AS id, 'John' AS first_name, NULL AS commission\nFROM dual\nINTERSECT\nSELECT 1. 'John', NULL\nFROM dual\nORDER BY 3;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query in the SQL exhibit does not return any data, so the result of the query execution would not be 1 row.",
                    "The SQL exhibit shows an incomplete query with a missing keyword 'SELECT'. This would result in an error message when the query is executed.",
                    "Since the query in the SQL exhibit is incomplete and does not select any data, the result of the query execution would not be 0 rows.",
                    "The query in the SQL exhibit does not return any data, so the result of the query execution would not be 2 rows.",
                    "The query in the SQL exhibit does not return any data, so the result of the query execution would not be 3 rows."
                ],
                "explanation": "<p>Correct Answer: <strong>An error message</strong> because the SQL is <strong>not valid</strong> due to the syntax issue in the second <code>SELECT</code> statement.</p><p>Analyze the query from <strong>Exhibit 1</strong>:</p><p><strong>SQL Statement Given:</strong></p><pre class=\"prettyprint linenums\">SELECT 1 AS id, 'John' AS first_name, NULL AS commission\nFROM dual\nINTERSECT\nSELECT 1. 'John', NULL\nFROM dual\nORDER BY 3;\n</pre><p><br></p><p><strong>Step-by-step Analysis:</strong></p><p><strong>1. Syntax Error:</strong></p><p>This part of the second <code>SELECT</code>:</p><pre class=\"prettyprint linenums\">SELECT 1. 'John', NULL\n</pre><p>is <strong>invalid</strong> SQL syntax.</p><ul><li><p><code>1. 'John'</code> is not valid. Oracle will interpret <code>1.</code> as an incomplete <strong>numeric literal</strong>, and then see <code>'John'</code>, which makes no sense in that context.</p></li><li><p>The correct syntax should use <strong>commas</strong> to separate columns:</p><pre class=\"prettyprint linenums\">SELECT 1, 'John', NULL\n</pre></li></ul><p><strong>Other Notes (If Syntax Was Corrected):</strong></p><p>If we fixed the syntax like this:</p><pre class=\"prettyprint linenums\">SELECT 1 AS id, 'John' AS first_name, NULL AS commission\nFROM dual\nINTERSECT\nSELECT 1, 'John', NULL\nFROM dual\nORDER BY 3;\n</pre><ul><li><p>This would <strong>not return any rows</strong>, because <code>NULL</code> is not considered equal to <code>NULL</code> in set operations like <code>INTERSECT</code>.</p></li></ul><p>As written in the exhibit, the code contains a <strong>clear syntax error</strong> due to the <code>1. 'John'</code> part.</p>",
                "answers": [
                    "<p>1 row</p>",
                    "<p>An error message.</p>",
                    "<p>0 rows</p>",
                    "<p>2 rows</p>",
                    "<p>3 rows </p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.Exhibit 1:SELECT 1 AS id, 'John' AS first_name, NULL AS commission\nFROM dual\nINTERSECT\nSELECT 1. 'John', NULL\nFROM dual\nORDER BY 3;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289425,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the data in the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS</strong></p><pre class=\"prettyprint linenums\">CUSTNO                       CUSTNAME                CITY\n1                            MUNOZ                   LONDON\n2                            GREEN                   PARIS\n3                            KOCHAR                  LONDON\n4                            SMITH                   TORONTO\n</pre><p><br></p><p>Evaluate the following query:</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT c1.custname, c1.city\nFROM customers c1 ________ customers c2\nON (c1.city = c2.city AND c1.custname &lt;&gt; c2.custname);\n</pre><p><br></p><p><strong>Required:</strong> List all cities that have more than one customer along with the customer details.</p><p>Identify the JOIN options can be used in the blank in the above query to give the correct output. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Joins](https://www.techonthenet.com/oracle/joins.php)"
                ],
                "feedbacks": [
                    "LEFT OUTER JOIN includes all records from the left table (customers c1) and the matched records from the right table (customers c2). In this scenario, using a LEFT OUTER JOIN may include customers who do not have a matching city with another customer, which is not suitable for the requirement of listing cities with more than one customer.",
                    "INNER JOIN returns only the rows where there is a match found in both tables (customers c1 and c2) based on the specified condition. Using an INNER JOIN in this query will ensure that only cities with more than one customer are listed along with their details, meeting the requirement.",
                    "NATURAL JOIN performs a join based on the columns with the same name in both tables. Since the query requires a join condition on the city and customer name, using a NATURAL JOIN may not provide the desired output.",
                    "RIGHT OUTER JOIN includes all records from the right table (customers c2) and the matched records from the left table (customers c1). This type of join may not be suitable for this query as it focuses on including all records from the right table, which is not necessary for listing cities with more than one customer.",
                    "FULL OUTER JOIN returns all records when there is a match in either the left table (customers c1) or the right table (customers c2). This type of join may include cities with only one customer, which does not meet the requirement of listing cities with more than one customer.",
                    "Only using an INNER JOIN is correct in this scenario as it ensures that only cities with more than one customer are listed along with their details, meeting the requirement of the query."
                ],
                "explanation": "<p>The correct answers are <strong>INNER JOIN</strong>​ and <strong>Only one option is correct</strong>.</p><p>We are requested to identify two options that will produce the correct output for the given query and data. The requirement is to \"List all cities that have more than one customer along with the customer details.\" The <code>SELECT</code> clause specifically asks for <code>c1.custname</code> and <code>c1.city</code>.</p><p>Evaluate each <code>JOIN</code> type carefully, focusing on whether the final <code>SELECT c1.custname, c1.city</code> output meets the exact requirement.</p><p><strong>1. INNER JOIN</strong></p><ul><li><p><strong>Behaviour:</strong> An <code>INNER JOIN</code> returns only the rows where the <code>ON</code> condition evaluates to TRUE in both tables.</p></li><li><p><strong>Analysis:</strong></p><ul><li><p>For customers in <strong>LONDON</strong> (MUNOZ, KOCHAR):</p><ul><li><p>When <code>c1</code> is MUNOZ and <code>c2</code> is KOCHAR, <code>c1.city = c2.city</code> (LONDON = LONDON) is TRUE and <code>c1.custname &lt;&gt; c2.custname</code> (MUNOZ &lt;&gt; KOCHAR) is TRUE. A row is returned.</p></li><li><p>When <code>c1</code> is KOCHAR and <code>c2</code> is MUNOZ, <code>c1.city = c2.city</code> (LONDON = LONDON) is TRUE and <code>c1.custname &lt;&gt; c2.custname</code> (KOCHAR &lt;&gt; MUNOZ) is TRUE. A row is returned.</p></li></ul></li><li><p>For customers in <strong>PARIS</strong> (GREEN) and <strong>TORONTO</strong> (SMITH):</p><ul><li><p>There is no other customer in the same city with a different name. Therefore, for <code>c1</code> as GREEN/SMITH, no <code>c2</code> will satisfy <code>c2.city = c1.city AND c2.custname &lt;&gt; c1.custname</code>. No rows related to these single-customer cities will be returned by the join.</p></li></ul></li></ul></li><li><p><strong>Output of </strong><code><strong>SELECT c1.custname, c1.city</strong></code><strong>:</strong></p><ul><li><p>MUNOZ, LONDON</p></li><li><p>KOCHAR, LONDON</p></li></ul></li><li><p><strong>Meets Requirement?</strong> Yes. It correctly lists only the customers from cities that have more than one customer.</p></li></ul><p><strong>2. RIGHT OUTER JOIN</strong></p><ul><li><p><strong>Behaviour:</strong> A <code>RIGHT OUTER JOIN</code> returns all rows from the <em>right</em> table (<code>customers c2</code>) and the matched rows from the <em>left</em> table (<code>customers c1</code>) based on the <code>ON</code> condition. If a row in <code>c2</code> has no match in <code>c1</code>, the <code>c1</code> columns will be <code>NULL</code>.</p></li><li><p><strong>Analysis:</strong></p><ul><li><p>For <code>c2</code> (MUNOZ, LONDON): A match is found with <code>c1</code> (KOCHAR, LONDON). The <code>c1</code> values (KOCHAR, LONDON) are used.</p></li><li><p>For <code>c2</code> (KOCHAR, LONDON): A match is found with <code>c1</code> (MUNOZ, LONDON). The <code>c1</code> values (MUNOZ, LONDON) are used.</p></li><li><p>For <code>c2</code> (GREEN, PARIS): No <code>c1</code> row satisfies <code>c1.city = 'PARIS' AND c1.custname &lt;&gt; 'GREEN'</code>. So, <code>c1</code>'s columns are <code>NULL</code>.</p></li><li><p>For <code>c2</code> (SMITH, TORONTO): No <code>c1</code> row satisfies <code>c1.city = 'TORONTO' AND c1.custname &lt;&gt; 'SMITH'</code>. So, <code>c1</code>'s columns are <code>NULL</code>.</p></li></ul></li><li><p><strong>Output of </strong><code><strong>SELECT c1.custname, c1.city</strong></code><strong>:</strong></p><ul><li><p>KOCHAR, LONDON</p></li><li><p>MUNOZ, LONDON</p></li><li><p>NULL, NULL (for GREEN)</p></li><li><p>NULL, NULL (for SMITH)</p></li></ul></li><li><p><strong>Meets Requirement?</strong> No. The <code>NULL, NULL</code> entries for single-customer cities do not represent \"customer details\" from cities with multiple customers. The requirement is to <em>list</em> the details, not to list <code>NULL</code>s indicating an absence of details.</p></li></ul><p><strong>3. LEFT OUTER JOIN</strong></p><ul><li><p><strong>Behaviour:</strong> A <code>LEFT OUTER JOIN</code> returns all rows from the <em>left</em> table (<code>customers c1</code>) and the matched rows from the <em>right</em> table (<code>customers c2</code>) based on the <code>ON</code> condition. If a row in <code>c1</code> has no match in <code>c2</code>, the <code>c2</code> columns will be <code>NULL</code>.</p></li><li><p><strong>Analysis:</strong></p><ul><li><p>For <code>c1</code> (MUNOZ, LONDON): Matches <code>c2</code> (KOCHAR, LONDON).</p></li><li><p>For <code>c1</code> (KOCHAR, LONDON): Matches <code>c2</code> (MUNOZ, LONDON).</p></li><li><p>For <code>c1</code> (GREEN, PARIS): No <code>c2</code> row satisfies <code>c2.city = 'PARIS' AND c2.custname &lt;&gt; 'GREEN'</code>. The <code>c2</code> columns would be <code>NULL</code>, but <code>c1</code>'s columns (GREEN, PARIS) are always included.</p></li><li><p>For <code>c1</code> (SMITH, TORONTO): No <code>c2</code> row satisfies <code>c2.city = 'TORONTO' AND c2.custname &lt;&gt; 'SMITH'</code>. The <code>c2</code> columns would be <code>NULL</code>, but <code>c1</code>'s columns (SMITH, TORONTO) are always included.</p></li></ul></li><li><p><strong>Output of </strong><code><strong>SELECT c1.custname, c1.city</strong></code><strong>:</strong></p><ul><li><p>MUNOZ, LONDON</p></li><li><p>KOCHAR, LONDON</p></li><li><p>GREEN, PARIS</p></li><li><p>SMITH, TORONTO</p></li></ul></li><li><p><strong>Meets Requirement?</strong> No. It lists customers from cities that have only one customer (Paris, Toronto), which violates the requirement to list <em>only</em> cities with more than one customer.</p></li></ul><p><strong>4. NATURAL JOIN</strong></p><ul><li><p><strong>Behaviour:</strong> Automatically joins tables based on all columns with identical names. It does not allow an explicit <code>ON</code> clause.</p></li><li><p><strong>Analysis:</strong> This would attempt to join on <code>CUSTNO</code>, <code>CUSTNAME</code>, and <code>CITY</code>. It cannot incorporate the <code>c1.custname &lt;&gt; c2.custname</code> condition, and would fundamentally change the query's logic.</p></li><li><p><strong>Meets Requirement?</strong> No.</p></li></ul><p><strong>5. FULL OUTER JOIN</strong></p><ul><li><p><strong>Behaviour:</strong> Returns all rows when there is a match in either the left or the right table, with <code>NULL</code>s for non-matching columns. It combines the results of <code>LEFT OUTER JOIN</code> and <code>RIGHT OUTER JOIN</code>.</p></li><li><p><strong>Analysis:</strong> This would result in an output that includes all the rows from <code>LEFT OUTER JOIN</code> and <code>RIGHT OUTER JOIN</code> (with distinct rows), leading to <code>NULL</code>s and single-customer city entries.</p></li><li><p><strong>Meets Requirement?</strong> No.</p></li></ul><p><strong>Final Conclusion: </strong>Based on a rigorous interpretation of the <code>SELECT</code> statement and the \"Required\" output, only <code>INNER JOIN</code> (or simply <code>JOIN</code>) produces the exact list of customer details for cities with more than one customer, without including extraneous <code>NULL</code>s or single-customer entries.</p><p>The only correct query option from the given list, which precisely fulfils the requirement, is <strong>INNER JOIN</strong>.</p><p>The final answers are INNER JOIN​ and Only one option is correct.</p>",
                "answers": [
                    "<p><code>LEFT OUTER JOIN</code> </p>",
                    "<p><code>INNER JOIN</code> </p>",
                    "<p><code>NATURAL JOIN</code> </p>",
                    "<p><code>RIGHT OUTER JOIN</code> </p>",
                    "<p><code>FULL OUTER JOIN</code> </p>",
                    "<p>Only one option is correct.</p>"
                ]
            },
            "correct_response": [
                "b",
                "f"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the data in the CUSTOMERS table.Table: CUSTOMERSCUSTNO                       CUSTNAME                CITY\n1                            MUNOZ                   LONDON\n2                            GREEN                   PARIS\n3                            KOCHAR                  LONDON\n4                            SMITH                   TORONTO\nEvaluate the following query:Exhibit 1:SELECT c1.custname, c1.city\nFROM customers c1 ________ customers c2\nON (c1.city = c2.city AND c1.custname &lt;&gt; c2.custname);\nRequired: List all cities that have more than one customer along with the customer details.Identify the JOIN options can be used in the blank in the above query to give the correct output. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289427,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description of the SALES1 table.</p><p><strong>Table: SALES1</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nSALES_ID                      NOT NULL          NUMBER\nSTORE_ID                      NOT NULL          NUMBER\nITEMS_ID                                        NUMBER\nQUANTITY                                        NUMBER\nSALES_DATE                                      DATE\n</pre><p><br></p><p><strong>Given: </strong></p><ul><li><p>SALES2 is a table with the same description as SALES1.</p></li><li><p>Some sales data is duplicated in both tables.</p></li></ul><p><strong>Required: </strong>Display the rows from the SALES1 table which are not present in the SALES2 table.</p><p>Identify the set operator would generate the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: MINUS Operator](https://www.techonthenet.com/oracle/minus.php)"
                ],
                "feedbacks": [
                    "The SUBTRACT set operator does not exist in Oracle SQL. It is not a valid option for generating the required output of displaying rows from SALES1 that are not present in SALES2.",
                    "The INTERSECT set operator would display the rows that are common between SALES1 and SALES2, not the rows that are present in SALES1 but not in SALES2. It is not the correct choice for this scenario.",
                    "The UNION ALL set operator combines the results of two queries, including duplicates. It does not filter out rows that are present in one table but not in the other, so it is not the appropriate choice for this requirement.",
                    "The UNION set operator combines the results of two queries, including duplicates. It does not filter out rows that are present in one table but not in the other, so it is not the correct choice for displaying rows from SALES1 that are not in SALES2.",
                    "The MINUS set operator in Oracle SQL is used to display the rows from the first query that are not present in the result of the second query. It is the correct choice for generating the required output of displaying rows from SALES1 that are not present in SALES2.",
                    "The COMBINE set operator does not exist in Oracle SQL. It is not a valid option for generating the required output of displaying rows from SALES1 that are not present in SALES2."
                ],
                "explanation": "<p>To display the rows from the <code>SALES1</code> table that are <strong>not present</strong> in the <code>SALES2</code> table, the correct set operator to use is: <code><strong>MINUS</strong></code></p><p>Explanation of Set Operators:</p><p><strong>Operator &amp;</strong> <strong>Description</strong> </p><ul><li><p><code>MINUS</code> Returns rows from the first query that are <strong>not</strong> in the second query. </p></li><li><p><code>SUBTRACT</code> Not a valid SQL operator in standard SQL (including Oracle, SQL Server, etc.) </p></li><li><p><code>INTERSECT</code> Returns only the rows that are <strong>common</strong> to both queries. </p></li><li><p><code>UNION</code> Combines results from both queries and removes duplicates. </p></li><li><p><code>UNION ALL</code> Combines results from both queries <strong>including duplicates</strong>.</p></li></ul><p>Example Query Using <code>MINUS</code>:</p><pre class=\"prettyprint linenums\">SELECT * FROM SALES1\nMINUS\nSELECT * FROM SALES2;\n</pre><p>This will return all rows that exist in <code>SALES1</code> but <strong>do not exist</strong> in <code>SALES2</code>.</p><p><br></p><p><strong>MINUS</strong></p><p>The Oracle <code>MINUS</code> operator is used to return all rows in the first <code>SELECT</code> statement that are not returned by the second <code>SELECT</code> statement. Each <code>SELECT</code> statement will define a dataset. The <code>MINUS</code> operator will retrieve all records from the first dataset and then remove from the results all records from the second dataset.</p><p><strong>Minus Query</strong></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-09_13-04-53-11cb5e566a2fcd9a915e10e0fbc51570.png\"></p><p><strong>Explanation:</strong> The <code>MINUS</code> query will return the records in the blue shaded area. These are the records that exist in Table1 and not in Table2.</p><p>Each <code>SELECT</code> statement within the <code>MINUS</code> query must have the same number of fields in the result sets with similar data types.</p>",
                "answers": [
                    "<p><code>SUBTRACT</code> </p>",
                    "<p><code>INTERSECT</code> </p>",
                    "<p><code>UNION ALL</code> </p>",
                    "<p><code>UNION</code> </p>",
                    "<p><code>MINUS</code> </p>",
                    "<p><code>COMBINE</code> </p>"
                ]
            },
            "correct_response": [
                "e"
            ],
            "section": "MINUS",
            "question_plain": "View and examine the description of the SALES1 table.Table: SALES1Name                          Null??            Type\nSALES_ID                      NOT NULL          NUMBER\nSTORE_ID                      NOT NULL          NUMBER\nITEMS_ID                                        NUMBER\nQUANTITY                                        NUMBER\nSALES_DATE                                      DATE\nGiven: SALES2 is a table with the same description as SALES1.Some sales data is duplicated in both tables.Required: Display the rows from the SALES1 table which are not present in the SALES2 table.Identify the set operator would generate the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289429,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Required: </strong></p><ul><li><p>Write a query that prompts users for column names and conditions every time it is executed.</p></li><li><p>The user must be prompted only once for the table name.</p></li></ul><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Prompt user for a parameter value in SQLPlus](https://www.techonthenet.com/oracle/questions/parameter.php)"
                ],
                "feedbacks": [
                    "This choice uses the incorrect syntax for prompting users for column names and conditions. The use of single ampersands (&amp;) for column names and conditions will not prompt the user for input every time the query is executed. Additionally, the double ampersand (&amp;&amp;) for the condition will prompt the user twice for the same condition, which is not the desired behavior.",
                    "This choice does not use the correct syntax for prompting users for input. The use of single ampersands (&amp;) for column names and conditions will not prompt the user for input every time the query is executed. Also, the table name is enclosed in double quotes, which is not necessary for prompting user input.",
                    "This choice correctly uses the double ampersand (&amp;&amp;) for the table name, which prompts the user only once for the table name. The single ampersands (&amp;) for column names and conditions will prompt the user for input every time the query is executed, meeting the required criteria for the query.",
                    "This choice uses single quotes for the column names, table name, and condition, which will not prompt the user for input. Additionally, the use of single ampersands (&amp;) instead of double ampersands (&amp;&amp;) for the table name will prompt the user multiple times for the same input, which is not the desired behavior."
                ],
                "explanation": "<p>The correct SQL query that meets the requirement — prompting the user:</p><ul><li><p>Once for the <strong>table name</strong> (using <code>&amp;&amp;</code>)</p></li><li><p>Every time for <strong>column names</strong> and <strong>conditions</strong> (using <code>&amp;</code>)</p></li></ul><p>— is:</p><pre class=\"prettyprint linenums\">SELECT &amp;col1, &amp;col2 \nFROM &amp;&amp;table \nWHERE condition = &amp;condition;\n</pre><p><br></p><p><strong>Syntax Element</strong> <strong>Behaviour</strong></p><p><code>&amp;parameter</code> Prompts the user for input <strong>each time</strong> it appears in the script. </p><p><code>&amp;&amp;parameter</code> Prompts the user <strong>once</strong>, then reuses the value for the rest of the session. </p><p><code>'&amp;parameter'</code> Treats the input as a <strong>string literal</strong>, which may not be desired for column names. </p><p><code>\"&amp;parameter\"</code> Interprets the input as a <strong>quoted identifier</strong>, which can cause issues unless exact case-sensitive names are used. </p><p><code>'&amp;&amp;parameter'</code> Same as above, but reused — still not suitable for identifiers.</p><p>Why the this Option Works:</p><pre class=\"prettyprint linenums\">SELECT &amp;col1, &amp;col2 --requests input for the column each time it is run\nFROM &amp;&amp;table -- carries the value forward for the entire session, but discarded when the session terminates\nWHERE condition = &amp;condition; -- requests for the condition each time it is run\n</pre><ul><li><p>Prompts once for <code>table</code> name (due to <code>&amp;&amp;table</code>)</p></li><li><p>Prompts every time for <code>col1</code>, <code>col2</code>, and <code>condition</code></p></li><li><p>Uses correct syntax for identifiers (no quotes around column or table names)</p></li></ul><p><br></p><p><strong>Prompting for a numeric value</strong></p><p>In our first example, we'll prompt the user for a supplier_id value.</p><p>In this example, we've entered the following SQL statement:</p><pre class=\"prettyprint linenums\">select * from suppliers\nwhere supplier_id = &amp;supplier_id;</pre><p><br></p><p>SQLPlus will then prompt as follows:</p><pre class=\"prettyprint linenums\">Enter value for supplier_id:</pre><p><br></p><p>In this example, we've entered 1. SQLPlus has then returned records for the following SQL statement:</p><pre class=\"prettyprint linenums\">select * from suppliers\nwhere supplier_id = 1;</pre><p><br></p><p><strong>Prompting for a text value</strong></p><p>In our second example, we'll prompt the user for a supplier_name value.</p><p>In this example, we've entered the following SQL statement:</p><pre class=\"prettyprint linenums\">select * from suppliers\nwhere supplier_name = '&amp;supplier_name';</pre><p><br></p><p>Please note that the <em>&amp;supplier_name</em> value is enclosed in single quotes since the supplier_name field is defined as a varchar2 field.</p><p>SQLPlus will then prompt as follows:</p><pre class=\"prettyprint linenums\">Enter value for supplier_name:</pre><p><br></p><p>In this example, we've entered Microsoft. SQLPlus has then returned records for the following SQL statement:</p><pre class=\"prettyprint linenums\">select * from suppliers\nwhere supplier_id = 'Microsoft';</pre><p><br></p><p><strong>Difference Between \"&amp;\" and \"&amp;&amp;\" Prefixes</strong></p><p>Both single ampersand (&amp;) and double ampersand (&amp;&amp;) can prefix a substitution variable name in a statement. SQL*Plus pre-processes the statement and substitutes the variable's value. The statement is then executed. If the variable was not previously defined then SQL*Plus prompts you for a value before doing the substitution.</p><p>If a single ampersand prefix is used with an undefined variable, the value you enter at the prompt is not stored. Immediately after the value is substituted in the statement the variable is discarded and remains undefined. If the variable is referenced twice, even in the same statement, then you are prompted twice. Different values can be entered at each prompt.</p><p>If a double ampersand reference causes SQL*Plus to prompt you for a value, then SQL*Plus defines the variable as that value (i.e. the value is stored until you exit). Any subsequent reference to the variable (even in the same command) using either \"&amp;\" or \"&amp;&amp;\" substitutes the newly defined value. SQL*Plus will not prompt you again.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT &amp;col1, '&amp;col2'\nFROM &amp;table\nWHERE &amp;&amp;condition = '&amp;condition';\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT &amp;col1, &amp;col2\nFROM \"&amp;table\"\nWHERE &amp;condition = &amp;condition;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT &amp;col1, &amp;col2\nFROM &amp;&amp;table\nWHERE condition = &amp;condition;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT '&amp;col1', '&amp;col2'\nFROM '&amp;&amp;table'\nWHERE condition = '&amp;&amp;condition'\n</pre>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Prompt User for value",
            "question_plain": "View and examine the following available responses.Required: Write a query that prompts users for column names and conditions every time it is executed.The user must be prompted only once for the table name.Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289431,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE),'MON'),'fmonth dd\"is the first Monday for \" fmonth rrrr')\nFROM dual\n</pre><p><br></p><p><strong>Required: </strong>Display the month and date for the first Monday of the next month in the following format: </p><ul><li><p>[month] [day] is the first Monday for the [month] [ year]</p></li></ul><p><strong>Given: </strong>The above SQL query has been executed.</p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The format string in the TO_CHAR function is correct with 'rrrr' for the year format. There is no error related to the format string in the query, so this choice is incorrect.",
                    "The query is designed to display the month and date for the first Monday of the next month, and if executed correctly, it should return the desired result. This choice is incorrect as it suggests the query does not return the correct result.",
                    "The query is structured to display the month and date for the first Monday of the next month in the specified format. If executed successfully, it will return the correct result as requested in the question. This choice is correct.",
                    "The TO_CHAR function is used correctly in the query to format the date output, and there is no need to replace it with TO_DATE. Therefore, this choice is incorrect.",
                    "The usage of 'fm' and double quotation marks in the format string is appropriate for the desired output format. There is no error related to these elements in the query, so this choice is incorrect."
                ],
                "explanation": "<p>Correct Answer: <strong>It executes successfully and returns the correct result.</strong></p><p>Breakdown of the SQL Query:</p><pre class=\"prettyprint linenums\">SELECT TO_CHAR(\n         NEXT_DAY(LAST_DAY(SYSDATE), 'MON'),\n         'fmonth dd\"is the first Monday for \" fmonth rrrr'\n       )\nFROM dual;\n</pre><p><br></p><p><strong>What This Query Does:</strong></p><ol><li><p><code><strong>LAST_DAY(SYSDATE)</strong></code></p><ul><li><p>Returns the last day of the current month.</p></li></ul></li><li><p><code><strong>NEXT_DAY(..., 'MON')</strong></code></p><ul><li><p>Finds the next Monday after that last day — which is the <strong>first Monday of the next month</strong>.</p></li></ul></li><li><p><code><strong>TO_CHAR(..., 'fmonth dd\"is the first Monday for \" fmonth rrrr')</strong></code></p><ul><li><p>Formats the date into a string like:<br><code>\"August 05 is the first Monday for August 2025\"</code></p></li></ul></li></ol><p><strong>Format Model Details: </strong>Format Element &amp; Meaning </p><ul><li><p><code>fmonth</code> Returns the full month name with <strong>no leading spaces</strong> (due to <code>fm</code>). </p></li><li><p><code>dd</code> Day of the month (e.g., 05). <code>\"...\"</code> Literal text included in the output. </p></li><li><p><code>rrrr</code> Four-digit year (Oracle supports both <code>rrrr</code> and <code>yyyy</code>).</p></li></ul><p>Why It Works:</p><ul><li><p><code>rrrr</code> is valid and equivalent to <code>yyyy</code> in Oracle.</p></li><li><p><code>fm</code> (in <code>fmonth</code>) is used to suppress leading spaces — perfectly valid.</p></li><li><p>Quoted text (<code>\"is the first Monday for\"</code>) is correctly embedded in the format string.</p></li><li><p><code>TO_CHAR</code> is appropriate here because we are converting a date to a formatted string.</p></li></ul>",
                "answers": [
                    "<p>It generates an error because rrrr should be replaced by rr in the format string.</p>",
                    "<p>It executes successfully but does not return the correct result.</p>",
                    "<p>It executes successfully and returns the correct result.</p>",
                    "<p>It generates an error because TO_CHAR should be replaced with TO_DATE.</p>",
                    "<p>It generates an error because fm and double quotation marks should not be used in the format string.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.Exhibit 1:SELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE),'MON'),'fmonth dd\"is the first Monday for \" fmonth rrrr')\nFROM dual\nRequired: Display the month and date for the first Monday of the next month in the following format: [month] [day] is the first Monday for the [month] [ year]Given: The above SQL query has been executed.Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289433,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about multiple-row subqueries. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What are subqueries in oracle?](https://techgoeasy.com/sql-subqueries/)",
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "Multiple-row subqueries can indeed contain a subquery within a subquery, allowing for complex nested queries to be executed.",
                    "Multiple-row subqueries have the capability to return multiple columns along with multiple rows, providing flexibility in the data retrieved from the database.",
                    "Contrary to this statement, multiple-row subqueries can indeed contain a subquery within a subquery, enabling the execution of more intricate and detailed queries.",
                    "Multiple-row subqueries are not limited to returning only one column; they can return multiple columns along with multiple rows, providing a comprehensive set of data.",
                    "Multiple-row subqueries can include group functions, GROUP BY, and HAVING clauses, allowing for aggregation and filtering of data based on specified conditions.",
                    "This statement is incorrect as multiple-row subqueries can contain group functions and the GROUP BY clause, as well as the HAVING clause, enabling further manipulation and analysis of data based on specific criteria."
                ],
                "explanation": "<p>True statements about multiple-row subqueries:</p><ol><li><p><strong>They can contain a subquery within a subquery.</strong> (Nested subqueries are a common feature.)</p></li><li><p><strong>They can contain group functions and GROUP BY and HAVING clauses.</strong> (Subqueries are often used to aggregate data and filter based on those aggregations.)</p></li><li><p><strong>They can return multiple columns as well as rows.</strong> (While single-column, multiple-row results are common for <code>IN</code> or <code>ANY</code>/<code>ALL</code> operators, subqueries in the <code>FROM</code> clause or for <code>EXISTS</code> can return multiple columns.)</p></li></ol><p>Incorrect options:</p><ul><li><p><strong>\"They cannot contain a subquery within a subquery.\"</strong></p><ul><li><p><strong>Why it's incorrect:</strong> This directly contradicts the true statement that \"They can contain a subquery within a subquery.\" Nested subqueries are a powerful and common feature in SQL, allowing for complex queries where the result of one subquery feeds into another.</p></li></ul></li><li><p><strong>\"They can return only one column but multiple rows.\"</strong></p><ul><li><p><strong>Why it's incorrect:</strong> While it's true that multiple-row subqueries often return a single column when used with operators like <code>IN</code>, <code>ANY</code>, or <code>ALL</code>, they are not limited to this.</p><ul><li><p><strong>Subqueries in the </strong><code><strong>FROM</strong></code><strong> clause (derived tables):</strong> These can return multiple columns and multiple rows, effectively acting like a temporary table.</p></li><li><p><strong>Correlated subqueries (especially with </strong><code><strong>EXISTS</strong></code><strong>):</strong> While <code>EXISTS</code> itself doesn't return data, the subquery within it might logically be thought of as processing multiple columns internally to determine existence.</p></li><li><p>The statement implies a strict limitation that isn't true for all contexts where multiple-row subqueries are used.</p></li></ul></li></ul></li><li><p><strong>\"They can contain group functions and the GROUP BY clause, but not the HAVING clause.\"</strong></p><ul><li><p><strong>Why it's incorrect:</strong> Subqueries frequently use <code>HAVING</code> clauses, especially when performing aggregations. The <code>HAVING</code> clause is used to filter the <em>groups</em> created by the <code>GROUP BY</code> clause. If a subquery contains <code>GROUP BY</code> and a group function, it can (and often does) contain <code>HAVING</code> to further refine the aggregated results.</p></li></ul></li></ul><p><strong>Oracle SubQueries</strong></p><ol><li><p>A Subquery or Nested query is a query within another SQL query and embedded within the WHERE clause. A subquery is a query within a query</p></li><li><p>A subquery is used to return data that will be used in the main query as a condition to further restrict the data to be retrieved.</p></li><li><p>Subqueries answer the queries that have multiple parts. The parent query answers a part and the sub query answers other part</p></li></ol><p>Subqueries can be used with the <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements along with the operators like <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>IN</code>, <code>BETWEEN</code> etc.</p><p>Using subqueries in a <code>FROM</code> clause is known as an <strong>inline </strong><a href=\"https://techgoeasy.com/oracle-views/\"><strong>view</strong></a>.</p><p>Using subqueries in the <code>WHERE</code> clause is called a <strong>nested subquery</strong>. Up to 255 nested queries are allowed.</p><p><br></p><p><strong>Guidelines for Sql SubQueries</strong></p><ol><li><p>We need to put sub queries in parenthesis always</p></li><li><p>We need to place subqueries on the right side of the comparison operator</p></li><li><p>Use single row operator with single row subqueries and multiple row operator with multiple row subqueries</p></li></ol><p><strong>General Syntax</strong></p><pre class=\"prettyprint linenums\">SELECT col1, col2\nFROM&nbsp;&nbsp; table1\nWHERE&nbsp; col1 &nbsp;OPERATOR\n(SELECT col1\nFROM table2\n[WHERE])\n</pre><p><br></p><p><strong>Single Row Subquery</strong></p><p>It returns only one row of results and uses a single row operator (most common is the equal operator <code>(=)</code>). The other operators are <code>&gt;</code> ,<code>&lt;</code> ,<code>&gt;=</code> ,<code>=&lt;</code>. </p><p>Single row subqueries can select data from the same table or from another table.</p><pre class=\"prettyprint linenums\">SELECT ENAME FROM EMP WHERE SAL =&nbsp;(\n    SELECT MIN(SAL) FROM EMP);\n\nSELECT ENAME FROM EMP WHERE DEPTNO = (\n    SELECT DEPTNO FROM DEPT WHERE DNAME = 'RESEARCH');</pre><p><br></p><p><a href=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-single-row.png\"><img src=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-single-row.png\"></a></p><p><br></p><p><a href=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-single-row-subquery.png\"><img src=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-single-row-subquery.png\"></a></p><p><br></p><p><em>√&nbsp; They can return multiple columns as well as rows.</em></p><p><br></p><p><strong>Multiple Row Subquery</strong></p><p>It returns several rows of results from the subquery, uses the IN operator. In the previous query, if there was more than one research department, the query would have failed. Example of returning more than one row in the subquery.</p><p>The other operator which are used is any and all.</p><pre class=\"prettyprint linenums\">SELECT ENAME, DEPTNO FROM EMP\nWHERE DEPTNO&nbsp;IN (SELECT DEPTNO FROM DEPT WHERE DNAME LIKE 'R%');</pre><p><br></p><p><a href=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-multiple-value.png\"><img src=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-multiple-value.png\"></a></p><p><br></p><p><a href=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-multiple-value-subquery.png\"><img src=\"https://techgoeasy.com/wp-content/uploads/2018/06/sql-subquery-multiple-value-subquery.png\"></a></p><p><br></p><p><strong>Oracle evaluates the whole query above in two steps:</strong></p><p>First, execute the subquery.</p><p>Second, use the result of the subquery in the outer query.</p><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS such as MySQL and PostgreSQL use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p><p><em>√&nbsp; They can contain a subquery within a subquery.</em></p><p><br></p><p><strong>Oracle subquery with comparison operators</strong></p><p>The subqueries that use comparison operators e..g, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, = often include <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a>, because an aggregate function returns a single value that can be used for comparison in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the outer query.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    employee_id, first_name, last_name\nFROM\n    employees\nWHERE\n    employee_id IN(\n        SELECT salesman_id\n        FROM orders\n        INNER JOIN order_items USING(order_id)\n        WHERE status = 'Shipped'\n        GROUP BY salesman_id,\n            EXTRACT(\n                    YEAR\n                    FROM order_date)\n        HAVING SUM( quantity * unit_price )  &gt;= 1000000  \n        AND EXTRACT(\n                    YEAR\n                    FROM order_date) = 2017\n        AND salesman_id IS NOT NULL)\nORDER BY\n    first_name, last_name;</pre><p><br></p><p><em>√ They can contain group functions and GROUP BY and HAVING clauses.</em></p>",
                "answers": [
                    "<p>They can contain a subquery within a subquery.</p>",
                    "<p>They can return multiple columns as well as rows.</p>",
                    "<p>They cannot contain a subquery within a subquery.</p>",
                    "<p>They can return only one column but multiple rows.</p>",
                    "<p>They can contain group functions and GROUP BY and HAVING clauses.</p>",
                    "<p>They can contain group functions and the GROUP BY clause, but not the HAVING clause.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "e"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements about multiple-row subqueries. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289435,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the rules of precedence for operators. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Operator Precedence](https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/operator-precedence.html)",
                    "[Operators, Functions, Expressions, Conditions](https://docs.oracle.com/cd/A58617_01/server.804/a58225/ch3all.htm)"
                ],
                "feedbacks": [
                    "<p>Concatenation, addition and subtraction has the same precedence, in that case it is evaluated from left to right within an expression.</p>",
                    "Using multiple parentheses in an expression allows you to explicitly define the order of operations, overriding the default precedence of operators. This can be useful when you want to ensure a specific calculation order.",
                    "When multiple arithmetic operators with equal precedence are present in an expression, they are evaluated from left to right. This means that the operators will be applied in the order they appear in the expression.",
                    "NULLs do not influence the precedence of operators in an expression. NULL values are treated differently in SQL and do not affect the order of operations for operators.",
                    "The + binary operator has a higher precedence than the concatenation operator | | in SQL expressions. This means that addition is evaluated before concatenation when both operators are present in an expression."
                ],
                "explanation": "<p><strong>True Statements: </strong></p><ol><li><p><strong>Multiple parentheses can be used to override the default precedence of operators in an expression.</strong></p><ol><li><p>Parentheses are evaluated first and can be nested.</p></li><li><p>They are used to explicitly control the order of operations, especially in complex expressions.</p></li></ol></li><li><p><strong>Arithmetic operators with equal precedence are evaluated from left to right within an expression.</strong></p><ol><li><p>Operators with the same precedence level are evaluated based on their associativity.</p></li><li><p>Most arithmetic operators are <strong>left-associative</strong>, meaning they are evaluated from left to right.</p></li></ol></li></ol><p>False Statements:</p><ul><li><p><strong>\"The concatenation operator </strong><code><strong>||</strong></code><strong> is always evaluated before addition and subtraction\"</strong><br>→ This is <strong>not universally true</strong>. In many SQL dialects (like SQL Server), <code>+</code> is used for both addition and string concatenation, and precedence depends on context.</p></li><li><p><strong>\"NULLS influence the precedence of operators in an expression\"</strong><br>→ NULLs affect the <strong>result</strong> of expressions, not the <strong>precedence</strong> of operators.</p></li><li><p><strong>\"The + binary operator is the highest precedence in an expression in a SQL statement\"</strong><br>→ This is incorrect. Operators like <code>*</code>, <code>/</code>, and <code>%</code> have <strong>higher precedence</strong> than <code>+</code> and <code>-</code>.</p></li></ul><p><strong>Operator Precedence</strong></p><p>Operator precedences are shown in the following list, from highest precedence to the lowest. Operators that are shown together on a line have the same precedence.</p><pre class=\"prettyprint linenums\">INTERVAL\nBINARY, COLLATE\n!\n- (unary minus), ~ (unary bit inversion)\n^\n*, /, DIV, %, MOD\n-, +\n&lt;&lt;, &gt;&gt;\n&amp;\n|\n= (comparison), &lt;=&gt;, &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN\nBETWEEN, CASE, WHEN, THEN, ELSE\nNOT\nAND, &amp;&amp;\nXOR\nOR, ||\n= (assignment), :=</pre><p><br></p><p>The precedence of <code>=</code> depends on whether it is used as a comparison operator <code>(=)</code> or as an assignment operator <code>(=)</code>. </p><p>When used as a comparison operator, it has the same precedence as <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_equal-to\"><code>&lt;=&gt;</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_greater-than-or-equal\"><code>&gt;=</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_greater-than\"><code>&gt;</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_less-than-or-equal\"><code>&lt;=</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_less-than\"><code>&lt;</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_not-equal\"><code>&lt;&gt;</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_not-equal\"><code>!=</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_is\"><code>IS</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/string-comparison-functions.html#operator_like\"><code>LIKE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/regexp.html#operator_regexp\"><code>REGEXP</code></a>, and <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/comparison-operators.html#operator_in\"><code>IN()</code></a>. When used as an assignment operator, it has the same precedence as <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/assignment-operators.html#operator_assign-value\"><code>:=</code></a>. </p><p>For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.</p><p>The precedence of operators determines the order of evaluation of terms in an expression. To override this order and group terms explicitly, use parentheses. For example:</p><pre class=\"prettyprint linenums\">SELECT 1+2*3;\n        -&gt; 7\nSELECT (1+2)*3;\n        -&gt; 9</pre><p><em>√&nbsp; Multiple parentheses can be used to override the default precedence of operators in an expression.</em></p><p><br></p><p><em>Precedence</em> is the order in which Oracle evaluates different operators in the same expression. When evaluating an expression containing multiple operators, Oracle evaluates operators with higher precedence before evaluating those with lower precedence. Oracle evaluates operators with equal precedence from left to right within an expression.</p><p><em>√&nbsp; Arithmetic operators with equal precedence area evaluated from left to right within an expression.</em></p>",
                "answers": [
                    "<p>The concatenation operator | | is always evaluated before addition and subtraction in an expression.</p>",
                    "<p>Multiple parentheses can be used to override the default precedence of operators in an expression.</p>",
                    "<p>Arithmetic operators with equal precedence area evaluated from left to right within an expression.</p>",
                    "<p>NULLS influence the precedence of operators in an expression.</p>",
                    "<p>The + binary operator is the highest precedence in an expression in a SQL statement.</p>"
                ]
            },
            "correct_response": [
                "b",
                "c"
            ],
            "section": "Operator precedences",
            "question_plain": "View and examine the following available responses.Identify the true statements about the rules of precedence for operators. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289437,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT&nbsp;NVL(arg1, arg2)\nFROM dual;\n</pre><p><br></p><p>Identify the true statements regarding the NVL statement in the exhibit. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Difference between Implicit Conversion and Explicit Conversion in SQL Server](https://stackoverflow.com/questions/20967973/difference-between-implicit-conversion-and-explicit-conversion-in-sql-server)",
                    "[NVL](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/NVL.html)",
                    "[Implicit conversion](https://community.oracle.com/thread/2614986)"
                ],
                "feedbacks": [
                    "This statement is true because when using NVL with a VARCHAR2 argument, Oracle DB will convert the second argument to the datatype of the first argument before comparing them. The return value will be in the character set of the first argument.",
                    "This statement is incorrect as the NVL function can be used with arguments of the DATE datatype. It can handle different data types, not just VARCHAR2 or NUMBER.",
                    "This statement is incorrect because the arguments arg1 and arg2 do not have to be matching data types for the NVL function to work. It can handle different data types and perform conversions as needed.",
                    "This statement is incorrect as the NVL function can handle data types other than just VARCHAR2 or NUMBER. It is not limited to only these two data types.",
                    "This statement is true because explicit conversions are preferred over implicit conversions when using NVL with arguments of different data types. This ensures that the data is handled correctly and avoids any potential issues with implicit conversions."
                ],
                "explanation": "<p>True Statements: </p><ol><li><p><strong>If </strong><code><strong>arg1</strong></code><strong> is </strong><code><strong>VARCHAR2</strong></code><strong>, then Oracle DB converts </strong><code><strong>arg2</strong></code><strong> to the datatype of </strong><code><strong>arg1</strong></code><strong> before comparing them and returns </strong><code><strong>VARCHAR2</strong></code><strong> in the character set of </strong><code><strong>arg1</strong></code><strong>.</strong></p><ol><li><p>Oracle performs <strong>implicit conversion</strong> of <code>arg2</code> to match the datatype of <code>arg1</code> when they differ.</p></li><li><p>If <code>arg1</code> is character data, <code>arg2</code> is converted to that character type and the result is in the character set of <code>arg1</code>.</p></li></ol></li><li><p><strong>Explicit conversions are preferred to implicit conversions if </strong><code><strong>arg1</strong></code><strong> is a different datatype than </strong><code><strong>arg2</strong></code><strong>.</strong></p><ol><li><p>While Oracle allows implicit conversions, it is <strong>best practice</strong> to use explicit conversions to avoid unexpected behavior or errors.</p></li><li><p>This ensures clarity and control over how data is interpreted and returned.</p></li></ol></li></ol><p>False Statements :</p><ul><li><p><strong>\"An NVL function cannot be used with arguments of DATE datatype\"</strong><br>→ Incorrect. <code>NVL</code> <strong>can</strong> be used with <code>DATE</code> values, as long as both arguments are of compatible types.</p></li><li><p><strong>\"The arguments </strong><code><strong>arg1</strong></code><strong> and </strong><code><strong>arg2</strong></code><strong> must be matching data types.\"</strong><br>→ Not strictly true. Oracle allows <strong>different datatypes</strong> and performs <strong>implicit conversion</strong> when necessary.</p></li><li><p><strong>\"The two expressions </strong><code><strong>arg1</strong></code><strong> and </strong><code><strong>arg2</strong></code><strong> should only be in </strong><code><strong>VARCHAR2</strong></code><strong> or </strong><code><strong>NUMBER</strong></code><strong> data type format.\"</strong><br>→ False. <code>NVL</code> supports <strong>any datatype</strong>, including <code>DATE</code>, <code>TIMESTAMP</code>, and more, as long as they are compatible or convertible.</p></li></ul><p><br></p><p><strong>Implicit conversions</strong> are not visible to the user. SQL Server automatically converts the data from one data type to another. For example, when a <code>smallint</code> is compared to an <code>int</code>, the <code>smallint</code> is implicitly converted to int before the comparison proceeds. <code>GETDATE()</code> implicitly converts to date style 0. <code>SYSDATETIME()</code> implicitly converts to date style 21.</p><p><strong>Explicit conversions</strong> use the <code>CAST</code> or <code>CONVERT</code> functions. The CAST and CONVERT functions convert a value (a local variable, a column, or another expression) from one data type to another. For example, the following CAST function converts the numeric value of <em>$157.27</em> into a character string of <em>'157.27'</em>:</p><p><br></p><p><strong>NVL </strong></p><p><code>NVL</code> lets you replace null (returned as a blank) with a string in the results of a query. If <code>expr1</code> is null, then <code>NVL</code> returns <code>expr2</code>. If <code>expr1</code> is not null, then <code>NVL</code> returns <code>expr1</code>.</p><p>The arguments <code>expr1</code> and <code>expr2</code> can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows:</p><p>If <code>expr1</code> is character data, then Oracle Database converts <code>expr2</code> to the data type of <code>expr1</code> before comparing them and returns <code>VARCHAR2</code> in the character set of <code>expr1</code>.</p><p>If <code>expr1</code> is numeric, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type.</p><p><em>√&nbsp; If arg1 is VARCHAR2, then Oracle DB converts arg2 to the datatype of arg1 before comparing them and returns VARCHAR2 in the character set of arg1.</em></p><p><br></p><p><strong>Implicit conversions are never necessary. </strong>Explicit conversions are always simple. Always use the correct datatype. If you must convert from one datatype to another, use an explicit conversion.</p><p><em>√&nbsp; Explicit conversions are preferred to implicit conversions if arg1 is a different datatype than arg2.</em></p><p><br></p><p><strong>The Oracle/PLSQL NVL function</strong> lets you substitute a value when a null value is encountered.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>NVL</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">NVL( string1, replace_with )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string1 - The string to test for a null value. </p><p>replace_with - The value returned if <em>string1</em> is null.</p><p><strong>Returns</strong></p><p>The <code>NVL</code> function returns a substitute value.</p><p><a href=\"https://www.techonthenet.com/oracle/functions/nvl.php\">https://www.techonthenet.com/oracle/functions/nvl.php</a></p>",
                "answers": [
                    "<p>If arg1 is VARCHAR2, then Oracle DB converts arg2 to the datatype of arg1 before comparing them and returns VARCHAR2 in the character set of arg1.</p>",
                    "<p>An NVL function cannot be used with arguments of DATE datatype.</p>",
                    "<p>The arguments arg1 and arg2 must be matching data types.</p>",
                    "<p>The two expressions arg1 and arg2 should only be in VARCHAR2 or NUMBER data type format.</p>",
                    "<p>Explicit conversions are preferred to implicit conversions if arg1 is a different datatype than arg2.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "Conversions",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT&nbsp;NVL(arg1, arg2)\nFROM dual;\nIdentify the true statements regarding the NVL statement in the exhibit. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289439,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the data types. (Choose three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What is the max size of VARCHAR2 in PL/SQL and SQL?](https://stackoverflow.com/questions/25237463/what-is-the-max-size-of-varchar2-in-pl-sql-and-sql)",
                    "[Datatype Limits](https://docs.oracle.com/cd/B28359_01/server.111/b28320/limits001.htm#i287903)",
                    "[Character Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-1BABC478-FB47-4962-9B0C-8B8BD059E733)"
                ],
                "feedbacks": [
                    "The minimum column width for a varchar2 data type column is indeed one character. This allows for flexibility in storing variable-length character data.",
                    "In Oracle Database, only one LONG column is allowed per table. LONG data type is used to store variable-length character data, but it is considered deprecated and should be replaced with CLOB data type.",
                    "A TIMESTAMP data type column in Oracle Database stores both date and time values, including fractional seconds. It is not limited to storing only time values with fractional seconds.",
                    "The BLOB data type in Oracle Database is used to store large binary data, such as images or documents, directly in the database. It is not specifically used to store binary data in an operating system file.",
                    "The value for a CHAR data type column in Oracle Database is indeed blank-padded to the maximum defined column width. This ensures that all values in the column have the same length, regardless of the actual length of the stored data."
                ],
                "explanation": "<p>True statements: </p><p><strong>1. The minimum column width that can be specified for a </strong><code><strong>VARCHAR2</strong></code><strong> data type column is one.</strong></p><ul><li><p><strong>Explanation</strong>: In Oracle, <code>VARCHAR2(n)</code> must have <code>n ≥ 1</code>. You cannot define a <code>VARCHAR2(0)</code> column.</p></li><li><p><code>VARCHAR2</code> - Variable-length character string having maximum length size bytes or characters. Maximum size is 4000 bytes or characters, and <strong>minimum is 1 byte or 1 character</strong>. </p></li><li><p>You must specify size for VARCHAR2. BYTE indicates that the column will have byte length semantics; CHAR indicates that the column will have character semantics.</p></li></ul><p>2. <strong>Only one </strong><code><strong>LONG</strong></code><strong> column can be used per table.</strong></p><ul><li><p><strong>Explanation</strong>: Oracle restricts tables to <strong>one </strong><code><strong>LONG</strong></code><strong> column</strong>. <code>LONG</code> is a deprecated data type used for storing large character data.</p></li><li><p><code>LONG</code> Maximum size: 2 GB - 1 <strong>Only one </strong><code><strong>LONG</strong></code><strong> column is allowed per table.</strong></p></li></ul><p>3. <strong>The value for a </strong><code><strong>CHAR</strong></code><strong> data type column is blank-padded to the maximum defined column width.</strong></p><ul><li><p><strong>Explanation</strong>: <code>CHAR(n)</code> always stores <strong>exactly n characters</strong>, padding with spaces as needed.</p></li><li><p><code>CHAR</code> - <strong>Fixed-length character data of length</strong> <code>size</code> bytes or characters. Maximum <code>size</code> is 2000 bytes or characters. Default and minimum <code>size</code> is 1 byte. </p></li><li><p>If the value entered is less than the fixed length, blank placeholders are added to top-up the data length.</p></li></ul><p><strong>False statements</strong>: </p><p><strong>A </strong><code><strong>TIMESTAMP</strong></code><strong> data type column stores only time values with fractional seconds.</strong></p><ul><li><p><strong>Correction</strong>: <code>TIMESTAMP</code> stores <strong>both date and time</strong>, including fractional seconds. It does <em>not</em> store only time.</p></li></ul><p><strong>The </strong><code><strong>BLOB</strong></code><strong> data type column is used to store binary data in an operating system file.</strong></p><ul><li><p><strong>Correction</strong>: <code>BLOB</code> stores binary data <strong>in the database</strong>, <strong>not</strong> in an OS file. For storing external file references, <code>BFILE</code> is used.</p></li></ul>",
                "answers": [
                    "<p>The minimum column width that can be specified for a varchar2 data type column is one.</p>",
                    "<p>Only one LONG column can be used per table.</p>",
                    "<p>A TIMESTAMP data type column stores only time values with fractional seconds.</p>",
                    "<p>The BLOB data type column is used to store binary data in an operating system file.</p>",
                    "<p>The value for a CHAR data type column is blank-padded to the maximum defined column width.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "e"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the data types. (Choose three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289441,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about indexes and their administration in an Oracle database. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Indexes](https://www.techonthenet.com/oracle/indexes.php)",
                    "[Oracle Create Index](https://www.oracletutorial.com/oracle-index/oracle-create-index/)",
                    "[Invisible Indexes in Oracle Database](https://oracle-base.com/articles/11g/invisible-indexes-11gr1)"
                ],
                "feedbacks": [
                    "An index can indeed be created as part of a CREATE TABLE statement in an Oracle database. This allows for the creation of an index on a specific column at the same time the table is created, improving query performance.",
                    "A DROP INDEX statement does not always prevent updates to the table during the drop operation in an Oracle database. While the index is being dropped, updates to the table may still be allowed, depending on the locking mechanism and isolation level being used.",
                    "A descending index is a type of function-based index in an Oracle database. It allows for the sorting of data in descending order based on the indexed column, providing flexibility in query optimization and performance improvement.",
                    "If a query filters on an indexed column in an Oracle database, it does not guarantee that the index will always be used during the execution of the query. The optimizer may choose to use the index based on factors such as data distribution, query complexity, and available statistics.",
                    "An INVISIBLE index in an Oracle database is maintained when Data Manipulation Language (DML) operations are performed on its underlying table. The index is still available for query optimization, but it is not visible to the optimizer by default, allowing for testing and performance evaluation without affecting query plans."
                ],
                "explanation": "<p><strong>True statements</strong>: </p><p><strong>1. An index can be created as part of a </strong><code><strong>CREATE TABLE</strong></code><strong> statement.</strong></p><ul><li><p><strong>Explanation</strong>: You <strong>can</strong> define <strong>indexes on columns</strong> when creating a table using <strong>constraints</strong> (e.g., <code>PRIMARY KEY</code>, <code>UNIQUE</code>). Oracle implicitly creates indexes for these constraints.</p></li></ul><p>2. <strong>A descending index is a type of function-based index.</strong></p><ul><li><p><strong>Explanation</strong>: In Oracle, a descending index is implemented using a function-based index internally (e.g., <code>ORDER BY column DESC</code> translates to indexing on <code>-column</code> or similar logic).</p></li></ul><p><strong>False statements</strong>: </p><p><strong>A </strong><code><strong>DROP INDEX</strong></code><strong> statement always prevents updates to the table during the drop operation.</strong></p><ul><li><p><strong>Correction</strong>: Dropping an index does <strong>not</strong> lock the table against DML (INSERT/UPDATE/DELETE). DML operations <strong>can still occur</strong> during index drop.</p></li><li><p><strong>If you define ONLINE then DML operations will be allowed during the dropping of the index.</strong></p></li></ul><p><strong>If a query filters on an indexed column then it will always be used during execution of the query.</strong></p><ul><li><p><strong>Correction</strong>: The <strong>optimizer</strong> decides whether to use the index or not based on statistics and cost. So, even if a column is indexed, it <strong>might not be used</strong> in a query.</p></li></ul><p><strong>An </strong><code><strong>INVISIBLE</strong></code><strong> index is not maintained when DML is performed on its underlying table.</strong></p><ul><li><p><strong>Correction</strong>: <strong>Invisible indexes are still maintained</strong> during DML operations. They’re just <strong>ignored by the optimizer</strong> unless explicitly enabled for use.</p></li></ul><p><strong>An index is a performance-tuning method</strong> of allowing faster retrieval of records. An index creates an entry for each value that appears in the indexed columns. By default, Oracle creates B-tree indexes.</p><p><strong>Create an Index</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating an index in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE [UNIQUE] INDEX index_name\n  ON table_name (column1, column2, ... column_n)\n  [ COMPUTE STATISTICS ];</pre><p>UNIQUE - It indicates that the combination of values in the indexed columns must be unique. </p><p>index_name - The name to assign to the index. </p><p>table_name - The name of the table in which to create the index. </p><p>column1, column2, ... column_n - The columns to use in the index. </p><p>COMPUTE STATISTICS - It tells Oracle to collect statistics during the creation of the index. The statistics are then used by the optimizer to choose a \"plan of execution\" when SQL statements are executed.</p><p><br></p><p><strong>CREATE&nbsp;TABLE with INDEX</strong></p><p>The following statement <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-create-table/\">creates a new table</a> named <code>members</code> that stores members’ data:</p><pre class=\"prettyprint linenums\">CREATE TABLE members(\n    member_id INT GENERATED BY DEFAULT AS IDENTITY,\n    first_name VARCHAR2(100) NOT NULL,\n    last_name VARCHAR2(100) NOT NULL,\n    gender CHAR(1) NOT NULL,\n    dob DATE NOT NULL,\n    email VARCHAR2(255) NOT NULL,\n    PRIMARY KEY(member_id)\n);</pre><p><br></p><p>The <code>members</code> table has a primary key column, therefore,<code>member_id</code> Oracle created a new index for this column. To view all indexes of a table, you query from the <code>all_indexes</code> view:</p><pre class=\"prettyprint linenums\">SELECT index_name, index_type, visibility, status \nFROM all_indexes\nWHERE table_name = 'MEMBERS';</pre><p><br></p><p>The Oracle database supports descending indexes which has a special min/max execution plans associated with their usage. With a descending index you will see the execution plan reference the index.</p><pre class=\"prettyprint linenums\">INDEX RANGE SCAN DESCENDING</pre><p>It is interesting to note that when you create an index with the \"desc\" option, it creates a index as a composite function based index. The choice of ascending or descending index when defining an index would depend on the kind of SQL queries that you want to answer using that index.</p><p><br></p><p>Oracle 11g allows indexes to be marked as invisible. Invisible indexes are maintained like any other index, but they are ignored by the optimizer unless the <code>OPTIMIZER_USE_INVISIBLE_INDEXES</code> parameter is set to <code>TRUE</code> at the instance or session level. Indexes can be created as invisible by using the <code>INVISIBLE</code> keyword, and their visibility can be toggled using the <code>ALTER INDEX</code> command.</p>",
                "answers": [
                    "<p>An index can be created as part of a CREATE TABLE statement.</p>",
                    "<p>A DROP INDEX statement always prevents updates to the table during the drop operation.</p>",
                    "<p>A descending index is a type of function-based index.</p>",
                    "<p>If a query filters on an indexed column then it will always be used during execution of the query.</p>",
                    "<p>An INVISIBLE index is not maintained when Data Manipulation Language (DML) is performed on its underlying table.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "INDEX",
            "question_plain": "View and examine the following available responses.Identify the true statements about indexes and their administration in an Oracle database. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289443,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the details of the ORDER_ITEMS table.</p><p><strong>Table: ORDER_ITEMS </strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-02-13_16-31-06-1ed751b9934c0c425cc1f5d48199c9a4.png\"></p><p><br></p><p>Evaluate the following SQL statements.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items;\n</pre><p><br></p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items\nGROUP&nbsp;BY order_id;\n</pre><p><br></p><p>Identify the true statements regarding the output of these SQL statements. (Choose all that apply.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Exhibit 2 includes a GROUP BY clause on the order_id column, which means the query will return multiple rows of output, each representing the maximum order value for a specific order_id.",
                    "Exhibit 1 does not include a GROUP BY clause, so it will calculate the maximum order value across all rows in the ORDER_ITEMS table and return only one row of output with the overall maximum order value.",
                    "Exhibit 1 will return output as it calculates the maximum order value across all rows in the ORDER_ITEMS table. Therefore, this statement is incorrect.",
                    "The two statements would not give the same output. Exhibit 1 calculates the overall maximum order value, while Exhibit 2 calculates the maximum order value for each order_id, resulting in multiple rows of output."
                ],
                "explanation": "<p>SQL Statement Analysis</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items;\n</pre><ul><li><p>This computes the maximum value of <code>unit_price * quantity</code> across the entire table.</p></li><li><p>It returns <strong>a single row</strong> with one column: the highest total for any line item.</p></li></ul><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items\nGROUP&nbsp;BY order_id;\n</pre><ul><li><p>This groups the data by <code>order_id</code>, then finds the maximum <code>unit_price * quantity</code> <strong>within each order</strong>.</p></li><li><p>It returns <strong>one row per order</strong>, showing the highest line item total for that order.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-09_20-33-27-4dac325fd31074d99016312c80c9157e.png\"></p><p><br></p><p>Incorrect statements:</p><p>Exhibit 1 would not return any output.</p><ul><li><p>The table has valid data, so it will return a result.</p></li></ul><p>Both the statements would give the same output.</p><ul><li><p>Exhibit 1 gives one overall max; Exhibit 2 gives max per order.</p></li></ul>",
                "answers": [
                    "<p>Exhibit 2 would return multiple rows of output.</p>",
                    "<p>Exhibit 1 would return only one row of output.</p>",
                    "<p>Exhibit 1 would not return any output.</p>",
                    "<p>Both the statements would give the same output.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the details of the ORDER_ITEMS table.Table: ORDER_ITEMS Evaluate the following SQL statements.Exhibit 1:SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items;\nExhibit 2:SELECT MAX(unit_price*quantity) \"Maximum Order\"\nFROM order_items\nGROUP&nbsp;BY order_id;\nIdentify the true statements regarding the output of these SQL statements. (Choose all that apply.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289445,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure and data in the PRICE_LIST table.</p><p><strong>Table: PRICE_LIST </strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nPROD_ID                       NOT NULL          NUMBER(3)\nPROD_PRICE                                      VARCHAR2(10)\n</pre><p><br></p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">PROD_ID                   PROD_PRICE\n100                       $1,234.55\n101                       $6,509.75\n102                       $1,234.00\n </pre><p><br></p><p><strong>Required:</strong> Give a discount of 25% on the product price and display the discount amount in the same format as the PROD_PRICE.</p><p>Identify the SQL queries which would give you the required output. (Select two.)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query correctly selects the product ID and price from the PRICE_LIST table, calculates a 25% discount on the product price using TO_NUMBER and TO_CHAR functions, and formats the discount amount in the same format as the original price. The query uses the correct syntax and functions to achieve the required output.",
                    "This query correctly selects the product ID from the PRICE_LIST table, calculates a 25% discount on the product price using TO_NUMBER and TO_CHAR functions, and formats the discount amount in the same format as the original price. The query uses the correct syntax and functions to achieve the required output.",
                    "This query correctly selects the product ID from the PRICE_LIST table, calculates a 25% discount on the product price using TO_NUMBER and TO_CHAR functions, and formats the discount amount in the same format as the original price. The query uses the correct syntax and functions to achieve the required output.",
                    "This query attempts to convert the product price to a number and calculate a 25% discount, but it uses incorrect syntax and functions. The TO_NUMBER function is used incorrectly, and the formatting of the discount amount is not done in the same format as the original price. This query will not provide the required output.",
                    "<p>This choice is incorrect as there are correct options that will execute properly and provide the required output.</p>"
                ],
                "explanation": "<p>We are given:</p><ul><li><p>Table: <code>PRICE_LIST</code></p></li><li><p>Columns:</p><ul><li><p><code>PROD_ID</code>: <code>NUMBER(3)</code></p></li><li><p><code>PROD_PRICE</code>: <code>VARCHAR2(10)</code> — stores values like <code>$1,234.55</code></p></li></ul></li></ul><p><strong>Objective</strong></p><p>Apply <strong>25% discount</strong> to <code>PROD_PRICE</code> and <strong>display the discount amount</strong> in the <strong>same format as </strong><code><strong>PROD_PRICE</strong></code>, i.e., in dollar format (<code>$9,999.00</code> or similar).</p><p><strong>Correct Approach</strong></p><p>To get the correct output:</p><ol><li><p>Convert <code>PROD_PRICE</code> <strong>from string to number</strong> using <code>TO_NUMBER</code>.</p></li><li><p>Multiply it by <code>0.25</code> to get the discount.</p></li><li><p>Use <code>TO_CHAR</code> to format the result as currency (<code>$999,999.00</code>).</p></li></ol><p><strong>Option Review</strong></p><p><strong>Option 1</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, prod_price AS \"Regular Price\", \n    TO_CHAR(\n        (TO_NUMBER(prod_price, '$9,999.99') * .25), '$9,999.00') \nAS \"Discount\" \nFROM price_list;\n</pre><ul><li><p>Correct usage of <code>TO_NUMBER()</code> and <code>TO_CHAR()</code></p></li><li><p>Uses proper format models.</p></li><li><p><strong>Valid and will execute properly.</strong></p></li></ul><p><strong>Option 2</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_CHAR(\n        (TO_NUMBER(prod_price, '$999,999.99') * .25), '$999,999.00') AS \"Discount\" \nFROM price_list;\n</pre><ul><li><p>Same logic as Option 1, but with a larger format mask (which is also valid).</p></li><li><p><strong>Valid and will execute properly.</strong></p></li></ul><p><strong>Option 3</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_CHAR (\n        TO_NUMBER(prod_price, '$999,999.99') * .25, '$999,999.00') AS \"Discount\" \nFROM PRICE_LIST;\n</pre><ul><li><p>Functionally same as Option 2, different whitespace.</p></li><li><p><strong>Also valid</strong>.</p></li></ul><p><strong>Option 4</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_NUMBER (\n        TO_NUMBER(prod_price, '$999,999.99') * .25, '$999,999.00')\nFROM PRICE_LIST;\n</pre><ul><li><p><code>TO_NUMBER(..., format)</code> is invalid <strong>for numeric input</strong> — format is for <strong>strings</strong>, not numbers.</p></li><li><p>This will throw <strong>ORA-01722: invalid number</strong> or similar error.</p></li><li><p><strong>Invalid</strong></p></li></ul><p><strong>Option 5</strong> is also valid, but question asks for <strong>two</strong> answers.)</p><p> None of the options will execute properly</p><p>Incorrect, as Options 1, 2, 3 do execute properly.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-05-18_22-17-02-35700347f81c7cbf5b70fea5ca928409.png\"></p><p>Note: There is an extra space between . and 25 (. 25) causing the statement to fail</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, prod_price AS \"Regular Price\", \n    TO_CHAR(\n        (TO_NUMBER(prod_price, '$9,999.99') * .25),'$9,999.00') \nAS \"Discount\" FROM price_list;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_CHAR(\n        (TO_NUMBER(prod_price, '$999,999.99') * .25),'$999,999.00') AS \"Discount\" \nFROM price_list;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_CHAR (\n        TO_NUMBER(prod_price, '$999,999.99') * .&nbsp; 25, '$999,999.00') AS \"Discount\" \nFROM PRICE_LIST\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT prod_id, \n    TO_NUMBER (\n        TO_NUMBER(prod_price, '$999,999.99') * .&nbsp; 25, '$999,999.00')\nFROM PRICE_LIST\n</pre>",
                    "<p>None of the options will execute properly.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure and data in the PRICE_LIST table.Table: PRICE_LIST Name                          Null??            Type\nPROD_ID                       NOT NULL          NUMBER(3)\nPROD_PRICE                                      VARCHAR2(10)\nExhibit 1:PROD_ID                   PROD_PRICE\n100                       $1,234.55\n101                       $6,509.75\n102                       $1,234.00\n Required: Give a discount of 25% on the product price and display the discount amount in the same format as the PROD_PRICE.Identify the SQL queries which would give you the required output. (Select two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289447,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the Oracle join and ANSI join syntax. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle9i ANSI/ISO SQL:1999-Compliant SQL](https://www.freelists.org/post/oracle/Oracle9i-ANSIISO-SQL1999Compliant-SQL)",
                    "[Equijoins](https://docs.oracle.com/database/121/SQLRF/queries006.htm#SQLRF52351)"
                ],
                "feedbacks": [
                    "The Oracle join syntax does not support natural joins. Natural joins are not recommended due to potential ambiguity in column names.",
                    "The Oracle join syntax is optimized for Oracle databases and may perform better in certain scenarios compared to the SQL:1999 compliant ANSI join syntax.",
                    "The Oracle join syntax does support the creation of a Cartesian product of two tables, where every row in the first table is combined with every row in the second table.",
                    "The SQL:1999 compliant ANSI join syntax does support natural joins, which join tables based on columns with the same name and data type.",
                    "It is not accurate to say that the Oracle join syntax always performs better than the SQL:1999 compliant ANSI join syntax. Performance can vary based on the specific query and database configuration.",
                    "The Oracle join syntax supports various types of joins, including inner joins, outer joins, and cross joins. It is not limited to only right outer joins.",
                    "The SQL:1999 compliant ANSI join syntax also supports the creation of a Cartesian product of two tables, similar to the Oracle join syntax."
                ],
                "explanation": "<p>Correct Statements:</p><ol><li><p><strong>The Oracle join syntax supports creation of a Cartesian product of two tables.</strong></p><ul><li><p>True. If no join condition is specified in Oracle's traditional join syntax (e.g., <code>FROM table1, table2</code> without a <code>WHERE</code> clause), it results in a Cartesian product—every row from one table is combined with every row from the other.</p></li></ul></li><li><p><strong>The SQL:1999 compliant ANSI join syntax supports natural joins.</strong></p><ul><li><p>True. ANSI SQL supports the <code>NATURAL JOIN</code> keyword, which automatically joins tables based on columns with the same name and compatible data types.</p></li></ul></li><li><p><strong>The SQL:1999 compliant ANSI join syntax supports creation of a Cartesian product of two tables.</strong></p><ul><li><p>True. ANSI SQL allows Cartesian products using the <code>CROSS JOIN</code> syntax, which explicitly returns all combinations of rows from two tables.</p></li></ul></li></ol><p>Incorrect Statements:</p><ul><li><p><strong>The Oracle join syntax supports natural joins.</strong></p><ul><li><p>False. Oracle's traditional (non-ANSI) join syntax does not support <code>NATURAL JOIN</code>. That is a feature of ANSI SQL.</p></li></ul></li><li><p><strong>The Oracle join syntax performs less well than the SQL:1999 compliant ANSI join syntax.</strong></p><ul><li><p>False. Performance is generally the same; the difference is in readability and flexibility, not execution speed.</p></li></ul></li><li><p><strong>The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax.</strong></p><ul><li><p>False. Again, performance is typically equivalent. Oracle recommends ANSI syntax for clarity and maintainability.</p></li></ul></li><li><p><strong>The Oracle join syntax only supports right outer joins.</strong></p><ul><li><p>False. Oracle's traditional syntax supports left, right, and full outer joins using the <code>(+)</code> operator, though it's more limited and less readable than ANSI syntax.</p></li></ul></li></ul><p><strong>1. SQL:1999 Joins </strong></p><p> SQL:1999 join syntax differs from traditional Oracle join syntax in that the join type is specified explicitly in the FROM clause. </p><p> Oracle9i introduces the following SQL:1999-compliant joins: </p><p>&nbsp; &nbsp; &nbsp;1.1 CROSS Join </p><p>&nbsp; &nbsp; 1.2 NATURAL Join </p><p>&nbsp; &nbsp; 1.3 OUTER Join </p><p>&nbsp; &nbsp; 1.3.1 LEFT OUTER Join </p><p>&nbsp; &nbsp; 1.3.2 RIGHT OUTER Join </p><p>&nbsp; &nbsp; 1.3.3 FULL OUTER Join </p><p> </p><p><strong>1.1 CROSS Join </strong></p><p> A CROSS join is the cross-product of two tables. It is the equivalent of a Cartesian product. </p><p><strong>1.2 NATURAL Join </strong>\n</p><p>A NATURAL join selects rows from the tables which have equal values in all matched columns(same column names). If the columns having the same nameshave different datatypes, an error is returned. \n</p><p>If SELECT * syntax is used, the common columns appear only once in the result set.&nbsp; </p><p>Qualifiers such as table names or aliases may not be used for those columns involved in the natural join. </p><p><strong>1.3 OUTER Join </strong>\n</p><p>The join of two tables returning only matched rows is considered an INNER JOIN. \n</p><p>A join between two tables which returns the result of the INNER join as well as unmatched rows from the LEFT(or RIGHT) table is a LEFT(or RIGHT) OUTER join. \n</p><p>INNER and OUTER JOINS were available in prior relaeses. The '(+)' symbol was used on one of the tables to create outer joins.&nbsp; \n </p><p><strong>1.3.1 LEFT OUTER Join </strong>\n</p><p>A join between two tables which returns the result of the INNER join as well as&nbsp; unmatched rows from the LEFT table is a LEFT OUTER join.</p><p><strong>1.3.2 RIGHT OUTER Join </strong></p><p>A join between two tables which returns the result of the INNER join as well as unmatched rows from the RIGHT table is a RIGHT OUTER join. </p><p><strong>1.3.3 FULL OUTER Join </strong></p><p>A join between two tables which returns the result of the INNER join as well as unmatched rows from the LEFT and RIGHT outer joins is a FULL OUTER join.</p><p>This&nbsp; is a new type of join in Oracle9i which did not exist previously. </p><p><br></p><p><strong>Cartesian Products</strong></p><p>If two tables in a join query have no join condition, then Oracle Database returns their Cartesian product. Oracle combines each row of one table with each row of the other. A Cartesian product always generates many rows and is rarely useful. For example, the Cartesian product of two tables, each with 100 rows, has 10,000 rows. Always include a join condition unless you specifically need a Cartesian product. If a query joins three or more tables and you do not specify a join condition for a specific pair, then the optimizer may choose a join order that avoids producing an intermediate Cartesian product.</p><p>Oracle join syntax uses a Cartesian product by default.</p>",
                "answers": [
                    "<p>The Oracle join syntax supports natural joins.</p>",
                    "<p>The Oracle join syntax performs less well than the SQL:1999 compliant ANSI join syntax.</p>",
                    "<p>The Oracle join syntax supports creation of a Cartesian product of two tables.</p>",
                    "<p>The SQL:1999 compliant ANSI join syntax supports natural joins.</p>",
                    "<p>The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax.</p>",
                    "<p>The Oracle join syntax only supports right outer joins.</p>",
                    "<p>The SQL:1999 compliant ANSI join syntax supports creation of a Cartesian product of two tables.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d",
                "g"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements about the Oracle join and ANSI join syntax. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289449,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibits.</p><p><strong>Given:</strong> The current SYSDATE output is 7/8/2025.</p><p><strong>Exhibit 1:</strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question/2025-07-08_18-22-02-43ecc13c8f776bd65f735c9603c85cb1.png\"></p><p><br></p><p>The following query is run:</p><p><strong>Exhibit 2:</strong></p><pre class=\"prettyprint linenums\">SELECT SUBSTR(TO_CHAR(SYSDATE + 90, 'DD-MON-YYYY'), 7, 4)\nFROM dual;\n</pre><p><br></p><p>Identify the result of the query execution as of the current date.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: SUBSTR Function](https://www.techonthenet.com/oracle/functions/substr.php)",
                    "[Oracle / PLSQL: TRUNC Function (with dates)](https://www.techonthenet.com/oracle/functions/trunc_date.php)",
                    "[Oracle / PLSQL: ROUND Function (with dates)](https://www.techonthenet.com/oracle/functions/round_date.php)"
                ],
                "feedbacks": [
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>",
                    "<p>The query adds 90 days to the current date (7/8/2025) and extracts the year portion from the resulting date. The year portion of the date 90 days from 7/8/2025 is 06-OCT-2025. By extracting the last 4 characters starting from the 7th character, the result will be -202.</p>"
                ],
                "explanation": "<p>Step-by-Step Analysis</p><p>1. <strong>SYSDATE + 90</strong></p><p>Given <code>SYSDATE = 7/8/2025</code></p><p>Adding 90 days → <code>October 6, 2025</code></p><p>2. <code>TO_CHAR(..., 'DD-MON-YYYY')</code></p><pre class=\"prettyprint linenums\">sql\nTO_CHAR(DATE, 'DD-MON-YYYY')\n</pre><p>Formats the date as:</p><pre class=\"prettyprint linenums\">bash\n'06-OCT-2025'\n</pre><p>3. <code>SUBSTR('06-OCT-2025', 7, 4)</code></p><p>Break down the character positions:</p><pre class=\"prettyprint linenums\">mathematica\nString:    0 6 - O C T - 2 0 2 5\nPosition:  1 2 3 4 5 6 7 8 9 10 11\n                       ↑\nSUBSTR(..., 7, 4) starts at position 7:\n</pre><p>Characters from position 7:</p><ul><li><p>7 = <code>'-'</code></p></li><li><p>8 = <code>'2'</code></p></li><li><p>9 = <code>'0'</code><br>-10 = <code>'2'</code></p></li></ul><p>→ Result = <code>'-202'</code></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-07-08_18-22-03-fe30f26c6976ca3cfcb5bb1a227a3a3f.png\"></p><p><br></p><p>If we wanted to get a result of <code>'2025'</code>, the following would be the query:</p><pre class=\"prettyprint linenums\">SELECT SUBSTR(TO_CHAR(SYSDATE + 90, 'DD-MON-YYYY'), 8, 4)\nFROM dual;\n</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-07-08_18-22-03-29f9080fea073482c3dd9e5f0c7d616a.png\"></p><p><br></p><p><strong>The Oracle/PLSQL SUBSTR</strong> functions allows you to extract a substring from a string.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUBSTR</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SUBSTR( string, start_position [, length ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>string - The source string. </p><p>start_position - The starting position for extraction. The first position in the string is always 1. </p><p>length Optional. - It is the number of characters to extract. If this parameter is omitted, the <code>SUBSTR</code> function will return the entire string.</p><p><strong>Returns</strong></p><p>The <code>SUBSTR</code> function returns a string value.<br>If <em>length</em> is a negative number, then the <code>SUBSTR</code> function will return a NULL value.</p><p><strong>Note:</strong></p><ul><li><p>If <em>start_position</em> is 0, then the <code>SUBSTR</code> function treats <em>start_position</em> as 1 (ie: the first position in the string).</p></li><li><p>If <em>start_position</em> is a positive number, then the <code>SUBSTR</code> function starts from the beginning of the string.</p></li><li><p>If <em>start_position</em> is a negative number, then the <code>SUBSTR</code> function starts from the end of the string and counts backwards.</p></li></ul><p><br></p><p><strong>The Oracle/PLSQL TRUNC</strong> function returns a date truncated to a specific unit of measure.</p><p><strong>Syntax (with dates)</strong></p><p>The syntax for the <code>TRUNC</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">TRUNC ( date [, format ] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>date - The date to truncate. </p><p>format Optional. - The unit of measure to apply for truncating. If the <em>format</em> parameter is omitted, the TRUNC function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off.</p><p><br></p><p><strong>The Oracle/PLSQL ROUND</strong> function returns a number rounded to a certain number of decimal places.</p><p><strong>ROUND Function Syntax (with dates)</strong></p><p>The syntax for the <code>ROUND</code> function in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">ROUND( date [, format] )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>date - The date to round. </p><p>format Optional. - The unit of measure to apply for rounding. If the <em>format</em> parameter is omitted, the <code>ROUND</code> function will round to the nearest day.</p>",
                "answers": [
                    "<p>-202</p>",
                    "<p>/202</p>",
                    "<p>7/9</p>",
                    "<p>2025</p>",
                    "<p>7820</p>",
                    "<p>0708</p>",
                    "<p>/09/</p>",
                    "<p>None of the listed responses.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SUBSTR",
            "question_plain": "View and examine the following SQL exhibits.Given: The current SYSDATE output is 7/8/2025.Exhibit 1:The following query is run:Exhibit 2:SELECT SUBSTR(TO_CHAR(SYSDATE + 90, 'DD-MON-YYYY'), 7, 4)\nFROM dual;\nIdentify the result of the query execution as of the current date.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289451,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given:</strong> </p><ul><li><p>The <code>books_transactions</code> table&nbsp; exists in your database.</p></li><li><p>The <code>books_transactions</code> table has 6 columns</p></li></ul><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM&nbsp;books_transactions ORDER&nbsp;BY 3;\n</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ORDER BY Clause](https://www.techonthenet.com/oracle/order_by.php)",
                    "[What does clause order by 1,2,3 means in sql query](https://community.oracle.com/thread/496341)"
                ],
                "feedbacks": [
                    "The query execution will not fail if the numeral 3 in the ORDER BY clause is not replaced by a column name. The query will still execute successfully, but the sorting order may not be as expected.",
                    "The rows will not be displayed in the order they are stored in the table for only the three rows with the lowest values in the key column. The ORDER BY clause will sort all rows based on the values in the specified column, not just the first three rows.",
                    "The rows will not be displayed in the order they are stored in the table for only the first three rows. The ORDER BY clause will sort all rows based on the values in the specified column, not just the first three rows.",
                    "The rows will be displayed sorted in ascending order of the values in the third column in the table. The ORDER BY clause will sort all rows based on the values in the specified column, in this case, the third column."
                ],
                "explanation": "<p>Analyze the SQL query in Exhibit 1:</p><pre class=\"prettyprint linenums\">SELECT *\nFROM books_transactions\nORDER BY 3;\n</pre><p>What does <code>ORDER BY 3</code> mean?</p><ul><li><p>The <code><strong>ORDER BY</strong></code><strong> clause</strong> allows you to sort the result by:</p><ul><li><p><strong>Column name</strong></p></li><li><p><strong>Column alias</strong></p></li><li><p><strong>Column position</strong> (i.e., <code>1</code> for the first column, <code>2</code> for the second, etc.)</p></li></ul></li></ul><p>So <code>ORDER BY 3</code> means:</p><p>Sort rows by the <strong>3rd column</strong> in the <code>SELECT *</code> result set, <strong>in ascending order by default</strong>.</p><p><strong>Given:</strong> </p><ul><li><p>The <code>books_transactions</code> table&nbsp; exists in your database.</p></li><li><p>The <code>books_transactions</code> table has 6 columns</p></li></ul><p>The query:</p><ul><li><p><strong>Will execute successfully</strong></p></li><li><p><strong>Will return all rows</strong></p></li><li><p><strong>Sorted in ascending order by the values in the 3rd column</strong></p></li></ul><p>Correct option:</p><p><strong>Rows are displayed sorted in ascending order of the values in the third column in the table.</strong></p><ul><li><p><strong>Correct.</strong> This is exactly what <code>ORDER BY 3</code> does.</p></li></ul><p>Incorrect options:</p><p><strong>The execution fails unless the numeral 3 in the ORDER BY clause is replaced by a column name.</strong></p><ul><li><p><strong>Incorrect.</strong></p></li><li><p>Oracle <strong>supports positional </strong><code><strong>ORDER BY</strong></code> — this is valid syntax.</p></li></ul><p><strong>Rows are displayed in the order that they are stored in the table only for the three rows with the lowest values in the key column.</strong></p><ul><li><p><strong>Incorrect.</strong></p></li><li><p>This describes neither the function of <code>ORDER BY</code> nor <code>ROWNUM</code> or <code>FETCH</code>. It’s unrelated.</p></li></ul><p><strong>Rows are displayed in the order that they are stored in the table only for the first three rows.</strong></p><ul><li><p><strong>Incorrect.</strong></p></li><li><p>This also misrepresents what <code>ORDER BY</code> does. The clause reorders the full result set, not just the first few rows.</p></li></ul><p><br></p><p><strong>The Oracle ORDER BY clause</strong> is used to sort the records in your result set. The <code>ORDER BY</code> clause can only be used in<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>ORDER BY</code> clause in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">SELECT expressions\nFROM tables\n[WHERE conditions]\nORDER BY expression [ ASC | DESC ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. </p><p>tables - The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. </p><p><code>WHERE</code> conditions Optional. - The conditions that must be met for the records to be selected. <code>ASC</code> Optional. It sorts the result set in ascending order by <em>expression</em> (default, if no modifier is provider). <code>DESC</code> Optional. It sorts the result set in descending order by <em>expression</em>.</p><p><strong>Note: </strong>If the <code>ASC</code> or <code>DESC</code> modifier is not provided in the <code>ORDER BY</code> clause, the results will be sorted by expression in ascending order (which is equivalent to <code>ORDER BY expression ASC</code>.</p><p><br></p><p><strong>What does clause order by 1,2,3 means in sql query?</strong></p><p>1,2,3 refers to the sequence of columns in the select list. e.g., </p><pre class=\"prettyprint linenums\">SELECT empno, ename, sal, job, deptno\nFROM emp\nORDER BY 1,2</pre><p><br></p><p>In the above query the output is ordered first on <code>empno</code> and then on <code>ename</code>.</p>",
                "answers": [
                    "<p>The execution fails unless the numeral 3 in the ORDER BY clause is replaced by a column name.</p>",
                    "<p>Rows are displayed in the order that they are stored in the table only for the three rows with the lowest values in the key column.</p>",
                    "<p>Rows are displayed in the order that they are stored in the table only for the first three rows.</p>",
                    "<p>Rows are displayed sorted in ascending order of the values in the third column in the table.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Reference",
            "question_plain": "View and examine the following available responses.Given: The books_transactions table&nbsp; exists in your database.The books_transactions table has 6 columnsExhibit: 1SELECT *\nFROM&nbsp;books_transactions ORDER&nbsp;BY 3;\nIdentify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289347,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description for the SALES and CHANNELS tables.&nbsp; </p><p> </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_17-49-47-ba27de4cc2bfcdd70d148761f9b0caa7.png\"></p><p><br></p><p><strong>Given: </strong>This SQL statement has been executed.</p><p><strong>Exhibit: 1&nbsp; &nbsp;</strong></p><pre class=\"prettyprint linenums\">INSERT INTO SALES\nVALUES\n(23, 2300, SYSDATE,\n (SELECT CHANNEL_ID\n  FROM CHANNELS\n  WHERE CHANNEL_DESC = 'DIRECT SALES'),\n 12, 1, 500);\n</pre><p><br></p><p><br></p><p>Identify the true statement regarding the result. (Choose the best answer)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement will fail due to a reason not mentioned in the options. This choice is correct because there may be other reasons for the statement to fail that are not covered in the given options, such as data type mismatches, constraint violations, or permission issues.",
                    "The statement will fail because a subquery cannot be used in a VALUES clause. This choice is incorrect because subqueries can be used in the VALUES clause in SQL statements, so this is not a valid reason for the statement to fail.",
                    "The statement will execute and a new row will be inserted in the SALES table. This choice is incorrect because without knowing the specific details of the SQL statement and the data in the tables, it is not possible to determine with certainty whether a new row will be inserted in the SALES table.",
                    "The statement will fail because the VALUES clause is not required with the subquery. This choice is incorrect because the VALUES clause can be used with subqueries in SQL statements, so the absence of the VALUES clause is not a reason for the statement to fail.",
                    "The statement will fail because the subquery in the VALUES clause is not enclosed within single quotation marks. This choice is incorrect because subqueries do not need to be enclosed in single quotation marks in SQL statements, so this is not a valid reason for the statement to fail."
                ],
                "explanation": "<p>Correct option: <strong>The statement will fail due to a reason not mentioned in the options.</strong></p><p><br></p><p><strong>The SALES table has 6 fields: </strong></p><p>1. Product ID, </p><p>2. Customer ID, </p><p>3. Time ID, </p><p>4. Channel ID, </p><p>5. Promotion ID, and </p><p>6. Quantity Sold.</p><p><br></p><p><strong>The Insert statement has 7 values:</strong></p><p>1. 23,</p><p>2. 2300,</p><p>3. SYSDATE,</p><p>4. Channel ID which is equal to Direct Sales,</p><p>5. 12,</p><p>6. 1,</p><p>7. 500.</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO SALES\nVALUES\n(23, 2300, SYSDATE,\n (SELECT CHANNEL_ID\n  FROM CHANNELS\n  WHERE CHANNEL_DESC = 'DIRECT SALES'),\n 12, 1, 500);</pre><p><br></p><p>The error message will be 'too many values'.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-09_23-58-39-fb183935c349a074cd184b2ddd26c324.png\"></p><p>Results in: <strong>ORA-00913: too many values</strong></p><p>Because Oracle doesn't allow a <strong>SELECT subquery</strong> in between <code>VALUES(...)</code> unless the subquery is fully scalar and cleanly interpreted.</p><p><br></p><p>The problem is with this line:</p><pre class=\"prettyprint linenums\">VALUES \n(23, 2300, SYSDATE,\n (SELECT CHANNEL_ID \n  FROM CHANNELS \n  WHERE CHANNEL_DESC = 'DIRECT SALES'),\n12, 1, 500);</pre><p><br></p><p>Oracle interprets the <strong>entire </strong><code><strong>VALUES</strong></code><strong> clause</strong> as a flat list of <strong>scalar values</strong>.</p><p>So you have:</p><p><code>23, 2300, SYSDATE, (subquery), 12, 1, 500</code></p><p>That is a total of <strong>7 expressions</strong>.</p><p>So Oracle expects the <code>SALES</code> table to have <strong>7 columns</strong>.</p><p>BUT the subquery is a <strong>nested SELECT</strong>, which Oracle internally interprets as a <strong>\"row source\"</strong> — so if the subquery returns <strong>a row</strong>, Oracle tries to <strong>merge it into the VALUES list</strong>.</p><p>This works <strong>only if the subquery is used inside a </strong><code><strong>SELECT</strong></code><strong> form like this</strong>:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO SALES (\n    column1, column2, column3, column4, column5, column6, column7\n)\nSELECT 23, 2300, SYSDATE,\n       CHANNEL_ID,\n       12, 1, 500\nFROM CHANNELS\nWHERE CHANNEL_DESC = 'DIRECT SALES';\n</pre><p><br></p><p>Once the number of values have been corrected, it will execute and insert the value.</p><pre class=\"prettyprint linenums\">INSERT INTO sales\nVALUES\n(23,2300,SYSDATE,\n (SELECT channel_id\n  FROM channels\n  WHERE channel_desc = 'Direct Sales'),\n12,500);</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-10_00-03-29-fc422f6ec08b150f322d9ecc05d0deb6.png\"></p>",
                "answers": [
                    "<p>The statement will fail due to a reason not mentioned in the options.</p>",
                    "<p>The statement will fail because a subquery cannot be used in a VALUES clause.</p>",
                    "<p>The statement will execute and a new row will be inserted in the SALES table.</p>",
                    "<p>The statement will fail because the VALUES clause is not required with the subquery.</p>",
                    "<p>The statement will fail because the subquery in the VALUES clause is not enclosed within single quotation marks.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the description for the SALES and CHANNELS tables.&nbsp;  Given: This SQL statement has been executed.Exhibit: 1&nbsp; &nbsp;INSERT INTO SALES\nVALUES\n(23, 2300, SYSDATE,\n (SELECT CHANNEL_ID\n  FROM CHANNELS\n  WHERE CHANNEL_DESC = 'DIRECT SALES'),\n 12, 1, 500);\nIdentify the true statement regarding the result. (Choose the best answer)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289453,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the SALES table.</p><p><strong>Table: SALES</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nPRODUCT_ID                    NOT NULL          NUMBER(2)\nCUSTOMER_ID                   NOT NULL          NUMBER(10)\nTIME_ID                       NOT NULL          DATE\nCHANNEL_ID                    NOT NULL          NUMBER(5)\nPROMO_ID                      NOT NULL          NUMBER(5)\nQUANTITY_SOLD                 NOT NULL          NUMBER(10,2)\nPRICE                                           NUMBER(10,2)\nAMOUNT_SOLD                  NOT NULL           NUMBER(10,2)\n</pre><p><br></p><p>Examine this statement.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE sales1(prod_id, cust_id, quantity_sold, price)\nAS\nSELECT product_id, customer_id, quantity_sold, price\nFROM sales\nWHERE 1 = 2;\n</pre><p><br></p><p>Identify the true statements about the SALES1 table. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: CREATE TABLE AS Statement](https://www.techonthenet.com/oracle/tables/create_table2.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect because the column names specified in the SELECT and CREATE TABLE clauses do not need to match for the new table to be created. The new table will be created with the specified column names from the SELECT statement.",
                    "This statement is correct because when creating a new table using a SELECT statement, the new table will inherit NOT NULL constraints from the selected columns that had those constraints in the original table. This ensures data integrity in the new table.",
                    "This statement is incorrect because the validity of the WHERE clause does not affect the creation of a new table using a SELECT statement. The WHERE clause is used to filter data during the selection process and does not impact the creation of the new table.",
                    "This statement is correct because when creating a new table using a SELECT statement that returns no rows, the new table will be created with the specified columns but will have no data in it. This can be useful for creating an empty table structure based on an existing table.",
                    "This statement is incorrect because when creating a new table using a SELECT statement, the new table will not automatically inherit PRIMARY KEY and UNIQUE constraints from the selected columns in the original table. These constraints need to be explicitly defined in the CREATE TABLE statement for the new table."
                ],
                "explanation": "<p>The two true statements are:</p><ul><li><p>It will have NOT NULL constraints on the selected columns which had those constraints in the SALES table.</p></li><li><p>It is created with no rows.</p></li></ul><p><strong>Understanding </strong><code><strong>CREATE TABLE AS SELECT</strong></code></p><p>This SQL construct allows you to create a new table based on the result set of a <code>SELECT</code> statement. When you use this, the new table inherits certain properties from the source table(s) and the <code>SELECT</code> query.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE sales1(prod_id, cust_id, quantity_sold, price)\nAS\nSELECT product_id, customer_id, quantity_sold, price\nFROM sales\nWHERE 1 = 2;\n</pre><ul><li><p><code><strong>CREATE TABLE sales1(prod_id, cust_id, quantity_sold, price)</strong></code>: This part specifies the name of the new table (<code>sales1</code>) and explicitly defines the new column names for the columns that will be created. These new column names (<code>prod_id</code>, <code>cust_id</code>, etc.) will correspond to the columns selected in the <code>SELECT</code> statement.</p></li><li><p><code><strong>AS SELECT product_id, customer_id, quantity_sold, price FROM sales</strong></code>: This specifies that the <code>sales1</code> table will be populated with data from the <code>sales</code> table, selecting only the <code>product_id</code>, <code>customer_id</code>, <code>quantity_sold</code>, and <code>price</code> columns.</p></li><li><p><code><strong>WHERE 1 = 2</strong></code>: This is a condition that is always false.</p></li></ul><p><strong>Evaluating the Options:</strong></p><ol><li><p><strong>\"It will have NOT NULL constraints on the selected columns which had those constraints in the SALES table.\"</strong></p><ul><li><p>Let's look at the <code>SALES</code> table structure:</p><ul><li><p><code>PRODUCT_ID NOT NULL</code></p></li><li><p><code>CUSTOMER_ID NOT NULL</code></p></li><li><p><code>QUANTITY_SOLD NOT NULL</code></p></li><li><p><code>PRICE</code> (no NOT NULL, so it can be null)</p></li></ul></li><li><p>When you create a table using <code>CREATE TABLE AS SELECT</code>, <strong>NOT NULL constraints are inherited</strong> from the source columns for the new columns, <em>unless</em> the source column is an expression (not a direct column reference) or there are other complexities. In this case, <code>product_id</code>, <code>customer_id</code>, and <code>quantity_sold</code> in <code>SALES</code> are <code>NOT NULL</code>, so <code>prod_id</code>, <code>cust_id</code>, and <code>quantity_sold</code> in <code>SALES1</code> will also be <code>NOT NULL</code>.</p></li><li><p><strong>This statement is TRUE.</strong></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-05-10_16-02-30-26c1392d33e31935464f27ab5583481a.png\"></p></li></ul></li><li><p><strong>\"It is created with no rows.\"</strong></p><ul><li><p>The <code>WHERE 1 = 2</code> clause is always false. This means that the <code>SELECT</code> statement will return an empty set (0 rows).</p></li><li><p>Therefore, the <code>sales1</code> table will be created with the specified structure but will contain no rows.</p></li><li><p><strong>This statement is TRUE.</strong></p></li></ul></li><li><p><strong>\"It will not be created because the column-specified names in the SELECT and CREATE TABLE clauses do not match.\"</strong></p><ul><li><p>In <code>CREATE TABLE sales1(prod_id, cust_id, quantity_sold, price)</code>, you are <em>defining</em> the new column names for <code>sales1</code>.</p></li><li><p>In <code>SELECT product_id, customer_id, quantity_sold, price</code>, you are selecting the original column names from <code>sales</code>.</p></li><li><p>Oracle (and most SQL databases) allows you to specify new column names in the <code>CREATE TABLE</code> clause for the columns being selected. The order matters, but the names don't have to match the source table's names. <code>prod_id</code> will map to <code>product_id</code>, <code>cust_id</code> to <code>customer_id</code>, and so on.</p></li><li><p><strong>This statement is FALSE.</strong> The table will be created.</p></li></ul></li><li><p><strong>\"It will not be created because of the invalid WHERE clause.\"</strong></p><ul><li><p>The <code>WHERE 1 = 2</code> clause is perfectly valid SQL syntax. It's a condition that always evaluates to false, which results in no rows being selected, but it does not prevent the table from being created. It simply creates an empty table.</p></li><li><p><strong>This statement is FALSE.</strong></p></li></ul></li><li><p><strong>\"It has PRIMARY KEY and UNIQUE constraints on the selected columns which had those constraints in the SALES table.\"</strong></p><ul><li><p><code>CREATE TABLE AS SELECT</code> <strong>does not inherit PRIMARY KEY, UNIQUE, or FOREIGN KEY constraints</strong>. It only inherits <code>NOT NULL</code> constraints (and data types, lengths, precision, and scale). You would need to explicitly add these constraints after the table creation using <code>ALTER TABLE</code>.</p></li><li><p>Looking at the <code>SALES</code> table structure provided, there's no indication of PRIMARY KEY or UNIQUE constraints. Even if there were, they would not be inherited.</p></li><li><p><strong>This statement is FALSE.</strong></p></li></ul></li></ol><p><br></p><p><strong>You can also use the Oracle CREATE TABLE AS statement </strong>to create a table from an existing table by copying the existing table's columns.</p><p>It is important to note that when creating a table in this way, the new table will be populated with the records from the existing table (based on the <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT Statement</a>).</p><p><strong>Create Table - By Copying all columns from another table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE TABLE AS</code> statement that copies all of the columns in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT * FROM old_table);</pre><p><br></p><p><strong>Create table - By Copying selected columns from multiple tables</strong></p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE TABLE AS</code> statement that copies columns from multiple tables in Oracle/PLSQL is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT column_1, column2, ... column_n\n      FROM old_table_1, old_table_2, ... old_table_n);</pre><p><br></p><p><strong>Create table from another table without copying any values from the old table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the <code>CREATE TABLE AS</code> statement creates a table from another table without copying any values from the old table</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT *\n      FROM old_table WHERE 1=2);</pre>",
                "answers": [
                    "<p>It will not be created because the column-specified names in the SELECT and CREATE TABLE clauses do not match.</p>",
                    "<p>It will have NOT NULL constraints on the selected columns which had those constraints in the SALES table.</p>",
                    "<p>It will not be created because of the invalid WHERE clause.</p>",
                    "<p>It is created with no rows.</p>",
                    "<p>It has PRIMARY KEY and UNIQUE constraints on the selected columns which had those constraints in the SALES table.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "CREATE TABLE AS",
            "question_plain": "View and examine the structure of the SALES table.Table: SALESName                          Null??            Type\nPRODUCT_ID                    NOT NULL          NUMBER(2)\nCUSTOMER_ID                   NOT NULL          NUMBER(10)\nTIME_ID                       NOT NULL          DATE\nCHANNEL_ID                    NOT NULL          NUMBER(5)\nPROMO_ID                      NOT NULL          NUMBER(5)\nQUANTITY_SOLD                 NOT NULL          NUMBER(10,2)\nPRICE                                           NUMBER(10,2)\nAMOUNT_SOLD                  NOT NULL           NUMBER(10,2)\nExamine this statement.Exhibit 1:CREATE TABLE sales1(prod_id, cust_id, quantity_sold, price)\nAS\nSELECT product_id, customer_id, quantity_sold, price\nFROM sales\nWHERE 1 = 2;\nIdentify the true statements about the SALES1 table. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289455,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the execution of the correlated subqueries. (Choose two.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)"
                ],
                "feedbacks": [
                    "This statement is correct as correlated subqueries are dependent on the outer query, and the nested query is executed for each row returned by the outer query.",
                    "This statement is incorrect as the nested query in a correlated subquery is executed for each row returned by the outer query, not before the outer query.",
                    "This statement is incorrect as the outer query is executed for each row returned by the inner query, not just once for the entire result set.",
                    "This statement is correct as each row returned by the outer query is evaluated against the results returned by the inner query in correlated subqueries."
                ],
                "explanation": "<p>The two true statements regarding the execution of correlated subqueries are:</p><ul><li><p><strong>The nested query executes for each row returned by the outer query as an iterative process where the inner query relies on values from the current row being processed by the outer query.</strong></p></li><li><p><strong>Each row returned by the outer query is evaluated for the results returned by the inner query.</strong></p></li></ul><p><br></p><p><strong>Understanding Correlated Subqueries</strong></p><p>A correlated subquery is a type of subquery that relies on values from the outer query. This means the inner query cannot be executed independently. Instead, it's re-evaluated for each row processed by the outer query, using values from that specific outer row.</p><p><strong>Evaluating the Options:</strong></p><ol><li><p><strong>\"The nested query executes for each row returned by the outer query as an iterative process where the inner query relies on values from the current row being processed by the outer query.\"</strong></p><ul><li><p>This is an excellent and accurate description of how a correlated subquery functions. The inner query's execution is tightly coupled with each individual row being processed by the outer query, making it an iterative process.</p></li><li><p><strong>This statement is TRUE.</strong></p></li></ul></li><li><p><strong>\"Each row returned by the outer query is evaluated for the results returned by the inner query.\"</strong></p><ul><li><p>This statement is also a correct description of correlated subqueries. For every row that the outer query considers, the inner query is run, and its result is used to determine if that outer row should be included in the final output. This implies the iterative nature mentioned in the first true statement.</p></li><li><p><strong>This statement is TRUE.</strong></p></li></ul></li><li><p><strong>\"The nested query executes first and then the outer query executes.\"</strong></p><ul><li><p>This describes the behavior of an <strong>uncorrelated subquery</strong>, where the inner query runs once independently and then its result is used by the outer query. This is <strong>not</strong> true for correlated subqueries.</p></li><li><p><strong>This statement is FALSE.</strong></p></li></ul></li><li><p><strong>\"The outer query executes only once for the result returned by the inner query.\"</strong></p><ul><li><p>Similar to the previous point, this also describes an <strong>uncorrelated subquery</strong>. In a correlated subquery, the outer query drives the process, and the inner query executes multiple times (once for each outer row being evaluated).</p></li><li><p><strong>This statement is FALSE.</strong></p></li></ul></li></ol><p><strong>Oracle subquery</strong></p><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. Typically, you can use a subquery anywhere that you use an expression.</p><p><br></p><p><strong>Oracle evaluates the whole query above in two steps:</strong></p><p>First, execute the subquery.</p><p>Second, use the result of the subquery in the outer query.</p><ul><li><p>A subquery which is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS such as MySQL and PostgreSQL use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p></li><li><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p></li><li><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p></li></ul><p><br></p><p><strong>Advantages of Oracle subqueries</strong></p><p>These are the main advantages of subqueries:</p><ol><li><p>Provide an alternative way to query data that would require complex <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">joins</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\">unions</a>.</p></li><li><p>Make the complex queries more readable.</p></li><li><p>Allow a complex query to be structured in a way that it is possible to isolate each part.</p></li></ol>",
                "answers": [
                    "<p>The nested query executes for each row returned by the outer query as an iterative process where the inner query relies on values from the current row being processed by the outer query.</p>",
                    "<p>The nested query executes first and then the outer query executes.</p>",
                    "<p>The outer query executes only once for the result returned by the inner query.</p>",
                    "<p>Each row returned by the outer query is evaluated for the results returned by the inner query.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the execution of the correlated subqueries. (Choose two.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289459,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCT_DETAILS table.</p><p><strong>Table: PRODUCT_DETAILS</strong></p><pre class=\"prettyprint linenums\">Name                          Null??            Type\nPRODUCT_ID                    NOT NULL          NUMBER(2)\nPRODUCT_NAME                  NOT NULL          VARCHAR2(25)\nPRODUCT_PRICE                                   NUMBER(8,2)\nEXPIRY_DATE                                     DATE\n</pre><p><br></p><p>Indicate the statements which are true regarding the result. (Select three.)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Expressions](https://docs.oracle.com/cd/A58617_01/server.804/a58225/ch3all.htm#1002628)"
                ],
                "feedbacks": [
                    "In Oracle Database, NULL values are treated as unknown or missing data, and arithmetic operations involving NULL values will result in a NULL value. Therefore, PRODUCT_PRICE can be used in an arithmetic expression even if it has no value stored in it.",
                    "A PRIMARY KEY constraint uniquely identifies each record in a table and ensures that the values in the specified column (in this case, PRODUCT_ID) are unique and not NULL. Therefore, PRODUCT_ID can be assigned the PRIMARY KEY constraint.",
                    "In Oracle Database, if no value is assigned to a column, it will contain a NULL value by default, not zero. Therefore, PRODUCT_PRICE will contain NULL if no value is assigned to it.",
                    "Date columns, such as EXPIRY_DATE, can be used in arithmetic expressions in Oracle Database. However, it is important to handle date calculations and conversions appropriately to avoid errors.",
                    "In Oracle Database, if no value is assigned to a DATE column like EXPIRY_DATE, it will contain a NULL value by default, not the current system date (SYSDATE). Therefore, EXPIRY_DATE will contain NULL if no date is assigned to it.",
                    "The uniqueness constraint for ensuring no duplicate values in a column is enforced by a UNIQUE constraint, not by default in Oracle Database. Therefore, PRODUCT_NAME can contain duplicate values unless a UNIQUE constraint is explicitly defined on it."
                ],
                "explanation": "<p>The three true statements are:</p><ul><li><p><strong>PRODUCT_PRICE can be used in an arithmetic expression even if it has no value stored in it.</strong></p></li><li><p><strong>PRODUCT_ID can be assigned the PRIMARY KEY constraint.</strong></p></li><li><p><strong>EXPIRY_DATE can be used in arithmetic expressions.</strong></p></li></ul><p><strong>Table Structure:</strong></p><ul><li><p><code>PRODUCT_ID</code>: <code>NUMBER(2)</code>, <code>NOT NULL</code></p></li><li><p><code>PRODUCT_NAME</code>: <code>VARCHAR2(25)</code>, <code>NOT NULL</code></p></li><li><p><code>PRODUCT_PRICE</code>: <code>NUMBER(8,2)</code>, (Allows <code>NULL</code> values)</p></li><li><p><code>EXPIRY_DATE</code>: <code>DATE</code>, (Allows <code>NULL</code> values)</p></li></ul><p><strong>Evaluating Each Statement:</strong></p><ol><li><p><strong>PRODUCT_PRICE can be used in an arithmetic expression even if it has no value stored in it.</strong></p><ul><li><p>If <code>PRODUCT_PRICE</code> has no value, it means it is <code>NULL</code>.</p></li><li><p>In SQL, you can use a <code>NULL</code> value in arithmetic expressions (e.g., <code>PRODUCT_PRICE + 10</code>). The result of such an operation will be <code>NULL</code>. The expression itself is syntactically valid and will execute without error.</p></li><li><p><strong>TRUE.</strong></p></li></ul></li><li><p><strong>PRODUCT_ID can be assigned the PRIMARY KEY constraint.</strong></p><ul><li><p>A <code>PRIMARY KEY</code> requires the column(s) to be <code>NOT NULL</code> and contain unique values.</p></li><li><p><code>PRODUCT_ID</code> is defined as <code>NOT NULL</code>. It's a numeric type, which is suitable for a unique identifier. Assuming <code>PRODUCT_ID</code> values are meant to be unique (as is typical for IDs), it meets the criteria to be assigned a <code>PRIMARY KEY</code> constraint.</p></li><li><p><strong>TRUE.</strong></p></li></ul></li><li><p><strong>EXPIRY_DATE can be used in arithmetic expressions.</strong></p><ul><li><p><code>DATE</code> data types in SQL (and specifically in Oracle, as implied by the syntax) fully support arithmetic operations. You can add/subtract numbers (which represent days), or subtract one date from another to get the difference in days.</p></li><li><p><strong>TRUE.</strong></p></li></ul></li><li><p><strong>PRODUCT_PRICE contains the value zero by default if no value is assigned to it.</strong></p><ul><li><p>When a column is nullable (like <code>PRODUCT_PRICE</code>) and no explicit <code>DEFAULT</code> clause is specified during table creation, it will contain <code>NULL</code> if no value is provided during an <code>INSERT</code>. It does not automatically default to zero.</p></li><li><p><strong>FALSE.</strong></p></li></ul></li><li><p><strong>EXPIRY_DATE contains the SYSDATE by default if no date is assigned to it.</strong></p><ul><li><p>Similar to <code>PRODUCT_PRICE</code>, unless a <code>DEFAULT SYSDATE</code> clause was explicitly included in the <code>CREATE TABLE</code> statement for <code>EXPIRY_DATE</code>, it will be <code>NULL</code> by default if no value is provided. It does not automatically default to the current system date.</p></li><li><p><strong>FALSE.</strong></p></li></ul></li><li><p><strong>PRODUCT_NAME cannot contain duplicate values.</strong></p><ul><li><p>The <code>PRODUCT_NAME</code> column is <code>NOT NULL VARCHAR2(25)</code>.</p></li><li><p>There is no <code>UNIQUE</code> constraint or <code>PRIMARY KEY</code> constraint defined on <code>PRODUCT_NAME</code> in the provided table structure that would prevent duplicate values. Therefore, it <em>can</em> contain duplicates (e.g., two different products could coincidentally have the same name, or a generic name like 'Widget').</p></li><li><p><strong>FALSE.</strong></p></li></ul><p><br></p></li></ol><p><strong>Expressions</strong></p><p>An <em>expression</em> is a combination of one or more values, operators, and SQL functions that evaluate to a value. An expression generally assumes the datatype of its components.</p><p>This simple expression evaluates to 4 and has datatype NUMBER (the same datatype as its components):</p><pre class=\"prettyprint linenums\">2 * 2 </pre><p><br></p><p><strong>Arithmetic Operators</strong></p><p>You can use an arithmetic operator in an expression to negate, add, subtract, multiply, and divide numeric values. The result of the operation is also a numeric value.</p><pre class=\"prettyprint linenums\">SELECT salary + commission\nFROM employees\n  WHERE SYSDATE - hire_date &gt; 365</pre><p><br></p><p>EXPIRY_DATE can be used in arithmetic expressions is not always correct as you can't multiply the date (EXPIRY_DATE*5 will return an error)</p><p>Null values in any arithmetic expression is going to be Null, it can be used without error but the result is Null</p><p><em>√&nbsp; PRODUCT_PRICE can be used in an arithmetic expression even if it has no value stored in it.</em></p><p><em>√ EXPIRY_DATE can be used in arithmetic expressions.</em></p><p><em>√&nbsp;PRODUCT_ID can be assigned the PRIMARY KEY constraint.</em></p><p><br></p><ul><li><p>PRODUCT_ID be assigned Primary Key even though it is already NOT NULL; it can be done with and without NOT NULL in the definition. </p></li><li><p>CREATE TABLE price_list ( PROD_ID NUMBER(3) NOT NULL, -- Column has NOT NULL in definition PROD_PRICE VARCHAR2(10)); </p></li><li><p>ALTER TABLE PRICE_LIST ADD CONSTRAINT PK_PROD_ID PRIMARY KEY (PROD_ID); </p></li><li><p>CREATE TABLE PRODUCT_PRICE ( PROD_ID NUMBER(3), -- Column was defined without NOT NULL PROD_PRICE VARCHAR2(10)); </p></li><li><p>ALTER TABLE PRODUCT_PRICE ADD CONSTRAINT PK_PROD_ID2 PRIMARY KEY (PROD_ID); </p></li></ul>",
                "answers": [
                    "<p>PRODUCT_PRICE can be used in an arithmetic expression even if it has no value stored in it.</p>",
                    "<p>PRODUCT_ID can be assigned the PRIMARY KEY constraint.</p>",
                    "<p>PRODUCT_PRICE contains the value zero by default if no value is assigned to it.</p>",
                    "<p>EXPIRY_DATE can be used in arithmetic expressions.</p>",
                    "<p>EXPIRY_DATE contains the SYSDATE by default if no date is assigned to it.</p>",
                    "<p>PRODUCT_NAME cannot contain duplicate values.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "d"
            ],
            "section": "Expressions",
            "question_plain": "View and examine the structure of the PRODUCT_DETAILS table.Table: PRODUCT_DETAILSName                          Null??            Type\nPRODUCT_ID                    NOT NULL          NUMBER(2)\nPRODUCT_NAME                  NOT NULL          VARCHAR2(25)\nPRODUCT_PRICE                                   NUMBER(8,2)\nEXPIRY_DATE                                     DATE\nIndicate the statements which are true regarding the result. (Select three.)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289463,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the USING clause in table joins.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Natural Join in Oracle](https://www.educba.com/natural-join-in-oracle/)"
                ],
                "feedbacks": [
                    "The USING clause in table joins can be used when joining tables that have columns with the same name and compatible data types. This allows for a more concise and clear way of specifying the join condition between the tables.",
                    "The USING clause in table joins is not limited to joining a maximum of three tables. It can be used to join any number of tables as long as the join conditions are met and the columns specified in the USING clause exist in the tables being joined.",
                    "The USING clause in table joins can be used to access data from tables through equijoins, where the join condition is based on equality between columns, as well as nonequijoins, where the join condition is based on other comparison operators such as greater than or less than.",
                    "The USING clause in table joins is not limited to restricting the number of columns used in a NATURAL JOIN or INNER JOIN only. It can be used in various types of joins, including LEFT JOIN, RIGHT JOIN, and FULL JOIN, to specify the columns used in the join condition."
                ],
                "explanation": "<p>True Statement:<strong> \"It can be used to join tables that have columns with the same name and compatible data types.\"</strong></p><ul><li><p>The <code>USING</code> clause <strong>joins tables based on columns that share the same name and compatible data types</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">SELECT *\nFROM orders\nJOIN customers\nUSING (customer_id);\n</pre></li><li><p>In this case, <code>customer_id</code> must <strong>exist in both tables</strong> with <strong>the same name</strong> and <strong>data types must be compatible</strong>.</p></li></ul><p>Incorrect options:</p><p><strong>\"It can be used to join a maximum of three tables.\"</strong></p><ul><li><p>There is <strong>no such limit</strong>. You can join <strong>as many tables as needed</strong> using <code>USING</code>, as long as the syntax and logic are valid.</p></li></ul><p><strong>\"It can be used to access data from tables through equijoins as well as nonequijoins.\"</strong></p><ul><li><p><code>USING</code> is used <strong>only in equijoins</strong> (joins based on equality of column values).</p></li><li><p>It <strong>cannot be used</strong> for <strong>nonequijoins</strong> (joins using operators like <code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>, etc.).</p></li></ul><p><strong>\"It can be used to restrict the number of columns used in a NATURAL JOIN or INNER JOIN only.\"</strong></p><ul><li><p><code>USING</code> is <strong>not related to NATURAL JOIN column restriction</strong>.</p></li><li><p>It’s used <strong>explicitly to define join columns</strong>, and can be used with <strong>INNER JOIN</strong>, <strong>LEFT OUTER JOIN</strong>, etc.</p></li><li><p>It does <strong>not restrict</strong> columns in NATURAL JOIN (which auto-matches columns by name).</p></li></ul><p><br></p><p><strong>NATURAL JOIN</strong></p><p>A <code>NATURAL JOIN</code> is a <a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj29840.html#rrefsqlj29840\">JOIN operation</a> that creates an implicit join clause for you based on the common columns in the two tables being joined. Common columns are columns that have the same name in both tables.</p><p>A <code>NATURAL JOIN</code> can be an <code>INNER</code> join, a <code>LEFT OUTER</code> join, or a <code>RIGHT OUTER</code> join. The default is <code>INNER</code> join.</p><p>Oracle Natural Join is a join query which combines multiple Tables, View or Materialized View to retrieve data. It does not need to declare the join condition explicitly because it considers implicitly a join condition based on the same column name and data type. So, it can be used to get the records for single or multiple join conditions without being explicitly declared.</p><p><code>NATURAL JOIN</code> will consider all the columns with same name and datatype. <code>USING</code> / <code>ON </code>will consider the columns with the same name and datatype, but not all, it will consider only the columns you want.</p>",
                "answers": [
                    "<p>It can be used to join tables that have columns with the same name and compatible data types.</p>",
                    "<p>It can be used to join a maximum of three tables.</p>",
                    "<p>It can be used to access data from tables through equijoins as well as nonequijoins.</p>",
                    "<p>It can be used to restrict the number of columns used in a NATURAL JOIN or INNER JOIN only.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "JOIN",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the USING clause in table joins.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289465,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PROGRAMS table.</p><p><strong>Table: PROGRAMS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nPROG_ID                 NOT NULL          NUMBER(3)\nPROG_COST                                 NUMBER(8,2)\nSTART_DATE              NOT NULL          DATE\nEND_DATE                                  DATE</pre><p><br></p><p>Identify the best SQL statement which would execute successfully.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[COALESCE function](https://docs.oracle.com/javadb/10.8.3.0/ref/rreffunccoalesce.html)"
                ],
                "feedbacks": [
                    "This SQL statement uses the COALESCE function to handle NULL values and calculate the difference in months between the start_date and end_date columns. The TO_CHAR function is used to convert the result to a string, and the ROUND function is used to round the result. The statement will execute successfully and provide the desired output.",
                    "This SQL statement uses the NVL function to handle NULL values, but the calculation of the difference in months between start_date and end_date is incorrect. The subtraction operator (-) is used instead of the MONTHS_BETWEEN function, which will result in an error when executed. Therefore, this statement will not execute successfully.",
                    "<p>This will execute successfully, however, <code>NVL(END_DATE, SYSDATE)</code> returns a DATE; <code>TO_DATE()</code> expects a string, but Oracle allows implicit conversion, so no error; <code>TO_DATE()</code> is unnecessary here since the value is already a DATE.&nbsp; Valid, but redundant.</p>",
                    "This SQL statement uses the NVL function to handle NULL values, but the calculation of the difference in months between start_date and end_date is incorrect. The MONTHS_BETWEEN function is not used properly, as it requires two separate date arguments. Additionally, the subtraction operator (-) is used incorrectly. This statement will not execute successfully.",
                    "This SQL statement uses the NVL function to handle NULL values and attempts to add a month to the END_DATE column using the ADD_MONTHS function. However, there is a syntax error in the statement as the comma is missing between ADD_MONTHS(END_DATE,1) and SYSDATE. This will result in a syntax error when the statement is executed, making it unsuccessful."
                ],
                "explanation": "<p>Best option:</p><pre class=\"prettyprint linenums\">SELECT \n  COALESCE(TO_CHAR(ROUND(MONTHS_BETWEEN(start_date, end_date))), 'Ongoing') AS months_diff\nFROM programs;\n</pre><ul><li><p>The preferred, cleaner choice.</p></li></ul><p><br></p><p>Let's analyze each SQL statement based on the <code>PROGRAMS</code> table structure and Oracle SQL syntax rules:</p><pre class=\"prettyprint linenums\">SELECT \n  COALESCE(TO_CHAR(ROUND(MONTHS_BETWEEN(start_date, end_date))), 'Ongoing') AS months_diff\nFROM programs;\n</pre><ul><li><p><strong>Valid</strong>:</p><ul><li><p><code>MONTHS_BETWEEN(start_date, end_date)</code> → returns number or NULL</p></li><li><p><code>ROUND()</code> → rounds the number</p></li><li><p><code>TO_CHAR()</code> → converts number to string</p></li><li><p><code>COALESCE()</code> → returns the first non-null argument; if NULL, returns <code>'Ongoing'</code></p></li><li><p>This will execute successfully.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT TO_DATE(NVL(END_DATE, SYSDATE)) \nFROM programs;\n\n</pre><ul><li><p><strong>Valid, but redundant</strong>:</p><ul><li><p><code>NVL(END_DATE, SYSDATE)</code> returns a DATE</p></li><li><p><code>TO_DATE()</code> expects a string, but Oracle allows implicit conversion, so no error</p></li><li><p><code>TO_DATE()</code> is unnecessary here since the value is already a DATE</p></li><li><p>This will execute successfully.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(MONTHS_BETWEEN(start_date - end_date)),'Ongoing') \nFROM programs;\n\n</pre><ul><li><p><strong>Invalid</strong>:</p><ul><li><p><code>MONTHS_BETWEEN</code> expects <strong>two DATE arguments</strong>, but here it receives a single numeric argument <code>(start_date - end_date)</code> (which is a number, difference of dates)</p></li><li><p>This will cause an error.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT NVL(MONTHS_BETWEEN(start_date - end_date),'Ongoing') \nFROM programs;\n</pre><ul><li><p><strong>Invalid</strong>:</p><ul><li><p>Same issue as #2 — <code>MONTHS_BETWEEN</code> receives a single numeric argument, not two DATEs</p></li><li><p>Will cause an error.</p></li></ul></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT NVL(ADD_MONTHS(END_DATE,1)SYSDATE) \nFROM programs;\n</pre><ul><li><p><strong>Invalid syntax</strong>:</p><ul><li><p>Missing comma between <code>ADD_MONTHS(END_DATE, 1)</code> and <code>SYSDATE</code> inside NVL</p></li><li><p>Will cause syntax error.</p></li></ul></li></ul><p><br></p>\n<img src=\"https://img-c.udemycdn.com/redactor/raw/practice_test_question_explanation/2025-06-14_18-44-48-f672a015e9ecb9cac284dc92e4cf82ff.png\">",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT \n  COALESCE(TO_CHAR(ROUND(MONTHS_BETWEEN(start_date, end_date))), 'Ongoing') AS months_diff\nFROM programs;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(TO_CHAR(MONTHS_BETWEEN(start_date - end_date)),'Ongoing') \nFROM programs;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_DATE(NVL(END_DATE, SYSDATE)) \nFROM programs;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(MONTHS_BETWEEN(start_date - end_date),'Ongoing') \nFROM programs;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT NVL(ADD_MONTHS(END_DATE,1)SYSDATE) \nFROM programs;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "COALESCE",
            "question_plain": "View and examine the structure of the PROGRAMS table.Table: PROGRAMS Name                    Null??            Type\nPROG_ID                 NOT NULL          NUMBER(3)\nPROG_COST                                 NUMBER(8,2)\nSTART_DATE              NOT NULL          DATE\nEND_DATE                                  DATEIdentify the best SQL statement which would execute successfully.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289467,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the following SQL query</p><pre class=\"prettyprint linenums\">SELECT ROUND(AVG(SALARY), -3)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 50;\n</pre><p><br></p><p>Which of the following is the result of the SQL query?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ROUND (number)](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/ROUND-number.html)"
                ],
                "feedbacks": [
                    "The ROUND function with a negative precision (-3) rounds the average salary in Department 50 to the nearest thousand, as specified in the query. This means that the result will be rounded to the nearest thousand.",
                    "This choice is incorrect because the ROUND function is applied to the AVG(SALARY) function, not to individual salaries. Therefore, the rounding occurs after calculating the average salary, not before.",
                    "This choice is incorrect because using a negative value for rounding in the ROUND function is valid in SQL. It does not cause a syntax error, but rather specifies the precision to which the number should be rounded.",
                    "This choice is incorrect because the query specifically calculates the average salary in Department 50 and then rounds it to the nearest thousand using the ROUND function. The result will be a rounded average salary, not an unrounded one."
                ],
                "explanation": "<p>Break down the SQL query:</p><pre class=\"prettyprint linenums\">SELECT ROUND(AVG(SALARY), -3)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 50;\n</pre><p>Step-by-step Explanation:</p><ul><li><p><code>AVG(SALARY)</code> computes the <strong>average salary</strong> of employees in <code>DEPARTMENT_ID = 50</code>.</p></li><li><p><code>ROUND(..., -3)</code> rounds the result of that average <strong>to the nearest thousand</strong>:</p><ul><li><p>A <strong>negative precision</strong> in <code>ROUND</code> means you're rounding to the left of the decimal point.</p><ul><li><p>Example: <code>ROUND(5234, -3)</code> → <code>5000</code></p></li></ul></li></ul></li></ul><p>Correct Answer: <strong>Rounds the average salary in Department 50 to the nearest thousand</strong></p><p>Why the other options are incorrect:</p><ul><li><p><strong>\"Rounds all salaries... before averaging\"</strong> – False: <code>ROUND</code> is applied <strong>after</strong> <code>AVG</code>, not before.</p></li><li><p><strong>\"Causes a syntax error...\"</strong> – False: Negative precision is valid in Oracle’s <code>ROUND</code> function.</p></li><li><p><strong>\"Returns an unrounded average...\"</strong> – False: The <code>ROUND(..., -3)</code> ensures rounding <strong>does happen</strong>.</p></li></ul>",
                "answers": [
                    "<p>Rounds the average salary in Department 50 to the nearest thousand</p>",
                    "<p>Rounds all salaries in Department 50 to the nearest thousand before averaging</p>",
                    "<p>Causes a syntax error due to use of negative rounding</p>",
                    "<p>Returns an unrounded average salary</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "ROUND",
            "question_plain": "View and examine the structure of the following SQL querySELECT ROUND(AVG(SALARY), -3)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 50;\nWhich of the following is the result of the SQL query?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289469,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Which query retrieves the last non-null salary in department 80 based on hire date order?</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query correctly uses the LAST_VALUE function with the IGNORE NULLS clause to retrieve the last non-null salary in department 80 based on hire date order. The PARTITION BY clause ensures that the calculation is done per department, and the ORDER BY clause specifies the hire date order.",
                    "This query uses the LAST_VALUE function but does not include the IGNORE NULLS clause, which means it will include null values in the calculation. This would not accurately retrieve the last non-null salary in department 80 based on hire date order.",
                    "The LAST function is not a valid function in Oracle SQL for retrieving the last non-null value. This query would not provide the desired result of retrieving the last non-null salary in department 80 based on hire date order.",
                    "This query uses the MAX function to retrieve the maximum salary in department 80, which may not necessarily be the last non-null salary based on hire date order. Additionally, it does not consider null values in the calculation, which could lead to inaccurate results."
                ],
                "explanation": "<p><strong>Goal: </strong>Retrieve the <strong>last non-null salary</strong> in <strong>Department 80</strong>, based on <strong>hire date order</strong>.</p><p><strong>Correct Query:</strong></p><pre class=\"prettyprint linenums\">SELECT LAST_VALUE(SALARY IGNORE NULLS)\n  OVER (\n    PARTITION BY DEPARTMENT_ID \n    ORDER BY HIRE_DATE \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  )\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre><p>Why this is correct:</p><ul><li><p><code>LAST_VALUE(... IGNORE NULLS)</code> skips nulls when looking for the \"last\" value.</p></li><li><p><code>ORDER BY HIRE_DATE</code> ensures salaries are ordered by hire date.</p></li><li><p><code>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code> ensures the window includes all rows in the partition (otherwise, the default window might not reach the actual last row).</p></li><li><p>It restricts results to <strong>Department 80</strong>.</p></li></ul><p>Review incorrect options:</p><p>1.</p><pre class=\"prettyprint linenums\">SELECT LAST_VALUE(SALARY)\n  OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre><ul><li><p><strong>Incorrect</strong>: This will return the <strong>last salary within the current window</strong>, but <strong>includes NULLs</strong> and may not return the true last non-null value without proper windowing.</p></li></ul><p>2.</p><pre class=\"prettyprint linenums\">SELECT LAST(SALARY)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre><ul><li><p><strong>Incorrect</strong>: <code>LAST()</code> is <strong>not a valid Oracle SQL aggregate function</strong> — this will <strong>produce an error</strong>.</p></li></ul><p>3.</p><pre class=\"prettyprint linenums\">SELECT MAX(SALARY)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80 AND SALARY IS NOT NULL;\n</pre><ul><li><p><strong>Incorrect</strong>: This gives the <strong>highest</strong> salary, <strong>not the last based on hire date</strong>.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT LAST_VALUE(SALARY IGNORE NULLS)\n  OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LAST_VALUE(SALARY)\n  OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LAST(SALARY)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT MAX(SALARY)\nFROM EMPLOYEES\nWHERE DEPARTMENT_ID = 80 AND SALARY IS NOT NULL;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Which query retrieves the last non-null salary in department 80 based on hire date order?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289471,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Examine this statement.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">ALTER TABLE employees \nADD CONSTRAINT emp_email_ck \nCHECK (INSTR(email, '@') &gt; 1);\n</pre><p><br></p><p>Which of the following is true about this constraint declaration?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CONSTRAINT ](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/constraint.html)"
                ],
                "feedbacks": [
                    "The constraint declaration in Exhibit 1 does not specify the NOT NULL constraint, so it allows null values in the email column. The constraint only checks if the '@' symbol is present in the email, not if the email itself is null.",
                    "The constraint in Exhibit 1 does not explicitly check for null values in the email column. It only checks if the '@' symbol is present in the email. Therefore, the constraint does not fail if the email contains a null value.",
                    "The constraint in Exhibit 1 checks if the '@' symbol is present in the email column, but it does not enforce that the email must start with '@'. It only ensures that the '@' symbol is present at a position greater than 1 in the email.",
                    "The constraint declaration in Exhibit 1 does not enforce email uniqueness. It only checks if the '@' symbol is present in the email column at a position greater than 1. It does not prevent duplicate email addresses in the table."
                ],
                "explanation": "<p>Correct Answer: <strong>The constraint allows null values in email</strong></p><p>Analyze the SQL statement:</p><pre class=\"prettyprint linenums\">ALTER TABLE employees \nADD CONSTRAINT emp_email_ck \nCHECK (INSTR(email, '@') &gt; 1);\n</pre><p>What does this do?</p><ul><li><p><code>INSTR(email, '@') &gt; 1</code> checks <strong>if the '@' symbol exists and is not in the first position</strong>.</p></li><li><p><code>INSTR(...)</code> returns <strong>0</strong> if the substring is not found.</p></li><li><p>A <code>CHECK</code> constraint <strong>does not evaluate to false for NULL values</strong> — it evaluates to <strong>UNKNOWN</strong>, which is <strong>allowed</strong>.</p></li></ul><p>Why the other options are incorrect:</p><ul><li><p><strong>\"The constraint fails if email contains a null value\"</strong> – False. NULL values are <strong>not rejected</strong> by CHECK constraints unless you explicitly disallow them using <code>NOT NULL</code>.</p></li><li><p><strong>\"It enforces that email must start with '@'\"</strong> – Incorrect. It ensures <code>'@'</code> is <strong>not</strong> the first character — it must appear <strong>after</strong> position 1.</p></li><li><p><strong>\"It enforces email uniqueness\"</strong> – False. This is a <strong>CHECK</strong> constraint, not a <strong>UNIQUE</strong> constraint.</p></li></ul>",
                "answers": [
                    "<p>The constraint allows null values in <code>email</code></p>",
                    "<p>The constraint fails if <code>email</code> contains a null value</p>",
                    "<p>It enforces that email must start with '@'</p>",
                    "<p>It enforces email uniqueness</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "CONSTRAINT",
            "question_plain": "View and examine the following available responses.Examine this statement.Exhibit 1:ALTER TABLE employees \nADD CONSTRAINT emp_email_ck \nCHECK (INSTR(email, '@') &gt; 1);\nWhich of the following is true about this constraint declaration?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289473,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Examine this statement.</p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id;\n</pre><p><br></p><p>Given this query, which clause will cause an error if added?</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Adding a WHERE clause with an aggregate function like COUNT(*) in this context will cause an error because the WHERE clause is used for filtering rows before grouping, and it cannot directly reference an aggregate function like COUNT(*).",
                    "The HAVING clause is used to filter groups based on aggregate values like COUNT(*). In this case, adding a HAVING clause with COUNT(*) &gt; 5 is valid and will not cause an error because it filters groups after the grouping operation.",
                    "The ORDER BY clause is used to sort the result set based on specified columns. Adding an ORDER BY clause with department_id is valid and will not cause an error because it sorts the result set after the grouping operation.",
                    "The GROUP BY clause is essential in this query as it specifies the columns to group the result set by. Removing the GROUP BY clause or changing it to a different column would cause an error because it is necessary for the query to function correctly."
                ],
                "explanation": "<p>Which clause <strong>will cause an error</strong> if added?</p><p><code><strong>WHERE COUNT(*) &gt; 5</strong></code> — <strong>Causes Error</strong></p><ul><li><p><code>WHERE</code> is used <strong>before</strong> grouping, and <strong>cannot</strong> reference aggregate functions like <code>COUNT(*)</code>.</p></li><li><p><strong>COUNT(*)</strong> is calculated <strong>after</strong> rows are grouped.</p></li><li><p>This is <strong>invalid syntax</strong>.</p></li></ul><p>Analyze the query and the options.</p><pre class=\"prettyprint linenums\">SELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id;\n</pre><p>This query groups employees by <code>department_id</code> and counts how many employees are in each department.</p><p><br></p><p><strong>Correct Clause for Filtering on Aggregates:</strong></p><p>You must use <code>HAVING</code> instead.</p><p><code><strong>HAVING COUNT(*) &gt; 5</strong></code> — ✅ <strong>Valid</strong></p><ul><li><p><code>HAVING</code> is designed to filter <strong>after</strong> aggregation.</p></li><li><p>This would work correctly.</p></li></ul><p><code><strong>ORDER BY department_id</strong></code> — ✅ <strong>Valid</strong></p><ul><li><p>You can sort the grouped results.</p></li></ul><p><code><strong>GROUP BY department_id</strong></code> — ✅ <strong>Already present and valid</strong></p><ul><li><p>It’s essential for grouping in this query.</p></li></ul>",
                "answers": [
                    "<p><code>WHERE COUNT(*) &gt; 5</code> </p>",
                    "<p><code>HAVING COUNT(*) &gt; 5</code> </p>",
                    "<p><code>ORDER BY department_id</code> </p>",
                    "<p><code>GROUP BY department_id</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "WHERE",
            "question_plain": "View and examine the following available responses.Examine this statement.SELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id;\nGiven this query, which clause will cause an error if added?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289475,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Examine this statement.</p><pre class=\"prettyprint linenums\">MERGE INTO products p\nUSING promotions pr\nON (p.promo_id = pr.promo_id)\nWHEN MATCHED THEN\n  UPDATE SET p.price = p.price * 0.9\nWHEN NOT MATCHED THEN\n  INSERT (product_id, promo_id, price)\n  VALUES (pr.promo_product_id, pr.promo_id, pr.discount_price);\n</pre><p><br></p><p>Which of the following is the outcome of the above MERGE statement?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[MERGE ](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/MERGE.html)"
                ],
                "feedbacks": [
                    "The MERGE statement is used to perform a combination of INSERT, UPDATE, and DELETE operations based on a condition. In this specific statement, when a match is found between the products and promotions tables, the price of the product is updated by reducing it by 10%. If no match is found, a new record is inserted into the products table with the product_id, promo_id, and discount_price from the promotions table.",
                    "This statement does not update unmatched promotions or insert matched ones. The UPDATE SET clause only applies to matched rows, where the price of the product is updated. The INSERT clause is executed only for rows in the promotions table that do not have a corresponding promo_id in the products table.",
                    "The statement will not result in an error if promo_id is null. The ON clause specifies the condition for matching rows between the products and promotions tables based on the promo_id column. If a promo_id is null in either table, it will not match with any rows in the other table, and the appropriate action (UPDATE or INSERT) will be taken accordingly.",
                    "The MERGE statement does not require a DELETE clause for unmatched rows in this scenario. The WHEN NOT MATCHED THEN INSERT clause handles the insertion of new records from the promotions table into the products table when there is no match based on the promo_id column. The DELETE operation is not needed for this specific statement."
                ],
                "explanation": "<p>Correct Answer: <strong>Updates products that match, inserts unmatched promotions</strong> </p><p>Break down the <strong>MERGE</strong> statement and evaluate each option.</p><p><strong>Given SQL:</strong></p><pre class=\"prettyprint linenums\">MERGE INTO products p\nUSING promotions pr\nON (p.promo_id = pr.promo_id)\nWHEN MATCHED THEN\n  UPDATE SET p.price = p.price * 0.9\nWHEN NOT MATCHED THEN\n  INSERT (product_id, promo_id, price)\n  VALUES (pr.promo_product_id, pr.promo_id, pr.discount_price);\n</pre><p><strong>What this MERGE does:</strong></p><ul><li><p><strong>MERGE INTO</strong> → target table is <code>products</code>.</p></li><li><p><strong>USING</strong> → source is <code>promotions</code>.</p></li><li><p><strong>ON</strong> → condition: match on <code>promo_id</code>.</p></li></ul><p>Behaviour:</p><ul><li><p>If a row in <code>promotions</code> <strong>matches</strong> a row in <code>products</code>, it <strong>updates</strong> the product price (10% discount).</p></li><li><p>If there's <strong>no match</strong>, it <strong>inserts</strong> a new row into <code>products</code> using values from <code>promotions</code>.</p></li></ul><p>Option Analysis:</p><p><strong>1. \"Updates products that match, inserts unmatched promotions\"</strong> — <strong>Correct</strong></p><ul><li><p>This is exactly what the MERGE does.</p></li></ul><p><strong>2. \"Updates unmatched promotions and inserts matched ones\"</strong> — Incorrect</p><ul><li><p>It's the opposite of what MERGE does.</p></li><li><p><strong>Updates occur on matches</strong>, <strong>inserts on non-matches</strong>.</p></li></ul><p><strong>3. \"Results in an error if promo_id is null\"</strong> — Incorrect</p><ul><li><p><code>NULL</code> values in the <strong>join condition</strong> (<code>ON</code>) don't cause an error.</p></li><li><p>However, <strong>nulls won't match</strong>, so they'll go into the <strong>NOT MATCHED</strong> path (insertion).</p></li><li><p>An error only occurs if constraints (e.g., NOT NULL) are violated — not from the join itself.</p></li></ul><p><strong>4. \"Requires a DELETE clause for unmatched rows\"</strong> — Incorrect</p><ul><li><p>A <code>DELETE</code> clause is <strong>optional</strong> in a <code>MERGE</code> and not required.</p></li></ul>",
                "answers": [
                    "<p>Updates products that match, inserts unmatched promotions</p>",
                    "<p>Updates unmatched promotions and inserts matched ones</p>",
                    "<p>Results in an error if promo_id is null</p>",
                    "<p>Requires a DELETE clause for unmatched rows</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "MERGE",
            "question_plain": "View and examine the following available responses.Examine this statement.MERGE INTO products p\nUSING promotions pr\nON (p.promo_id = pr.promo_id)\nWHEN MATCHED THEN\n  UPDATE SET p.price = p.price * 0.9\nWHEN NOT MATCHED THEN\n  INSERT (product_id, promo_id, price)\n  VALUES (pr.promo_product_id, pr.promo_id, pr.discount_price);\nWhich of the following is the outcome of the above MERGE statement?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 119289477,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Which of the following queries uses scalar subqueries correctly?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Scalar Subquery Expressions](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Scalar-Subquery-Expressions.html)"
                ],
                "feedbacks": [
                    "This query correctly uses a scalar subquery by selecting a single value (department_id) from the departments table based on the condition specified in the WHERE clause (location_id = 1000). The subquery is embedded in the SELECT statement to retrieve the department_id for each employee_id in the employees table.",
                    "This query uses a scalar subquery to select a single value (department_id) from the departments table, but it does not specify any condition in the subquery. As a result, the subquery will return multiple values, which is not valid for a scalar subquery. Scalar subqueries should return only one value.",
                    "This query attempts to use a scalar subquery by selecting all columns (*) from the departments table based on the condition specified in the WHERE clause (location_id = 1000). However, scalar subqueries should return a single value, not multiple columns. Using * in the subquery makes it a non-scalar subquery.",
                    "This query incorrectly uses a scalar subquery by attempting to select all employee_id values from the employees table within the subquery. Scalar subqueries should return a single value, not multiple values. In this case, the subquery does not have a condition to filter the results, which would result in multiple employee_id values being returned."
                ],
                "explanation": "<p>Evaluate each query based on <strong>correct scalar subquery usage</strong>.</p><p><strong>Definition: Scalar Subquery</strong></p><p>A <strong>scalar subquery</strong>:</p><ul><li><p>Is a subquery used <strong>in a SELECT</strong>, <code>WHERE</code>, or <code>ORDER BY</code> clause.</p></li><li><p><strong>Returns exactly one row and one column</strong>.</p></li><li><p>If it returns <strong>more than one row</strong>, it causes an error.</p></li></ul><p>Analyze Each Option:</p><p><strong>Option 1: (Correct)</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT department_id\n        FROM departments\n        WHERE location_id = 1000)\nFROM employees;\n</pre><ul><li><p><strong>Valid</strong>, if the subquery returns <strong>exactly one row</strong> (i.e., only one department exists in location <code>1000</code>).</p></li><li><p><strong>Returns one column</strong>, used as a scalar.</p></li><li><p><strong>Correct scalar subquery usage.</strong></p></li></ul><p><strong>Option 2:</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT department_id\n        FROM departments)\nFROM employees;\n</pre><ul><li><p>Invalid. No <code>WHERE</code> clause → likely returns <strong>multiple rows</strong>.</p></li><li><p>Scalar subqueries <strong>must return only one row</strong>.</p></li><li><p><strong>Incorrect.</strong></p></li></ul><p><strong>Option 3:</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT *\n        FROM departments\n        WHERE location_id = 1000)\nFROM employees;\n</pre><ul><li><p>Invalid syntax.</p></li><li><p>Scalar subqueries must return <strong>exactly one column</strong>, not <code>*</code>.</p></li><li><p><strong>Incorrect.</strong></p></li></ul><p><strong>Option 4:</strong></p><pre class=\"prettyprint linenums\">SELECT (SELECT employee_id FROM employees)\nFROM departments;\n</pre><ul><li><p>Potential error if <code>employees</code> table has <strong>more than one row</strong>.</p></li><li><p>Will work <strong>only if one employee exists</strong>, but it's risky and likely to fail.</p></li><li><p><strong>Incorrect unless guaranteed only one row in employees.</strong></p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT department_id\n        FROM departments\n        WHERE location_id = 1000)\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT department_id\n        FROM departments)\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT employee_id,\n       (SELECT *\n        FROM departments\n        WHERE location_id = 1000)\nFROM employees;\n</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT (SELECT employee_id FROM employees)\nFROM departments;\n</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Subqueries",
            "question_plain": "View and examine the following available responses.Which of the following queries uses scalar subqueries correctly?",
            "related_lectures": []
        }
    ]
}