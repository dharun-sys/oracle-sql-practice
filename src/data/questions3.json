{
    "count": 80,
    "next": null,
    "previous": null,
    "results": [
        {
            "_class": "assessment",
            "id": 130305943,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p><strong>Given: </strong>The NLS_DATE_FORMAT is set to DD-MON-YYYY HH24:MI:SS in the DUAL table.</p><p>Identify the two true statements about date/time functions in this session.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "CURRENT_TIMESTAMP and CURRENT_DATE do not return the same date. CURRENT_TIMESTAMP includes the time portion with fractional seconds, while CURRENT_DATE only returns the date portion without the time.",
                    "CURRENT_TIMESTAMP returns the current date and time with fractional seconds, providing more detailed information compared to SYSDATE. This makes the statement true in the context of the session's NLS_DATE_FORMAT setting.",
                    "SYSDATE and CURRENT_DATE do not rely on the operating system's date and time settings. They return the current date and time based on the database server's system clock.",
                    "SYSDATE can be used in expressions regardless of the default date format. It returns the current date and time in the session's time zone, and the format can be adjusted as needed.",
                    "SYSDATE is a built-in function in Oracle that returns the current date and time. It can be queried from any table or context, not just the DUAL table.",
                    "CURRENT_DATE returns the current date based on the session's time zone setting. It does not include the time portion or fractional seconds, making it different from CURRENT_TIMESTAMP and SYSDATE."
                ],
                "explanation": "<p>Set the NLS_DATE_FORMAT to DD-MON-YYYY HH24:MI:SS in the DUAL table.</p><p><br></p><pre class=\"prettyprint linenums\">alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';</pre><p><br></p><p><strong>Queries executed:</strong></p><ol><li><p><code>SELECT CURRENT_TIMESTAMP FROM dual;</code>&nbsp; executes successfully and renders: 10-APR-20 09.45.38.203191 PM +00:00</p></li><li><p><code>SELECT CURRENT_DATE FROM dual;</code>&nbsp; executes successfully and renders: 04/10/2020</p></li><li><p><code>SELECT SYSDATE FROM dual;</code>&nbsp; executes successfully and renders: 04/10/2020</p></li></ol><p><br></p><p><strong>TRUE: CURRENT_DATE returns the current date per the session time zone.</strong></p><ul><li><p><strong>Explanation:</strong> <code>CURRENT_DATE</code> returns the current date and time <strong>in the session's time zone</strong>, not the database server's time zone. This is a key difference from <code>SYSDATE</code>.</p></li></ul><p><strong>TRUE: CURRENT_TIMESTAMP returns the same date and time as SYSDATE with additional details of fractional seconds.</strong></p><ul><li><p><strong>Explanation:</strong> <code>CURRENT_TIMESTAMP</code> returns the <strong>session time zone</strong>'s current timestamp with fractional seconds and time zone info. While the <strong>date and time</strong> might match <code>SYSDATE</code>, <code>CURRENT_TIMESTAMP</code> includes fractional seconds and time zone, unlike <code>SYSDATE</code>.</p></li></ul><p><strong>FALSE: CURRENT_TIMESTAMP returns the same date as CURRENT_DATE.</strong></p><ul><li><p>This can be misleading. Though both return the current date and time, they are tied to the <strong>session time zone</strong>, so they usually match. But <code>CURRENT_TIMESTAMP</code> has more precision (fractional seconds + time zone), so they are not the same in all aspects.</p></li></ul><p><strong>FALSE: SYSDATE and CURRENT_DATE return the current date and time set for the operating system of the database server.</strong></p><ul><li><p><code>SYSDATE</code> uses the <strong>database server's OS time</strong>.</p></li><li><p><code>CURRENT_DATE</code> uses the <strong>session's time zone</strong>, which can differ.</p></li></ul><p><strong>FALSE: SYSDATE can be used in expressions only if the default date format is DD-MON-RR.</strong></p><ul><li><p>This is incorrect. <code>SYSDATE</code> can be used in expressions regardless of the date format. The <code>NLS_DATE_FORMAT</code> only affects how the date is displayed, not how expressions work.</p></li></ul><p><strong>FALSE: SYSDATE can be queried only from the DUAL table.</strong></p><ul><li><p><code>SYSDATE</code> is often used with <code>DUAL</code>, but it can be used in any query or expression (e.g., in <code>WHERE</code> clauses, <code>SELECT</code> lists, PL/SQL code, etc.)</p></li></ul>",
                "answers": [
                    "<p>CURRENT_TIMESTAMP returns the same date as CURRENT_DATE.</p>",
                    "<p>CURRENT_TIMESTAMP returns the same date and time as SYSDATE with additional details of fractional seconds.</p>",
                    "<p>SYSDATE and CURRENT_DATE return the current date and time set for the operating system of the database server.</p>",
                    "<p>SYSDATE can be used in expressions only if the default date format is DD-MON-RR.</p>",
                    "<p>SYSDATE can be queried only from the DUAL table.</p>",
                    "<p>CURRENT_DATE returns the current date per the session time zone.</p>"
                ]
            },
            "correct_response": [
                "f",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Given: The NLS_DATE_FORMAT is set to DD-MON-YYYY HH24:MI:SS in the DUAL table.Identify the two true statements about date/time functions in this session.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305945,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The data dictionary stores information about all users in the database, including their usernames. This information is essential for managing user access and permissions within the database.",
                    "<p>Data dictionary views consist of predefined views that present information about database objects. These views are based on dictionary base tables maintained by the database and <strong>do not involve user-defined tables.</strong></p><p>For example <strong>ALL_</strong>, <strong>USER_</strong>, and <strong>DBA_</strong> <strong>views</strong></p>",
                    "Views with different prefixes, such as DBA, ALL, and USER, provide access to the same underlying base tables in the data dictionary. These views offer different levels of visibility and access rights based on the user's role in the database.",
                    "The data dictionary is a set of tables and views that contain metadata about the database objects. While the database administrator plays a crucial role in managing the data dictionary, it is not solely created and maintained by the DBA.",
                    "Data dictionary views are a combination of dictionary base tables and user-defined tables. These views provide a structured way to access metadata information about database objects, relationships, and constraints.",
                    "<p>Generally, each view is a subset of the higher-privileged view set, row-wise and column wise. They all have to reference the same base tables, they only display filtered rowsets from these tables.</p>"
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ul><li><p>The usernames of all users, including database administrators, are stored in the data dictionary.</p></li><li><p>The USER_CONS_COLUMNS view should be queried to find the names of columns to which constraints apply.</p></li><li><p>Views with the same name but different prefixes, such as DBA, ALL, and USER, reference the same base tables from the data dictionary.</p></li></ul><p><strong>Incorrect Answers:</strong></p><p> The data dictionary is created and maintained by the database administrator.</p><ul><li><p>The <strong>data dictionary is automatically created and maintained by Oracle</strong>, not the DBA. The DBA can <strong>query</strong> or <strong>view</strong> it, but cannot directly <strong>create or maintain</strong> it.</p></li></ul><p>Data dictionary views consist of joins of dictionary base tables and user-defined tables.</p><ul><li><p>Data dictionary views are built on <strong>dictionary base tables</strong>, not on <strong>user-defined tables</strong>.</p></li><li><p>They provide metadata, and user-defined tables are <strong>not part</strong> of the data dictionary views.</p></li></ul><p>Both the USER_OBJECTS and CAT views provide the same information about all objects that are owned by the user.</p><ul><li><p><code>USER_OBJECTS</code> provides <strong>detailed metadata</strong> about all objects owned by the user.</p></li><li><p><code>CAT</code> is a <strong>simplified view</strong> that shows just the name and type of certain objects (tables, views, and synonyms).</p></li><li><p>So, they do <strong>not</strong> provide the same depth or breadth of information.</p></li></ul><p><br></p><p><strong>One of the most important parts of an Oracle database is its data dictionary</strong>, which is a read-only set of tables that provides information about the database. A data dictionary contains:</p><ul><li><p>The definitions of all schema objects in the database (tables, views, indexes, clusters, synonyms, sequences, procedures, functions, packages, triggers, and so on)</p></li><li><p>How much space has been allocated for, and is currently used by, the schema objects</p></li><li><p>Default values for columns</p></li><li><p>Integrity constraint information</p></li><li><p>The names of Oracle users (usernames of all users, including database administrators)</p></li><li><p>Privileges and roles each user has been granted</p></li><li><p>Auditing information, such as who has accessed or updated various schema objects</p></li><li><p>Other general database information</p></li></ul><p>The data dictionary is structured in tables and views, just like other database data. All the data dictionary tables and views for a given database are stored in that database's <code>SYSTEM</code> tablespace.</p><p>Not only is the data dictionary central to every Oracle database, but it is also an important tool for all users, from end users to application designers and database administrators. Use SQL statements to access the data dictionary. Because the data dictionary is read-only, you can issue only queries (<code>SELECT</code> statements) against its tables and views.</p><p><br></p><p><strong>The data dictionary consists of the following:</strong></p><p><strong>Base Tables</strong></p><p>The underlying tables that store information about the associated database. Only Oracle should write to and read these tables. Users rarely access them directly because they are normalized, and most of the data is stored in a cryptic format.</p><p><strong>User-Accessible Views</strong></p><p>The views that summarize and display the information stored in the base tables of the data dictionary. These views decode the base table data into useful information, such as user or table names, using joins and <code>WHERE</code> clauses to simplify the information. Most users are given access to the views rather than the base tables.</p><p><strong>SYS, Owner of the Data Dictionary</strong></p><p>The Oracle user <code>SYS</code> owns all base tables and user-accessible views of the data dictionary. No Oracle user should ever alter (<code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code>) any rows or schema objects contained in the <code>SYS</code> schema, because such activity can compromise data integrity. The security administrator must keep strict control of this central account.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28318/datadict.htm#CNCPT1210\">https://docs.oracle.com/cd/B28359_01/server.111/b28318/datadict.htm#CNCPT1210</a></p><p><br></p><p><strong>The data dictionary has three primary uses:</strong></p><ul><li><p>Oracle accesses the data dictionary to find information about users, schema objects, and storage structures.</p></li><li><p>Oracle modifies the data dictionary every time a data definition language (DDL) statement is issued.</p></li><li><p>Any Oracle user can use the data dictionary as a read-only reference for information about the database.</p></li></ul><p><br></p><p><strong>Data Dictionary View Prefixes</strong></p><p><code>ALL</code>&nbsp; Expanded user's view (what the user can access)</p><p><code>DBA</code>&nbsp; Database administrator's view (what is in all users' schemas)</p><p><code>USER</code>&nbsp; User's view (what is in the user's schema)</p><p><code>ALL</code>, <code>DBA</code>and <code>USER</code>, reference the same base tables from the data dictionary.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14220/datadict.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14220/datadict.htm</a></p><p><br></p><p><strong>USER_CONS_COLUMNS</strong></p><p><code>USER_CONS_COLUMNS</code> describes columns that are owned by the current user and that are specified in constraint definitions. Its columns are the same as those in <a href=\"https://docs.oracle.com/cd/B14117_01/server.101/b10755/statviews_1035.htm#i1575870\">\"ALL_CONS_COLUMNS\"</a>.</p><p><a href=\"https://docs.oracle.com/cd/B14117_01/server.101/b10755/statviews_2508.htm\">https://docs.oracle.com/cd/B14117_01/server.101/b10755/statviews_2508.htm</a></p><p><br></p><p>The <code>USER_OBJECTS</code> and <code>USER_CATALOG</code> views in Oracle Database serve different purposes and contain distinct sets of information about database objects.</p><p>1. **USER_OBJECTS**: This view provides information about all objects owned by the current user. It includes details such as the object type (e.g., table, view, index), the object name, its status, and the date it was created. The <code>USER_OBJECTS</code> view is specifically tailored to show only the objects that belong to the user executing the query, making it useful for users to manage and review their own database objects.</p><p><code>USER_OBJECTS</code> describes all objects owned by the current user. Its columns are the same as those in <a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14237/statviews_2005.htm#i1583352\">\"ALL_OBJECTS\"</a>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14237/statviews_4378.htm#i1634422\">https://docs.oracle.com/cd/B19306_01/server.102/b14237/statviews_4378.htm#i1634422</a></p><p><br></p><p>An object type can represent any real-world entity. For example, an object type can represent a student, bank account, computer screen, rational number, or data structure such as a queue, stack, or list.</p><p>Currently, you cannot define object types in a PL/SQL block, subprogram, or package. You can define them interactively in SQL*Plus using the SQL statement <code>CREATE TYPE</code></p><p><a href=\"https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/objects.htm\">https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/objects.htm</a></p><p><br></p><p>2. **USER_CATALOG**: This view, on the other hand, contains a broader set of information about all types of objects in the database, not limited to those owned by the user. It includes metadata about various database objects, such as tables, views, indexes, and synonyms, along with their definitions and properties. The <code>USER_CATALOG</code> view is more comprehensive and is often used for querying metadata across different schemas and understanding the overall structure of the database.</p><p>In summary, use <code>USER_OBJECTS</code> when you want to focus on your own objects, and <code>USER_CATALOG</code> when you need a wider perspective on the database's object definitions and properties. Understanding these differences can help you effectively navigate and manage your database environment.</p><p><br></p><p><strong>CAT &amp; USER_CATALOG</strong></p><p><code>CAT</code> is a synonym for <code>USER_CATALOG,</code> which lists tables, views, clusters, synonyms, and sequences owned by the current user. Its columns are the same as those in <a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_1028.htm#i1575120\">\"ALL_CATALOG\"</a>.</p><p><a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_5212.htm#REFRN26036\">https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_5212.htm#REFRN26036</a></p>",
                "answers": [
                    "<p>The data dictionary is created and maintained by the database administrator.</p>",
                    "<p>Data dictionary views consist of joins of dictionary base tables and user-defined tables.</p>",
                    "<p>The usernames of all users including database administrators are stored in the data dictionary.</p>",
                    "<p>The USER_CONS_COLUMNS view should be queried to find the names of columns to which constraints apply.</p>",
                    "<p>Both USER_OBJECTS and CAT views provide the same information about all objects that are owned by the user.</p>",
                    "<p>Views with the same name but different prefixes, such as DBA, ALL and USER, reference the same base tables from the data dictionary.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d",
                "f"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305949,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario and the exhibit.</p><p><strong>Required:</strong> List the employees in DEPARTMENT_ID 30 in a single row, ordered by HIRE_DATE.&nbsp; </p><p>Examine the sample output.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">EMP_LIST                                                                        EARLIEST\nRaphaelly; Khoo; Tobais; Baida; Himuro; Colmenares                              01-23-18</pre><p><br></p><p>Which query will provide the required output?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: LISTAGG Function](https://www.techonthenet.com/oracle/functions/listagg.php)",
                    "[LISTAGG](https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions089.htm#SQLRF30030)"
                ],
                "feedbacks": [
                    "The query is missing the correct syntax for the LISTAGG function. The ORDER BY clause should be inside the WITHIN GROUP clause, not outside of it. Additionally, the hire_date should be included in the ORDER BY clause of the LISTAGG function.",
                    "The query is missing the correct syntax for the LISTAGG function. The WITHIN GROUP clause should come before the ORDER BY clause. The hire_date should be included in the ORDER BY clause of the LISTAGG function.",
                    "The query is missing the correct syntax for the LISTAGG function. The WITHIN GROUP clause should come before the ORDER BY clause. The hire_date should be included in the ORDER BY clause of the LISTAGG function.",
                    "This query correctly uses the LISTAGG function with the correct syntax. It orders the employees in department_id 30 by hire_date and last_name in a single row. The MIN function is used to find the earliest hire_date."
                ],
                "explanation": "<p><strong>Requirement:</strong></p><ul><li><p><strong>List all employees in </strong><code><strong>DEPARTMENT_ID = 30</strong></code></p></li><li><p><strong>In a single row</strong></p></li><li><p><strong>Ordered by </strong><code><strong>HIRE_DATE</strong></code></p></li><li><p><strong>Separated by semicolons</strong></p></li><li><p>Also, show the <strong>earliest hire date</strong></p></li></ul><p><strong>Correct Query Format Should Include:</strong></p><ol><li><p><code>LISTAGG(last_name, '; ')</code> – for concatenation with semicolons.</p></li><li><p><code>WITHIN GROUP (ORDER BY hire_date)</code> – to ensure the names are ordered by <code>HIRE_DATE</code>.</p></li><li><p><code>MIN(hire_date)</code> – to return the earliest hire date.</p></li><li><p><code>FROM employees WHERE department_id = 30</code> – the correct filter.</p></li><li><p>The entire expression should return a <strong>single row</strong> with both <code>Emp_list</code> and <code>Earliest</code>.</p></li></ol><pre class=\"prettyprint linenums\">SELECT LISTAGG(last_name, '; ')\nWITHIN GROUP (ORDER BY hire_date, last_name) \"Emp_list\",\nMIN(hire_date) \"Earliest\"\nFROM employees\nWHERE department_id = 30;</pre><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-11_00-36-54-92c9894ba8e7920cf0f8447c57f672c3.png\"></p><p><br></p><ol><li><p>Correct syntax.</p></li><li><p>Orders are <code>last_name</code> by <code>hire_date</code>, and then by <code>last_name</code> as a tiebreaker.</p></li><li><p>Returns concatenated names in the required order.</p></li><li><p>Shows the earliest hire date.</p></li></ol><p><strong>Evaluate the incorrect options:</strong></p><p>Option 1:</p><pre class=\"prettyprint linenums\">sql\nSELECT LISTAGG(last_name) \nWITHIN GROUP  \nORDER BY (hire_date) \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30;\n</pre><ul><li><p>Syntax error: <code>ORDER BY</code> is incorrectly placed outside of <code>WITHIN GROUP</code>.</p></li><li><p>Missing delimiter in <code>LISTAGG</code> (should be <code>'; '</code>).</p></li><li><p><strong>Invalid syntax</strong></p></li></ul><p>Option 2:</p><pre class=\"prettyprint linenums\">sql\nSELECT LISTAGG(last_name, '; ') \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30; \nWITHIN GROUP  \nORDER BY (hire_date);\n</pre><ul><li><p><code>WITHIN GROUP</code> can't come after the <code>FROM</code> clause.</p></li><li><p>Invalid SQL structure.</p></li><li><p><strong>Invalid syntax</strong></p></li></ul><p>Option 3:</p><pre class=\"prettyprint linenums\">sql\nSELECT LISTAGG(last_name, '; ') \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30; \nORDER BY (hire_date);\n</pre><ul><li><p>Missing <code>WITHIN GROUP</code>, so ordering inside aggregation is <strong>not guaranteed</strong>.</p></li><li><p><code>ORDER BY</code> outside of <code>LISTAGG</code> affects rows, not the aggregation.</p></li><li><p><strong>Incorrect output</strong></p></li></ul><p><br></p><p><strong>LISTAGG function</strong></p><p>The Oracle/PLSQL<code> LISTAGG</code> function concatenates values of the <em>measure_column</em> for each GROUP based on the <em>order_by_clause</em> to transform data from multiple rows into a single list of values separated by a specified delimiter.</p><p><strong>Syntax</strong></p><p>The syntax for the LISTAGG function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">LISTAGG (measure_column [, 'delimiter'])\n  WITHIN GROUP (order_by_clause) [OVER (query_partition_clause)]</pre><p><br></p><p>For a specified measure, <code>LISTAGG</code> orders data within each group specified in the <code>ORDER BY</code> clause and then concatenates the values of the measure column.</p><p>• As a single-set aggregate function, <code>LISTAGG</code> operates on all rows and returns a single output row.</p><p>• As a group-set aggregate, the function operates on and returns an output row for each group defined by the GROUP BY clause.</p><p>• As an analytic function, <code>LISTAGG</code> partitions the query result set into groups based on one or more expressions in the query_partition_clause.</p><p><br></p><p><strong>The arguments to the function are subject to the following rules:</strong></p><p>• The measure_expr can be any expression. Null values in the measure column are ignored.</p><p>• The delimiter_expr designates the string that is to separate the measure values. This clause is optional and defaults to NULL.</p><p>• The order_by_clause determines the order in which the concatenated values are returned. The function is deterministic only if the <code>ORDER BY</code> column list achieves unique ordering.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT LISTAGG(last_name) \nWITHIN GROUP&nbsp; \nORDER BY (hire_date) \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LISTAGG(last_name, '; ') \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30; \nWITHIN GROUP&nbsp; \nORDER BY (hire_date);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LISTAGG(last_name, '; ') \"Emp_list\", \nMIN(hire_date) \"Earliest\" \nFROM employees \nWHERE department_id = 30; \nORDER BY (hire_date);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT LISTAGG(last_name, '; ')\nWITHIN GROUP (ORDER BY hire_date, last_name) \"Emp_list\",\nMIN(hire_date) \"Earliest\"\nFROM employees\nWHERE department_id = 30;</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario and the exhibit.Required: List the employees in DEPARTMENT_ID 30 in a single row, ordered by HIRE_DATE.&nbsp; Examine the sample output.Exhibit: 1EMP_LIST                                                                        EARLIEST\nRaphaelly; Khoo; Tobais; Baida; Himuro; Colmenares                              01-23-18Which query will provide the required output?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305951,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding working with dates (Choose two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Datetime Datatypes and Time Zone Support](https://docs.oracle.com/cd/B19306_01/server.102/b14225/ch4datetime.htm)",
                    "[Format Models](https://docs.oracle.com/cd/B28359_01/server.111/b28286/sql_elements004.htm#SQLRF00210)",
                    "[DATE_FORMAT](https://docs.oracle.com/cd/B28359_01/olap.111/b28126/dml_commands_1029.htm#OLADM780)"
                ],
                "feedbacks": [
                    "A format model is essential for describing how datetime or numeric data is stored in a character string, allowing for proper interpretation and manipulation of date values in Oracle Database SQL.",
                    "Storing 20th century dates in the 21st century using two digits can lead to ambiguity and incorrect date representations, which is not a recommended practice in date handling.",
                    "The format of datetime data is typically stored in a specific format that is recognized by the database system, ensuring consistency and accuracy in date operations.",
                    "Storing 19th century dates in the 21st century using two digits can also result in incorrect date interpretations and should be avoided for accurate date handling.",
                    "The RR date format is designed to replace the deprecated YY format, providing a more reliable and standardized way to represent years in date values, ensuring compatibility and consistency in date operations."
                ],
                "explanation": "<p><strong>Correct Options:</strong></p><p>A format model is a character literal that describes the format of datetime or numeric data stored in a character string.</p><ul><li><p>This is correct. A <strong>format model</strong> (like <code>'DD-MON-YYYY'</code> or <code>'MM/DD/RR'</code>) is a string literal used in functions like <code>TO_DATE</code>, <code>TO_CHAR</code>, etc., to <strong>interpret or display</strong> date/time or numeric data.</p></li></ul><p>The RR date format replaced the YY deprecated format.</p><ul><li><p><code>RR</code> was introduced to <strong>overcome the limitations</strong> of the <code>YY</code> format (which couldn't handle century transitions well).</p></li><li><p>While <code>YY</code> isn't officially deprecated, <code><strong>RR</strong></code><strong> is preferred</strong> for handling 2-digit years correctly across centuries.</p></li></ul><p><strong>Incorrect Options:</strong></p><p><strong>Misleading:</strong> It lets you store 20th-century dates in the 21st century using two digits.</p><ul><li><p>The <strong>RR</strong> format helps interpret <strong>two-digit years</strong> correctly across <strong>centuries</strong>:</p><ul><li><p>If you enter <code>50</code>–<code>99</code>, Oracle interprets it as <strong>1950–1999</strong>.</p></li><li><p>If you enter <code>00</code>–<code>49</code>, Oracle interprets it as <strong>2000–2049</strong>.</p></li></ul></li><li><p>So, this wording is <strong>unclear</strong> or <strong>incorrect</strong>, as it's not just about storing \"20th-century dates in the 21st century\".</p></li></ul><p><strong>False: </strong>The format of datetime data can be stored in either numeric or string format.</p><ul><li><p>Oracle stores <code>DATE</code> data in a <strong>binary format</strong>, not as a string or a number.</p></li><li><p>You can <strong>display or convert</strong> it to/from strings or numbers, but <strong>internally</strong>, it's stored in its <strong>own binary format</strong>.</p></li></ul><p><strong>False: </strong>It lets you store 19th-century dates in the 21st century using two digits.</p><ul><li><p>Similar to Statement 2, this is incorrect. The <strong>RR format</strong> does <strong>not</strong> support 19th-century dates when using 2-digit years.</p></li><li><p>It only spans <strong>1950–2049</strong> when using <code>RR</code>.</p></li></ul><p><br></p><p>The datetime datatypes are <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIME ZONE,</code> and <code>TIMESTAMP WITH LOCAL TIME ZONE</code>. Values of datetime datatypes are sometimes called datetimes.</p><p>The interval datatypes are <code>INTERVAL YEAR TO MONTH</code> and <code>INTERVAL DAY TO SECOND</code>. Values of interval datatypes are sometimes called intervals.</p><p>Both datetimes and intervals are made up of fields. The values of these fields determine the value of the datatype. The fields that apply to all Oracle datetime and interval datatypes are:</p><ul><li><p><code>YEAR</code></p></li><li><p><code>MONTH</code></p></li><li><p><code>DAY</code></p></li><li><p><code>HOUR</code></p></li><li><p><code>MINUTE</code></p></li><li><p><code>SECOND</code></p></li></ul><p><br></p><p>The default date format for an Oracle date value is derived from the <code>NLS_DATE_FORMAT</code> and <code>NLS_DATE_LANGUAGE</code> initialization parameters. The date format in the example includes a two-digit number for the day of the month, an abbreviation of the month name, the last two digits of the year, and a 24-hour time designation. The specification for <code>NLS_DATE_LANGUAGE</code> is included because '<code>DEC'</code> is not a valid value for <code>MON</code> in all locales.</p><p>Oracle automatically converts character values that are in the default date format into date values when they are used in date expressions.</p><p>If you specify a date value without a time component, then the default time is midnight. If you specify a date value without a date, then the default date is the first day of the current month.</p><p><br></p><p>A format model is a character literal that describes the format of datetime or numeric data stored in a character string. </p><p>A format model does not change the internal representation of the value in the database. When you convert a character string into a date or number, a format model determines how Oracle Database interprets the string. In SQL statements, you can use a format model as an argument of the <code>TO_CHAR</code> and <code>TO_DATE</code> functions to specify:</p><p>The format for Oracle to use to return a value from the database</p><p>The format for a value you have specified for Oracle to store in the database</p><p>For example:</p><p>• The datetime format model for the string '<code>17:45:29</code>' is '<code>HH24:MI:SS</code>'.</p><p>• The datetime format model for the string '<code>11-Nov-1999</code>' is '<code>DD-Mon-YYYY</code>'.</p><p>• The number format model for the string '<code>$2,304.25</code>' is '<code>$9,999.99</code>'.</p><p><br></p><p><strong>How RR Date Format Works?</strong></p><p>'RR' format was designed to complement 'YY' format; it does the same sort of thing inside a different window of years.</p><p>In 'YY' format, a 2-digit year is assumed to be in the 100 consecutive years starting with the most recent xx00 and ending with the next xx99.</p><p>In 'RR' format, a 2-digit year is assumed to be in the 100 consecutive years starting with the most recent xx50 and ending with the next xx49. That is, the window of possible dates is shifted by 50 years.</p><p>Currently, and until 2049 (inclusive), 'RR' years will always be in the range 1950 through 2049, inclusive. That is, the years returned by TO_DATE (x, 'RR') will be between 1950 and 2049.</p><p>Starting in 2050, 'RR' years will always be in the range 2050 through 2149, inclusive.</p><ul><li><p>Both the 'YY' and 'RR' formats are bad. You should not be using 2-digit years. Always use 4-digit years. The small amount of extra typing that users have to do whenever they enter a 4-digit year is very little compared to the work needed to correct errors that always happen when you use 2-digit years.</p></li><li><p><code>RR</code> - Lets you store 20th-century dates in the 21st century using only two digits.</p></li><li><p><code>RRRR </code>- Accepts either 4-digit or 2-digit input. If 2-digit, provides the same return as <code>RR</code>. If you do not want this functionality, then enter the 4-digit year.</p></li></ul><p><a href=\"https://community.oracle.com/thread/974281\">https://community.oracle.com/thread/974281</a></p><p><br></p><p>The DATE datatype is a datetime datatype. It stores a date and a time. The date portion is based on the number of days since January 1, 4712 BC. The time portion is based on the number of seconds since midnight. A date field is declared as a variable name followed by the DATE keyword: v_date_field DATE; </p><p>There is no \"correct\" format for a date. The format is determined by several variables. At the database level, you can set the NLS_DATE_FORMAT. Regardless of how the default is set in your database, you should always make sure you explicitly use a date format mask when converting.</p>",
                "answers": [
                    "<p>A format model is a character literal that describes the format of datetime or numeric data stored in a character string.</p>",
                    "<p>Lets you store 20th century dates in the 21st century using two digits.</p>",
                    "<p>The format of datetime data can be stored in either numeric or string format.</p>",
                    "<p>Lets you store 19th century dates in the 21st century using two digits.</p>",
                    "<p>The RR date format replaced the YY deprecated format.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding working with dates (Choose two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305953,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS table and the exhibit. </p><p><strong>Table: PRODUCTS </strong> </p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPROD_ID          NOT NULL          NUMBER(2)\nQTY                                NUMBER(5,2)\nCOST                               NUMBER(8,2)</pre><p><br></p><p><strong>Given: </strong>The following command has been successfully executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE new_prices(prod_id NUMBER(2), PRICE number(8,2));</pre><p><br></p><p>Identify the MERGE statement that executes without an error.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[MERGE](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/MERGE.html)"
                ],
                "feedbacks": [
                    "<ol><li><p><strong>Deletes records where </strong><code><strong>p.cost &lt; 200</strong></code><strong> first</strong></p><ul><li><p><code>WHEN MATCHED AND p.cost &lt; 200 THEN DELETE</code> ensures that <strong>rows with </strong><code><strong>cost &lt; 200</strong></code><strong> are deleted first</strong>.</p></li></ul></li><li><p><strong>Updates remaining matched records</strong></p><ul><li><p><code>WHEN MATCHED THEN UPDATE SET n.price = p.cost * 0.01;</code> applies <strong>only to rows that were not deleted</strong>.</p></li></ul></li><li><p><strong>Maintains correct processing order</strong></p><ul><li><p><strong>Oracle processes </strong><code><strong>DELETE</strong></code><strong> first</strong> (for matching rows) before applying <code>UPDATE</code> to the remaining records.</p></li></ul></li></ol>",
                    "<p>This <code>MERGE</code> statement has <strong>two major syntax errors</strong>:</p><ol><li><p><code><strong>INSERT</strong></code><strong> is not allowed in </strong><code><strong>WHEN MATCHED THEN</strong></code></p><ul><li><p><code>INSERT</code> can <strong>only be used</strong> in the <code>WHEN NOT MATCHED THEN</code> clause.</p></li><li><p><code>WHEN MATCHED</code> allows <strong>only </strong><code><strong>UPDATE</strong></code><strong> or </strong><code><strong>DELETE</strong></code>, not <code>INSERT</code>.</p></li></ul></li><li><p><strong>The </strong><code><strong>WHERE</strong></code><strong> condition in </strong><code><strong>INSERT</strong></code><strong> is invalid</strong></p><ul><li><p>The <code>WHERE</code> clause <strong>cannot be used directly inside </strong><code><strong>INSERT</strong></code><strong> in </strong><code><strong>MERGE</strong></code>.</p></li><li><p>If you want to filter records for insertion, you should:</p><ul><li><p><strong>Filter in the </strong><code><strong>USING</strong></code><strong> clause</strong> or</p></li><li><p><strong>Use </strong><code><strong>WHEN NOT MATCHED AND</strong></code><strong> condition</strong>.</p></li></ul></li></ul></li></ol>",
                    "<ol><li><p><strong>Incorrect DELETE Condition in </strong><code><strong>WHEN MATCHED THEN DELETE</strong></code></p><ul><li><p>The alias <code><strong>P</strong></code><strong> (products)</strong> is not directly accessible in the <code>DELETE</code> condition.</p></li><li><p>The correct alias to use is <code><strong>N</strong></code><strong> (new_prices)</strong>, because the <code>DELETE</code> operation applies to the target table (<code>new_prices</code>).</p></li></ul></li><li><p><strong>Incorrect Column Reference in </strong><code><strong>WHEN NOT MATCHED THEN INSERT</strong></code></p><ul><li><p>The <code>cost</code> column belongs to <code>p</code> (products), but since <code>cost</code> is not included in the <code>USING</code> clause projection, it should be referenced explicitly as <code>p.cost</code>.</p></li></ul></li></ol>",
                    "<p>This <code>MERGE</code> statement contains a <strong>syntax error</strong>:</p><ul><li><p>The <code><strong>WHERE (p.cost &lt; 200);</strong></code> at the end is invalid in a <code>MERGE</code> statement.</p></li><li><p><strong>Filters</strong> should be placed either:</p><ul><li><p>In the <code>USING</code> clause to limit rows being merged.</p></li><li><p>In the <code>WHEN MATCHED THEN UPDATE</code> or <code>WHEN MATCHED THEN DELETE</code> clauses.</p></li></ul></li></ul>"
                ],
                "explanation": "<p><strong>MERGE statement, which executes without an error.</strong></p><p><br></p><pre class=\"prettyprint linenums\">MERGE INTO new_prices n\nUSING (\n    SELECT prod_id, cost  \n    FROM products \n    WHERE cost &gt; 150\n) p\nON (n.prod_id = p.prod_id)\nWHEN MATCHED AND p.cost &lt; 200 THEN\n    DELETE\nWHEN MATCHED THEN\n    UPDATE SET n.price = p.cost * 0.01;</pre><p><br></p><p><strong>Step-by-step validation:</strong></p><ol><li><p><strong>Target Table: </strong><code><strong>new_prices</strong></code><strong> (alias </strong><code><strong>n</strong></code><strong>)</strong></p><ul><li><p>Columns: <code>prod_id</code>, <code>price</code></p></li></ul></li><li><p><strong>Source Table: Subquery </strong><code><strong>p</strong></code></p><ul><li><p>Returns <code>prod_id</code>, <code>cost</code> from <code>products</code> where <code>cost &gt; 150</code></p></li></ul></li><li><p><strong>ON condition:</strong> <code>n.prod_id = p.prod_id</code><br>Valid join condition</p></li><li><p><strong>WHEN MATCHED AND condition:</strong></p><ul><li><p><code>p.cost &lt; 200</code> → Conditional <code>DELETE</code><br>This is syntactically correct and allowed</p></li></ul></li><li><p><strong>Second WHEN MATCHED clause:</strong></p><ul><li><p><code>UPDATE SET n.price = p.cost * 0.01</code><br>Valid update using compatible data types (<code>NUMBER(8,2)</code> * number results in a valid number for <code>price</code>)</p></li></ul></li><li><p><strong>No </strong><code><strong>WHEN NOT MATCHED</strong></code><strong> clause</strong><br>Not required — it's optional</p></li></ol><p><strong>This MERGE statement is valid and will execute without error.</strong></p><p>It correctly:</p><ul><li><p>Uses a valid subquery as the source</p></li><li><p>Has a valid ON condition</p></li><li><p>Uses a conditional <code>DELETE</code></p></li><li><p>Follows up with a <code>WHEN MATCHED</code> <code>UPDATE</code></p></li><li><p>Targets valid and properly typed columns</p></li></ul><p><br></p><p><strong>You cannot combine </strong><code><strong>UPDATE</strong></code><strong> and </strong><code><strong>DELETE</strong></code><strong> directly</strong> within <code>WHEN MATCHED</code>.</p><p><code><strong>DELETE WHERE</strong></code><strong> is invalid</strong> in <code>MERGE</code>. Instead, you should use <code>DELETE</code> as a separate <code>WHEN MATCHED</code> clause with <code>AND</code> for the condition.</p><p><br></p><p><strong>MERGE</strong></p><p>Purpose</p><p>Use the <code>MERGE</code> statement to select rows from one or more sources for update or insertion into a table or view. You can specify conditions to determine whether to update or insert into the target table or view.</p><p>This statement is a convenient way to combine multiple operations. It lets you avoid multiple <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> DML statements.</p><p><code>MERGE</code> is a deterministic statement. You cannot update the same row of the target table multiple times in the same <code>MERGE</code> statement.</p><p>Prerequisites</p><p>You must have the <code>INSERT</code> and <code>UPDATE</code> object privileges on the target table and the <code>SELECT</code> object privilege on the source objects. To specify the <code>DELETE</code> clause of the <code>merge_update_clause</code>, you must also have the <code>DELETE</code> object privilege on the target table or view.</p><p>Syntax</p><p>merge::=</p><p><img src=\"https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/img/merge.gif\"></p><p><br></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">MERGE INTO new_prices n\nUSING (\n    SELECT prod_id, cost  \n    FROM products \n    WHERE cost &gt; 150\n) p\nON (n.prod_id = p.prod_id)\nWHEN MATCHED AND p.cost &lt; 200 THEN\n    DELETE\nWHEN MATCHED THEN\n    UPDATE SET n.price = p.cost * 0.01;</pre>",
                    "<pre class=\"prettyprint linenums\">MERGE INTO new_prices n\n\tUSING products p\n\tON (n.prod_id = prod_id)\n\tWHEN MATCHED THEN\n\t\tINSERT (n.prod_id, n.price) \n\t\tVALUES (p.prod_id, cost * .01)\n\t\tWHERE (p.cost &lt; 200);</pre>",
                    "<pre class=\"prettyprint linenums\">MERGE INTO new_prices n\n\tUSING (\n\t\tSELECT * \n\t\tFROM products \n\t\tWHERE cost &gt; 150\n                ) p\n\tON (n.prod_id = p.prod_id)\n\tWHEN MATCHED THEN\n\t\tDELETE WHERE (P.COST &lt; 200);\n\tWHEN NOT MATCHED THEN\n\t\tINSERT (n.prod_id, n.price) \n\t\tVALUES (p.prod_id, cost * .01)</pre>",
                    "<pre class=\"prettyprint linenums\">MERGE INTO new_prices n\n\tUSING (\n\t\tSELECT * \n\t\tFROM products p\n                )\n\tWHEN MATCHED THEN\n\t\tUPDATE SET n.price = p.cost * .01\n\tWHEN NOT MATCHED THEN\n\t\tINSERT (n.prod_id, n.price) \n\t\tVALUES (p.prod_id, cost * .01)\n\tWHERE (p.cost &lt; 200);</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the PRODUCTS table and the exhibit. Table: PRODUCTS  Name             Null??            Type\nPROD_ID          NOT NULL          NUMBER(2)\nQTY                                NUMBER(5,2)\nCOST                               NUMBER(8,2)Given: The following command has been successfully executed.Exhibit: 1CREATE TABLE new_prices(prod_id NUMBER(2), PRICE number(8,2));Identify the MERGE statement that executes without an error.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305955,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the description for the SALES and CHANNELS tables. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-12-28-b40bd34129b99da1f821c7b7abcc8042.png\"></p><p><br></p><p><strong>Given: </strong>The following SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">INSERT INTO sales (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold)\nVALUES (\n  23, \n  2300, \n  SYSDATE, \n  (\n    SELECT channel_id\n    FROM channels\n    WHERE channel_desc = 'Direct Sales'\n  ), \n  12, \n  500\n);</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The subquery in the VALUES clause does not need to be enclosed within single quotation marks. The syntax for subqueries in the VALUES clause does not require single quotation marks.",
                    "Subqueries can be used in the VALUES clause in SQL statements. It is a valid and common practice to use subqueries in the VALUES clause to insert data into a table.",
                    "While the VALUES clause is typically used to specify literal values for insertion, it is also possible to use subqueries in the VALUES clause. The presence of a subquery does not make the VALUES clause unnecessary.",
                    "The statement will execute successfully and insert a new row into the SALES table based on the result of the subquery. Using subqueries in the VALUES clause allows for dynamic data insertion based on the result of the subquery."
                ],
                "explanation": "<p><strong>The statement will execute, and a new row will be inserted in the SALES table. </strong>(Assuming the subquery returns exactly one row.)</p><p><br></p><p><strong>Key Points:</strong></p><ol><li><p><strong>Subquery inside VALUES clause</strong>:</p><ul><li><p>Oracle <strong>does</strong> allow <strong>scalar subqueries</strong> (returning a single value) inside the <code>VALUES</code> clause.</p></li><li><p>So this is <strong>syntactically valid</strong> <strong>as long as</strong> the subquery returns <strong>exactly one row</strong>.</p></li></ul></li><li><p><strong>Single quotation marks around subqueries</strong>:</p><ul><li><p>This is a common misconception. You <strong>do not</strong> enclose a subquery in quotes — that would make it a string literal.</p></li><li><p>So the first option is <strong>incorrect</strong>.</p></li></ul></li><li><p><strong>“Subquery not allowed in VALUES”</strong>:</p><ul><li><p>This is false. Oracle fully supports <strong>single-row subqueries</strong> in the <code>VALUES</code> clause.</p></li><li><p>So the second option is <strong>wrong</strong>.</p></li></ul></li><li><p><strong>“VALUES clause not required with subquery”</strong>:</p><ul><li><p>You <strong>can</strong> use subqueries in <code>VALUES</code>. You only omit <code>VALUES</code> if you're using an <code>INSERT ... SELECT ...</code> form.</p></li><li><p>This statement <strong>is not</strong> the case. So the third option is <strong>incorrect</strong>.</p></li></ul></li><li><p><strong>Will it execute?</strong></p><ul><li><p>Yes — <strong>if</strong> the subquery returns <strong>exactly one row</strong> (i.e., <code>'Direct Sales'</code> exists only once in the <code>CHANNELS</code> table).</p></li><li><p>If more than one row is returned, it will fail with <strong>\"ORA-01427: single-row subquery returns more than one row\"</strong>.</p></li></ul></li></ol>",
                "answers": [
                    "<p>The statement will fail because the subquery in the VALUES clause is not enclosed within single quotation marks.</p>",
                    "<p>The statement will fail because a subquery cannot be used in a VALUES clause.</p>",
                    "<p>The statement will fail because the VALUES clause is not required with a subquery.</p>",
                    "<p>The statement will execute and a new row will be inserted in the SALES table.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View the exhibit and examine the description for the SALES and CHANNELS tables. Given: The following SQL statement has been executed.Exhibit: 1INSERT INTO sales (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold)\nVALUES (\n  23, \n  2300, \n  SYSDATE, \n  (\n    SELECT channel_id\n    FROM channels\n    WHERE channel_desc = 'Direct Sales'\n  ), \n  12, \n  500\n);Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305957,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement about an INNER JOIN specified in a query's WHERE clause.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle WHERE Clause](https://www.oracletutorial.com/oracle-basics/oracle-where/)",
                    "[Oracle EQUIJOINS](https://www.w3resource.com/oracle/joins/oracle-equijoins.php)",
                    "[Oracle NON-EQUIJOINS](https://www.w3resource.com/oracle/joins/oracle-non-equijoins.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect as an INNER JOIN can be specified in a query's WHERE clause for both equijoin and nonequijoin conditions, not just for equijoin conditions.",
                    "This statement is correct as an INNER JOIN can be used for both equijoin (matching columns with equal values) and nonequijoin (matching columns with different values) conditions in a query's WHERE clause.",
                    "This statement is incorrect as an INNER JOIN does not require column names to be the same in all tables being joined. It only requires a common column to join the tables.",
                    "This statement is incorrect as an INNER JOIN does not necessarily require primary-key and foreign-key constraints to be defined on the join columns. It simply matches rows from two tables based on a related column between them."
                ],
                "explanation": "<p>In SQL, an <strong>INNER JOIN</strong> can be written in two ways:</p><ol><li><p><strong>Explicit JOIN syntax:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT ...\nFROM table1\nJOIN table2 ON table1.col = table2.col;</pre></li><li><p><strong>WHERE clause syntax (traditional):</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT ...\nFROM table1, table2\nWHERE table1.col = table2.col;</pre></li></ol><p><br></p><p><strong>Let's examine each option:</strong></p><p><strong>True: </strong>It applies to equijoin and nonequijoin conditions.</p><ul><li><p>The WHERE clause allows for <strong>any valid join condition</strong>, whether it's equality-based or not.</p></li></ul><p><strong>False:</strong> It only applies to equijoin conditions.</p><ul><li><p> You can use the WHERE clause to express <strong>both equijoins</strong> (<code>=</code>) and <strong>nonequijoins</strong> (<code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>, etc.).</p></li><li><p>So it's <strong>not limited</strong> to equijoins.</p></li></ul><p><strong>False: </strong>It requires column names to be the same in all tables being joined.</p><ul><li><p>Column names <strong>do not need to be the same</strong>.</p></li><li><p>You just need to <strong>explicitly specify</strong> the columns in the join condition.</p></li></ul><p><strong>False: </strong>It must have primary-key and foreign-key constraints defined on the join columns.</p><ul><li><p>While it's <strong>good practice</strong>, it is <strong>not required</strong> for writing a join.</p></li><li><p>The DBMS does <strong>not require</strong> constraints to perform a join.</p></li></ul><p><strong>INNER JOIN</strong></p><p>An <code>INNER JOIN</code> can be used for both an equijoin and a non-equijoin. It is not dependent on the type of <code>JOIN</code> but on the operator used.&nbsp; <code>INNER JOIN</code> can be used with a non-equal join operator, such as &gt;, &lt;. &lt;=, &gt;=, &lt;&gt;, EXISTS, etc. </p><p><strong>WHERE clause</strong></p><p>The <code>WHERE</code> clause specifies a search condition for rows returned by the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement.</p><p>The <code>WHERE</code> clause appears after the <code>FROM</code> clause but before the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code>ORDER BY</code></a> clause. Following the <code>WHERE</code> keyword is the <code>search_condition</code> that defines a condition that returned rows must satisfy.</p><p>Besides the <code>SELECT</code> statement, you can use the <code>WHERE</code> clause in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a> or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a> statement to specify which rows to update or delete.</p><p><strong>EQUIJOIN </strong></p><p>An <code>EQUIJOIN</code> is such a join that performs against a join condition containing an equality operator. It combines rows of one table associated with one or more rows in another table based on the equality of column values or expressions.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT  *  \nFROM    FRUIT F INNER JOIN FRUIT_COLOR FC\nON      F.color = FC.id\nWHERE   F.name='orange';</pre><p><br></p><p><strong>NON-EQUIJOIN</strong></p><p>The <code>NON-EQUIJOIN </code>is a join that matches column values from different tables based on an inequality (instead of the equal sign, like <strong>&gt;, &lt;, &gt;=, &lt;= </strong>) expression. The value of the join column in each row in the source table is compared to the corresponding values in the target table. A match is found if the expression based on an inequality operator used in the join evaluates to true.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT  *  \nFROM    FRUIT F INNER JOIN FRUIT_COLOR FC\nON      F.color = FC.id\nWHERE   F.name !='orange';</pre>",
                "answers": [
                    "<p>It only applies for equijoin conditions.</p>",
                    "<p>It applies for equijoin and nonequijoin conditions.</p>",
                    "<p>It requires column names to be the same in all tables being joined.</p>",
                    "<p>It must have primary-key and foreign-key constraints defined on the join columns.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statement about an INNER JOIN specified in a query's WHERE clause.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305959,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the description of the DEPARTMENTS and EMPLOYEES tables. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-15-53-f476e5490991bf584fcdeecb839582b4.png\"></p><p><br></p><p><strong>Required:</strong> Create a SQL statement to retrieve EMPLOYEE_ID, FIRST_NAME, and DEPARTMENT_NAME for all employees.</p><p><strong>Given:</strong> The desired output is not obtained after executing the following SQL statement. </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, department_name\nFROM employees\nNATURAL&nbsp;JOIN departments;</pre><p><br></p><p>Identify the possible reason for this.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Natural Join](https://www.w3resource.com/oracle/joins/natural-join.php)",
                    "[SQL Natural Join](https://www.w3resource.com/sql/joins/natural-join.php)"
                ],
                "feedbacks": [
                    "The issue with missing table prefixes for column names in the SELECT clause can cause ambiguity and confusion in SQL queries, especially when multiple tables are involved. This can result in incorrect or unexpected output as the database may not be able to determine which table the column belongs to.",
                    "The absence of the USING clause in a NATURAL JOIN can lead to unexpected results, especially when there are columns with the same name in both tables. Without specifying the columns to join on, the database will automatically join based on columns with the same name, which may not always be the desired behavior.",
                    "The order of tables in the FROM clause is crucial in SQL queries, especially when performing joins. If the DEPARTMENTS table is not listed before the EMPLOYEES table, the database may not be able to establish the correct relationship between the tables, resulting in incorrect output.",
                    "Having multiple columns with the same name and data type in the EMPLOYEES and DEPARTMENTS tables can lead to ambiguity and potential data inconsistencies. This can cause issues in SQL queries, especially when referencing these columns in SELECT statements, as the database may not be able to distinguish between them, resulting in unexpected output."
                ],
                "explanation": "<p><strong>Correct Answer: </strong><em>The EMPLOYEES and DEPARTMENTS tables have more than one column with the same column name and data type, which may cause a problem if there are table data inconsistencies.</em></p><ol><li><p>This is the <strong>most likely reason</strong> for not getting the desired result.</p></li><li><p>If the tables share more than one column name (e.g., both have <code>DEPARTMENT_ID</code>, maybe <code>LOCATION_ID</code> too), the <code>NATURAL JOIN</code> will <strong>automatically join on <em>all</em> matching columns</strong>, which could:</p><ul><li><p>Lead to incorrect results</p></li><li><p>Return <strong>no rows</strong> if the extra matching columns don’t align properly</p></li></ul></li></ol><p><strong>Incorrect Options:</strong></p><p><strong>The table prefix is missing for the column names in the SELECT clause.</strong></p><ul><li><p><strong>False</strong> – In a <code>NATURAL JOIN</code>, the common columns are merged, and there's no need for table prefixes unless there’s ambiguity.</p></li><li><p>Also, Oracle will resolve the columns if their names are unique.</p></li></ul><p><strong>The NATURAL JOIN clause is missing the USING clause.</strong></p><ul><li><p><strong>False</strong> – A <code>NATURAL JOIN</code> <strong>does not require</strong> or support a <code>USING</code> clause.</p></li><li><p>That would apply to an <code>INNER JOIN ... USING (...)</code>.</p></li></ul><p><strong>The DEPARTMENTS table is not used before the EMPLOYEES table in the FROM clause.</strong></p><ul><li><p><strong>False</strong> – The order of tables in the <code>FROM</code> clause does <strong>not matter</strong> in a <code>NATURAL JOIN</code>.</p></li></ul><p><br></p><p><strong>Analysis</strong></p><p>You have two tables in focus: <code>EMPLOYEES</code> and <code>DEPARTMENTS</code></p><ul><li><p>You're trying to <strong>retrieve</strong>:</p><ul><li><p><code>EMPLOYEE_ID</code></p></li><li><p><code>FIRST_NAME</code></p></li><li><p><code>DEPARTMENT_NAME</code></p></li></ul></li><li><p>The query used is:</p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id, first_name, department_name\nFROM employees\nNATURAL JOIN departments;</pre></li></ul><p><strong>Understanding NATURAL JOIN:</strong></p><ul><li><p>A <code>NATURAL JOIN</code> automatically joins tables <strong>based on all columns with the same name and data type</strong>.</p></li><li><p>You <strong>do not specify</strong> the join condition — the database finds matching column names and joins on them.</p></li><li><p>This can be <strong>risky</strong> if:</p><ul><li><p>There are <strong>multiple common columns</strong> (e.g., <code>DEPARTMENT_ID</code>, <code>LOCATION_ID</code>)</p></li><li><p>Or if <strong>column names match, but the meaning doesn’t</strong></p></li></ul></li></ul><p><strong>Natural Join in Oracle</strong></p><p>• The join is based on all the columns in the two tables that have the same name and data types.</p><p>• The join is created by using the <code>NATURAL JOIN</code> keywords.</p><p>• It selects rows from the two tables that have equal values in all matched columns.</p><p>• When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias.</p><p>• The associated tables have one or more pairs of identically named columns.</p><p>• Don’t use an <code>ON</code> clause in a natural join.</p><p>This question assumes data integrity issues. While the <code>NATURAL JOIN</code> needs only one column to be the same in each table, and it can have more than one pair of identically named columns, if there are inconsistencies in the table contents, it can cause an error. </p><p>The EMPLOYEES and DEPARTMENTS tables have two columns that are the same (Department_ID and Manager_ID)</p><p>If there were no data inconsistencies, then it would produce the required results.</p>",
                "answers": [
                    "<p>The table prefix is missing for the column names in the SELECT clause.</p>",
                    "<p>The NATURAL JOIN clause is missing the USING clause.</p>",
                    "<p>The DEPARTMENTS table is not used before the EMPLOYEES table in the FROM clause.</p>",
                    "<p>The EMPLOYEES and DEPARTMENTS tables have more than one column with the same column name and data type which may cause a problem if there are table data inconsistencies.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "",
            "question_plain": "View the exhibit and examine the description of the DEPARTMENTS and EMPLOYEES tables. Required: Create a SQL statement to retrieve EMPLOYEE_ID, FIRST_NAME, and DEPARTMENT_NAME for all employees.Given: The desired output is not obtained after executing the following SQL statement. Exhibit: 1SELECT employee_id, first_name, department_name\nFROM employees\nNATURAL&nbsp;JOIN departments;Identify the possible reason for this.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305961,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View the Exhibit and examine the structure of the PRODUCTS table. </p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-22-57-6b0c1f76b96c5d1c6c1177a50508d55e.png\"><p><br></p><p>Which two tasks would require subqueries? (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Subqueries](https://www.techonthenet.com/oracle/subqueries.php)"
                ],
                "feedbacks": [
                    "This task requires a subquery to calculate the average list price of products with the status 'orderable' and then compare it with the minimum list price of all products to display the desired result.",
                    "This task does not require a subquery as it involves filtering products based on specific criteria (supplier ID and product status) without the need for additional calculations or comparisons.",
                    "This task requires a subquery to calculate the average list price of all products and then compare it with the list prices of individual products to determine the number of products that meet the specified condition.",
                    "This task does not require a subquery as it involves a simple comparison of list prices with a fixed value (1000) without the need for additional calculations or comparisons.",
                    "This task requires a subquery to retrieve the minimum list price for each distinct product status, as it involves aggregating data based on different product statuses to display the desired result."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p><em>Display all products whose minimum list price is more than the average list price of products having the status 'orderable'</em></p><ul><li><p>You need to:</p><ul><li><p>Compare <strong>each product’s minimum list price</strong> with</p></li><li><p>The <strong>average list price</strong> of products with status = 'orderable'</p></li></ul></li><li><p>This requires a <strong>subquery</strong> to calculate the average list price.</p></li><li><p><strong>Requires a subquery</strong></p></li></ul></li><li><p><em>Display the number of products whose list prices are more than the average list price</em></p><ul><li><p>You're comparing list prices <strong>to the overall average</strong></p></li><li><p>That <strong>average</strong> must be computed in a <strong>subquery</strong></p></li><li><p><strong>Requires a subquery</strong></p></li></ul></li></ol><p><strong>Incorrect Options:</strong></p><p><strong>Display the total number of products supplied by supplier 102 and have product status as 'OBSOLETE'</strong></p><ul><li><p>Can be done with a <strong>single SELECT + WHERE clause + COUNT()</strong></p></li></ul><pre class=\"prettyprint linenums\">sql\nSELECT COUNT(*) \nFROM products \nWHERE supplier_id = 102 AND product_status = 'OBSOLETE';</pre><ul><li><p><strong>Does not require a subquery</strong></p></li></ul><p><br></p><p><strong>Display all products whose list price is more than 1000</strong></p><ul><li><p>Simple WHERE condition:</p></li></ul><pre class=\"prettyprint linenums\">sql\nSELECT * FROM products WHERE list_price &gt; 1000;</pre><ul><li><p><strong>Does not require a subquery</strong></p></li></ul><p><br></p><p><strong>Display the minimum list price for each product status</strong></p><ul><li><p>This can be done with a <strong>GROUP BY</strong>:</p></li></ul><pre class=\"prettyprint linenums\">sql\nSELECT product_status, MIN(list_price)\nFROM products\nGROUP BY product_status;</pre><ul><li><p><strong>Does not require a subquery</strong></p></li></ul><p><br></p><p>In Oracle, a subquery is a query within a query. You can create subqueries within your SQL statements. These subqueries can reside in the <code>WHERE</code> clause, the <code>FROM</code> clause, or the <code>SELECT</code> clause.</p><p><code>WHERE</code> clause</p><p>Most often, the subquery will be found in the <code>WHERE</code> clause. These subqueries are also called nested subqueries.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \nFROM all_tables tabs\nWHERE tabs.table_name IN (SELECT cols.table_name\n                          FROM all_tab_columns cols\n                          WHERE cols.column_name = 'SUPPLIER_ID');</pre><p><br></p><p><strong>Limitation:</strong> Oracle allows up to 255 levels of subqueries in the WHERE clause.</p><p><code>FROM</code> clause</p><p>A subquery can also be found in the <code>FROM</code> clause. These are called <strong>inline views</strong>.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT suppliers.name, subquery1.total_amt\nFROM suppliers,\n (SELECT supplier_id, SUM(orders.amount) AS total_amt\n  FROM orders\n  GROUP BY supplier_id) subquery1\nWHERE subquery1.supplier_id = suppliers.supplier_id;</pre><p><br></p><p>In this example, we've created a subquery in the <code>FROM</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT supplier_id, SUM(orders.amount) AS total_amt\n FROM orders\n GROUP BY supplier_id) subquery1</pre><p><br></p><p>This subquery has been aliased with the name <em>subquery1</em>. This will be the name used to reference this subquery or any of its fields.</p><p><br></p><p><strong>Limitations</strong></p><p>Oracle allows an unlimited number of subqueries in the FROM clause.</p><p><code>SELECT</code> clause</p><p>A subquery can also be found in the <code>SELECT</code> clause.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT tbls.owner, tbls.table_name,\n  (SELECT COUNT(column_name) AS total_columns\n   FROM all_tab_columns cols\n   WHERE cols.owner = tbls.owner\n   AND cols.table_name = tbls.table_name) subquery2\nFROM all_tables tbls;</pre><p><br></p><p>In this example, we've created a subquery in the <code>SELECT</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT COUNT(column_name) AS total_columns\n FROM all_tab_columns cols\n WHERE cols.owner = tbls.owner\n AND cols.table_name = tbls.table_name) subquery2</pre><p><br></p><p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p><p>The trick to placing a subquery in the select clause is that the subquery must return a single value. This is why an aggregate function, such as the <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\">SUM function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\">COUNT function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\">MIN function</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/max.php\">MAX function</a>, is commonly used in the subquery.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-11_22-18-45-e5d6c2f62f65f6a258b12942af83831f.png\"></p>",
                "answers": [
                    "<p>Display all products whose minimum list price is more than the average list price of products having the status 'orderable'</p>",
                    "<p>Display the total number of products supplied by supplier 102 and have product status as 'OBSOLETE'</p>",
                    "<p>Display the number of products whose list prices are more than the average list price</p>",
                    "<p>Display all products whose list price is more than 1000</p>",
                    "<p>Display the minimum list price for each product status</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "",
            "question_plain": "View the Exhibit and examine the structure of the PRODUCTS table. Which two tasks would require subqueries? (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305963,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the MEMBERS table.</p><p><strong>Table: MEMBERS</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nMEMBER_ID        NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME        NOT NULL          VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(25)\nSTATE                              VARCHAR2(3)</pre><p><br></p><p><strong>Required:</strong> Display details of all members who reside in states starting with the letter A, followed by exactly one character.&nbsp; </p><p>Identify the SQL query that would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: LIKE Condition](https://www.techonthenet.com/oracle/like.php)",
                    "[Pattern-matching Conditions](https://docs.oracle.com/cd/B19306_01/server.102/b14200/conditions007.htm)"
                ],
                "feedbacks": [
                    "This query uses the LIKE operator with the pattern '%A_', which will match any state that ends with 'A' followed by exactly one character. However, the requirement is to find states starting with 'A' followed by exactly one character, so this query is incorrect.",
                    "This query uses the LIKE operator with the pattern 'A_', which will match any state that starts with 'A' followed by exactly one character. This query correctly identifies the members who reside in states starting with the letter A followed by exactly one character.",
                    "This query uses the LIKE operator with the pattern 'A_%', which will match any state that starts with 'A' followed by zero or more characters. This pattern does not meet the requirement of exactly one character following the letter A, so this query is incorrect.",
                    "This query uses the LIKE operator with the pattern 'A%', which will match any state that starts with the letter A followed by zero or more characters. Since the requirement is to find states starting with the letter A followed by exactly one character, this query is incorrect."
                ],
                "explanation": "<p><strong>Requirement: </strong>Display details of all members who reside in <strong>states starting with the letter \"A\" followed by exactly one character</strong>.</p><p>This means:</p><ul><li><p>The <strong>state</strong> should be <strong>two characters</strong> long.</p></li><li><p>It should <strong>start with 'A'</strong>.</p></li><li><p>The <strong>second character</strong> can be <strong>any single character</strong>.</p></li></ul><p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT *  \nFROM MEMBERS  \nWHERE state LIKE 'A_';</pre><p><br></p><ol><li><p><code>'A_'</code> means:</p><ul><li><p>First character must be <code>'A'</code></p></li><li><p>The second character can be <strong>any single character</strong></p></li><li><p>Total length = <strong>2 characters</strong></p></li></ul></li><li><p><strong>Exactly what is required</strong></p></li></ol><p><strong>Incorrect Options:</strong></p><p><code>WHERE state LIKE '%A_'</code></p><ul><li><p><code>%A_</code> means:</p><ul><li><p>Any number of characters ending with <code>'A'</code> and then <strong>one more character</strong>.</p></li><li><p>This <strong>does not</strong> guarantee the string <strong>starts</strong> with <code>'A'</code>, nor is it limited to <strong>2 characters</strong>.</p></li></ul></li></ul><p><code>WHERE state LIKE 'A_%'</code></p><ul><li><p><code>'A_%'</code> means:</p><ul><li><p>Starts with <code>'A'</code></p></li><li><p>Followed by <strong>at least one</strong> character (because of <code>_</code>), then <strong>any number</strong> of characters (<code>%</code>)</p></li><li><p>Could match values like <code>ARZ</code>, <code>ALM</code>, <code>AZZ</code>, etc.</p></li></ul></li><li><p><strong>Too many characters</strong> — not limited to exactly two</p></li></ul><p><code>WHERE state LIKE 'A%'</code></p><ul><li><p><code>'A%'</code> means:</p><ul><li><p>Starts with <code>'A'</code></p></li><li><p>Can be followed by <strong>zero or more characters</strong></p></li><li><p>Will match strings like <code>'A'</code>, <code>'AZ'</code>, <code>'AL'</code>, <code>'ARK'</code>, etc.</p></li></ul></li><li><p><strong>Does not limit to exactly two characters</strong></p></li></ul><p><br></p><p><strong>Oracle LIKE condition</strong></p><p>The Oracle <code>LIKE</code> condition allows wildcards to be used in the<a href=\"https://www.techonthenet.com/oracle/where.php\"> WHERE clause</a> of a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement. This allows you to perform pattern matching.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>LIKE</code> condition in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">Expression LIKE pattern [ ESCAPE 'escape_character' ]</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p><strong>expression</strong> </p><p>A character expression, such as a column or field. </p><p><strong>pattern</strong></p><p>A character expression that contains pattern matching. The patterns that you can choose from are:</p><p><strong>Wildcard Explanation </strong></p><p>% - Allows you to match any string of any length (including zero length) </p><p>_&nbsp; - Allows you to match on a single character</p><p><strong>escape_character </strong></p><p>Optional. It allows you to test for literal instances of a wildcard character, such as % or _.</p><p><br></p><p><strong>Using _ wildcard (underscore wildcard)</strong></p><p>The _ wildcard (underscore wildcard) is looking for only one character.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT supplier_name\nFROM suppliers\nWHERE supplier_name LIKE 'Sm_th';</pre><p><br></p><p>This Oracle <code>LIKE</code> condition example would return all suppliers whose <em>supplier_name</em> is 5 characters long, where the first two characters are 'Sm' and the last two characters are 'th'. For example, it could return suppliers whose <em>supplier_name</em> is 'Smith', 'Smyth', 'Smath', 'Smeth', etc.</p><p>Here is another example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM suppliers\nWHERE account_number LIKE '92314_';</pre><p><br></p><p>You might find that you are looking for an account number, but you only have 5 of the 6 digits. The example above would retrieve potentially 10 records back (where the missing value could equal anything from 0 to 9). For example, it could return suppliers whose account numbers are:</p><ul><li><p>923140, 923141, 923142, 923143, 923144, 923145, 923146, 923147, 923148, 923149</p></li></ul><p>The pattern can contain special pattern-matching characters; an underscore (_) in the pattern matches exactly one character.</p><p><br></p><p><strong>Using % wildcard (percent sign wildcard)</strong></p><p>The % wildcard works in the Oracle LIKE condition looks for strings that have the characters preceding or following the %, depending on its placement; the % can represent any number of characters. Let's look at some examples to demonstrate. </p><p>We want to find all of the customers whose <em>last_name</em> begins with 'Ap'.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT last_name\nFROM customers\nWHERE last_name LIKE 'Ap%';</pre><p><br></p><p>You can also use the % wildcard multiple times within the same string. For example,</p><p><br></p><pre class=\"prettyprint linenums\">SELECT last_name\nFROM customers\nWHERE last_name LIKE '%er%';</pre><p><br></p><p>In this Oracle LIKE condition example, we are looking for all <em>customers</em> whose <em>last_name</em> contains the characters 'er'.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT *&nbsp; \nFROM MEMBERS&nbsp; \nWHERE state LIKE '%A_';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *&nbsp; \nFROM MEMBERS&nbsp; \nWHERE state LIKE 'A_';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *&nbsp; \nFROM MEMBERS&nbsp; \nWHERE state LIKE 'A_%';</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT *&nbsp; \nFROM MEMBERS&nbsp; \nWHERE state LIKE 'A%';</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the structure of the MEMBERS table.Table: MEMBERSName             Null??            Type\nMEMBER_ID        NOT NULL          VARCHAR2(6)\nFIRST_NAME                         VARCHAR2(50)\nLAST_NAME        NOT NULL          VARCHAR2(50)\nADDRESS                            VARCHAR2(50)\nCITY                               VARCHAR2(25)\nSTATE                              VARCHAR2(3)Required: Display details of all members who reside in states starting with the letter A, followed by exactly one character.&nbsp; Identify the SQL query that would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305965,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about Data Manipulation Language (DML) (Select three).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Data Manipulation Language (DML) Statements](https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_1001.htm#i2099257)"
                ],
                "feedbacks": [
                    "UPDATE statements in DML can indeed have different subqueries to specify the values for each updated column. This allows for flexibility in updating specific columns with different values based on various conditions.",
                    "INSERT statements in DML can explicitly insert NULL values into a column. This is useful when there is a need to insert a NULL value into a specific column during data insertion.",
                    "DELETE statements in DML can remove multiple rows based on multiple conditions. This allows for the deletion of specific rows that meet certain criteria, making it a powerful tool for data manipulation.",
                    "DML statements, including UPDATE, INSERT, and DELETE, do not necessarily require a primary key to be defined on a table. While having a primary key can be beneficial for data integrity and performance, it is not a strict requirement for DML operations.",
                    "INSERT statements in DML do not automatically commit the transaction. It is the responsibility of the developer to explicitly commit the transaction after executing the INSERT statement to make the changes permanent in the database."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><p><strong>1. UPDATE statements can have different subqueries to specify the values for each updated column.</strong></p><ul><li><p>Yes, <strong>UPDATE</strong> statements can assign each column a <strong>separate subquery</strong> that returns a single value.</p></li></ul><pre class=\"prettyprint linenums\">sql\nUPDATE employees\nSET salary = (SELECT avg(salary) FROM employees),\n    department_id = (SELECT department_id FROM departments WHERE location_id = 1400)\nWHERE employee_id = 100;\n</pre><p><br></p><p><strong>2. INSERT statements can insert NULLS explicitly into a column.</strong></p><ul><li><p>Yes, you can insert <code>NULL</code> values explicitly like this:</p></li></ul><pre class=\"prettyprint linenums\">sql\nINSERT INTO employees (employee_id, first_name, salary)\nVALUES (999, 'John', NULL);\n</pre><p><br></p><p><strong>3. DELETE statements can remove multiple rows based on multiple conditions.</strong></p><ul><li><p>Definitely true.</p></li><li><p>A <code>DELETE</code> with a <code>WHERE</code> clause that matches multiple rows will delete them all.</p></li></ul><pre class=\"prettyprint linenums\">sql\nDELETE FROM employees\nWHERE department_id = 50 OR job_id = 'SA_REP';</pre><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>DML statements require a primary key to be defined on a table.</strong></p><ul><li><p>No, a table <strong>does not need</strong> a primary key for DML operations.</p></li><li><p>You can perform <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> without a primary key.</p></li></ul><p><strong>INSERT statements automatically commit.</strong></p><ul><li><p>No — <strong>DML statements do not auto-commit</strong> by default.</p></li><li><p>Changes are only saved after an explicit <code>COMMIT</code>.</p></li><li><p>Auto-commit might happen in some tools (e.g., SQL Developer), but it’s not the SQL standard behaviour. </p></li></ul><p><br></p><p>Sample table created with Nullable columns</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-26_02-31-35-bb1758087a1aed21b89ff87d1933d54d.png\"></p><p><br></p><p>Inserting null values to all / specific columns was executed successfully without error</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-26_02-32-32-624526ff33d0e75d16128230040de8d4.png\"><br><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-26_02-32-51-20b47a2e0dc07d0cab70a9e97a538dbc.png\"></p><p><br></p><p>Data manipulation language (DML) statements access and manipulate data in existing schema objects. These statements <strong>do not implicitly commit</strong> the current transaction. The data manipulation language statements are:</p><p>• <code>CALL</code></p><p>• <code>DELETE</code></p><p>• <code>EXPLAIN PLAN</code></p><p>• <code>INSERT</code></p><p>• <code>LOCK TABLE</code></p><p>• <code>MERGE</code></p><p>• <code>SELECT</code></p><p>• <code>UPDATE</code></p><p>The SELECT statement is a limited form of DML statement in that it can only access data in the database. It cannot manipulate data in the database, although it can operate on the accessed data before returning the results of the query.</p>",
                "answers": [
                    "<p>UPDATE statements can have different subqueries to specify the values for each updated column.</p>",
                    "<p>INSERT statements can insert NULLS explicitly into a column.</p>",
                    "<p>DELETE statements can remove multiple rows based on multiple conditions.</p>",
                    "<p>DML statements require a primary key be defined on a table.</p>",
                    "<p>INSERT statements automatically commit.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about Data Manipulation Language (DML) (Select three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305967,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding subqueries (Choose two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)",
                    "[Dynamic Contexts](https://docs.oracle.com/cd/B19306_01/network.102/b14266/accessre.htm#i1007222)"
                ],
                "feedbacks": [
                    "This statement is incorrect. Multiple subqueries can be placed at one level in a SQL query, depending on the complexity of the query and the database system being used. There is no specific limit to the number of subqueries that can be used at one level.",
                    "This statement is incorrect. In SQL, a subquery in the WHERE clause of a SELECT statement can be nested to more than three levels. The number of nesting levels allowed for subqueries depends on the database system being used and its specific limitations.",
                    "This statement is correct. A subquery can be used to access data from one or more tables or views in SQL. Subqueries are commonly used to retrieve specific data based on certain conditions or criteria, making them a powerful tool in SQL query writing.",
                    "This statement is incorrect. While it is recommended to qualify columns in a subquery with the name or alias of the table for clarity and to avoid ambiguity, it is not always mandatory. Depending on the context and structure of the query, column qualification may or may not be required.",
                    "This statement is correct. If a subquery returns zero rows, the value returned by the subquery expression is NULL. This behavior is consistent with SQL standards and is important to consider when using subqueries in SQL queries to handle cases where no matching data is found."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><p><strong>A subquery can be used to access data from one or more tables or views.</strong></p><ul><li><p><strong>True</strong> – A subquery can reference:</p><ul><li><p>A single table</p></li><li><p>Multiple tables (via joins)</p></li><li><p>Views or materialized views</p></li></ul></li></ul><p><strong>If the subquery returns 0 rows, then the value returned by the subquery expression is NULL.</strong></p><ul><li><p><strong>True</strong>, with a <strong>caveat</strong>:</p><ul><li><p>For <strong>scalar subqueries</strong> (subqueries used in expressions like <code>SELECT</code> or <code>WHERE =</code>), if <strong>no rows are returned</strong>, then the result is <strong>treated as </strong><code><strong>NULL</strong></code>.</p></li><li><p>For example:</p><pre class=\"prettyprint linenums\">sql\nSELECT (SELECT salary FROM employees WHERE employee_id = -1) AS result FROM dual;</pre><p>→ returns NULL</p></li></ul></li></ul><p><strong>Incorrect Options:</strong></p><p><strong>Only two subqueries can be placed at one level.</strong></p><ul><li><p><strong>False</strong> – There is <strong>no such hard limit</strong> in Oracle SQL.</p></li><li><p>You can place <strong>multiple subqueries</strong> at the same level, depending on the SQL and nesting structure.</p></li><li><p>Oracle supports <strong>more than two subqueries</strong> at the same level.</p></li></ul><p><strong>A subquery in the WHERE clause of a SELECT statement can be nested up to three levels only.</strong></p><ul><li><p><strong>False</strong> – Oracle allows <strong>up to 255 levels</strong> of nesting for subqueries (although that's not practical).</p></li><li><p>There is <strong>no limit of three levels</strong> in the WHERE clause, specifically.</p></li></ul><p><strong>The columns in a subquery must always be qualified with the name or alias of the table used.</strong></p><ul><li><p><strong>False</strong> – Column names <strong>do not have to be qualified</strong>, unless:</p><ul><li><p>There is <strong>ambiguity</strong>, or</p></li><li><p>You're writing a <strong>correlated subquery</strong></p></li></ul></li><li><p>In simple subqueries, unqualified column names are acceptable if there’s only one source.</p></li></ul><p><br></p><p><strong>The Oracle subquery</strong></p><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement, such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. Typically, you can use a subquery anywhere that you use an expression.</p><p><br></p><p><strong>Order of operation</strong></p><p>Oracle evaluates the whole query above in two steps:</p><ol><li><p>First, execute the subquery.</p></li><li><p>Second, use the result of the subquery in the outer query.</p></li></ol><p>A subquery that is nested within the <code>FROM</code> clause of the <code>SELECT</code> statement is called an <a href=\"https://www.oracletutorial.com/oracle-view/inline-view-in-oracle/\"><strong>inline view</strong></a>. Note that other RDBMS, such as MySQL and PostgreSQL, use the term <a href=\"http://www.mysqltutorial.org/mysql-derived-table/\"><strong>derived table</strong></a> instead of the inline view.</p><p>A subquery nested in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement is called a <strong>nested subquery</strong>.</p><p>A subquery can contain another subquery. Oracle allows you to have an unlimited number of subquery levels in the <code>FROM</code> clause of the top-level query and up to 255 subquery levels in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause.</p><p><br></p><p><strong>Main advantages of Oracle subqueries</strong></p><ul><li><p>Provide an alternative way to query data that would require complex <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">joins</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\">unions</a>.</p></li><li><p>Make the complex queries more readable.</p></li><li><p>Allow a complex query to be structured in a way that it is possible to isolate each part.</p></li></ul><p><br></p><p><strong>Subquery with comparison operators</strong></p><p>The subqueries that use comparison operators, g, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, =, often include <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a>, because an aggregate function returns a single value that can be used for comparison in the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause of the outer query.</p><p><strong>Subquery with </strong><code><strong>IN</strong></code><strong> and </strong><code><strong>NOT IN</strong></code><strong> operators</strong></p><p>The subquery that uses the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-in/\"><code>IN</code></a> operator often returns a list of zero or more values. After the subquery returns the result set, the outer query makes use of it.</p><ul><li><p>If the subquery returns 0 rows, then the value returned by the subquery expression is NULL which will cause the query the the subquery in nested in to have NULL values to reference in its query.</p></li><li><p>A view is a presentation of data selected from one or more tables (possibly including other views). In addition to showing the selected data, a view also shows the structure of the underlying tables, and can be thought of as the result of a stored query.</p></li><li><p>A subquery can be used to access data from one or more tables or views contingent on user access permissions.</p></li></ul>",
                "answers": [
                    "<p>Only two subqueries can be placed at one level.</p>",
                    "<p>A subquery in the WHERE clause of a SELECT statement can be nested up to three levels only.</p>",
                    "<p>A subquery can be used to access data from one or more tables or views.</p>",
                    "<p>The columns in a subquery must always be qualified with the name or alias of the table used.</p>",
                    "<p>If the subquery returns 0 rows, then the value returned by the subquery expression is NULL.</p>"
                ]
            },
            "correct_response": [
                "c",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding subqueries (Choose two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305969,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">TRUNCATE TABLE depts;</pre><p><br></p><p>Identify two true statements.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[TRUNCATE TABLE](https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_10007.htm#SQLRF01707)"
                ],
                "feedbacks": [
                    "The SQL exhibit provided shows a DELETE statement, which removes rows from a table based on a specified condition. It does not have any impact on triggers defined on the table, as triggers are separate database objects that are not affected by DML statements like DELETE.",
                    "The DELETE statement removes rows from a table, but it does not automatically release the space used by the removed rows. The space will be marked as available for reuse within the table, but it may not be immediately released back to the operating system.",
                    "A ROLLBACK statement is used to undo changes made in a transaction, but once a DELETE statement is committed, the deleted data is permanently removed from the table. It cannot be retrieved using a ROLLBACK statement.",
                    "The DELETE statement retains the integrity constraints defined on the table, such as primary key, foreign key, and unique constraints. Deleting rows does not impact the structure of the table or its constraints.",
                    "The DELETE statement retains the indexes defined on the table. Indexes are separate database objects that help optimize query performance, and deleting rows from a table does not impact the existence or structure of indexes associated with the table.",
                    "The FLASHBACK TABLE statement is used to recover a table to a previous state by using the undo data stored in the Oracle database. However, once rows are deleted using a DELETE statement, they may not be recoverable using the FLASHBACK TABLE statement unless the database has been configured to retain undo data for a sufficient period."
                ],
                "explanation": "<p><strong>Statement in Exhibit:</strong></p><pre class=\"prettyprint linenums\">TRUNCATE TABLE depts;</pre><p><br></p><ol><li><p><code>TRUNCATE</code> is a <strong>DDL (Data Definition Language)</strong> command that <strong>removes all rows</strong> from a table <strong>faster</strong> and with <strong>less undo/redo</strong> than a <code>DELETE</code>.</p></li><li><p>It <strong>cannot be rolled back</strong>.</p></li><li><p>It <strong>preserves structure, constraints, and indexes</strong>, but <strong>does not fire triggers</strong> and <strong>does not log row-level changes</strong>.</p></li></ol><p><strong>Correct Answers:</strong></p><p><strong>It always retains the space used by the removed rows.</strong></p><ul><li><p><strong>True</strong> – <code>TRUNCATE</code> by default <strong>releases row-level space</strong> but <strong>retains the table's allocated extent</strong> (space).</p></li><li><p>This is considered <strong>true</strong>, especially in contrast to DELETE, which may keep the data blocks more occupied.</p></li></ul><p><strong>It retains the integrity constraints defined on the table.</strong></p><ul><li><p><strong>True</strong> – Constraints like <strong>primary keys, foreign keys, NOT NULL</strong>, etc., remain intact after a <code>TRUNCATE</code>.</p></li></ul><p><strong>It retains the indexes defined on the table.</strong></p><ul><li><p><strong>True</strong> – Any indexes (B-tree, bitmap, etc.) on the table are <strong>not dropped</strong>. They're retained.</p></li></ul><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>It drops any triggers defined on the table.</strong></p><ul><li><p><strong>False</strong> – Triggers are <strong>not dropped</strong>.</p></li><li><p>However, <strong>TRUNCATE does not fire triggers</strong> (unlike DELETE).</p></li></ul><p><strong>A ROLLBACK statement can be used to retrieve the deleted data.</strong></p><ul><li><p><strong>False</strong> – Since <code>TRUNCATE</code> is <strong>DDL</strong>, it <strong>auto-commits</strong> and <strong>cannot be rolled back</strong>.</p></li></ul><p><strong>A FLASHBACK TABLE statement can be used to retrieve the deleted data.</strong></p><ul><li><p><strong>False</strong> – <code>TRUNCATE</code> <strong>cannot be flashed back</strong> unless the <strong>Recycle Bin</strong> is used (which applies to the table being dropped).</p></li><li><p>For just truncated data, <strong>Flashback Table does not apply</strong>.</p></li></ul><p><br></p><p>Use the <code>TRUNCATE TABLE</code> statement to remove all rows from a table. By default, Oracle Database also performs the following tasks:</p><p>Deallocates all space used by the removed rows except that specified by the <code>MINEXTENTS</code> storage parameter</p><p>Sets the <code>NEXT</code> storage parameter to the size of the last extent removed from the segment by the truncation process</p><p>Removing rows with the <code>TRUNCATE TABLE</code> statement can be more efficient than dropping and re-creating a table. Dropping and re-creating a table invalidates dependent objects of the table, requires you to regrant object privileges on the table, and requires you to re-create the indexes, integrity constraints, and triggers on the table and respecify its storage parameters. Truncating has none of these effects.</p><p>Removing rows with the <code>TRUNCATE TABLE</code> statement can be faster than removing all rows with the <code>DELETE</code> statement, especially if the table has numerous triggers, indexes, and other dependencies.</p><p>You cannot roll back a <code>TRUNCATE TABLE</code> statement, nor can you use a <code>FLASHBACK TABLE</code> statement to retrieve the contents of a table that has been truncated.</p>",
                "answers": [
                    "<p>It drops any triggers defined on the table.</p>",
                    "<p>It always retains the space used by the removed rows.</p>",
                    "<p>A ROLLBACK statement can be used to retrieve the deleted data.</p>",
                    "<p>It retains the integrity constraints defined on the table.</p>",
                    "<p>It retains the indexes defined on the table.</p>",
                    "<p>A FLASHBACK TABLE statement can be used to retrieve the deleted data.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e"
            ],
            "section": "",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1TRUNCATE TABLE depts;Identify two true statements.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305971,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>External tables are created using the SQL <code>CREATE TABLE...ORGANIZATION EXTERNAL</code> statement. </p><p><br></p><p>Which of the following attributes are specified when you run the following SQL command?</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE emp_load\n  2    (employee_number      CHAR(5),\n  3     employee_dob         CHAR(20),\n  4     employee_last_name   CHAR(20),\n  5     employee_first_name  CHAR(15),\n  6     employee_middle_name CHAR(15),\n  7     employee_hire_date   DATE)\n  8  ORGANIZATION EXTERNAL\n  9    (TYPE ORACLE_LOADER\n 10     DEFAULT DIRECTORY def_dir1\n 11     ACCESS PARAMETERS\n 12       (RECORDS DELIMITED BY NEWLINE\n 13        FIELDS (employee_number      CHAR(2),\n 14                employee_dob         CHAR(20),\n 15                employee_last_name   CHAR(18),\n 16                employee_first_name  CHAR(11),\n 17                employee_middle_name CHAR(11),\n 18                employee_hire_date   CHAR(10) date_format DATE mask \"mm/dd/yyyy\"\n 19               )\n 20       )\n 21     LOCATION ('info.dat')\n 22    );\n \nTable created.</pre>",
                "relatedLectureIds": [],
                "links": [
                    "[External Tables Concepts](https://docs.oracle.com/cd/B19306_01/server.102/b14215/et_concepts.htm)"
                ],
                "feedbacks": [
                    "The TYPE attribute specifies the type of external table organization being used, in this case, ORACLE_LOADER.",
                    "The DEFAULT DIRECTORY attribute specifies the default directory where the external data files are located.",
                    "The ACCESS PARAMETERS attribute specifies the parameters for accessing the external data files, such as the record delimiter and field definitions.",
                    "The LOCATION attribute specifies the location of the external data file that the external table will be accessing.",
                    "The FROM attribute is not specified in the CREATE TABLE...ORGANIZATION EXTERNAL statement for defining external tables."
                ],
                "explanation": "<p>The SQL command provided creates an <strong>external table</strong> using <code>ORACLE_LOADER</code>, which allows Oracle to treat flat-file data (like a CSV or <code>.dat</code> file) as if it were in a database table.</p><p><strong>The attributes specified in this command are:</strong></p><p><code>TYPE</code></p><ul><li><p>Declares the type of external table.</p></li><li><p><strong>In this case:</strong></p><pre class=\"prettyprint linenums\">sql\nTYPE ORACLE_LOADER</pre></li><li><p><strong>Specified</strong></p></li></ul><p><code>DEFAULT DIRECTORY</code></p><ul><li><p>Tells Oracle where to find the data file on the file system.</p></li><li><p>The directory must be predefined using the <code>CREATE DIRECTORY</code> command.</p></li><li><p><strong>In this case:</strong></p><pre class=\"prettyprint linenums\">sql\nDEFAULT DIRECTORY def_dir1</pre></li><li><p><strong>Specified</strong></p></li></ul><p><code>ACCESS PARAMETERS</code></p><ul><li><p>Defines how the file is read (e.g., field lengths, delimiters, formats).</p></li><li><p><strong>In this case:</strong></p><pre class=\"prettyprint linenums\">sql\nACCESS PARAMETERS\n  (RECORDS DELIMITED BY NEWLINE\n   FIELDS (...)\n  )</pre></li><li><p><strong>Specified</strong></p></li></ul><p><code>LOCATION</code></p><ul><li><p>Specifies the file(s) used as the source for the external table.</p></li><li><p><strong>In this case:</strong></p><pre class=\"prettyprint linenums\">sql\nLOCATION ('info.dat')</pre></li><li><p><strong>Specified</strong></p></li></ul><p><br></p><p><strong>Incorrect Option:</strong></p><p><code>FROM</code></p><ul><li><p>This is <strong>not a valid attribute</strong> in a <code>CREATE TABLE ... ORGANIZATION EXTERNAL</code> statement.</p></li><li><p>So it's <strong>not specified</strong> or applicable here.</p></li></ul><p><br></p><p>External tables are created using the SQL <code>CREATE TABLE...ORGANIZATION EXTERNAL</code> statement. When you create an external table, you specify the following attributes:</p><ul><li><p><code>TYPE</code> - specifies the type of external table. The two available types are the <code>ORACLE_LOADER</code> type and the <code>ORACLE_DATAPUMP</code> type. Each type of external table is supported by its own access driver.</p><ul><li><p>The <code>ORACLE_LOADER</code> access driver is the default. It can perform only data loads, and the data must come from text data files. Loads from external tables to internal tables are done by reading from the external tables' text-only data files.</p></li><li><p>The <code>ORACLE_DATAPUMP</code> access driver can perform both loads and unloads. The data must come from binary dump files. Loads to internal tables from external tables are done by fetching from the binary dump files. Unloading from internal tables to external tables is done by populating the external tables' binary dump files.</p></li></ul></li><li><p><code>DEFAULT DIRECTORY</code> - specifies the default location of files that are read or written by external tables. The location is specified with a directory object, not a directory path. See <a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14215/et_concepts.htm#i1009094\">Location of Datafiles and Output Files</a> for more information.</p></li><li><p><code>ACCESS PARAMETERS</code> - describe the external data source and implement the type of external table that was specified. Each type of external table has its own access driver that provides access parameters unique to that type of external table. See <a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14215/et_concepts.htm#i1009331\">Access Parameters</a>.</p></li><li><p><code>LOCATION</code> - specifies the location of the external data. The location is specified as a list of directory objects and filenames. If the directory object is not specified, then the default directory object is used as the file location.</p></li></ul><p>The following example shows the use of each of these attributes:</p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; CREATE TABLE emp_load\n  2    (employee_number      CHAR(5),\n  3     employee_dob         CHAR(20),\n  4     employee_last_name   CHAR(20),\n  5     employee_first_name  CHAR(15),\n  6     employee_middle_name CHAR(15),\n  7     employee_hire_date   DATE)\n  8  ORGANIZATION EXTERNAL\n  9    (TYPE ORACLE_LOADER\n 10     DEFAULT DIRECTORY def_dir1\n 11     ACCESS PARAMETERS\n 12       (RECORDS DELIMITED BY NEWLINE\n 13        FIELDS (employee_number      CHAR(2),\n 14                employee_dob         CHAR(20),\n 15                employee_last_name   CHAR(18),\n 16                employee_first_name  CHAR(11),\n 17                employee_middle_name CHAR(11),\n 18                employee_hire_date   CHAR(10) date_format DATE mask \"mm/dd/yyyy\"\n 19               )\n 20       )\n 21     LOCATION ('info.dat')\n 22    );\n \nTable created.</pre><p><br></p><p>The information you provide through the access driver ensures that data from the data source is processed so that it matches the definition of the external table. The fields listed after <code>CREATE TABLE emp_load</code> are actually defining the metadata for the data in the <code>info.dat</code> source file. The access parameters are optional.</p>",
                "answers": [
                    "<p><code>TYPE</code></p>",
                    "<p><code>DEFAULT DIRECTORY</code></p>",
                    "<p><code>ACCESS PARAMETERS</code></p>",
                    "<p><code>LOCATION</code></p>",
                    "<p><code>FROM</code> </p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c",
                "d"
            ],
            "section": "Database Utilities",
            "question_plain": "External tables are created using the SQL CREATE TABLE...ORGANIZATION EXTERNAL statement. Which of the following attributes are specified when you run the following SQL command?CREATE TABLE emp_load\n  2    (employee_number      CHAR(5),\n  3     employee_dob         CHAR(20),\n  4     employee_last_name   CHAR(20),\n  5     employee_first_name  CHAR(15),\n  6     employee_middle_name CHAR(15),\n  7     employee_hire_date   DATE)\n  8  ORGANIZATION EXTERNAL\n  9    (TYPE ORACLE_LOADER\n 10     DEFAULT DIRECTORY def_dir1\n 11     ACCESS PARAMETERS\n 12       (RECORDS DELIMITED BY NEWLINE\n 13        FIELDS (employee_number      CHAR(2),\n 14                employee_dob         CHAR(20),\n 15                employee_last_name   CHAR(18),\n 16                employee_first_name  CHAR(11),\n 17                employee_middle_name CHAR(11),\n 18                employee_hire_date   CHAR(10) date_format DATE mask \"mm/dd/yyyy\"\n 19               )\n 20       )\n 21     LOCATION ('info.dat')\n 22    );\n \nTable created.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305973,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding subqueries (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Subqueries](https://www.techonthenet.com/oracle/subqueries.php)",
                    "[Database Implementations of ORDER BY in a Subquery](https://dba.stackexchange.com/questions/82930/database-implementations-of-order-by-in-a-subquery)"
                ],
                "feedbacks": [
                    "The ORDER BY Clause can indeed be used in a subquery to sort the results before they are returned to the main query. This can be useful for organizing the data in a specific way.",
                    "A subquery can be used in the FROM clause of a SELECT statement to create a temporary table that the main query can then reference. This can be helpful when complex data manipulations are needed.",
                    "If a subquery returns NULL, the main query may still return rows because the subquery is treated as a single value. This can affect the overall result set of the main query.",
                    "<p>Group by a subquery is not possible (where and having can have subqueries)</p><figure><img src=\"https://udemy-images.s3.amazonaws.com:443/redactor/raw/q_and_a/2025-01-09_12-31-45-46f52aa99a008e4ac72cd901b9071d79.png\"></figure>",
                    "Logical operators, such as AND, OR, and NOT, can be used in the WHERE clause of a subquery to create complex conditions for filtering data. These operators allow for more precise control over the data being retrieved."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><p><strong>The ORDER BY clause can be used in a subquery.</strong></p><ul><li><p><strong>True</strong>, but with a condition:</p><ul><li><p><code>ORDER BY</code> is <strong>allowed</strong> in subqueries, <strong>only</strong> when it's in the context of:</p><ul><li><p>A <strong>subquery with </strong><code><strong>ROWNUM</strong></code><strong> or </strong><code><strong>FETCH FIRST</strong></code></p></li><li><p>A <strong>subquery in the FROM clause</strong> (inline views)</p></li></ul></li><li><p>It is <strong>not allowed</strong> in scalar or simple <code>WHERE</code> clause subqueries unless used with constructs that require ordering.</p></li></ul></li></ul><p><strong>A subquery can be used in the FROM clause of a SELECT statement.</strong></p><ul><li><p><strong>True</strong> – This is known as an <strong>inline view</strong>.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT dept_name, total_salary\nFROM (\n  SELECT department_id, SUM(salary) AS total_salary\n  FROM employees\n  GROUP BY department_id\n) dept_summary\nJOIN departments d ON dept_summary.department_id = d.department_id;</pre></li></ul><p><br></p><p><strong>If a subquery returns NULL, the main query may still return rows.</strong></p><ul><li><p><strong>True</strong> – Especially in scalar or <code>IN</code> conditions:</p><ul><li><p>For example:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM employees\nWHERE department_id = (SELECT department_id FROM departments WHERE department_name = 'X');\n</pre><p>If the subquery returns <code>NULL</code>, it just makes the condition fail, but not necessarily cause the <strong>main query</strong> to fail completely.</p></li></ul></li><li><p>Also, other conditions outside the subquery may still produce results.</p></li></ul><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>A subquery can be placed in a WHERE clause, a GROUP BY clause, or a HAVING clause.</strong></p><ul><li><p><strong>Partially false</strong> – A subquery <strong>can</strong> be placed in:</p><ul><li><p><code>WHERE</code> (True)</p></li><li><p><code>HAVING</code> (True)</p></li><li><p><strong>But not in </strong><code><strong>GROUP BY</strong></code>. <code>GROUP BY</code> only allows column expressions.</p></li></ul></li></ul><p><br></p><p><strong>Logical operators, such as AND, OR and NOT, cannot be used in the WHERE clause of a subquery.</strong></p><ul><li><p><strong>False</strong> – Logical operators <strong>can absolutely be used</strong> in the <code>WHERE</code> clause of subqueries.</p><ul><li><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM employees\nWHERE employee_id IN (\n  SELECT employee_id\n  FROM job_history\n  WHERE start_date &lt; SYSDATE AND end_date IS NOT NULL\n);</pre></li></ul></li></ul><p><br></p><p><strong>Oracle subquery</strong></p><p>In Oracle, a subquery is a query within a query. You can create subqueries within your SQL statements. These subqueries can reside in the <strong>WHERE clause, the FROM clause, or the SELECT clause.</strong></p><p><strong>WHERE clause</strong></p><p>Most often, the subquery will be found in the WHERE clause. These subqueries are also called nested subqueries.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * \nFROM all_tables tabs\nWHERE tabs.table_name IN (SELECT cols.table_name\n                          FROM all_tab_columns cols\n                          WHERE cols.column_name = 'SUPPLIER_ID');</pre><p><br></p><p><strong>Limitation:</strong> Oracle allows up to 255 levels of subqueries in the WHERE clause.</p><p><strong>FROM clause</strong></p><p>A subquery can also be found in the FROM clause. These are called <strong>inline views</strong>.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT suppliers.name, subquery1.total_amt\nFROM suppliers,\n (SELECT supplier_id, SUM(orders.amount) AS total_amt\n  FROM orders\n  GROUP BY supplier_id) subquery1\nWHERE subquery1.supplier_id = suppliers.supplier_id;</pre><p><br></p><p>In this example, we've created a subquery in the <code>FROM</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT supplier_id, SUM(orders.amount) AS total_amt\n FROM orders\n GROUP BY supplier_id) subquery1</pre><p><br></p><p>This subquery has been aliased with the name <em>subquery1</em>. This will be the name used to reference this subquery or any of its fields.</p><p>Limitations</p><p>Oracle allows an unlimited number of subqueries in the FROM clause.</p><p><br></p><p><strong>SELECT clause</strong></p><p>A subquery can also be found in the SELECT clause.</p><p>For example:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT tbls.owner, tbls.table_name,\n  (SELECT COUNT(column_name) AS total_columns\n   FROM all_tab_columns cols\n   WHERE cols.owner = tbls.owner\n   AND cols.table_name = tbls.table_name) subquery2\nFROM all_tables tbls;</pre><p><br></p><p>In this example, we've created a subquery in the SELECT clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">(SELECT COUNT(column_name) AS total_columns\n FROM all_tab_columns cols\n WHERE cols.owner = tbls.owner\n AND cols.table_name = tbls.table_name) subquery2</pre><p><br></p><p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p><p>The trick to placing a subquery in the select clause is that the subquery must return a single value. This is why an aggregate function such as <a href=\"https://www.techonthenet.com/oracle/functions/sum.php\">SUM function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/count.php\">COUNT function</a>, <a href=\"https://www.techonthenet.com/oracle/functions/min.php\">MIN function</a>, or <a href=\"https://www.techonthenet.com/oracle/functions/max.php\">MAX function</a> is commonly used in the subquery.</p><p><br></p><p><strong>ORDER BY in a Subquery</strong></p><p>Although some database systems allow the specification of an <code>ORDER BY </code>clause in subselects or view definitions, the presence there has no effect.</p><p>Oracle supports ORDER BY in a subquery. </p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-12_17-05-13-e24a298b0717c86d6727e4d8d7519199.png\"></p><p><br></p><p>Keep in mind that the query results cannot be guaranteed unless the ORDER&nbsp;BY is in the outer query.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM \n    (SELECT *\n    FROM products)\nORDER BY PROD_NAME;</pre><p><br></p><p>Logical operators, such as AND, OR and NOT, can be used in the WHERE clause of a subquery.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM products\nWHERE prod_id IN(\n        SELECT prod_id\n        FROM products\n        WHERE prod_id NOT IN(\n            SELECT prod_id\n            FROM more_products));</pre><p><br></p><p>The above query executes successfully.</p>",
                "answers": [
                    "<p>The ORDER BY Clause can be used in a subquery.</p>",
                    "<p>A subquery can be used in the FROM clause of a SELECT statement.</p>",
                    "<p>If a subquery returns NULL, the main query may still return rows.</p>",
                    "<p>A subquery can be placed in a WHERE clause, a GROUP BY clause, or a HAVING clause.</p>",
                    "<p>Logical operators, such as AND, OR and NOT, cannot be used in the WHERE clause of a subquery.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding subqueries (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305975,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table and the exhibit.</p><p><strong>Table: CUSTOMERS</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nCUST_NAME                          VARCHAR2(20)\nCUST_EMAIL                         VARCHAR2(30)\nINCOME_LEVEL                       VARCHAR2(20)</pre><p> </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">MERGE INTO customers c\nUSING customer_vu cv\nON (c.customer_id = cv.customer_id)\nWHEN&nbsp;MATCHED&nbsp;THEN\nUPDATE&nbsp;SET\nc.customer_id = cv.customer_id,\nc.cust_name = cv.cust_name,\nc.cust_email = cv.cust_email,\nc.income_level = cv.income_level\nWHEN&nbsp;NOT MATCHED&nbsp;THEN\nINSERT VALUES (cv.customer_id, cv.cust_name, cv.cust_email, cv.income_level)\nWHERE cv.income_level &lt; 100000;</pre><p><br></p><p><strong>Given: </strong></p><ol><li><p>CUSTOMER_VU is a view based on the CUSTOMERS_BR1 table, which has the same structure as the CUSTOMERS table. CUSTOMERS need to be updated to reflect the latest information about the customers.&nbsp;</p></li><li><p>CUSTOMER_ID is the primary key in the CUSTOMERS table</p></li></ol><p>Identify the error in the following MERGE statement.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The CUSTOMER_ID column is typically used as a primary key in the CUSTOMERS table, and primary key columns cannot be updated using the MERGE statement. This is to maintain data integrity and prevent accidental changes to unique identifiers.",
                    "The INTO clause in the MERGE statement is correctly placed at the beginning of the command. It specifies the target table where the data will be merged. Placing it elsewhere in the command would result in a syntax error.",
                    "The WHERE clause in the MERGE statement is used to specify the condition for updating or inserting data based on certain criteria. It is a valid and necessary part of the MERGE statement to control the data manipulation process.",
                    "CUSTOMER_VU, being a view based on the CUSTOMERS_BR1 table, can be used as a data source in the MERGE statement. Views can be used to simplify complex queries and provide a virtual representation of the underlying data, making them suitable for use in data manipulation operations like MERGE."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><p>The CUSTOMER_ID column cannot be updated.</p><p>In the given <code>MERGE</code> statement:</p><pre class=\"prettyprint linenums\">sql\nMERGE INTO customers c\nUSING customer_vu cv\nON (c.customer_id = cv.customer_id)\nWHEN MATCHED THEN\nUPDATE SET\nc.customer_id = cv.customer_id,\nc.cust_name = cv.cust_name,\nc.cust_email = cv.cust_email,\nc.income_level = cv.income_level\n...</pre><p>You're trying to <strong>update </strong><code><strong>c.customer_id</strong></code>, which is the <strong>primary key</strong> of the <code>CUSTOMERS</code> table.</p><p><strong>Oracle does not allow the primary key column to be updated in a MERGE statement</strong> if that column is also part of the <strong>join condition</strong> (<code>ON (c.customer_id = cv.customer_id)</code>) — which it is here.</p><p>This merge is matching on the customer ID between the source and the destination pivot, so this pivot point cannot be updated. If the customer ID is to be changed, the match will need to be performed on a different field.</p><p>It's important to clarify that the <code>customer_id</code> field not being defined as a primary key does indeed imply that it can be updated, assuming there are no other constraints in place. In relational databases, primary keys are unique identifiers for records, and if a field is not designated as such, it can typically be modified.</p><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>The INTO clause is misplaced in the command.</strong></p><ul><li><p>Incorrect — <code>MERGE INTO</code> is syntactically correct.</p></li></ul><p><strong>The WHERE clause cannot be used with INSERT.</strong></p><ul><li><p>Incorrect — <code>WHERE</code> in <code>WHEN NOT MATCHED THEN INSERT</code> is <strong>valid</strong> to <strong>filter</strong> what gets inserted.</p></li></ul><p><strong>CUSTOMER_VU cannot be used as a data source.</strong></p><ul><li><p>Incorrect — views <strong>can</strong> be used in the <code>USING</code> clause as a data source.</p></li></ul><p>Regarding the <code>TIME_ID</code> field, which is of type <code>DATE</code>, it can serve as a foreign key (FK) reference to another table, such as a <code>times</code> table. Foreign keys can be of various data types, including <code>DATE</code>, as long as they match the data type of the corresponding primary key in the referenced table. This means that you can have a <code>DATE</code> column functioning as a foreign key without any issues.</p><p>When working with Data Manipulation Language (DML) statements, remember that they allow for updates, inserts, and deletes on the data in your tables. The ability to manipulate data is not contingent on having a primary key defined, which aligns with your observation about the <code>customer_id</code> field.</p>",
                "answers": [
                    "<p>The CUSTOMER_ID column cannot be updated.</p>",
                    "<p>The INTO clause is misplaced in the command.</p>",
                    "<p>The WHERE clause cannot be used with INSERT.</p>",
                    "<p>CUSTOMER_VU cannot be used as a data source.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the CUSTOMERS table and the exhibit.Table: CUSTOMERSName             Null??            Type\nCUSTOMER_ID      NOT NULL          NUMBER(6)\nCUST_NAME                          VARCHAR2(20)\nCUST_EMAIL                         VARCHAR2(30)\nINCOME_LEVEL                       VARCHAR2(20) Exhibit: 1MERGE INTO customers c\nUSING customer_vu cv\nON (c.customer_id = cv.customer_id)\nWHEN&nbsp;MATCHED&nbsp;THEN\nUPDATE&nbsp;SET\nc.customer_id = cv.customer_id,\nc.cust_name = cv.cust_name,\nc.cust_email = cv.cust_email,\nc.income_level = cv.income_level\nWHEN&nbsp;NOT MATCHED&nbsp;THEN\nINSERT VALUES (cv.customer_id, cv.cust_name, cv.cust_email, cv.income_level)\nWHERE cv.income_level &lt; 100000;Given: CUSTOMER_VU is a view based on the CUSTOMERS_BR1 table, which has the same structure as the CUSTOMERS table. CUSTOMERS need to be updated to reflect the latest information about the customers.&nbsp;CUSTOMER_ID is the primary key in the CUSTOMERS tableIdentify the error in the following MERGE statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305977,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about the results of using the INTERSECT operator in compound queries.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Null values in a join](https://community.oracle.com/thread/3579956)",
                    "[Oracle / PLSQL: INTERSECT Operator](https://www.techonthenet.com/oracle/intersect.php)",
                    "[Oracle / PLSQL: SELECT Statement](https://www.techonthenet.com/oracle/select.php)"
                ],
                "feedbacks": [
                    "Reversing the order of the intersected tables does not affect the output when using the INTERSECT operator in compound queries. The operator compares the result sets of the two SELECT statements and returns only the rows that appear in both result sets, regardless of the order of the tables.",
                    "The number of columns in each SELECT statement in a compound query using the INTERSECT operator must be the same. The operator compares the result sets based on the column values, so having a different number of columns in each SELECT statement would result in an error.",
                    "The INTERSECT operator in compound queries returns only the rows that are common to both sides of the query. This means that the result set will contain rows that exist in both result sets of the SELECT statements, effectively finding the intersection of the two sets.",
                    "Column names in each SELECT statement in a compound query using the INTERSECT operator can be different. The operator compares the result sets based on the column values, not the column names, so having different column names in each SELECT statement does not affect the operation of the INTERSECT operator."
                ],
                "explanation": "<p><strong>Key facts about </strong><code><strong>INTERSECT</strong></code><strong> in SQL:</strong></p><ul><li><p><code>INTERSECT</code> returns <strong>only the rows that are common</strong> to both <code>SELECT</code> statements.</p></li><li><p>Both <code>SELECT</code> queries must have:</p><ul><li><p>The <strong>same number of columns</strong></p></li><li><p>The <strong>same or compatible data types</strong> in corresponding positions</p></li></ul></li><li><p>The <strong>order</strong> of columns or query sides <strong>does not affect</strong> the result.</p></li><li><p><strong>Column names</strong> in the final result come from the <strong>first </strong><code><strong>SELECT</strong></code>.</p></li></ul><p><strong>Correct Answers:</strong></p><p><strong>INTERSECT returns rows common to both sides of the compound query.</strong></p><ul><li><p><strong>True</strong> – This is the <strong>definition</strong> of <code>INTERSECT</code>.</p></li><li><p>Only rows that <strong>exist in both result sets</strong> are returned (duplicates are automatically removed).</p></li></ul><p><strong>Column names in each SELECT in the compound query can be different.</strong></p><ul><li><p><strong>True</strong> – Yes, the <strong>column names can differ</strong>, but:</p><ul><li><p>The <strong>data types</strong> must be <strong>compatible</strong></p></li><li><p>The <strong>names in the final result</strong> are taken from the <strong>first SELECT</strong></p></li></ul></li></ul><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>Reversing the order of the intersected tables can sometimes affect the output.</strong></p><ul><li><p><strong>False</strong> – <code>INTERSECT</code> is <strong>commutative</strong>, meaning:</p><pre class=\"prettyprint linenums\">sql\nSELECT ... FROM A\nINTERSECT\nSELECT ... FROM B</pre><p>is the same as:</p><pre class=\"prettyprint linenums\">sql\nSELECT ... FROM B\nINTERSECT\nSELECT ... FROM A</pre></li><li><p>The result set is <strong>not affected</strong> by the order.</p></li></ul><p><br></p><p><strong>The number of columns in each SELECT in the compound query can be different.</strong></p><ul><li><p><strong>False</strong> – Both <code>SELECT</code> statements in a compound query must return the <strong>same number of columns</strong>; otherwise, you’ll get an error.</p></li></ul><p><br></p><p><strong>The Oracle INTERSECT</strong></p><p>The Oracle <code>INTERSECT</code> operator is used to return the results of 2 or more <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT statements</a>. However, it only returns the rows selected by all queries or data sets. If a record exists in one query and not in the other, it will be omitted from the INTERSECT results.</p><p><code>INTERSECT</code> combines the results of two queries and returns only those rows that match (=returned by both queries).</p><p><br></p><pre class=\"prettyprint linenums\">SELECT id FROM table_A\nINTERSECT\nSELECT id FROM table_B</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-12_18-47-04-2d74be2ab3a2aa55422e7d4056e3975e.png\"></p><p><br></p><p>No matter how the<code> INTERSECT</code> or <code>INNER JOIN</code>&nbsp;is approached, the results will always be the same.</p><p>Column names in each <code>SELECT</code> in the compound query can be different, but the data types within each subquery must be compatible.</p><p><br></p><p><strong>NULL&nbsp;</strong> </p><p>If a column in a row has no value, then the column is said to be null, or to contain null. Nulls can appear in columns of any datatype that are not restricted by <code>NOT NULL</code> or <code>PRIMARY KEY</code> integrity constraints. Use a null when the actual value is not known or when a value would not be meaningful.</p><p>Do not use null to represent a value of zero, because they are not equivalent.</p><p><code>NULL</code> is never equal to anything (even another NULL)</p>",
                "answers": [
                    "<p>Reversing the order of the intersected tables can sometimes affect the output.</p>",
                    "<p>The number of columns in each SELECT in the compound query can be different.</p>",
                    "<p>INTERSECT returns rows common to both sides of the compound query.</p>",
                    "<p>Column names in each SELECT in the compound query can be different.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify two true statements about the results of using the INTERSECT operator in compound queries.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305979,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the SALES table and the exhibit.</p><p><strong>Table: SALES</strong></p><pre class=\"prettyprint linenums\">Name             Null??            Type\nPROD_ID          NOT NULL          NUMBER\nCUST_ID          NOT NULL          NUMBER\nTIME_ID          NOT NULL          DATE\nCHANNEL_ID       NOT NULL          NUMBER\nPROMO_ID         NOT NULL          NUMBER\nQUANTITY_SOLD    NOT NULL          NUMBER(10,2)</pre><p> </p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id\nFROM sales\nWHERE quantity_sold &gt; 55000 AND&nbsp;COUNT(*) &gt; 10\nGROUP&nbsp;BY prod_id\nHAVING&nbsp;COUNT(*) &gt; 10</pre><p><br></p><p><strong>Given:</strong> The SQL query is written to retrieve all those product IDs from the SALES table that have more than 55000 sold and have been ordered more than 10 items. </p><p>Identify the true response.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle COUNT](https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/)",
                    "[Aggregate Functions](https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions001.htm#i89203)"
                ],
                "feedbacks": [
                    "The query may execute successfully and generate the required result if the conditions specified in the WHERE clause are met in the SALES table.",
                    "The query does not necessarily produce an error because COUNT(*) is not required in the SELECT clause for this specific query. It is used in aggregate functions like COUNT().",
                    "The query produces an error because the COUNT(*) function should only be used in the HAVING clause when filtering based on aggregate functions. In this case, the condition should be based on the actual column values, not the count of rows.",
                    "The query may execute successfully but produce no result if the condition specified in the WHERE clause is not met. Using COUNT(prod_id) instead of COUNT(*) would be more appropriate for this specific query to count the occurrences of product IDs."
                ],
                "explanation": "<p><strong>Correct Answer:</strong> It produces an error because COUNT (*) should be only in the HAVING clause and not in the WHERE clause.</p><p>Let’s break down the <strong>problem in the SQL query:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT prod_id\nFROM sales\nWHERE quantity_sold &gt; 55000 AND COUNT(*) &gt; 10  -- ERROR here\nGROUP BY prod_id\nHAVING COUNT(*) &gt; 10</pre><p><br></p><p><strong>Problem:</strong></p><ul><li><p>The <code><strong>WHERE</strong></code><strong> clause</strong> is used to <strong>filter rows before grouping</strong> happens.</p></li><li><p><strong>Aggregate functions like </strong><code><strong>COUNT(*)</strong></code><strong> cannot be used in the </strong><code><strong>WHERE</strong></code><strong> clause</strong>.</p></li><li><p>Instead, aggregate conditions <strong>must be placed in the </strong><code><strong>HAVING</strong></code><strong> clause</strong>, which filters <strong>after grouping</strong>.</p></li></ul><p><br></p><p><strong>Correct Version of the Query:</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id\nFROM sales\nWHERE quantity_sold &gt; 55000\nGROUP BY prod_id\nHAVING COUNT(*) &gt; 10;</pre><p><br></p><p><strong>Correct version:</strong></p><ul><li><p>Filters rows where <code>quantity_sold &gt; 55000</code> before grouping.</p></li><li><p>Groups by <code>prod_id</code>.</p></li><li><p>Filters grouped results to include only those with more than 10 entries.</p></li></ul><p><strong>Bonus Tip:</strong></p><ul><li><p>If the requirement was to <strong>sum</strong> the quantity and check if it's over 55000, you’d need to use <code>SUM(quantity_sold)</code> in the <code>HAVING</code> clause instead.</p><p><br></p></li></ul><p><strong>Oracle COUNT() </strong></p><p>The Oracle <code>COUNT()</code> function is an <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate function</a> that returns the number of items in a group.</p><p><strong>The syntax of the </strong><code><strong>COUNT()</strong></code><strong> function is as follows:</strong></p><pre class=\"prettyprint linenums\">   COUNT( [ALL | DISTINCT | * ] expression)</pre><p><br></p><p>The <code>COUNT()</code> function accepts a clause which can be either <code>ALL</code>, <code>DISTINCT</code>, or <code>*</code>:</p><p>• <code>COUNT(*)</code> function returns the number of items in a group, including <code>NULL</code> and duplicate values.</p><p>• <code>COUNT(DISTINCT expression)</code> function returns the number of unique and non-null items in a group.</p><p>• <code>COUNT(ALL expression)</code> evaluates the expression and returns the number of non-null items in a group, including duplicate values.</p><p>• If you don’t explicitly specify <code>DISTINCT</code> or <code>ALL</code>, the <code>COUNT()</code> function uses <code>ALL</code> by default.</p><p>Note that, unlike other <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>, the <code>COUNT(*)</code> function does not ignore <code>NULL</code> values.</p><p><code>COUNT</code> is an aggregate function that returns a single result row based on groups of rows, rather than on single rows. Aggregate functions can appear in select lists and in <code>ORDER</code> <code>BY</code> and <code>HAVING</code> clauses. They are commonly used with the <code>GROUP</code> <code>BY</code> clause in a <code>SELECT</code> statement, where Oracle Database divides the rows of a queried table or view into groups. In a query containing a <code>GROUP</code> <code>BY</code> clause, the elements of the select list can be aggregate functions, <code>GROUP</code> <code>BY</code> expressions, constants, or expressions involving one of these. Oracle applies the aggregate functions to each group of rows and returns a single result row for each group.</p><p>If you omit the <code>GROUP</code> <code>BY</code> clause, then Oracle applies aggregate functions in the select list to all the rows in the queried table or view. You use aggregate functions in the <code>HAVING</code> clause to eliminate groups from the output based on the results of the aggregate functions, rather than on the values of the individual rows of the queried table or view.</p><p><br></p><p><code> SELECT COUNT()</code>&nbsp; &nbsp;examples:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    COUNT(*)\nFROM\n    products;</pre><p><br></p><pre class=\"prettyprint linenums\">SELECT prod_id\nFROM sales\nWHERE quantity_sold &gt; 55000\nGROUP BY prod_id\nHAVING COUNT(*) &gt; 10;</pre><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    last_name,\n    COUNT( last_name )\nFROM\n    contacts\nGROUP BY\n    last_name\nHAVING\n    COUNT( last_name )&gt; 1\nORDER BY\n    last_name;</pre>",
                "answers": [
                    "<p>It executes successfully and generates the required result.</p>",
                    "<p>It produces an error because COUNT (*) should be specified in the SELECT clause also.</p>",
                    "<p>It produces an error because COUNT (*) should be only in the HAVING clause and not in the WHERE clause.</p>",
                    "<p>It executes successfully but produces no result because COUNT(prod_id) should be used instead of COUNT(*).</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the SALES table and the exhibit.Table: SALESName             Null??            Type\nPROD_ID          NOT NULL          NUMBER\nCUST_ID          NOT NULL          NUMBER\nTIME_ID          NOT NULL          DATE\nCHANNEL_ID       NOT NULL          NUMBER\nPROMO_ID         NOT NULL          NUMBER\nQUANTITY_SOLD    NOT NULL          NUMBER(10,2) Exhibit: 1SELECT prod_id\nFROM sales\nWHERE quantity_sold &gt; 55000 AND&nbsp;COUNT(*) &gt; 10\nGROUP&nbsp;BY prod_id\nHAVING&nbsp;COUNT(*) &gt; 10Given: The SQL query is written to retrieve all those product IDs from the SALES table that have more than 55000 sold and have been ordered more than 10 items. Identify the true response.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305981,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the DEPARTMENTS table and the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-15-53-f476e5490991bf584fcdeecb839582b4.png\"></p><p><br></p><p>Examine this SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT department_id \"DEPT_ID\", department_name, 'b'\nFROM departments\nWHERE department_id = 90\nUNION\nSELECT department_id, department_name DEPT_NAME, 'a'\nFROM&nbsp;departments\nWHERE department id = 10;</pre><p><br></p><p>Identify the ORDER BY clauses that can be used to sort the output (Choose two).</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "Sorting the output by the DEPT_NAME column will arrange the result set alphabetically based on the department names. This is a valid ORDER BY clause that can be used to sort the output.",
                    "Using ORDER BY DEPT_ID will sort the output based on the department IDs in ascending or descending order. This is a valid ORDER BY clause that can be used to sort the output.",
                    "ORDER BY 'b' is not a valid syntax for sorting the output. The ORDER BY clause should reference a column name or column position, not a string literal.",
                    "ORDER BY 3 is a valid syntax to sort the output based on the third column in the SELECT statement. In this case, it would sort the output based on the third column in the result set."
                ],
                "explanation": "<p><strong>The correct answers are:</strong></p><ol><li><p><em>ORDER BY DEPT_ID;</em></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-14_02-04-38-285faf8635e2a4d2f2ef15bf8de5b106.png\"></p></li><li><p><em>ORDER BY 3;</em></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-14_02-03-45-3f4cba19205c0f451a8c2bef5d31fce7.png\"></p></li></ol><p>In a <code><strong>UNION</strong></code> query, the <code>ORDER BY</code> clause <strong>must refer to the output of the final result set</strong> — not just the columns of one subquery. Here's the query for context:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT department_id \"DEPT_ID\", department_name, 'b'\nFROM departments\nWHERE department_id = 90\nUNION\nSELECT department_id, department_name DEPT_NAME, 'a'\nFROM departments\nWHERE department_id = 10;</pre><p><br></p><p>Columns in the Final Output:</p><ol><li><p><code>department_id</code> aliased as <code>\"DEPT_ID\"</code></p></li><li><p><code>department_name</code> (no alias at top level)</p></li><li><p>A <strong>literal string</strong> column (<code>'b'</code> or <code>'a'</code>), unnamed</p></li></ol><p><strong>Valid ORDER BY clauses:</strong></p><p><code><strong>ORDER BY DEPT_ID;</strong></code></p><ul><li><p><code>DEPT_ID</code> is a valid alias in the <strong>first SELECT</strong>, and since it's <strong>used in the final output</strong>, it can be used in <code>ORDER BY</code>.</p></li></ul><p><code><strong>ORDER BY 3;</strong></code></p><ul><li><p>Refers to the <strong>third column</strong> in the final result set — the one with values <code>'a'</code> or <code>'b'</code>.</p></li><li><p>Using column positions (1-based) is <strong>allowed</strong> in <code>ORDER BY</code>.</p></li></ul><p><br></p><p><strong>Invalid ORDER BY clauses:</strong></p><p><code><strong>ORDER BY DEPT_NAME;</strong></code></p><ul><li><p><code>DEPT_NAME</code> is an alias <strong>only in the second SELECT</strong>, not in the final output.</p></li><li><p>You can't use it in the <code>ORDER BY</code> unless it's defined at the top-level SELECT or is universally aliased.</p></li></ul><p><code><strong>ORDER BY 'b';</strong></code></p><ul><li><p><code>'b'</code> is a <strong>literal string</strong>, not a column name — this will raise an error in <code>ORDER BY</code>.</p></li></ul><p><br></p><p>The ORDER BY clause is an optional element of the following: </p><ul><li><p>A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a> </p></li><li><p>A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefselectexpression.html#rrefselectexpression\"><em>SelectExpression</em></a> </p></li><li><p>A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj11277.html#rrefsqlj11277\">VALUES expression</a> </p></li><li><p>A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefscalarsubquery.html#rrefscalarsubquery\"><em>ScalarSubquery</em></a> </p></li><li><p>A <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreftablesubquery.html#rreftablesubquery\"><em>TableSubquery</em></a></p></li><li><p>It can also be used in an <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj40774.html#rrefsqlj40774\">INSERT statement</a> or a <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15446.html#rrefsqlj15446\">CREATE VIEW statement</a>.</p></li></ul><p>An ORDER BY clause allows you to specify the order in which rows appear in the result set. In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqljoffsetfetch.html#rrefsqljoffsetfetch\">result offset and fetch first clauses</a> or in conjunction with the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rreffuncrownumber.html#rreffuncrownumber\">ROW_NUMBER function</a>, since there is no guarantee that the order is retained in the outer result set. It is permissible to combine ORDER BY on the outer query with ORDER BY in subqueries.</p><p><br></p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">ORDER BY { column-Name | ColumnPosition | Expression }\n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    [ , column-Name | ColumnPosition | Expression \n    [ ASC | DESC ]\n    [ NULLS FIRST | NULLS LAST ]\n    ] * </pre><p><br></p><p>Column-Name refers to the names visible from the SelectItems in the underlying query of the <a href=\"https://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj41360.html#rrefsqlj41360\">SELECT statement</a>. The column name that you specify in the ORDER BY clause does not need to be in the SELECT list.</p>",
                "answers": [
                    "<p><code>ORDER BY DEPT_NAME;</code> </p>",
                    "<p><code>ORDER BY DEPT_ID;</code> </p>",
                    "<p><code>ORDER BY 'b';</code> </p>",
                    "<p><code>ORDER BY 3;</code> </p>"
                ]
            },
            "correct_response": [
                "b",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the DEPARTMENTS table and the exhibit.Examine this SQL statement.Exhibit: 1SELECT department_id \"DEPT_ID\", department_name, 'b'\nFROM departments\nWHERE department_id = 90\nUNION\nSELECT department_id, department_name DEPT_NAME, 'a'\nFROM&nbsp;departments\nWHERE department id = 10;Identify the ORDER BY clauses that can be used to sort the output (Choose two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305983,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true responses about granting privileges on objects (Select two).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Object privileges](https://docs.oracle.com/database/121/TTSQL/privileges.htm#TTSQL341)",
                    "[Oracle / PLSQL: Grant/Revoke Privileges](https://www.techonthenet.com/oracle/grant_revoke.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect. An object privilege can be granted to other users by the owner of the object, as well as by users with the necessary privileges to grant object privileges.",
                    "This statement is incorrect. An object privilege can be granted to a role by the owner of the object, as well as by users with the necessary privileges to grant object privileges.",
                    "This statement is correct. In Oracle Database, a table owner must grant the REFERENCES privilege to allow other users to create FOREIGN KEY constraints using that table. This privilege controls the ability to create a foreign key that references the table.",
                    "This statement is correct. The owner of an object acquires all object privileges on that object by default. This means that the owner has full control over the object and can perform any operation on it without explicitly granting additional privileges."
                ],
                "explanation": "<p>The <strong>true responses</strong> about granting privileges on objects are:</p><p><strong>An object privilege can be granted to other users only by the owner of that object</strong></p><ul><li><p>Only the <strong>owner</strong> of an object (or a user with <code>GRANT OPTION</code> on that object) can grant object privileges to other users or roles.</p></li></ul><p><strong>A table owner must grant the REFERENCES privilege to allow other users to create FOREIGN KEY constraints using that table.</strong></p><p>In Oracle Database:</p><ul><li><p>If <strong>User A</strong> owns <strong>Table X</strong>, and <strong>User B</strong> wants to create a <strong>foreign key</strong> in their own table that <strong>references Table X</strong>, then:</p><ul><li><p><strong>User A must grant the </strong><code><strong>REFERENCES</strong></code><strong> privilege on Table X to User B</strong>.</p></li></ul></li></ul><p>This controls the ability to <strong>enforce referential integrity</strong> between tables owned by different users.</p><p>Example:</p><pre class=\"prettyprint linenums\">sql\nGRANT REFERENCES ON table_x TO user_b;</pre><p><br></p><p>Without this privilege, the database will raise a <strong>permission error</strong> when User B attempts to define a foreign key pointing to Table X.</p><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>False</strong>: <strong>An object privilege can be granted to other users only by the owner of that object.</strong><br>Object privileges can be granted not only by the owner but also by users who have been given those privileges with the <code>GRANT OPTION</code>.</p><p><strong>False</strong>: <strong>An object privilege can be granted to a role only by the owner of that object.</strong><br>Similarly, privileges can be granted to a role not just by the owner, but also by users who possess the privileges with the <code>GRANT OPTION</code>.</p><p><br></p><p><strong>Grant/Revoke Privileges on Table</strong></p><p>You can grant users various privileges to tables. These privileges can be any combination of <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>REFERENCES</code>, <code>ALTER</code>, <code>INDEX</code>, or <code>ALL</code>.</p><p><strong>Syntax</strong></p><p>The syntax for granting privileges on a table in Oracle is:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT privileges ON object TO user;</pre><pre class=\"prettyprint linenums\">REVOKE privileges ON object FROM user;</pre><p><br></p><p><strong>Privileges</strong></p><p><code>GRANT</code>&nbsp; <code>REVOKE</code>&nbsp; <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE </code>privileges on a table. For example:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT REVOKE SELECT, INSERT, UPDATE, DELETE ON suppliers TO user;</pre><p><br></p><p>Use the ALL keyword to indicate that you wish <code>ALL</code> permissions to be granted for a user. For example:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT REVOKE ALL ON object TO user;</pre><p><br></p><p>Grant only <code>SELECT</code> access on your table to all users; you could grant the privileges to the public keyword. For example:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT REVOKE SELECT ON object TO public;</pre><p><br></p><p><strong>object </strong></p><p>The name of the database object that you are granting/revoking privileges for. In the case of granting/revoking privileges on a table, this would be the table name.</p><p><strong> user </strong></p><p>The name of the user who will be granted/revoked from these privileges.</p><p><br></p><p><strong>Grant/Revoke Privileges on Functions/Procedures</strong></p><p>You can grant/revoke users the ability to EXECUTE these functions and procedures.</p><p><strong>Syntax</strong></p><p>The syntax for granting/revoking EXECUTE privileges on a function/procedure in Oracle is:</p><p><strong>specific user</strong></p><p><br></p><pre class=\"prettyprint linenums\">GRANT EXECUTE ON object TO user;</pre><pre class=\"prettyprint linenums\">REVOKE EXECUTE ON object FROM user;</pre><p><br></p><p><strong>group of users</strong></p><pre class=\"prettyprint linenums\">GRANT EXECUTE ON Find_Value TO public;</pre><pre class=\"prettyprint linenums\">REVOKE EXECUTE ON Find_Value FROM public;</pre><p><br></p><p><strong>EXECUTE </strong></p><p>The ability to compile the function/procedure. The ability to execute the function/procedure directly. </p><p><strong>object </strong></p><p>The name of the database object that you are granting privileges for. In the case of granting <code>EXECUTE</code> privileges on a function or procedure, this would be the function name or the procedure name. </p><p><strong>user </strong></p><p>The name of the user who will be granted the <code>EXECUTE</code> privileges.</p><p><strong>Privileges</strong></p><p>When multiple users can access database objects, authorization can be controlled for these objects through the assignment of privileges. Every object has an owner. Privileges control whether a user can modify an object owned by another user. <strong>Privileges are granted or revoked either by the instance administrator, a user with the </strong><code><strong>ADMIN</strong></code><strong> privilege, or, for privileges to a certain object, by the owner of the object</strong>.</p><p><strong>Object privileges</strong></p><p>An object privilege is the right to perform a particular action on an object or to access another user's object. Objects include tables, views, materialized views, indexes, synonyms, sequences, cache groups, replication schemes, and PL/SQL functions, procedures, and packages.</p><p><strong>An object's owner has all object privileges for that object, and those privileges cannot be revoked.</strong> The object's owner can grant object privileges for that object to other database users. A user with <code>ADMIN</code> privilege can grant and revoke object privileges from users who do not own the objects on which the privileges are granted.</p>",
                "answers": [
                    "<p>An object privilege can be granted to other users only by the owner of that object.</p>",
                    "<p>An object privilege can be granted to a role only by the owner of that object.</p>",
                    "<p>A table owner must grant the REFERENCES privilege to allow other users to create FOREIGN KEY constraints using that table.</p>",
                    "<p>The owner of an object acquires all object privileges on that object by default.</p>"
                ]
            },
            "correct_response": [
                "c",
                "d"
            ],
            "section": "System privileges",
            "question_plain": "View and examine the following available responses.Identify the true responses about granting privileges on objects (Select two).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305985,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true responses about a SQL statement using SET operators such as UNION. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Introduction to Oracle Datatypes](https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT113)",
                    "[SQL - Using the Set Operators](https://www.tutorialspoint.com/sql_certificate/using_the_set_operators.htm)",
                    "[SQL Set Operators: The Complete Guide to UNION, INTERSECT &amp; MINUS](https://www.databasestar.com/sql-set-operators/)"
                ],
                "feedbacks": [
                    "The number of columns in the SELECT statements must be the same when using SET operators like UNION. This ensures that the result sets can be combined properly without any mismatch in the number of columns.",
                    "When using SET operators like UNION, the data type of each column returned by the second query must be implicitly convertible to the data type of the corresponding column returned by the first query. This is necessary to ensure that the result set can be combined without any data type conflicts.",
                    "The data type group of each column returned by the second query must match the data type group of the corresponding column returned by the first query when using SET operators like UNION. This ensures that the data types are compatible for combining the result sets.",
                    "The names and number of columns must be identical for all SELECT statements in the query when using SET operators like UNION. This is incorrect as only the number of columns needs to be the same, not necessarily the names of the columns."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p>The number, but not the names, of columns must be identical for all SELECT statements in the query.</p></li><li><p>The data type of each column returned by the second query must be implicitly convertible to the data type of the corresponding column returned by the first query.</p></li><li><p>The data type group of each column returned by the second query must match the data type group of the corresponding column returned by the first query.</p></li></ol><p><strong>Incorrect Statement:</strong></p><ul><li><p>The names and number of columns must be identical for all SELECT statements in the query.<br>→ This is incorrect because <strong>only the number and data types (or implicitly convertible types)</strong> must match.<br>→ <strong>Column names don’t need to match</strong> — the column names from the <strong>first SELECT</strong> are used in the final result set.</p></li></ul><p>When using <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, or <code>MINUS</code>:</p><ul><li><p><strong>Same number of columns</strong> in each <code>SELECT</code>.</p></li><li><p><strong>Data types must be compatible</strong> (Oracle allows implicit conversion if needed).</p></li><li><p><strong>Column names don’t have to match</strong>.</p></li></ul><p>There are 6 \"types\" or \"groups\" </p><ol><li><p>Character Datatypes </p></li><li><p>Numeric Datatypes </p></li><li><p>DATE Datatype </p></li><li><p>LOB Datatypes </p></li><li><p>RAW and LONG RAW Datatypes </p></li><li><p>ROWID and UROWID Datatypes </p></li></ol><p>Data types of the column list must be compatible/implicitly convertible by Oracle. Oracle will not perform implicit type conversion if corresponding columns in the component queries belong to different data type groups. For example, if a column in the first component query is of data type DATE, and the corresponding column in the second component query is of data type CHAR, Oracle will not perform implicit conversion, but raise ORA-01790 error. </p><p>You cannot do a compound (SET) query from Character to ROWID, or Character to Numeric (even if they can implicitly convert like '1' -&gt; 1). Anything within a group is fine. </p><p>Like SYSDATE -&gt; CURRENT_TIMESTAMP</p><p><br></p><p><strong>Set Operators in SQL </strong></p><p>A set operator in SQL is a keyword that lets you combine the results of two queries into a single query. The set operators are:</p><ul><li><p><code>UNION</code></p></li><li><p><code>UNION ALL</code></p></li><li><p><code>MINUS</code></p></li><li><p><code>INTERCEPT</code></p></li><li><p><code>EXCEPT</code></p></li></ul><p>The <code>UNION</code> keyword or set operator will allow you to combine the results of two queries. It removes any duplicate results and shows you the combination of both.</p><p><strong>Syntax</strong></p><p>The syntax for the UNION operator in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nUNION\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, expression_n: The columns or calculations that you wish to retrieve. Tables: The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. <code>WHERE</code> conditions are optional. The conditions that must be met for the records to be selected.</p><p><strong>Note</strong></p><p>There must be the same number of expressions in both <code>SELECT</code> statements.</p><p>Each<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statement</a> within the <code>UNION</code> operator must have the same number of fields in the result sets with similar data types.</p><p><a href=\"https://www.techonthenet.com/oracle/union.php\">https://www.techonthenet.com/oracle/union.php</a></p>",
                "answers": [
                    "<p>The number, but not names, of columns must be identical for all SELECT statements in the query.</p>",
                    "<p>The data type of each column returned by the second query must be implicitly convertible to the data type of the corresponding column returned by the first query.</p>",
                    "<p>The data type group of each column returned by the second query must match the data type group of the corresponding column returned by the first query.</p>",
                    "<p>The names and number of columns must be identical for all SELECT statements in the query.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "Data Dictionary and Dynamic Performance Views",
            "question_plain": "View and examine the following available responses.Identify the true responses about a SQL statement using SET operators such as UNION. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306077,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statements about single-row functions (Choose three).</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CEIL](https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions017.htm)",
                    "[SQL CEIL and FLOOR Function Guide, FAQ, and Examples](https://www.databasestar.com/sql-ceil/)",
                    "[How do the floor and ceiling functions work on negative numbers?](https://math.stackexchange.com/questions/344815/how-do-the-floor-and-ceiling-functions-work-on-negative-numbers)"
                ],
                "feedbacks": [
                    "CEIL is a single-row function that returns the smallest integer greater than or equal to a specified number. It can be used for both positive and negative numbers, rounding up to the nearest integer.",
                    "FLOOR is a single-row function that returns the largest integer less than or equal to a specified number. It does not return the smallest integer greater than or equal to a number as mentioned in the choice.",
                    "TRUNC is a single-row function that can be used with both NUMBER and DATE values. It is used to truncate a number or date to a specified number of decimal places or to a specific date format.",
                    "CONCAT is not a single-row function. It is used to combine two or more strings or values together, but it is not specific to single-row functions.",
                    "MOD is a single-row function that returns the remainder of a division operation. It can be used to find the modulus of two numbers, which is the remainder after division."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p><strong>CEIL: can be used for positive and negative numbers</strong><br>→ <strong>True</strong> – <code>CEIL</code> returns the <strong>smallest integer greater than or equal to</strong> the number, and it works with both <strong>positive and negative</strong> numbers.</p></li><li><p><strong>TRUNC: can be used with NUMBER and DATE values</strong><br>→ <strong>True</strong> – <code>TRUNC</code> can <strong>truncate numbers</strong> to a specific decimal place or <strong>dates</strong> to a specific unit (like year, month, etc.).</p></li><li><p><strong>MOD: returns the remainder of a division operation</strong><br>→ <strong>True</strong> – <code>MOD(n, m)</code> returns the <strong>remainder</strong> after dividing <code>n</code> by <code>m</code>.</p></li><li><p><br></p></li></ol><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>FLOOR: returns the smallest integer greater than or equal to a specified number</strong><br>→ <strong>False</strong> – That describes <code>CEIL</code>.<br><code>FLOOR</code> actually returns the <strong>largest integer less than or equal to</strong> a specified number.</p></li><li><p><strong>CONCAT: can be used to combine any number of values</strong><br>→ <strong>False</strong> – <code>CONCAT</code> in Oracle takes <strong>only two arguments</strong>.<br>To combine more than two, you'd need to <strong>nest CONCATs</strong> or use the <code>||</code> operator.</p></li></ul><p><strong>Oracle CEIL</strong></p><p>The Oracle <code>CEIL</code> function and <code>FLOOR</code> function are opposites of each other and are very useful functions when dealing with numbers.</p><p>The word <code>CEI</code>L is short for <code>CEILING</code>.</p><p>The purpose of the Oracle <code>FLOOR</code> function is to return the highest integer value that is equal to or less than a number. It basically <strong>rounds down to a whole number</strong>.</p><p>It’s the opposite of the <code>CEILING</code> function, and is often used as an alternative to <code>ROUND</code>.</p><p><code>CEIL</code> returns the smallest integer greater than or equal to <code>n</code>.</p><p>This function takes as an argument any numeric datatype or any non-numeric datatype that can be implicitly converted to a numeric datatype. The function returns the same datatype as the numeric datatype of the argument.</p><p><br></p><p>The <strong>Oracle/PLSQL FLOOR </strong>function returns the largest integer value that is equal to or less than a <em>number</em>.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\nCEIL(41.8) AS ceil_test,\nFLOOR(41.8) AS floor_test\nFROM dual;\n\nCEIL Result: 42\nFLOOR Result: 41</pre><p><br></p><p><strong>CEIL: can be used for positive and negative numbers</strong></p><p><strong>CEIL: returns the smallest integer greater than or equal to a specified number</strong></p><p><strong>FLOOR: returns the largest integer less than or equal to a specified number</strong></p><p><br></p><p>The <code>TRUNC</code> (date) function returns a <code>date</code> with the time portion of the day truncated to the unit specified by the format model <code>fmt</code>. The value returned is always of the datatype <code>DATE</code>, even if you specify a different datetime datatype for <code>date</code>. If you omit <code>fmt</code>, then the <code>date</code> is truncated to the nearest day.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions200.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions200.htm</a></p><p><br></p><p>The <code>TRUNC</code> (number) function returns <code>n1</code> truncated to <code>n2</code> decimal places. If <code>n2</code> is omitted, then <code>n1</code> is truncated to 0 places. <code>n2</code> can be negative to truncate (make zero) <code>n2</code> digits left of the decimal point.</p><p>This function takes as an argument any numeric datatype or any non-numeric datatype that can be implicitly converted to a numeric datatype. If you omit <code>n2</code>, then the function returns the same datatype as the numeric datatype of the argument. If you include <code>n2</code>, then the function returns <code>NUMBER</code>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions200.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions200.htm</a></p><p><br></p><p><strong>TRUNC: can be used with NUMBER and DATE values</strong></p><p><code>CONCAT</code> returns <code>char1</code> concatenated with <code>char2</code>. Both <code>char1</code> and <code>char2</code> can be any of the datatypes <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is in the same character set as <code>char1</code>. Its datatype depends on the datatypes of the arguments.</p><p>In concatenations of two different datatypes, Oracle Database returns the datatype that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national datatype, then the returned value is a national datatype. For example:</p><p><code>CONCAT(CLOB, NCLOB)</code> returns <code>NCLOB</code></p><p><code>CONCAT(NCLOB, NCHAR)</code> returns <code>NCLOB</code></p><p><code>CONCAT(NCLOB, CHAR)</code> returns <code>NCLOB</code></p><p><code>CONCAT(NCHAR, CLOB)</code> returns <code>NCLOB</code></p><p>This function is equivalent to the concatenation operator <code>||</code>.</p><p>The result of concatenating two character strings is another character string. If both character strings are of datatype <code>CHAR</code>, the result has datatype <code>CHAR</code> and is limited to 2000 characters. If either string is of datatype <code>VARCHAR2</code>, the result has datatype <code>VARCHAR2</code> and is limited to 4000 characters. If either argument is a <code>CLOB</code>, the result is a temporary <code>CLOB</code>. Trailing blanks in character strings are preserved by concatenation, regardless of the datatypes of the string or <code>CLOB</code>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators003.htm#i997789\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators003.htm#i997789</a></p><p><br></p><p><strong>CONCAT: CANNOT be used to combine any number of values</strong></p><p><br></p><p><strong>Definition of <em>modulo</em></strong></p><p><strong><em>Modulo</em></strong>, often abbreviated “mod,” is a mathematical operation. It’s like a division problem, except that the answer is the remainder of an integer division operation, rather than a decimal result.</p><p><a href=\"https://www.quora.com/What-is-a-MOD-in-mathematics?share=1\">https://www.quora.com/What-is-a-MOD-in-mathematics?share=1</a></p><p><code>MOD</code> returns the remainder of <code>n2</code> divided by <code>n1</code>. Returns <code>n2</code> if <code>n1</code> is 0.</p><p>This function takes as arguments any numeric datatype or any non-numeric datatype that can be implicitly converted to a numeric datatype. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that datatype, and returns that datatype.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions088.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions088.htm</a></p><p>The result of concatenating two character strings is another character string. If both character strings are of datatype <code>CHAR</code>, the result has datatype <code>CHAR</code> and is limited to 2000 characters. If either string is of datatype <code>VARCHAR2</code>, the result has datatype <code>VARCHAR2</code> and is limited to 4000 characters. If either argument is a <code>CLOB</code>, the result is a temporary <code>CLOB</code>. Trailing blanks in character strings are preserved by concatenation, regardless of the datatypes of the string or <code>CLOB</code>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators003.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators003.htm</a></p><p><strong>Definition of <em>quotient</em></strong></p><p>The answer is obtained after we divide one number by another.</p><p>dividend ÷ divisor = quotient.</p><p>Example: in <strong>12 ÷ 3 = 4</strong>, 4 is the quotient.</p><p><a href=\"https://www.mathsisfun.com/definitions/quotient.html\">https://www.mathsisfun.com/definitions/quotient.html</a></p><p><br></p><p><code>MOD</code> returns the remainder of <code>n2</code> divided by <code>n1</code>. Returns <code>n2</code> if <code>n1</code> is 0.</p><p>This function takes as arguments any numeric datatype or any non-numeric datatype that can be implicitly converted to a numeric datatype. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that datatype, and returns that datatype.</p><p><strong>Consider:</strong></p><pre class=\"prettyprint linenums\">SELECT MOD(11,4) \"Modulus\" FROM DUAL;\n\n   Modulus\n----------\n         3</pre><p>The solution is 11 ÷ 4 = 2, remainder 3, so the output of the query is 3.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions088.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions088.htm</a></p><p><br></p><p><strong>MOD: DOES NOT return the quotient of a division operation; it returns the remainder.</strong></p>",
                "answers": [
                    "<p>CEIL: can be used for positive and negative numbers</p>",
                    "<p>FLOOR: returns the smallest integer greater than or equal to a specified number</p>",
                    "<p>TRUNC: can be used with NUMBER and DATE values</p>",
                    "<p>CONCAT: can be used to combine any number of values</p>",
                    "<p>MOD: returns the remainder of a division operation</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "e"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the statements about single-row functions (Choose three).",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306079,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS</strong></p><pre class=\"prettyprint linenums\">Name                   Null??            Type\nCUSTNO                 NOT NULL          NUMBER(3)\nCUSTNAME               NOT NULL          VARCHAR2(25)\nCUSTADDRESS                              VARCHAR2(35)\nCUST_CREDIT_LIMIT                        NUMBER(5)</pre><p><br></p><p><strong>Given: </strong> CUSTNO is the PRIMARY KEY.&nbsp; </p><p><strong>Required: </strong>Determine if any customers' details have been entered more than once using a different CUSTNO, by listing all duplicate names.&nbsp; </p><p>Identify the methods that can be used to get the required result. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[How to Find Duplicate Records in Oracle](https://www.oracletutorial.com/advanced-oracle-sql/find-duplicate-records-oracle/)",
                    "[What is Self Join in Oracle?](https://www.w3resource.com/oracle/joins/oracle-self-join.php)"
                ],
                "feedbacks": [
                    "Using a subquery, you can create a query that retrieves all duplicate names by comparing the CUSTOMERS table with itself based on the customer's name. This method allows you to filter out the duplicate entries efficiently.",
                    "A self-join involves joining a table to itself based on a related column, in this case, the customer's name. By performing a self-join on the CUSTOMERS table, you can identify all instances where the same customer details have been entered more than once with different CUSTNO values.",
                    "A full outer-join with a self-join is not the most suitable method for identifying duplicate customer details in this scenario. A full outer-join would return all records from both sides of the join, which may not be necessary when looking for specific duplicate entries.",
                    "A left outer-join with a self-join is not the most efficient method for identifying duplicate customer details in this case. A left outer-join would return all records from the left table (CUSTOMERS) and matching records from the right table, potentially including unnecessary data.",
                    "A right outer-join with a self-join is not the optimal approach for identifying duplicate customer details in this context. A right outer-join would return all records from the right table and matching records from the left table, which may not be the most effective way to isolate duplicate entries."
                ],
                "explanation": "<p><strong>Correct Methods:</strong></p><ol><li><p><strong>Subquery</strong><br>→ You can write a <strong>subquery</strong> that counts the number of times each <code>CUSTNAME</code> appears and filter those with a <strong>count &gt; 1</strong>.</p><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT custname\nFROM customers\nGROUP BY custname\nHAVING COUNT(*) &gt; 1;\n</pre></li><li><p><strong>Self-join</strong><br>→ You can join the <code>CUSTOMERS</code> table to itself on <code>CUSTNAME</code>, but make sure the <code>CUSTNO</code> values are different.</p><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT c1.custname\nFROM customers c1, customers c2\nWHERE c1.custname = c2.custname\n  AND c1.custno &lt;&gt; c2.custno;\n</pre></li></ol><p><strong>Incorrect Methods:</strong></p><ul><li><p><strong>Full outer-join with self-join</strong><br>→ Overkill here and unnecessary; the goal is to find duplicates, not combine all rows.</p></li><li><p><strong>Left outer-join with self-join</strong><br>→ Not needed — left outer joins are used to find <strong>non-matching</strong> records, which isn't our goal.</p></li><li><p><strong>Right outer-join with self-join</strong><br>→ Same as above — not suitable for finding duplicates.</p></li></ul><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-15_00-52-33-32893c6ca11e421b0320c337d68302bd.png\"></p><p><br></p><p><strong>Finding duplicate rows using the aggregate function</strong></p><p>To find duplicate rows from the table, you first list the customer name and address columns in both the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\"><code>GROUP BY</code></a> clauses. Then you count the number of appearances each combination appears with the <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/\"><code>COUNT(*)</code></a> function, as shown below.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT \n    custname,\n    custaddress,\n    COUNT(*)\nFROM \n    customers\nGROUP BY \n    custname,\n    custaddress;</pre><p><br></p><p><strong>Finding duplicate records using a SELF JOIN</strong></p><p>A self-join is a join in which a table is joined with itself.</p><p>To join a table itself means that each row of the table is combined with itself and with every other row of the table.</p><p>The table appears twice in the <code>FROM</code> clause and is followed by table aliases that qualify column names in the join condition.</p><p>The self-join can be viewed as a join of two copies of the same table. The table is not actually copied, but SQL performs the command as though it were.</p><p>To perform a self-join, Oracle Database combines and returns rows of the table that satisfy the join condition</p><p><br></p><pre class=\"prettyprint linenums\">SELECT c1.custno,c1.custname,c1.custaddress\nFROM customers c1, customers c2 \nWHERE c1.custname = c2.custname \nAND c1.custaddress = c2.custaddress \nAND&nbsp;c1.custno != c2.custno \nORDER BY custno;</pre>",
                "answers": [
                    "<p>Subquery</p>",
                    "<p>Self-join</p>",
                    "<p>Full outer-join with self-join</p>",
                    "<p>Left outer-join with self-join</p>",
                    "<p>Right outer-join with self-join</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Table: CUSTOMERSName                   Null??            Type\nCUSTNO                 NOT NULL          NUMBER(3)\nCUSTNAME               NOT NULL          VARCHAR2(25)\nCUSTADDRESS                              VARCHAR2(35)\nCUST_CREDIT_LIMIT                        NUMBER(5)Given:  CUSTNO is the PRIMARY KEY.&nbsp; Required: Determine if any customers' details have been entered more than once using a different CUSTNO, by listing all duplicate names.&nbsp; Identify the methods that can be used to get the required result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306081,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the SALES, CUSTOMERS, PRODUCTS, and TIMES tables as well as the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-14-07-2ffd98b287cb6506f667cf89125c3e72.png\"></p><p><br></p><p><strong>Given: </strong>&nbsp; </p><p>• The PROD_ID column is the foreign key in the SALES table referencing the PRODUCTS table.</p><p>• The CUST_ID and TIME_ID columns are also foreign keys in the SALES table referencing the CUSTOMERS and TIMES tables, respectively.&nbsp; </p><p><br></p><p>Examine this command.</p><p><br></p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">CREATE TABLE new_sales (prod_id, cust_id, order_date DEFAULT&nbsp;SYSDATE)\nAS\nSELECT prod_id, cust_id, time_id\nFROM&nbsp;sales;</pre><p><br></p><p>Identify the true statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL: CREATE TABLE AS Statement](https://www.techonthenet.com/sql/tables/create_table2.php)"
                ],
                "feedbacks": [
                    "The statement does not mention anything about FOREIGN KEY constraints or their creation in the NEW_SALES table. It focuses on the creation of the table and the constraints related to column names matching.",
                    "This statement is incorrect because the column names not matching between the CREATE TABLE command and the SELECT clause would not prevent the creation of the NEW_SALES table. It might affect the data mapping, but it would not prevent the table creation.",
                    "The statement is incorrect because specifying a DEFAULT value in the column definition does not prevent the creation of a table. It might affect the data integrity, but it is not a constraint that would prevent table creation.",
                    "This statement is correct because it correctly states that the NEW_SALES table would be created, and the NOT NULL constraints defined on the selected columns from the SALES table would be created on the corresponding columns in the NEW_SALES table. This ensures data integrity by enforcing the presence of values in those columns."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><p><em>The NEW_SALES table would be created, and all the NOT NULL constraints defined on the selected columns from the SALES table would be created on the corresponding columns in the NEW_SALES table.</em></p><p>Here's why:</p><ul><li><p>The statement:</p><pre class=\"prettyprint linenums\">sql\nCREATE TABLE new_sales (prod_id, cust_id, order_date DEFAULT SYSDATE)\nAS\nSELECT prod_id, cust_id, time_id\nFROM sales;</pre><p><strong>does create the table</strong> using a <code>CREATE TABLE AS SELECT</code> (CTAS) statement.</p></li><li><p>The third column in the <code>SELECT</code> clause is <code>time_id</code>, but in the <code>CREATE</code> clause, it's being <strong>aliased as </strong><code><strong>order_date</strong></code> and assigned a <strong>default value of SYSDATE</strong> — and this is <strong>allowed</strong> in Oracle 12c+.</p></li><li><p>In a CTAS operation:</p><ul><li><p><strong>NOT NULL constraints are preserved</strong> if present in the source table.</p></li><li><p><strong>DEFAULT values can be specified in the column definitions</strong> of the new table.</p></li><li><p><strong>Foreign keys and other constraints (like primary keys, unique, and checks)</strong> are <strong>not inherited</strong>.</p></li></ul></li></ul><p>Why are the other options wrong:</p><ul><li><p><strong>Foreign key constraints are NOT copied</strong> in a CTAS statement. They must be redefined manually.</p></li><li><p>The <strong>column names don't need to match</strong> in CTAS. The structure in the <code>CREATE</code> clause can override the <code>SELECT</code> clause.</p></li><li><p>You <strong>can specify a DEFAULT</strong> in the <code>CREATE TABLE</code> definition even with CTAS (in Oracle 12c and later).</p></li></ul><p><br></p><p><strong>In this case, only NOT NULL constraints are carried over when doing a CREATE TABLE ... SELECT.</strong></p><p>You use the SQL <code>CREATE TABLE AS</code> statement to create a table from an existing table by copying the existing table's columns.</p><p>It is important to note that when creating a table in this way, the new table will be populated with the records from the existing table (based on the<a href=\"https://www.techonthenet.com/sql/select.php\"> SELECT Statement</a>).</p><p><br></p><p><strong>Create Table - By copying all columns from another table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the CREATE TABLE AS statement when copying all of the columns in SQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT * FROM old_table);</pre><p><br></p><p><strong>Create Table - By copying selected columns from another table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the CREATE TABLE AS statement, copying the selected columns, is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT column_1, column2, ... column_n\n      FROM old_table);</pre><p><br></p><p><strong>Create Table - By copying selected columns from another table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the CREATE TABLE AS statement, copying the selected columns, is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT column_1, column2, ... column_n\n      FROM old_table);</pre><p><br></p><p><strong>Create Table - By copying selected columns from multiple tables</strong></p><p><strong>Syntax</strong></p><p>The syntax for the CREATE TABLE AS statement copying columns from multiple tables is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT column_1, column2, ... column_n\n      FROM old_table_1, old_table_2, ... old_table_n);</pre><p><br></p><p><strong>Create Table - By copying selected columns from another table without copying any values from the old table</strong></p><p><strong>Syntax</strong></p><p>The syntax for the CREATE TABLE AS statement without copying any values from the old table when copying all of the columns in SQL is:</p><pre class=\"prettyprint linenums\">CREATE TABLE new_table\n  AS (SELECT *\n      FROM old_table WHERE 1=2);</pre>",
                "answers": [
                    "<p>The NEW_SALES table would be created and all the FOREIGN KEY constraints defined on the selected columns from the SALES table would be created on the corresponding columns in the NEW_SALES table.</p>",
                    "<p>The NEW_SALES table would not be created because the column names in the CREATE TABLE command and the SELECT clause do not match.</p>",
                    "<p>The NEW_SALES table would not be created because the DEFAULT value cannot be specified in the column definition.</p>",
                    "<p>The NEW_SALES table would be created and all the NOT NULL constraints defined on the selected columns from the SALES table would be created on the corresponding columns in the NEW_SALES table.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the SALES, CUSTOMERS, PRODUCTS, and TIMES tables as well as the exhibit.Given: &nbsp; • The PROD_ID column is the foreign key in the SALES table referencing the PRODUCTS table.• The CUST_ID and TIME_ID columns are also foreign keys in the SALES table referencing the CUSTOMERS and TIMES tables, respectively.&nbsp; Examine this command.Exhibit: 1 CREATE TABLE new_sales (prod_id, cust_id, order_date DEFAULT&nbsp;SYSDATE)\nAS\nSELECT prod_id, cust_id, time_id\nFROM&nbsp;sales;Identify the true statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306083,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given: </strong>The BOOKS_TRANSACTIONS table exists in your schema in this database. </p><p>The following&nbsp; SQL statement has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT *\nFROM books_transactions ORDER&nbsp;BY 3;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What does clause order by 1,2,3 means in sql query ?](https://community.oracle.com/thread/496341)"
                ],
                "feedbacks": [
                    "The ORDER BY clause in SQL requires specifying either a column name or an expression that evaluates to a column in the table. Using a numeral like 3 directly in the ORDER BY clause is not valid syntax and would result in a query execution failure.",
                    "When the ORDER BY clause specifies a numeral like 3, it refers to the position of the column in the SELECT statement. In this case, the third column in the SELECT statement is used for sorting the table rows in ascending order based on the values in that column.",
                    "The default behavior of SQL queries is to return rows in the order they are stored in the table. Without an explicit ORDER BY clause, the database engine may return rows in the order they were inserted, which may not necessarily be the same as the order of the rows displayed in the table.",
                    "If the query includes an ORDER BY clause with a LIMIT or FETCH FIRST clause, it will only return the specified number of rows based on the sorting criteria. In this case, only the three rows with the lowest values in the key column will be displayed in ascending order."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><p><strong>All table rows are displayed sorted in ascending order of the values in the third column.</strong></p><p><br></p><p>In the SQL statement:</p><pre class=\"prettyprint linenums\">sql\nSELECT *  \nFROM books_transactions  \nORDER BY 3;</pre><ul><li><p>The number <code><strong>3</strong></code> in the <code>ORDER BY</code> clause refers to the <strong>third column</strong> in the <code>SELECT</code> list — <strong>not</strong> a limit on how many rows are returned.</p></li><li><p>Since <code>SELECT *</code> is used, all columns from the <code>BOOKS_TRANSACTIONS</code> table are returned, and the result is <strong>sorted by the values in the third column</strong> in <strong>ascending</strong> order by default.</p></li></ul><p>Why are the other options incorrect:</p><ul><li><p><strong>“The execution fails unless the numeral 3... is replaced...”</strong> → Incorrect. Using a <strong>column position</strong> like <code>ORDER BY 3</code> is <strong>valid SQL syntax</strong>.</p></li><li><p><strong>“The first three rows... are displayed...”</strong> → Incorrect. There's <strong>no row limit</strong> in this query.</p></li><li><p><strong>“Only the three rows with the lowest values...”</strong> → Also incorrect. Again, no row filtering or limiting.</p></li></ul>",
                "answers": [
                    "<p>The execution fails unless the numeral 3 in the ORDER BY clause is replaced by a column name.</p>",
                    "<p>All table rows are displayed sorted in ascending order of the values in the third column.</p>",
                    "<p>The first three rows in the table are displayed in the order that they are stored.</p>",
                    "<p>Only the three rows with the lowest values in the key column are displayed in the order that they are stored.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario.Given: The BOOKS_TRANSACTIONS table exists in your schema in this database. The following&nbsp; SQL statement has been executed.Exhibit: 1SELECT *\nFROM books_transactions ORDER&nbsp;BY 3;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306085,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about inner and outer joins. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Multiple FULL OUTER JOIN on multiple tables](https://stackoverflow.com/questions/16167902/multiple-full-outer-join-on-multiple-tables)",
                    "[Oracle FULL OUTER JOIN](https://www.w3resource.com/oracle/joins/oracle-full-outer-join.php)",
                    "[Oracle INNER JOIN](https://www.oracletutorial.com/oracle-basics/oracle-inner-join/)"
                ],
                "feedbacks": [
                    "Outer joins can indeed be used when there are multiple join conditions on two tables. This allows for more flexibility in joining tables based on different criteria.",
                    "Outer joins are not limited to only two tables; they can be used between two or more tables per query. This allows for joining multiple tables and handling unmatched rows accordingly.",
                    "A full outer join does return both matched and unmatched rows from the tables being joined. This type of join ensures that all rows from both tables are included in the result set.",
                    "An inner join specifically returns only the matched rows between the tables being joined. This type of join is used to retrieve data that exists in both tables based on the specified join condition.",
                    "The statement that a full outer join must use Oracle syntax is incorrect. Full outer joins can be implemented using standard SQL syntax and are not limited to Oracle-specific syntax.",
                    "The statement that a left or right outer join returns only unmatched rows is incorrect. Left and right outer joins return all rows from one table (left or right) along with matching rows from the other table, including unmatched rows with NULL values."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ol><li><p><strong>A full outer join returns matched and unmatched rows.</strong></p><ul><li><p>This is correct. A full outer join returns <strong>all rows</strong> from both tables — matched <strong>and</strong> unmatched. If there's no match, NULLs are shown for missing values.</p></li></ul></li><li><p><strong>An inner join returns matched rows.</strong></p><ul><li><p>This is also true. An inner join returns <strong>only the rows where there's a match</strong> between the join condition(s).</p></li></ul></li><li><p><strong>Outer joins can be used when there are multiple join conditions on two tables.</strong></p><ul><li><p>Yes, you <strong>can use outer joins</strong> with <strong>multiple conditions</strong> using either ANSI or Oracle syntax.</p></li></ul></li></ol><p><strong>False Statements:</strong></p><ul><li><p><strong>Outer joins can only be used between two specific tables per query.</strong></p><ul><li><p>Incorrect. Outer joins can be used in joins involving <strong>more than two tables</strong>.</p></li></ul></li><li><p><strong>A full outer join must use Oracle syntax.</strong></p><ul><li><p>Incorrect. In modern Oracle SQL, <strong>ANSI syntax</strong> (e.g., <code>FULL OUTER JOIN</code>) is <strong>preferred and standard</strong>. Oracle’s <strong>old-style syntax (</strong><code><strong>(+)</strong></code><strong>) does not support full outer joins</strong>.</p></li></ul></li><li><p><strong>A left or right outer join returns only unmatched rows.</strong></p><ul><li><p>Wrong. Left/right outer joins return <strong>both matched and unmatched</strong> rows from the <strong>left or right table</strong>, respectively.</p></li></ul></li></ul><p><strong>Oracle join</strong></p><p>Oracle join is used to combine columns from two or more tables based on the values of the related columns. The related columns are typically the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-primary-key/\">primary key</a> column(s) of the first table and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-foreign-key/\">foreign key</a> column(s) of the second table.</p><p>Oracle supports <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">inner join</a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-left-join/\">left join</a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-right-join/\">right join</a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-full-outer-join/\">full outer join</a>, and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-cross-join/\">cross join</a>.</p><p>Note that you can join a table to itself to query hierarchical data using an inner join, left join, or right join. This kind of join is known as a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-self-join/\">self-join</a>.</p><p>Outer Joins and Inner Joins work fine for Self Join<br><br><strong>LEFT OUTER JOIN</strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-21_01-38-03-403a68348f07d61dd06e2c182e340221.png\"></p><p><br></p><p><strong>INNER JOIN</strong></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-21_01-38-19-18b2c8757f927074bb08e50078881ca1.png\"></p><p>A full outer join returns matched and unmatched rows.</p><p>A full outer join performs a join between two tables that returns the results of an INNER join as well as the results of a left and right outer join. In other words, everything is returned combined.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-15_23-30-48-ca93445bdce34c7b448039498bffdbc3.png\"></p><p><br></p><p><br></p><p>An inner join returns matched rows.</p><p>The <code>INNER JOIN</code> clause is used to retrieve rows from a table that have matching rows from other tables. If they do not match, they are not returned.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-15_23-32-37-ba6788d8bd0d90bc601983b8760846bd.png\"></p><p><br></p>",
                "answers": [
                    "<p>Outer joins can be used when there are multiple join conditions on two tables.</p>",
                    "<p>Outer joins can only be used between two specific tables per query.</p>",
                    "<p>A full outer join returns matched and unmatched rows.</p>",
                    "<p>An inner join returns matched rows.</p>",
                    "<p>A full outer join must use Oracle syntax.</p>",
                    "<p>A left or right outer join returns only unmatched rows.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about inner and outer joins. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306087,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(30)\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBER</pre><p> </p><p><strong>Required:</strong> Write a query that does the following tasks: </p><ul><li><p>Display the first name and tax amount of the customers. Tax is 5% of their credit limit. </p></li><li><p>Only those customers whose income level has a value should be considered. </p></li><li><p>Customers whose tax amount is null should not be considered.&nbsp; </p></li></ul><p>Identify the response that would meet the requirements.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This query calculates the tax amount correctly as 5% of the credit limit, but it checks for the presence of the tax amount using the wrong column name 'tax_amount' instead of 'cust_credit_limit * .05'.",
                    "This query correctly calculates the tax amount as 5% of the credit limit and checks for both the income level and credit limit to be not null. It meets all the requirements specified in the question.",
                    "This query calculates the tax amount correctly but uses the wrong comparison operator '&lt;&gt;' for checking null values. The correct operator to check for null values is 'IS NULL'.",
                    "This query incorrectly uses a single condition to check if both 'cust_income_level' and 'tax_amount' are not null. It should have separate conditions to check the null values of each column individually."
                ],
                "explanation": "<p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit * .05 AS TAX_AMOUNT \nFROM customers \nWHERE cust_income_level IS NOT NULL  \nAND cust_credit_limit IS NOT NULL;</pre><p><br></p><p><strong>Requirements:</strong></p><ol><li><p><strong>Show first name and tax</strong> (5% of credit limit) → Done with <code>cust_credit_limit * .05 AS TAX_AMOUNT</code></p></li><li><p><strong>Only consider rows where </strong><code><strong>cust_income_level</strong></code><strong> has a value</strong> → Use <code>cust_income_level IS NOT NULL</code></p></li><li><p><strong>Exclude rows where tax is NULL</strong> → Since tax is derived from <code>cust_credit_limit</code>, we check that <code>cust_credit_limit IS NOT NULL</code></p></li></ol><p> <strong>Why the others are wrong:</strong></p><ol><li><pre class=\"prettyprint linenums\">sql\nWHERE cust_income_level IS NOT NULL  \nAND tax_amount IS NOT NULL;\n</pre><ul><li><p><code>tax_amount</code> is an <strong>alias</strong> in the SELECT clause, and <strong>can't be used</strong> directly in the WHERE clause.</p><p><br></p></li></ul></li><li><pre class=\"prettyprint linenums\">sql\nWHERE cust_income_level &lt;&gt; NULL  \nAND tax_amount &lt;&gt; NULL;</pre><ul><li><p>&lt;&gt; NULL is invalid in SQL. You must use IS NOT NULL.</p><p><br></p></li></ul></li><li><pre class=\"prettyprint linenums\">sql\nWHERE (cust_income_level, tax_amount) IS NOT NULL;</pre><p>SQL doesn't support <code>IS NOT NULL</code> for row value constructors like <code>(col1, col2)</code>.</p></li></ol><p><br></p><p>Let's review what is being asked for. The colour coding and arrows show where the requirements have been satisfied in the query.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-16_00-11-37-26f85bb849c8646f205574cdf096947f.png\"></p><p>If cust_credit_limit were NULL, no tax_amount could have been calculated; cust_credit_limit has to be NOT NULL.</p><p>Also, we cannot use tax_amount in the WHERE clause. Tax_amount is calculated based on cust_credit_limit, which is a derived field. In other words, you cannot use aliases in the WHERE clause.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit * .05 AS TAX_AMOUNT \nFROM customers \nWHERE cust_income_level IS NOT NULL&nbsp; \nAND tax_amount IS NOT NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit * .05 AS TAX_AMOUNT \nFROM customers \nWHERE cust_income_level IS NOT NULL&nbsp; \nAND cust_credit_limit IS NOT NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit * .05 AS TAX_AMOUNT \nFROM customers \nWHERE cust_income_level &lt;&gt; NULL&nbsp; \nAND tax_amount &lt;&gt; NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT cust_first_name, cust_credit_limit * .05 AS TAX_AMOUNT \nFROM customers \nWHERE (cust_income_level, tax_amount) IS NOT NULL;</pre>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the CUSTOMERS table.Table: CUSTOMERS Name                    Null??            Type\nCUST_ID                 NOT NULL          NUMBER\nCUST_FIRST_NAME         NOT NULL          VARCHAR2(20)\nCUST_LAST_NAME          NOT NULL          VARCHAR2(30)\nCUST_INCOME_LEVEL                         VARCHAR2(30)\nCUST_CREDIT_LIMIT                         NUMBER Required: Write a query that does the following tasks: Display the first name and tax amount of the customers. Tax is 5% of their credit limit. Only those customers whose income level has a value should be considered. Customers whose tax amount is null should not be considered.&nbsp; Identify the response that would meet the requirements.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305987,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT 1 AS id, 'John' AS first_name\nFROM dual\nUNION\nSELECT 1, 'John' AS name\nFROM dual\nORDER&nbsp;BY 1;</pre><p><br></p><p>Identify the result of the query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query in the SQL exhibit is valid and should return a result. Therefore, the choice stating 0 rows is incorrect.",
                    "There is no indication in the SQL exhibit that would result in an error. The query is syntactically correct, so the choice stating an error is incorrect.",
                    "The SQL exhibit shows a query that should return a result. Since the query is valid and properly structured, the choice stating 1 row is correct.",
                    "Based on the SQL exhibit provided, the query should not return 2 rows. Therefore, the choice stating 2 rows is incorrect."
                ],
                "explanation": "<p><strong>Correct Answer:</strong> 1 row</p><p>Let's break it down:</p><p><strong>Query:</strong></p><pre class=\"prettyprint linenums\">SELECT 1 AS id, 'John' AS first_name\nFROM dual\nUNION\nSELECT 1, 'John' AS name\nFROM dual\nORDER&nbsp;BY 1;</pre><p><br></p><p><strong>Key Points:</strong></p><ol><li><p>Both <code>SELECT</code> statements return:</p><ul><li><p><code>1</code> as the first column (named <code>id</code>)</p></li><li><p><code>'John'</code> as the second column (with different aliases: <code>first_name</code> and <code>name</code>)</p></li></ul></li><li><p>The <code>UNION</code> operator:</p><ul><li><p>Removes <strong>duplicate rows</strong></p></li><li><p>Looks at <strong>values</strong>, not aliases</p></li></ul><pre class=\"prettyprint linenums\">sql\n(1, 'John')  -- First row\n(1, 'John')  -- Second row\n</pre><p>➜ These are <strong>identical rows</strong>, so <code>UNION</code> keeps <strong>only one</strong>.</p></li><li><p><code>ORDER BY 1</code>:</p><ul><li><p>Orders the result by the first column (<code>id</code>) — no issue here</p></li></ul></li></ol><p>Final Result:</p><ul><li><p><strong>Only 1 row</strong> is returned (because of the <code>UNION</code> removing duplicates)</p></li><li><p>No syntax errors</p></li><li><p>Runs successfully</p></li></ul>",
                "answers": [
                    "<p>0 rows</p>",
                    "<p>An error</p>",
                    "<p>1 row</p>",
                    "<p>2 rows</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1SELECT 1 AS id, 'John' AS first_name\nFROM dual\nUNION\nSELECT 1, 'John' AS name\nFROM dual\nORDER&nbsp;BY 1;Identify the result of the query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305989,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statement that correctly grants a system privilege.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[System privileges](https://docs.oracle.com/cd/E11882_01/timesten.112/e21642/privileges.htm#TTSQL339)"
                ],
                "feedbacks": [
                    "The statement \"GRANT CREATE VIEW ON table1 TO user1;\" grants the privilege to create views on a specific table named table1 to a user named user1. This statement does not grant a system privilege, but rather a specific object privilege.",
                    "<p>The statement \"GRANT ALTER ON&nbsp;table_name TO PUBLIC;\" grants the privilege to alter tables to all users in the database, as PUBLIC includes all users. This statement grants a table-level privilege, not a system privilege.</p>",
                    "The statement \"GRANT CREATE TABLE TO user1,user2;\" correctly grants the system privilege to create tables to users user1 and user2. This statement provides the ability to create tables in the database, which is a system-level privilege.",
                    "The statement \"GRANT CREATE SESSION TO ALL;\" grants the privilege to create a session to all users in the database. This statement does not grant a system privilege, but rather a database-level privilege that allows users to connect to the database."
                ],
                "explanation": "<p><strong>Correct Statement: </strong> <code><strong>GRANT CREATE TABLE TO user1, user2;</strong></code></p><p><code>CREATE TABLE</code> is a <strong>system privilege</strong>.</p><ul><li><p>This syntax correctly grants it to <strong>multiple users</strong>.</p></li><li><p>Fully valid.</p></li></ul><p><strong>Incorrect Options:</strong></p><p><code>GRANT CREATE VIEW ON table1 TO user1;</code></p><ul><li><p><strong>Incorrect</strong>:</p><ul><li><p><code>CREATE VIEW</code> is a <strong>system privilege</strong>, not an <strong>object privilege</strong>.</p></li><li><p>You do <strong>not</strong> specify <code>ON table1</code> with system privileges.</p></li><li><p>Correct form: <code>GRANT CREATE VIEW TO user1;</code></p></li></ul></li></ul><p><code>GRANT ALTER TABLE TO PUBLIC;</code></p><ul><li><p><strong>Incorrect</strong>:</p><ul><li><p><code>ALTER TABLE</code> is <strong>not</strong> a standalone system privilege.</p></li><li><p><code>ALTER</code> is typically used as an <strong>object privilege</strong>, e.g., <code>GRANT ALTER ON table1 TO user1;</code></p></li><li><p>Also, granting such privileges to <code>PUBLIC</code> is risky and uncommon.</p></li></ul></li></ul><p><code>GRANT CREATE SESSION TO ALL;</code></p><ul><li><p><strong>Incorrect</strong>:</p><ul><li><p><code>ALL</code> is <strong>not</strong> a valid keyword for granting privileges.</p></li><li><p>Use specific usernames or the keyword <code>PUBLIC</code>.</p></li></ul></li></ul><p>A system privilege is the right to perform a particular action or to perform an action on any object of a particular type. Objects include tables, views, materialized views, synonyms, indexes, sequences, cache groups, replication schemes, and PL/SQL functions, procedures, and packages. Only the instance administrator or a user with <code>ADMIN</code> privilege can grant or revoke system privileges.</p><p><br></p><p><strong>Both </strong><code><strong>CREATE TABLE</strong></code><strong> and </strong><code><strong>CREATE ANY TABLE</strong></code><strong> are system privileges.</strong></p><p><code>CREATE TABLE</code></p><ul><li><p>Enables a user to create a table owned by that user.</p></li></ul><p><code>CREATE ANY TABLE</code></p><ul><li><p>Enables a user to create a table owned by any user in the database.</p></li></ul><p>The difference is that <code>CREATE TABLE</code> allows creation of tables in the user's own schema, whereas <code>CREATE ANY TABLE</code> allows creation of tables in other users' schemas too.</p>",
                "answers": [
                    "<p><code>GRANT CREATE VIEW ON table1 TO user1;</code> </p>",
                    "<p><code>GRANT ALTER TABLE TO PUBLIC;</code> </p>",
                    "<p><code>GRANT CREATE TABLE TO user1,user2;</code> </p>",
                    "<p><code>GRANT CREATE SESSION TO ALL;</code> </p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "System privileges",
            "question_plain": "View and examine the following available responses.Identify the statement that correctly grants a system privilege.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305991,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required: </strong>You are designing the structure of a table in which two columns have the specifications.</p><ol><li><p>COMPONENT_ID - must be able to contain a maximum of 12 alphanumeric characters and must uniquely identify the row.</p></li><li><p>EXECUTION_DATETIME - contains Century, Year, Month, Day, Hour, Minute, Second to the maximum precision and is used for calculations and comparisons between components.&nbsp; </p></li></ol><p>Identify the options that define the data types that satisfy these requirements most efficiently. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Built-in Data Types](https://docs.oracle.com/database/121/SQLRF/sql_elements001.htm#SQLRF30020)"
                ],
                "feedbacks": [
                    "The INTERVAL DAY TO SECOND data type is not suitable for the EXECUTION_DATETIME column as it does not provide the required precision for Century, Year, Month, Day, Hour, Minute, and Second.",
                    "The TIMESTAMP data type is the most efficient choice for the EXECUTION_DATETIME column as it can store the Century, Year, Month, Day, Hour, Minute, and Second with maximum precision for calculations and comparisons.",
                    "The DATE data type is not suitable for the EXECUTION_DATETIME column as it does not provide the required precision for Century, Year, Month, Day, Hour, Minute, and Second.",
                    "The ROWID data type is not suitable for the COMPONENT_ID column as it is used to store the unique address of a row in a table, not alphanumeric characters.",
                    "The VARCHAR2 data type is the most efficient choice for the COMPONENT_ID column as it can store alphanumeric characters up to a maximum length of 12 characters and can uniquely identify the row.",
                    "The CHAR data type is not the most efficient choice for the COMPONENT_ID column as it will allocate space for the maximum length of 12 characters for every row, even if the actual data is shorter, leading to potential wasted storage space."
                ],
                "explanation": "<p><strong>Required: </strong>1. COMPONENT_ID - must be able to contain a maximum of 12 alphanumeric characters and must uniquely identify the row.</p><p><strong>√ The COMPONENT_ID must be of the VARCHAR2 data type.</strong></p><ol><li><p>The value is <strong>alphanumeric</strong> and <strong>variable in length</strong>, up to 12 characters.</p></li><li><p><code>VARCHAR2(12)</code> is ideal and <strong>space-efficient</strong> for such use cases.</p></li><li><p>Also allows for defining a <strong>PRIMARY KEY constraint</strong> to ensure uniqueness.</p></li></ol><p>While CHAR(12) and VARCHAR2(12) can define the data types, VARCHAR2(12) is most efficient, so it is the best answer for this requirement.</p><p><strong>Required: </strong>2.&nbsp; EXECUTION_DATETIME - contains Century, Year, Month, Day, Hour, Minute, Second to the maximum precision and is used for calculations and comparisons between components.&nbsp; </p><p><strong>√ The EXECUTION_DATETIME must be of TIMESTAMP data type</strong>.</p><ol><li><p>You need to store <strong>century, year, month, day, hour, minute, second</strong>—which <strong>DATE</strong> supports, but <strong>TIMESTAMP</strong> supports a <strong>more precise time</strong> (fractional seconds).</p></li><li><p><strong>Best for calculations and high-precision comparisons.</strong></p></li><li><p>Most efficient for the given precision requirement.</p></li></ol><p><strong>CHAR </strong></p><p>Fixed-length character data of length size bytes or characters. Maximum size is 2000 bytes or characters. Default and minimum size is 1 byte.</p><p><code>BYTE</code> and <code>CHAR</code> have the same semantics as for <code>VARCHAR2</code>.</p><p><strong>VARCHAR2</strong></p><p>Variable-length character string having a maximum length size bytes or characters. You must specify the size for VARCHAR2. Minimum size is 1 byte or 1 character. Maximum size is:</p><p>32767 bytes or characters if <code>MAX_STRING_SIZE = EXTENDED</code></p><p>4000 bytes or characters if <code>MAX_STRING_SIZE = STANDARD</code></p><p>CHAR(12) will always store 12 bytes regardless of the size of the input. Whereas VARCHAR2(12) will only consume bytes based on input. The question says “COMPONENT_ID – must be able to contain a maximum of 12 alphanumeric characters” – a maximum of 12, which means the minimum can be less than 12. Hence, VARCHAR2 is the correct data type.</p><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>INTERVAL DAY TO SECOND</strong></p><ul><li><p>Used for <strong>duration</strong>, not for storing exact datetime values.</p></li><li><p>Not suitable for storing the execution timestamp itself.</p></li></ul><p><strong>DATE</strong></p><ul><li><p>Can store date and time, but lacks <strong>fractional seconds</strong>—<strong>less precise</strong> than TIMESTAMP.</p></li><li><p>Might be acceptable if fractional seconds aren't needed, but the question asks for <strong>maximum precision</strong>.</p></li><li><p>Storing the EXECUTION_DATETIME as simply DATE may not satisfy the requirement. <strong>TIMESTAMP </strong>Datatype stores Date + Time to the <em>maximum precision</em>.</p></li></ul><p><strong>ROWID for COMPONENT_ID</strong></p><ul><li><p>ROWID is a <strong>physical locator</strong>, not meant for storing application-specific unique IDs.</p></li></ul><p><strong>CHAR</strong></p><ul><li><p>Fixed-length (e.g., <code>CHAR(12)</code>), which can waste space if values are shorter.</p></li><li><p><code>VARCHAR2</code> is more efficient for variable-length data.</p></li></ul>",
                "answers": [
                    "<p>The EXECUTION_DATETIME must be of INTERVAL DAY TO SECOND data type.</p>",
                    "<p>The EXECUTION_DATETIME must be of TIMESTAMP data type.</p>",
                    "<p>The EXECUTION_DATETIME must be of DATE data type.</p>",
                    "<p>The COMPONENT_ID must be of ROWID data type.</p>",
                    "<p>The COMPONENT_ID must be of VARCHAR2 data type.</p>",
                    "<p>The COMPONENT_ID column must be of CHAR data type.</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario.Required: You are designing the structure of a table in which two columns have the specifications.COMPONENT_ID - must be able to contain a maximum of 12 alphanumeric characters and must uniquely identify the row.EXECUTION_DATETIME - contains Century, Year, Month, Day, Hour, Minute, Second to the maximum precision and is used for calculations and comparisons between components.&nbsp; Identify the options that define the data types that satisfy these requirements most efficiently. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305993,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about a full outer join. (Select two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle FULL OUTER JOIN](https://www.w3resource.com/oracle/joins/oracle-full-outer-join.php)"
                ],
                "feedbacks": [
                    "A full outer join includes rows that are returned by an inner join, which means it includes rows that have matching values in both tables being joined.",
                    "This statement is incorrect. A full outer join returns both matched and unmatched rows from both tables being joined, not only unmatched rows.",
                    "A full outer join does not include rows that are returned by a Cartesian product. It combines the results of both left and right outer joins, including all rows from both tables.",
                    "This statement is true. A full outer join returns both matched and unmatched rows from both tables being joined, providing a complete view of the data from both tables.",
                    "The Oracle join operator (+) is not required to be used on both sides of the join condition in the WHERE clause for a full outer join. Full outer joins can be performed using the standard JOIN syntax in Oracle SQL."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>It includes rows that are returned by an inner join.</strong></p><ul><li><p>A full outer join combines the results of an <strong>inner join</strong> (matched rows) with <strong>unmatched rows</strong> from both tables.</p></li></ul><p><strong>It returns matched and unmatched rows from both tables being joined.</strong></p><ul><li><p>This is the <strong>definition</strong> of a full outer join.</p></li><li><p>If there's <strong>no match</strong>, the result still includes the row with <code>NULL</code> in the columns from the other table.</p></li></ul><p><strong>Incorrect Statements:</strong></p><p><strong>It returns only unmatched rows from both tables being joined.</strong></p><ul><li><p>No — it returns both <strong>matched and unmatched</strong> rows, not just unmatched ones.</p></li></ul><p><strong>It includes rows that are returned by a Cartesian product.</strong></p><ul><li><p>A Cartesian product happens when there's <strong>no join condition</strong> — unrelated to full outer joins.</p></li></ul><p><strong>The Oracle join operator (+) must be used on both sides of the join condition in the WHERE clause.</strong></p><ul><li><p>Oracle’s <strong>(+) operator</strong> is only used with <strong>left or right outer joins</strong>, not full outer joins.</p></li><li><p>Full outer joins must use <strong>ANSI SQL syntax</strong> with <code>FULL OUTER JOIN</code>.</p></li></ul><p><br></p><p><strong>FULL OUTER JOIN</strong></p><p>A <code>FULL OUTER JOIN</code> performs a join between two or more tables that returns the results of an <code>INNER JOIN</code> as well as the results of a <code>LEFT</code> and <code>RIGHT OUTER JOIN</code>. In short, it combines all rows from all tables included in the <code>JOIN</code>.</p><p><strong>Syntax:</strong></p><p><br></p><pre class=\"prettyprint linenums\">SELECT table1.column, table2.column\nFROM table1\nFULL OUTER JOIN table2\nON (table1.column = table2.column);</pre><p><br></p><p><br></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-16_22-43-26-c62390ee65cf6beeba41d749afa2ea22.png\"></p>",
                "answers": [
                    "<p>It includes rows that are returned by an inner join.</p>",
                    "<p>It returns only unmatched rows from both tables being joined.</p>",
                    "<p>It includes rows that are returned by a Cartesian product.</p>",
                    "<p>It returns matched and unmatched rows from both tables being joined.</p>",
                    "<p>The Oracle join operator (+) must be used on both sides of the join condition in the WHERE clause.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about a full outer join. (Select two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305995,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statement regarding the default behaviour of the ORDER BY clause.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ASCII Sort Order Chart](http://support.ecisolutions.com/doc-ddms/help/reportsmenu/ascii_sort_order_chart.htm)"
                ],
                "feedbacks": [
                    "In a character sort, the values are case-sensitive by default in the ORDER BY clause. This means that uppercase and lowercase letters are treated as distinct values when sorting.",
                    "NULL values are included in the sort operation by default in the ORDER BY clause. They are typically displayed either at the beginning or end of the sorted results, depending on the ASC or DESC order specified.",
                    "Only columns that are specified in the SELECT list can be used in the ORDER BY clause by default. This means that you cannot reference column aliases, expressions, or aggregate functions in the ORDER BY clause unless they are also included in the SELECT list.",
                    "Numeric values are displayed in ascending order by default in the ORDER BY clause. If you want to display them in descending order, you need to explicitly specify the DESC keyword after the column name in the ORDER BY clause."
                ],
                "explanation": "<p><strong>Correct Statement: </strong><em>In a character sort, the values are case-sensitive.</em></p><ol><li><p>Yes — by default, character sorting is <strong>case-sensitive</strong> in Oracle.</p></li><li><p>Uppercase letters (e.g., <code>'A'</code>) come <strong>before</strong> lowercase letters (e.g., <code>'a'</code>) in ASCII-based sorting.</p></li><li><p>By default, in most databases (including Oracle), character sorting is case-sensitive, meaning <strong>uppercase letters come before lowercase</strong> ones in the ASCII/Unicode sequence. So <code>'A' &lt; 'a'</code>.</p></li></ol><p><br></p><p><strong>Incorrect Options:</strong></p><p><strong>NULLs are not included in the sort operation.</strong></p><ul><li><p>NULLs <strong>are</strong> included in the sort. However, their position depends on the sort order:</p><ul><li><p><code>ORDER BY ... ASC</code>: NULLs appear <strong>last</strong> by default.</p></li><li><p><code>ORDER BY ... DESC</code>: NULLs appear <strong>first</strong> by default.</p></li><li><p>You can control this using <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p></li></ul></li></ul><p><strong>Only columns that are specified in the SELECT list can be used in the ORDER BY clause.</strong></p><ul><li><p>You can use <strong>any column</strong> from the table, even if it is <strong>not</strong> in the SELECT list, in the <code>ORDER BY</code> clause.</p></li></ul><p><strong>Numeric values are displayed in descending order if they have decimal positions.</strong></p><ul><li><p>Numeric sorting is <strong>not affected</strong> by whether numbers have decimal positions. The sort order (ascending/descending) is <strong>explicitly defined</strong> or defaults to ascending (<code>ASC</code>), regardless of decimal places.</p></li></ul><p>When you select information for sorting, it is important to understand how characters are evaluated by the system. The ASCII (American Standard Code for Information Interchange) guidelines are followed. This means internationally accepted standards for character values are used when determining sort order.</p><p>When a sort is created for a report, UPPER CASE comes before lower case. The name \"BLAKE\" prints before the customer name \"Allen\", since \"B\" precedes \"a\" in ASCII sort order.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-16_22-58-03-1f4bfb36d730c5bd4385351fd1065f20.png\"></p><p><br></p><p><strong>Incorrect Statements:</strong></p><p><strong>NULLs are not included in the sort operation.</strong></p><ul><li><p>False — <code>NULL</code> values <strong>are included</strong> in the sort, but by default:</p><ul><li><p>In <strong>ascending order</strong>, <code>NULL</code>s come <strong>last</strong>.</p></li><li><p>In <strong>descending order</strong>, <code>NULL</code>s come <strong>first</strong>.</p></li></ul></li><li><p>You can override this with <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p></li></ul><p><strong>Only columns that are specified in the SELECT list can be used in the ORDER BY clause.</strong></p><ul><li><p>False — You <strong>can use columns</strong> in <code>ORDER BY</code> even if they are <strong>not selected</strong> in the <code>SELECT</code> list.</p></li></ul><p><strong>Numeric values are displayed in descending order if they have decimal positions.</strong></p><ul><li><p>False — Sort order for numeric values is <strong>not affected</strong> by whether they have decimal places.</p></li><li><p><strong>Order is determined explicitly</strong> using <code>ASC</code> (default) or <code>DESC</code>.</p></li></ul>",
                "answers": [
                    "<p>In a character sort, the values are case-sensitive.</p>",
                    "<p>NULLs are not included in the sort operation.</p>",
                    "<p>Only columns that are specified in the SELECT list can be used in the ORDER BY clause.</p>",
                    "<p>Numeric values are displayed in descending order if they have decimal positions.</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statement regarding the default behaviour of the ORDER BY clause.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305997,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the description of the PRODUCT_INFORMATION table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-16_23-19-39-4ecc8ce0ad9f90175f13fa06fb6b9c6f.png\"></p><p><br></p><p>Identify the SQL statement that would retrieve from the table the number of products having LIST_PRICE as NULL.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle NVL Function](https://www.oracletutorial.com/oracle-comparison-functions/oracle-nvl/)"
                ],
                "feedbacks": [
                    "This SQL statement correctly retrieves the number of products with a NULL value in the LIST_PRICE column from the PRODUCT_INFORMATION table. The COUNT(*) function counts all rows that meet the condition specified in the WHERE clause, which in this case is where LIST_PRICE is NULL.",
                    "This SQL statement uses the NVL function to replace NULL values with 0 before counting the number of products with a NULL LIST_PRICE. However, this is unnecessary as the COUNT function automatically excludes NULL values, so the NVL function is not needed in this context.",
                    "This SQL statement attempts to count the number of products with a NULL LIST_PRICE but contains a syntax error in the WHERE clause. The correct syntax for comparing NULL values is \"IS NULL\" not \"i = NULL\".",
                    "This SQL statement correctly selects the COUNT of the LIST_PRICE column from the PRODUCT_INFORMATION table where the LIST_PRICE is NULL. However, the COUNT function should be applied to the entire row, not a specific column.",
                    "This SQL statement incorrectly uses the DISTINCT keyword with the COUNT function to count the number of unique values in the LIST_PRICE column where LIST_PRICE is NULL. This is not necessary for this specific query, as the goal is to count the total number of products with a NULL LIST_PRICE, not the distinct values."
                ],
                "explanation": "<p><strong>Correct SQL&nbsp;Statement: </strong></p><pre class=\"prettyprint linenums\">SELECT COUNT(*) \nFROM product_information \nWHERE list_price IS NULL;</pre><ul><li><p>This counts all rows <strong>regardless of column content</strong> after filtering to only those where <code>LIST_PRICE IS NULL</code>.</p></li></ul><p><strong>Incorrect Options:</strong></p><ol><li><pre class=\"prettyprint linenums\">SELECT COUNT (DISTINCT list_price) \nFROM product_information \nWHERE list_price IS NULL</pre><ul><li><p><strong>Incorrect</strong>: <code>COUNT(DISTINCT list_price)</code> ignores <code>NULL</code> values, so it will return <code>0</code>.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT COUNT (NVL(list_price, 0)) \nFROM product_information \nWHERE list_price IS NULL</pre><ul><li><p><strong>Incorrect</strong>: Although <code>NVL</code> replaces <code>NULL</code> with <code>0</code>, <code>COUNT(...)</code> still works after the <code>WHERE</code> clause filters for <code>NULLs</code>, but this is an unnecessary and confusing way to do it.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT COUNT (list_price) \nFROM product_information \nWHERE list_price IS = NULL</pre><ul><li><p><strong>Syntax error. </strong>The correct comparison is <code>IS NULL</code>, <strong>not </strong><code><strong>IS = NULL</strong></code>.</p></li></ul></li><li><pre class=\"prettyprint linenums\">SELECT COUNT (list_price) \nFROM product_information \nWHERE list_price IS NULL</pre><ul><li><p><strong>Incorrect</strong>: <code>COUNT(list_price)</code> <strong>ignores NULLs</strong>, so this will return <code>0</code>, even though you're filtering for <code>NULLs</code>.</p></li></ul></li></ol><p><strong>Oracle NVL()</strong></p><p>The Oracle <code>NVL()</code> function allows you to replace null with a more meaningful alternative in the results of a query.</p><p>The following shows the syntax of the <code>NVL()</code> function:</p><pre class=\"prettyprint linenums\">     NVL(e1, e2)</pre><p>The <code>NVL()</code> function accepts two arguments. If <code>e1</code> evaluates to null, then the <code>NVL()</code> function returns <code>e2</code>. If <code>e1</code> evaluates to non-null, the <code>NVL()</code> function returns <code>e1</code>.</p><p>Where <code>SELECT COUNT (NVL(list_price, 0))</code>&nbsp; when the list_price value returns a <code>NULL</code>, the <code>NVL()</code> returns a zero. If list_price returns a NOT NULL, the <code>NVL()</code> function returns the value in the cell.</p><p><code>COUNT </code>inherently ignores null and duplicate values.&nbsp; In this case, <code>COUNT</code> counts the number of values returned by <code>NVL(list_price, 0)</code> filtered by the <code>WHERE</code> clause.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT COUNT(*) \nFROM product_information \nWHERE list_price IS NULL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (NVL(list_price, 0)) \nFROM product_information \nWHERE list_price IS NULL</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (list_price) \nFROM product_information \nWHERE list_price IS = NULL</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (list_price) \nFROM product_information \nWHERE list_price IS NULL</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT COUNT (DISTINCT list_price) \nFROM product_information \nWHERE list_price IS NULL</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View the exhibit and examine the description of the PRODUCT_INFORMATION table. Identify the SQL statement that would retrieve from the table the number of products having LIST_PRICE as NULL.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305999,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding the GROUP BY clause in a SQL statement. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle GROUP BY](https://www.oracletutorial.com/oracle-basics/oracle-group-by/)"
                ],
                "feedbacks": [
                    "You cannot use column aliases in the GROUP BY clause in a SQL statement. The GROUP BY clause requires the actual column names to group the data correctly.",
                    "Using the WHERE clause after the GROUP BY clause filters the rows after the groups have been created. The WHERE clause is used to filter the rows before the grouping operation.",
                    "The GROUP BY clause is not mandatory if you are using an aggregate function in the SELECT clause. You can use aggregate functions without the need for a GROUP BY clause.",
                    "<p>Using the WHERE clause before the GROUP BY clause filters the rows before the grouping operation. The WHERE clause is used to filter the rows before they are grouped based on the specified conditions.</p>",
                    "If the SELECT clause contains an aggregate function, then all individual columns without an aggregate function in the SELECT clause should be included in the GROUP BY clause. This ensures that the non-aggregated columns are part of the grouping criteria."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>1. Using the WHERE clause before the GROUP BY clause excludes the rows before creating groups.</strong></p><ul><li><p><strong>True</strong>: The <code>WHERE</code> clause filters rows <strong>before</strong> the <code>GROUP BY</code> clause is applied.</p></li><li><p>This means only the filtered rows are grouped.</p></li></ul><p><strong>2. If the SELECT clause has an aggregate function, then those individual columns without an aggregate function in the SELECT clause should be included in the GROUP BY clause.</strong></p><ul><li><p><strong>True</strong>: Any <strong>non-aggregated columns</strong> in the <code>SELECT</code> must appear in the <code>GROUP BY</code>.</p></li></ul><p><strong>Incorrect Statements:</strong></p><ol><li><p><strong>\"You can use a column alias in the GROUP BY clause.\"</strong><br>Not always: Column aliases defined in the <code>SELECT</code> clause generally <strong>cannot</strong> be used in the <code>GROUP BY</code> clause because <code>GROUP BY</code> is processed <strong>before</strong> <code>SELECT</code>.</p></li><li><p><strong>\"Using the WHERE clause after the GROUP BY clause excludes the rows after creating groups.\"</strong><br>Invalid: The <code>WHERE</code> clause must come <strong>before</strong> the <code>GROUP BY</code> clause.</p></li><li><p><strong>\"The GROUP BY clause is mandatory if you are using an aggregate function in the SELECT clause.\"</strong><br>Not necessarily: If <strong>only</strong> aggregate functions are used (no non-aggregated columns), then <code>GROUP BY</code> is <strong>not required</strong>.</p></li></ol><p>The <code>GROUP BY</code> clause is used in a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement to group rows into a set of summary rows by values of columns or expressions. The <code>GROUP BY</code> clause returns one row per group.</p><p>The <code>GROUP BY</code> clause is often used with <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/\"><code>COUNT()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-max/\"><code>MAX()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-min/\"><code>MIN()</code></a><code>,</code> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>. In this case, the aggregate function returns the summary information per group. For example, given groups of products in several categories, the <code>AVG()</code> function returns the average price of products in each category.</p><p>The following illustrates the syntax of the Oracle <code>GROUP BY</code> clause:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT column_list\nFROM table\nWHERE conditions\nGROUP BY conditions\nORDER BY conditions;</pre><p><br></p><p>The <code>GROUP BY</code> clause appears after the <code>FROM</code> clause. In case a <code>WHERE</code> clause is presented, the <code>GROUP BY</code> clause must be placed after the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a> clause. The <code>GROUP BY</code> clause groups rows by values in the grouping columns such as <code>c1</code>, <code>c2</code> and <code>c3</code>. The <code>GROUP BY</code> clause must contain only aggregates or grouping columns.</p>",
                "answers": [
                    "<p>You can use column alias in the GROUP BY clause.</p>",
                    "<p>Using the WHERE clause after the GROUP BY clause excludes the rows after creating groups.</p>",
                    "<p>The GROUP BY clause is mandatory if you are using an aggregate function in the SELECT clause.</p>",
                    "<p>Using the WHERE clause before the GROUP BY clause excludes the rows before creating groups.</p>",
                    "<p>If the SELECT clause has an aggregate function, then those individual columns without an aggregate function in the SELECT clause should be included in the GROUP BY cause.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding the GROUP BY clause in a SQL statement. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306001,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about the ALTER TABLE....DROP COLUMN.... command. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[How to drop Parent table without deleting or dropping constraints on child table in Oracle](https://stackoverflow.com/questions/21751280/how-to-drop-parent-table-without-deleting-or-dropping-constraints-on-child-table)"
                ],
                "feedbacks": [
                    "This statement is incorrect. In Oracle Database SQL, a column can be dropped even if it contains data. However, dropping a column with data will result in the data being lost.",
                    "This statement is correct. In Oracle Database SQL, a column can only be dropped if another column exists in the table. This ensures that the table always has at least one column.",
                    "This statement is incorrect. In Oracle Database SQL, once a column is dropped, it cannot be rolled back. Dropping a column is a permanent operation.",
                    "This statement is incorrect. In Oracle Database SQL, a column in a composite PRIMARY KEY with the CASCADE option cannot be dropped. Dropping a column in a composite PRIMARY KEY would require dropping the entire key constraint.",
                    "<p>This statement is correct. In Oracle Database SQL, a parent key column in the table cannot be dropped. This is to maintain referential integrity and prevent orphaned child records. If you attempt to drop a parent key column without addressing the foreign key constraints, you will encounter errors due to the dependencies that exist.</p>"
                ],
                "explanation": "<p><strong>√ A column can be dropped only if another column exists in the table.</strong> An error will be presented if an attempt to drop the only column in a table is made.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-17_00-50-32-5558437a48006ab7dfb7161eeff3839b.png\"></p><pre class=\"prettyprint linenums\">ALTER TABLE single_column_table\n  DROP COLUMN only_column;</pre><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-17_00-52-50-f5c963bfd7f7254acf0fafbfd81e7a1a.png\"></p><p><br></p><p><strong>√ A parent key column in the table cannot be dropped until foreign key constraints have been addressed. </strong>This is a true statement on its own.</p><p>In Oracle Database SQL, a \"Parent\" key column in the table cannot be dropped, as the word \"Parent\" insinuates that there are \"Child\" records. This is to maintain referential integrity and prevent orphaned child records.</p><p>We are not referring to just a \"Primary\" key, but a \"Parent\" key.</p><p>It is not possible to drop a parent table if you have a child table with a foreign key constraint in place, unless you specify the <code>CASCADE CONSTRAINTS</code> clause:</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE P CASCADE CONSTRAINTS;</pre><p><br></p><p>This command drops the FK constraint too.</p><p><strong>Dropping a parent key column in a relational database can indeed be done,</strong> but it comes with important considerations. When you have a foreign key relationship, the parent key is referenced by child tables. If you attempt to drop a parent key column without addressing the foreign key constraints, you will encounter errors due to the dependencies that exist.</p><p>Using the <code>CASCADE</code> option allows you to automatically drop the foreign key constraints associated with that parent key column. This means that when you drop the parent key, any related child records will also be affected, which can lead to data loss if not handled carefully. Therefore, while it is technically possible to drop a parent key column, the implications of doing so must be fully understood.</p><p>Regarding a reverse scenario, while it is possible to drop a parent key column, it is not advisable to think of it as a straightforward operation. The integrity of your database is paramount, and dropping a key column without considering the cascading effects can lead to orphaned records or loss of data integrity. Always ensure that you have a backup and a clear understanding of the relationships in your database before making such changes.</p><p>In summary, while you can drop a parent key column with the <code>CASCADE</code> option, it is crucial to approach this action with caution and a thorough understanding of the implications for your database structure and data integrity.</p><p><br></p><p><strong>✗ The column in a composite PRIMARY KEY with the CASCADE option can be dropped. </strong>In a composite PRIMARY KEY, if you want to delete a column, you need to first drop the primary key and after drop the column; the cascade options are just for foreign keys.</p><p><strong>✗ A column can be dropped only if it does not contain any data. </strong>It makes no difference if there is data or not; in general, a column can be dropped with or without data in the table.</p><p><strong>✗ A dropped column can be rolled back.</strong> Dropping a column commits the transaction, and committed transactions cannot be rolled back.</p><p>Data definition language (DDL) statements, like ALTER TABLE DROP COLUMN, cannot be rolled back.</p>",
                "answers": [
                    "<p>A column can be dropped only if it does not contain any data.</p>",
                    "<p>A column can be dropped only if another column exists in the table.</p>",
                    "<p>A dropped column can be rolled back.</p>",
                    "<p>The column in a composite PRIMARY KEY with the CASCADE option can be dropped.</p>",
                    "<p>A parent key column in the table cannot be dropped until foreign key constraints have been addressed</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about the ALTER TABLE....DROP COLUMN.... command. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306003,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding table joins available in the Oracle Database server. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle: Creating Joins with the ON Clause](https://www.w3resource.com/oracle/joins/joins-with-on-clause.php)",
                    "[Multiple conditions in ON Clause](https://community.oracle.com/thread/2282332)",
                    "[Oracle: Creating Joins with the USING Clause](https://www.w3resource.com/oracle/joins/joins-with-using-clause.php)"
                ],
                "feedbacks": [
                    "The ON clause in Oracle Database allows you to specify multiple conditions for joining tables, providing flexibility in defining the relationship between the tables being joined.",
                    "While you can use the NATURAL JOIN in Oracle Database to join tables based on columns with the same name, it does not allow you to explicitly provide the join condition. This lack of explicit control over the join condition can sometimes lead to unexpected results.",
                    "In Oracle Database, the JOIN clause can be used to join multiple tables, not just limited to joining only two tables. This clause allows for joining multiple tables in a single query to retrieve the desired result set.",
                    "<p>The USING clause in Oracle Database allows you to join tables on columns with the same name, making it possible to join tables on more than one column simultaneously. This can be useful when the join condition involves multiple columns that need to be matched. The columns must have the same name in both tables.</p>"
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>You can use the ON clause to specify multiple conditions while joining tables.</strong></p><ul><li><p><strong>Explanation</strong>: Yes, the <code>ON</code> clause allows you to specify <strong>multiple join conditions</strong> using logical operators like <code>AND</code> and <code>OR</code>.<br><strong>Example</strong>:</p><pre class=\"prettyprint linenums\">sql\nSELECT *  \nFROM employees e  \nJOIN departments d  \nON e.department_id = d.department_id AND e.location_id = d.location_id;</pre></li></ul><p><strong>You can use the USING clause to join tables on more than one column, as long as the columns have the same name in both tables.</strong></p><ul><li><p>The <code>USING</code> clause <strong>can list multiple column names</strong> <strong>if they have identical names</strong> in both tables.</p></li><li><p><strong>Example</strong>:</p><pre class=\"prettyprint linenums\">sql\nSELECT * \nFROM table1 \nJOIN table2 \nUSING (column1, column2);</pre></li></ul><p><br></p><p><strong>Incorrect Statements:</strong></p><p><strong>You can explicitly provide the join condition with a NATURAL JOIN.</strong></p><ul><li><p>False. <code>NATURAL JOIN</code> uses implicit conditions — you <strong>cannot</strong> specify the join condition manually.</p></li></ul><p><strong>You can use the JOIN clause to join only two tables.</strong></p><ul><li><p>False. You can join <strong>multiple tables</strong> using multiple <code>JOIN</code> clauses.</p></li></ul><p><br></p><p><strong>Create a join with the ON clause in Oracle</strong></p><p>The join condition for the natural join is basically an equijoin of identical column names.</p><p><code>ON</code> clause can be used to join columns that have different names.</p><p>Use the <code>ON</code> clause to specify conditions or specify columns to join.</p><p>The join condition is separated from other search conditions.</p><p>This is the easiest and most widely used form of the join clauses.</p><p><strong>Syntax:</strong></p><p><br></p><pre class=\"prettyprint linenums\">SELECT table1.column, table2.column\nFROM table1\nJOIN table2 ON (table1.column_name = table2.column_name);</pre><p><br></p><p>You can use the <code>WHERE</code> clause or the <code>AND</code> clause to apply additional conditions.</p><p>While joining multiple tables, is this possible to use multiple conditions in the ON clause?</p><p><br></p><p><strong>Create a join with the USING clause in Oracle</strong></p><p>Use the <code>USING</code> clause to specify the columns for the equijoin where several columns have the same names but not the same data types.</p><p>Use the <code>USING</code> clause to match only one column when more than one column matches.</p><p>The <code>NATURAL JOIN</code> and <code>USING</code> clauses are mutually exclusive.</p><p><strong>Syntax:</strong></p><p><br></p><pre class=\"prettyprint linenums\">SELECT table1.column, table2.column\nFROM table1\nJOIN table2 USING (join_column1, join_column2…);</pre>",
                "answers": [
                    "<p>You can use the ON clause to specify multiple conditions while joining tables.</p>",
                    "<p>You can explicitly provide the join condition with a NATURAL JOIN.</p>",
                    "<p>You can use the JOIN clause to join only two tables.</p>",
                    "<p>You can use the USING clause to join tables on more than one column.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding table joins available in the Oracle Database server. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306005,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the data in ORDERS_MASTER and MONTHLY_ORDERS tables. </p><p><strong>Table: ORDERS_MASTER&nbsp; </strong></p><pre class=\"prettyprint linenums\">ORDER_ID                      ORDER_TOTAL\n1                             1000\n2                             2000\n3                             3000\n4                             NULL</pre><p><br></p><p><strong>Table: MONTHLY_ORDERS</strong></p><pre class=\"prettyprint linenums\">ORDER_ID                      ORDER_TOTAL\n2                             2500\n3                             NULL</pre><p><br></p><p>Evaluate the following MERGE statement:&nbsp; &nbsp;</p><pre class=\"prettyprint linenums\">MERGE INTO orders_master o\nUSING monthly_orders m\nON (o.order_id = m.order_id)\nWHEN MATCHED THEN\n  UPDATE SET o.order_total = m.order_total\n  DELETE WHERE (m.order_total IS NULL)\nWHEN NOT MATCHED THEN\n  INSERT VALUES (m.order_id, m.order_total);</pre><p><br></p><p>Identify the outcome of the above statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[MERGE statement ](https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9016.htm)"
                ],
                "feedbacks": [
                    "This choice is incorrect because the MERGE statement does not include the ORDER_ID 3 from the MONTHLY_ORDERS table, so it would not be inserted into the ORDERS_MASTER table.",
                    "This choice is correct because the MERGE statement includes the ORDER_IDs 1, 2, and 4 from the MONTHLY_ORDERS table, and they would be inserted into the ORDERS_MASTER table as specified in the WHEN MATCHED THEN clause.",
                    "This choice is incorrect because the MERGE statement does not include the ORDER_ID 3 from the MONTHLY_ORDERS table, so it would not be inserted into the ORDERS_MASTER table.",
                    "This choice is incorrect because the MERGE statement includes the ORDER_ID 4 from the MONTHLY_ORDERS table, so the ORDERS_MASTER table would contain the ORDER_IDs 1, 2, and 4, not just 1 and 2."
                ],
                "explanation": "<p><strong>Step-by-step Evaluation</strong></p><p>Matching Rows:</p><ul><li><p><strong>ORDER_ID = 2</strong></p><ul><li><p>Match found</p></li><li><p><code>m.order_total = 2500</code> (not null)</p></li><li><p>Action: <strong>UPDATE</strong> <code>o.order_total</code> to <code>2500</code></p></li></ul></li><li><p><strong>ORDER_ID = 3</strong></p><ul><li><p>Match found</p></li><li><p><code>m.order_total = NULL</code></p></li><li><p>Action: <strong>DELETE</strong> the row (because of <code>DELETE WHERE m.order_total IS NULL</code>)</p></li></ul></li></ul><p>Non-matching Rows in <code>MONTHLY_ORDERS</code>:</p><ul><li><p>No new <code>ORDER_ID</code>s in <code>MONTHLY_ORDERS</code> — so <strong>no INSERT</strong> is performed.</p></li></ul><p><strong>Final ORDERS_MASTER Table:</strong></p><p>ORDER_IDORDER_TOTAL11000225004NULL</p><p><code>ORDER_ID = 3</code> → <strong>Deleted</strong></p><p><strong>Correct Answer</strong>: The ORDERS_MASTER table would contain the ORDER_IDs 1, 2, and 4.</p><p><br></p><p>Use the <code>MERGE</code> statement to select rows from one or more sources for update or insertion into a table or view. You can specify conditions to determine whether to update or insert into the target table or view.</p><p>This statement is a convenient way to combine multiple operations. It lets you avoid multiple <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> DML statements.</p><p><code>MERGE</code> is a deterministic statement. You cannot update the same row of the target table multiple times in the same <code>MERGE</code> statement.</p>",
                "answers": [
                    "<p>The ORDERS_MASTER table would contain the ORDER_IDs 1, 2, 3 and 4.</p>",
                    "<p>The ORDERS_MASTER table would contain the ORDER_IDs 1, 2 and 4.</p>",
                    "<p>The ORDERS_MASTER table would contain the ORDER_IDs 1, 2 and 3.</p>",
                    "<p>The ORDERS_MASTER table would contain the ORDER_IDs 1 and 2.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View the exhibit and examine the data in ORDERS_MASTER and MONTHLY_ORDERS tables. Table: ORDERS_MASTER&nbsp; ORDER_ID                      ORDER_TOTAL\n1                             1000\n2                             2000\n3                             3000\n4                             NULLTable: MONTHLY_ORDERSORDER_ID                      ORDER_TOTAL\n2                             2500\n3                             NULLEvaluate the following MERGE statement:&nbsp; &nbsp;MERGE INTO orders_master o\nUSING monthly_orders m\nON (o.order_id = m.order_id)\nWHEN MATCHED THEN\n  UPDATE SET o.order_total = m.order_total\n  DELETE WHERE (m.order_total IS NULL)\nWHEN NOT MATCHED THEN\n  INSERT VALUES (m.order_id, m.order_total);Identify the outcome of the above statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306007,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p>The following command has been executed.</p><p><strong>Exhibit: 1 </strong></p><pre class=\"prettyprint linenums\">DROP&nbsp;TABLE&nbsp;employees:</pre><p><br></p><p>Identify the true statements. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[DROP TABLE statement](https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9003.htm)"
                ],
                "feedbacks": [
                    "Sequences used in the EMPLOYEES table do not become invalid when the table is dropped. Sequences are separate database objects and are not affected by the dropping of a table.",
                    "If there is an uncommitted transaction in the session, it will be committed when the table is dropped. Dropping a table is a DDL operation that automatically commits any pending transactions.",
                    "All indexes and constraints defined on the table being dropped are also dropped. When a table is dropped, all associated indexes and constraints are also removed from the database.",
                    "The space used by the EMPLOYEES table is not always immediately reclaimed when the table is dropped. The space may be marked as available for reuse, but it is not immediately released back to the operating system.",
                    "The EMPLOYEES table cannot be recovered using the ROLLBACK command once it has been dropped. The ROLLBACK command is used to undo changes made within a transaction, not to recover dropped objects.",
                    "The EMPLOYEES table may be moved to the recycle bin when dropped. The recycle bin is a feature in Oracle Database that stores dropped objects temporarily, allowing them to be recovered if needed."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>All indexes and constraints defined on the table being dropped are also dropped.</strong></p><ul><li><p>When a table is dropped, <strong>all dependent objects</strong> like indexes, constraints, triggers, and privileges are also <strong>dropped automatically</strong>.</p></li></ul><p><strong>The EMPLOYEES table may be moved to the recycle bin.</strong></p><ul><li><p>If the <strong>recycle bin is enabled</strong> (which it is by default in most Oracle setups), then the table is <strong>not immediately removed</strong> but <strong>renamed and stored</strong> in the recycle bin. You can recover it using <code>FLASHBACK TABLE</code>.</p></li></ul><p><strong>If there is an uncommitted transaction in the session, it is committed.</strong></p><ul><li><p>In Oracle, a <code>DROP TABLE</code> is a <strong>DDL statement</strong>, and <strong>all DDLs</strong> perform an <strong>implicit commit</strong> before and after the operation. Any uncommitted transactions are <strong>automatically committed</strong>.</p></li></ul><p><strong>Incorrect Statements:</strong></p><p><strong>Sequences used in the EMPLOYEES table become invalid.</strong></p><ul><li><p><strong>Sequences are independent objects</strong> and are <strong>not tied</strong> to the table. Dropping a table <strong>does not affect</strong> the sequences used by it.</p></li></ul><p><strong>The space used by the EMPLOYEES table is always reclaimed immediately.</strong></p><ul><li><p>If the table goes to the <strong>recycle bin</strong>, the space is <strong>not immediately reclaimed</strong>. It is only reclaimed when the table is <strong>purged</strong> from the recycle bin.</p></li></ul><p><strong>The EMPLOYEES table can be recovered using the ROLLBACK command.</strong></p><ul><li><p><strong>DDL operations cannot be rolled back.</strong></p></li><li><p><code>ROLLBACK</code> only works for <strong>DML</strong> (like <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) — not for <code>DROP</code>.</p></li></ul><p><br></p><p><em>Use the </em><code><em>DROP</em></code><em> </em><code><em>TABLE</em></code><em> statement to move a table or object table to the recycle bin</em> or to remove the table and all its data from the database entirely.</p><p>Unless you specify the <code>PURGE</code> clause, the <code>DROP</code> <code>TABLE</code> statement does not result in space being released back to the tablespace for use by other objects, and the space continues to count toward the user's space quota.</p><p>For an external table, this statement removes only the table metadata in the database. It has no affect on the actual data, which resides outside of the database.</p><p>When you drop a table that is part of a cluster, the table is moved to the recycle bin. However, if you subsequently drop the cluster, the table is purged from the recycle bin and can no longer be recovered with a <code>FLASHBACK TABLE</code> operation.</p><p>Dropping a table invalidates dependent objects and removes object privileges on the table. <em>All indexes and constraints defined on the table being dropped are also dropped.</em></p><p>If you want to re-create the table, then you must regrant object privileges on the table, re-create the indexes, integrity constraints, and triggers for the table, and respecify its storage parameters. Truncating has none of these effects. Therefore, removing rows with the <code>TRUNCATE</code> statement can be more efficient than dropping and re-creating a table.</p><p><br></p><p><strong>Statements That Cause an Implicit Commit</strong></p><p>The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/commit.html\" title=\"13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Statements\"><code>COMMIT</code></a> before executing the statement. <em>If there is an uncommitted transaction in the session, it is committed upon execution of </em><code>DROP TABLE</code><em>.</em></p><p>These statements also cause an implicit commit after executing. The intent is to handle each such statement in its own special transaction because it cannot be rolled back anyway.</p><p><strong>Data definition language (DDL) statements that define or modify database objects.</strong> </p><p><code>ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-event.html\" title=\"13.1.2&nbsp;ALTER EVENT Statement\"><code>ALTER EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-procedure.html\" title=\"13.1.5&nbsp;ALTER PROCEDURE Statement\"><code>ALTER PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-server.html\" title=\"13.1.6&nbsp;ALTER SERVER Statement\"><code>ALTER SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-table.html\" title=\"13.1.7&nbsp;ALTER TABLE Statement\"><code>ALTER TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-view.html\" title=\"13.1.9&nbsp;ALTER VIEW Statement\"><code>ALTER VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-database.html\" title=\"13.1.10&nbsp;CREATE DATABASE Statement\"><code>CREATE DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-event.html\" title=\"13.1.11&nbsp;CREATE EVENT Statement\"><code>CREATE EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-index.html\" title=\"13.1.13&nbsp;CREATE INDEX Statement\"><code>CREATE INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-procedure.html\" title=\"13.1.15&nbsp;CREATE PROCEDURE and CREATE FUNCTION Statements\"><code>CREATE PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-server.html\" title=\"13.1.16&nbsp;CREATE SERVER Statement\"><code>CREATE SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-table.html\" title=\"13.1.17&nbsp;CREATE TABLE Statement\"><code>CREATE TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-trigger.html\" title=\"13.1.19&nbsp;CREATE TRIGGER Statement\"><code>CREATE TRIGGER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-view.html\" title=\"13.1.20&nbsp;CREATE VIEW Statement\"><code>CREATE VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-database.html\" title=\"13.1.21&nbsp;DROP DATABASE Statement\"><code>DROP DATABASE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-event.html\" title=\"13.1.22&nbsp;DROP EVENT Statement\"><code>DROP EVENT</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-index.html\" title=\"13.1.24&nbsp;DROP INDEX Statement\"><code>DROP INDEX</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-procedure.html\" title=\"13.1.26&nbsp;DROP PROCEDURE and DROP FUNCTION Statements\"><code>DROP PROCEDURE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-server.html\" title=\"13.1.27&nbsp;DROP SERVER Statement\"><code>DROP SERVER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-table.html\" title=\"13.1.28&nbsp;DROP TABLE Statement\"><code>DROP TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-trigger.html\" title=\"13.1.30&nbsp;DROP TRIGGER Statement\"><code>DROP TRIGGER</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-view.html\" title=\"13.1.31&nbsp;DROP VIEW Statement\"><code>DROP VIEW</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/rename-table.html\" title=\"13.1.32&nbsp;RENAME TABLE Statement\"><code>RENAME TABLE</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/truncate-table.html\" title=\"13.1.33&nbsp;TRUNCATE TABLE Statement\"><code>TRUNCATE TABLE</code></a>.</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/alter-function.html\" title=\"13.1.3&nbsp;ALTER FUNCTION Statement\"><code>ALTER FUNCTION</code></a>, <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/create-function.html\" title=\"13.1.12&nbsp;CREATE FUNCTION Statement\"><code>CREATE FUNCTION</code></a> and <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/drop-function.html\" title=\"13.1.23&nbsp;DROP FUNCTION Statement\"><code>DROP FUNCTION</code></a> also cause an implicit commit when used with stored functions, but not with user-defined functions.</p>",
                "answers": [
                    "<p>Sequences used in the EMPLOYEES table become invalid.</p>",
                    "<p>If there is an uncommitted transaction in the session, it is committed.</p>",
                    "<p>All indexes and constraints defined on the table being dropped are also dropped.</p>",
                    "<p>The space used by the EMPLOYEES table is always reclaimed immediately.</p>",
                    "<p>The EMPLOYEES table can be recovered using the ROLLBACK command.</p>",
                    "<p>The EMPLOYEES table may be moved to the recycle bin.</p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "f"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.The following command has been executed.Exhibit: 1 DROP&nbsp;TABLE&nbsp;employees:Identify the true statements. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306009,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View the Exhibit and examine the details of the PRODUCT_INFORMATION table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-10-58-3a15d5c20ea5685bc55f03f6099c8df6.png\"></p><p><br></p><p>Evaluate this SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT&nbsp;TO_CHAR (list_price, '$9,999')\nFROM&nbsp;product_information</pre><p><br></p><p>Identify the true statements regarding the output. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This statement is correct because the TO_CHAR function with the 'FM99999' format model will display the LIST_PRICE value 11235.90 as '#######', removing any leading or trailing spaces or zeros.",
                    "This statement is incorrect because the TO_CHAR function with the 'L999G999' format model will display the LIST_PRICE value 1123.90 as '$1,123', not as '$1,123.90'.",
                    "This statement is correct because the TO_CHAR function with the 'FML999G999' format model will display the LIST_PRICE value 1123.90 as '$1,124', rounding the value to the nearest whole number.",
                    "This statement is incorrect because the TO_CHAR function with the 'L999G999' format model will display the LIST_PRICE value 11235.90 as '$11,236', not as '$1,123'."
                ],
                "explanation": "<p>Let's break down the <code>TO_CHAR(list_price, '$9,999')</code> SQL statement and evaluate the options.</p><p><strong>Understanding the Format Mask '$9,999'</strong></p><ul><li><p><code>$</code> : This will prepend a dollar sign to the output.</p></li><li><p><code>9</code> : Represents a digit. If there are not enough digits to fill the <code>9</code>s, a leading space is used for positive numbers. If there are more digits than <code>9</code>s, pound signs (<code>#</code>) are returned to indicate overflow.</p></li><li><p><code>,</code> (comma): This acts as a group separator (thousand separator).</p></li></ul><p><strong>Key Rules for TO_CHAR (number, format_mask):</strong></p><ol><li><p><strong>Rounding:</strong> Numbers are rounded to the specified number of decimal places in the format mask. In '$9,999', there are no decimal places specified, so the number will be rounded to the nearest integer.</p></li><li><p><strong>Overflow:</strong> If the number of significant digits to the left of the decimal point exceeds the number of <code>9</code>s in the format mask (excluding the comma), the output will be replaced with hash signs (<code>#######</code>).</p></li></ol><p>Let's evaluate each option:</p><ul><li><p><strong>A row whose LIST_PRICE column contains the value 11235.90 would be displayed as #######.</strong></p><ul><li><p>The format mask allows for numbers up to 4 digits (9,999).</p></li><li><p>11235.90 has 5 digits to the left of the decimal (11235).</p></li><li><p>Since 11235 is larger than what the mask can accommodate (9999), it will result in <code>#######</code>.</p></li><li><p><strong>This statement is TRUE.</strong></p></li></ul></li><li><p><strong>A row whose LIST_PRICE column contains the value 1123.90 would be displayed as $1,124.</strong></p><ul><li><p>1123.90 rounded to the nearest integer is 1124.</p></li><li><p>Applying the format '$9,999' to 1124 would result in $1,124.</p></li><li><p><strong>This statement is TRUE.</strong></p></li></ul></li><li><p><strong>A row whose LIST_PRICE column contains the value 1123.90 would be displayed as $1,123.</strong></p><ul><li><p>As established above, 1123.90 rounds to 1124. So, this statement is false.</p></li></ul></li><li><p><strong>A row whose LIST_PRICE column contains the value 11235.90 would be displayed as $1,123.</strong></p><ul><li><p>As established above, 11235.90 would result in <code>#######</code> due to overflow. So, this statement is false.</p></li></ul></li></ul><p>Therefore, the true statements are:</p><ol><li><p>A row whose LIST_PRICE column contains the value 11235.90 would be displayed as #######.</p></li><li><p>A row whose LIST_PRICE column contains the value 1123.90 would be displayed as $1,124.</p></li></ol>",
                "answers": [
                    "<p>A row whose LIST_PRICE column contains value 11235.90 would be displayed as #######.</p>",
                    "<p>A row whose LIST_PRICE column contains value 1123.90 would be displayed as $1,123.</p>",
                    "<p>A row whose LIST_PRICE column contains value 1123.90 would be displayed as $1,124.</p>",
                    "<p>A row whose LIST_PRICE column contains value 11235.90 would be displayed as $1,123.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View the Exhibit and examine the details of the PRODUCT_INFORMATION table. Evaluate this SQL statement.Exhibit: 1SELECT&nbsp;TO_CHAR (list_price, '$9,999')\nFROM&nbsp;product_informationIdentify the true statements regarding the output. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306011,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>These are the steps for a correlated subquery, listed in random order:&nbsp; </p><ol><li><p>The WHERE clause of the outer query is evaluated. </p></li><li><p>A candidate row is fetched from the table specified in the outer query. </p></li><li><p>This is repeated for the subsequent rows of the table until all the rows are processed. </p></li><li><p>Rows are returned by the inner query, after being evaluated with the value from the candidate row in the outer query.&nbsp; </p></li></ol><p>Identify the correct sequence in which the Oracle server evaluates a correlated subquery.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[All About Oracle (SQL, PL/SQL , Forms and Reports) &amp; UNIX](http://rajanimohanty.blogspot.co.uk/2014/01/correlated-subquery.html)"
                ],
                "feedbacks": [
                    "This sequence starts with fetching a candidate row from the table specified in the outer query, followed by evaluating the WHERE clause of the outer query. Then, rows are returned by the inner query after being evaluated with the value from the candidate row. Finally, the process is repeated for subsequent rows of the table until all rows are processed. This order is not correct for the evaluation of a correlated subquery.",
                    "This sequence begins with rows being returned by the inner query after being evaluated with the value from the candidate row in the outer query. Then, the WHERE clause of the outer query is evaluated, followed by fetching a candidate row from the table specified in the outer query. The process is repeated for subsequent rows of the table until all rows are processed. This order is not correct for the evaluation of a correlated subquery.",
                    "This sequence starts with rows being returned by the inner query after being evaluated with the value from the candidate row in the outer query. Then, a candidate row is fetched from the table specified in the outer query, followed by evaluating the WHERE clause of the outer query. The process is repeated for subsequent rows of the table until all rows are processed. This order is not correct for the evaluation of a correlated subquery.",
                    "This sequence correctly identifies the order in which the Oracle server evaluates a correlated subquery. It starts with fetching a candidate row from the table specified in the outer query, followed by rows being returned by the inner query after being evaluated with the value from the candidate row. The WHERE clause of the outer query is evaluated, and the process is repeated for subsequent rows of the table until all rows are processed."
                ],
                "explanation": "<p>To determine the <strong>correct sequence</strong> of how Oracle evaluates a <strong>correlated subquery</strong>, let’s first understand what happens during execution:</p><p>A <strong>correlated subquery</strong> is a subquery that references a column from the <strong>outer query</strong>. It runs <strong>once for each row</strong> returned by the outer query.</p><p>Let's match the steps to the process:</p><p>Step Descriptions:</p><ol><li><p><strong>The WHERE clause of the outer query is evaluated.</strong></p></li><li><p><strong>A candidate row is fetched from the table specified in the outer query.</strong></p></li><li><p><strong>This is repeated for the subsequent rows of the table until all the rows are processed.</strong></p></li><li><p><strong>Rows are returned by the inner query, after being evaluated with the value from the candidate row in the outer query.</strong></p></li></ol><p>Correct Logical Sequence: <strong>2, 4, 1, 3</strong> </p><ol><li><p><strong>Step 2:</strong> Fetch a candidate row from the outer query's table.</p></li><li><p><strong>Step 4:</strong> Evaluate the inner query <strong>using values</strong> from that candidate row.</p></li><li><p><strong>Step 1:</strong> Use the result of the inner query to <strong>evaluate the WHERE clause</strong> of the outer query.</p></li><li><p><strong>Step 3:</strong> Repeat for the next candidate row.</p></li></ol><p><br></p><p><strong>Correlated subqueries are used for row-by-row processing. Each subquery is executed once for each row of the outer query.</strong></p><p><code>GET</code> candidate row from outer query</p><p><code>EXECUTE</code> inner query using the candidate row value</p><p><code>USE</code> values from the inner query to qualify or disqualify the candidate row.</p><p>The non-correlated subquery, or Nested Subquery, is that the subquery can be run independently of the outer query. Basically, the subquery has no relationship with the outer query.</p><p>Now, a correlated subquery has the opposite property – the subquery can not be run independently of the outer query. You can take a look at this example of a correlated subquery below and easily see the difference yourself:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT *\nFROM Employee Emp1\nWHERE (1) = (\n    SELECT COUNT(DISTINCT(Emp2.Salary))\n    FROM Employee Emp2\n    WHERE Emp2.Salary &gt; Emp1.Salary)</pre><p><br></p><p><strong>It is important to understand the order of operations in a correlated subquery.</strong></p><p>1. A row is processed in the outer query. (<em>A candidate row is fetched from the table specified in the outer query. </em>)</p><p>2. Then, for that particular row, the subquery is executed – so for each row processed by the outer query, the subquery will also be processed. (<em>Rows are returned by the inner query, after being evaluated with the value from the candidate row in the outer query.&nbsp;</em> )</p><p>3. Next then the outer query will move on to the next row, and the subquery will execute for that row’s value. (<em>The WHERE clause of the outer query is evaluated.</em>)</p><p>4. This will continue until the WHERE&nbsp; condition is satisfied. (<em>This is repeated for the subsequent rows of the table, until all the rows are processed.</em> )</p><p><br></p><p>The Oracle server performs a correlated subquery when the subquery references a column from a table referred to in the parent statement. A correlated subquery is evaluated once for each row processed by the parent statement. The parent statement can be a <code>SELECT </code>,<code>UPDATE</code> or <code>DELETE</code> statement.</p>",
                "answers": [
                    "<p>2, 1, 4, 3</p>",
                    "<p>4, 1, 2, 3</p>",
                    "<p>4, 2, 1, 3</p>",
                    "<p>2, 4, 1, 3</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "Database SQL Reference",
            "question_plain": "These are the steps for a correlated subquery, listed in random order:&nbsp; The WHERE clause of the outer query is evaluated. A candidate row is fetched from the table specified in the outer query. This is repeated for the subsequent rows of the table until all the rows are processed. Rows are returned by the inner query, after being evaluated with the value from the candidate row in the outer query.&nbsp; Identify the correct sequence in which the Oracle server evaluates a correlated subquery.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306013,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p>Identify the situations where a new transaction always starts. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Structure of a Transaction](https://docs.oracle.com/database/121/CNCPT/transact.htm#CNCPT038)"
                ],
                "feedbacks": [
                    "When a TRUNCATE statement is issued after a SELECT statement in the same session, a new transaction always starts. TRUNCATE is a DDL statement that cannot be rolled back, so it automatically commits the current transaction and starts a new one.",
                    "When issuing a CREATE INDEX statement after a CREATE TABLE statement in the same session, a new transaction does not necessarily start. Both CREATE INDEX and CREATE TABLE are DDL statements that do not require a new transaction to be initiated.",
                    "When a CREATE TABLE statement is issued after a SELECT statement in the same session, a new transaction always starts. CREATE TABLE is a DDL statement that automatically commits the current transaction and starts a new one.",
                    "When the first Data Manipulation Language (DML) statement is issued after a COMMIT or ROLLBACK statement in the same session, a new transaction always starts. COMMIT and ROLLBACK statements end the current transaction, so any subsequent DML statement initiates a new transaction.",
                    "When a DML statement is issued after a previous DML statement failed in the same session, a new transaction does not necessarily start. The failure of a DML statement does not automatically trigger the start of a new transaction.",
                    "When issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement in the same session, a new transaction does not necessarily start. Both SELECT FOR UPDATE and CREATE TABLE AS SELECT are DML statements that do not require the initiation of a new transaction."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>When issuing a TRUNCATE statement after a SELECT statement was issued in the same session</strong></p><ul><li><p><code>TRUNCATE</code> is a <strong>DDL</strong> statement and causes an <strong>implicit commit</strong>.</p></li><li><p>Even though it <strong>does not start a transaction</strong>, it <strong>ends any existing transaction</strong>, so the <strong>next DML</strong> will <strong>start a new transaction</strong>.</p></li><li><p>Correct in terms of triggering a new transactional state.</p></li></ul><p><strong>When issuing a CREATE TABLE statement after a SELECT statement was issued in the same session</strong></p><ul><li><p>Again, <code>CREATE TABLE</code> is <strong>DDL</strong>, and it causes an <strong>implicit commit</strong>.</p></li><li><p>This <strong>ends any ongoing transaction</strong>. So, <strong>after this, the next DML would begin a new transaction</strong>.</p></li></ul><p><strong>When issuing the first Data Manipulation Language (DML) statement after a COMMIT or ROLLBACK statement was issued in the same session</strong></p><ul><li><p>After a <code>COMMIT</code> or <code>ROLLBACK</code>, the next <strong>DML</strong> automatically starts a <strong>new transaction</strong>.</p></li><li><p>This is the <strong>classic definition</strong> of a new transaction beginning.</p></li></ul><p><br></p><p><strong>Incorrect Statements:</strong></p><p><strong>When issuing a CREATE INDEX statement after a CREATE TABLE statement has completed successfully in the same session</strong></p><ul><li><p>Both <code>CREATE TABLE</code> and <code>CREATE INDEX</code> are <strong>DDL</strong> statements.</p></li><li><p>Neither starts a transaction.</p></li><li><p>They perform <strong>implicit commits</strong>, but do <strong>not start</strong> a new transaction.</p></li></ul><p><strong>When issuing a DML statement after a DML statement failed in the same session</strong></p><ul><li><p>A <strong>failed DML</strong> doesn't end or commit a transaction.</p></li><li><p>You're still in the <strong>same transaction</strong> — Oracle lets you retry or continue within it.</p></li><li><p>So, the next DML does <strong>not necessarily start</strong> a new transaction.</p></li></ul><p><strong>When issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session</strong></p><ul><li><p><code>CREATE TABLE AS SELECT</code> is a <strong>DDL</strong>, so it causes an <strong>implicit commit</strong>.</p></li><li><p><code>SELECT FOR UPDATE</code> is <strong>not a DML statement</strong> (it only locks rows; it doesn't change data).</p></li><li><p>No new transaction starts unless an actual <strong>DML</strong> follows.</p></li></ul><p><br></p><p><strong>Structure of a Transaction</strong></p><p>A database transaction consists of one or more statements. Specifically, a transaction consists of one of the following:</p><ul><li><p>One or more data manipulation language (DML) statements that together constitute an atomic change to the database</p></li><li><p>One data definition language (DDL) statement</p></li></ul><p>A transaction has a beginning and an end.</p><p><br></p><p><strong>A transaction begins when the first executable SQL statement is encountered.</strong></p><p>An <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-2F2F02A4-2405-4A0A-ABAF-91DB48DD4B82\">executable SQL statement</a> is a SQL statement that generates calls to a <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-CFB1A30E-76B6-44EA-839E-9E63C8DA31AC\">database instance</a>, including DML and DDL statements and the <code>SET TRANSACTION</code> statement.</p><p>When a transaction begins, Oracle Database assigns the transaction to an available <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-297B963A-989C-4720-B061-A2352FF72892\">undo data</a> segment to record the undo entries for the new transaction. A transaction ID is not allocated until an undo segment and <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-BFF71130-2760-4C64-8829-7772C803FBE7\">transaction table</a> slot are allocated, which occurs during the first DML statement. A transaction ID is unique to a transaction and represents the undo segment number, slot, and sequence number.</p><p><strong>A transaction can end under different circumstances.</strong></p><ul><li><p>A transaction ends when any of the following actions occur:</p></li><li><p>A user issues a <code>COMMIT</code> or <code>ROLLBACK</code> statement without a <code>SAVEPOINT</code> clause.</p></li><li><p>In a <a href=\"https://docs.oracle.com/database/121/CNCPT/glossary.htm#GUID-0680EB2C-ADF4-431A-A259-FB2227E5AA93\">commit</a>, a user explicitly or implicitly requested that the changes in the transaction be made permanent. Changes made by the transaction are permanent and visible to other users only after the transaction commits. The transaction shown in \"<a href=\"https://docs.oracle.com/database/121/CNCPT/transact.htm#GUID-A049FE81-8B67-4386-B599-9CDD7E6B6C59\" title=\"To illustrate the concept of a transaction, consider a banking database.\">Sample Transaction: Account Debit and Credit</a>\" ends with a commit.</p></li><li><p>A user runs a DDL command such as <code>CREATE</code>, <code>DROP</code>, <code>RENAME</code>, or <code>ALTER</code>.</p></li></ul><p>The database issues an implicit <code>COMMIT</code> statement before and after every DDL statement. If the current transaction contains DML statements, then Oracle Database first commits the transaction and then runs and commits the DDL statement as a new, single-statement transaction.</p><ul><li><p>A user exits normally from most Oracle Database utilities and tools, causing the current transaction to be implicitly committed. The commit behavior when a user disconnects is application-dependent and configurable.</p></li><li><p>A client process terminates abnormally, causing the transaction to be implicitly rolled back using metadata stored in the transaction table and the undo segment.</p></li><li><p>After one transaction ends, the next executable SQL statement automatically starts the following transaction.</p></li></ul>",
                "answers": [
                    "<p>When issuing a TRUNCATE statement after a SELECT statement was issued in the same session</p>",
                    "<p>When issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session</p>",
                    "<p>When issuing a CREATE TABLE statement after a SELECT statement was issued in the same session</p>",
                    "<p>When issuing the first Data Manipulation Language (DML) statement after a COMMIT or ROLLBACK statement was issued in the same session</p>",
                    "<p>When issuing a DML statement after a DML statement failed in the same session</p>",
                    "<p>When issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session</p>"
                ]
            },
            "correct_response": [
                "d",
                "a",
                "c"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following SQL exhibit.Identify the situations where a new transaction always starts. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306015,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p>Identify the true statements about substitution variables. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[SQL*Plus Substitution Variables - DEFINE variables and parameters in SQL Queries](https://blogs.oracle.com/opal/sqlplus-101-substitution-variables)",
                    "[Using Substitution Variables](https://docs.oracle.com/en/cloud/paas/analytics-cloud/adess/using-substitution-variables.html)"
                ],
                "feedbacks": [
                    "A substitution variable can be used with any clause in a SELECT statement, allowing for dynamic values to be inserted into the query at runtime.",
                    "A substitution variable used to prompt for a column name does not need to be enclosed in single quotation marks. Substitution variables are typically used for values, not column names.",
                    "A substitution variable prefixed with &amp; prompts for a value each time it is encountered in the SQL statement, not just once per session. This allows for multiple prompts for different values within the same session.",
                    "A substitution variable can be used in various SQL statements, not limited to just SELECT statements. It can be used in INSERT, UPDATE, DELETE, and other SQL statements as well.",
                    "Substitution variables act as placeholders for variable values in SQL queries. They can be used globally across the entire application or limited to specific parts of the application.",
                    "A substitution variable prefixed with &amp;&amp; prompts for a value only once per session unless it is explicitly undefined in that session. This allows for consistent value prompts throughout the session unless the variable is intentionally reset."
                ],
                "explanation": "<p>Let’s examine each option about <strong>substitution variables</strong> in SQL (commonly used in tools like SQL*Plus, SQL Developer, etc.)</p><p><strong>Understanding Substitution Variables:</strong></p><ul><li><p><code>&amp;variable</code>: Prompts the user <strong>every time</strong> it’s used unless stored in a DEFINE.</p></li><li><p><code>&amp;&amp;variable</code>: Prompts <strong>once per session</strong> (or script), then stores the value.</p></li><li><p>Substitution variables can be used in <strong>any SQL or PL/SQL block</strong>, especially useful for reusability and interactive scripts.</p></li></ul><p><strong>Correct Statements:</strong></p><p><strong>A substitution variable can be used with any clause in a SELECT statement</strong></p><ul><li><p>You can use substitution variables in <strong>SELECT, WHERE, ORDER BY, GROUP BY</strong>, etc.</p></li><li><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM employees WHERE department_id = &amp;dept_id;</pre></li></ul><p><strong>Substitution variables are global or per-application placeholders that represent variable values</strong></p><ul><li><p>They act like <strong>temporary variables</strong>, often per <strong>session or script execution</strong>, depending on how they’re defined.</p></li></ul><p><strong>A substitution variable prefixed with &amp;&amp; prompts only once for a value in a session unless it is set to undefined in the session</strong></p><ul><li><p><code>&amp;&amp;</code> stores the variable value after the first prompt and <strong>reuses it</strong>.</p></li><li><p>You can unset it using:</p><pre class=\"prettyprint linenums\">sql\nUNDEFINE variable_name;</pre></li></ul><p><br></p><p><strong>Incorrect Statements:</strong></p><p><strong>A substitution variable used to prompt for a column name must be enclosed in single quotation marks</strong></p><ul><li><p>Column names are <strong>identifiers</strong>, not string literals.</p></li><li><p>They <strong>should not</strong> be enclosed in quotes when passed as substitution variables.</p></li><li><p>If you used <code>'&amp;column'</code>, it would pass a string literal, not a column reference.</p></li></ul><p><strong>A substitution variable prefixed with &amp; always prompts only once for a value in a session</strong></p><ul><li><p><code>&amp;</code> prompts <strong>every time</strong> it appears.</p></li><li><p>Only <code>&amp;&amp;</code> avoids re-prompting by <strong>storing</strong> the value.</p></li></ul><p><strong>A substitution variable can be used only in a SELECT statement</strong></p><ul><li><p>Substitution variables can be used in <strong>any SQL or PL/SQL statement</strong>, including <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE TABLE</code>, etc.</p></li></ul><p><br></p><p>DESCRIBE [table]</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-20_01-30-29-b5076ef8ddd849c1f15e64122369140d.png\"></p><p><br>Select using substitution variables w/o \" \"</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-20_01-32-49-7e83d4abc23599a680df0cdddd3af5d0.png\"></p><p><br></p><p>Select using substitution variables w/ \" \"</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-20_01-35-32-e05cea7f16a754d847edd2d9d21c7359.png\"></p><p><br>Using substitution variables in SELECT column, FROM table, and ORDER BY column, and it was able to execute successfully</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-07-20_01-39-52-df9b37f29fd28740eac09e5aa18cb591.png\"></p><p><br></p><p><br></p><p><strong>Substitution variables are global or per-application placeholders that represent variable values. </strong></p><p>The designation \"&amp;CurMnth\" might be a substitution variable representing the current month. Application designers or administrators define and manage substitution variables and their corresponding values</p><p><a href=\"https://docs.oracle.com/cd/E89578_01/SVPBC/substitution_variables.htm#SVPBC-adhoc_187\">https://docs.oracle.com/cd/E89578_01/SVPBC/substitution_variables.htm#SVPBC-adhoc_187</a></p><p><br></p><p>You can use substitution variables with both aggregate storage and block storage applications (unless otherwise noted) in the following areas:</p><p>• Aggregate storage outline formulas</p><p>• Block storage outline formulas</p><p>• Calculation scripts (block storage databases only)</p><p>• Substitution variables and runtime substitution variables are supported in calculation scripts. </p><p>• Data load rules file header definitions and field definitions. You can enter variable names for dimension and member names.</p><p>• Data source name (DSN) specifications in rules files for SQL data sources</p><p>• <code>SELECT</code>, <code>FROM</code>, or <code>WHERE</code> clauses in rules files for SQL data sources</p><p>• Security filters</p><p>• MDX statements</p><p>• Smart View</p><p><br></p><p><strong>Creating, Showing and Deleting Substitution Variables</strong></p><p>Substitution variables can be explicitly created with the DEFINE command. Defining a variable means storing a value for future use:</p><pre class=\"prettyprint linenums\">SQL&gt; define myv = 'King'</pre><p>This creates a variable called \"myv\" containing the text \"King\".</p><p>Another way to create substitution variables is with the <code>ACCEPT</code> command. This can be used to prompt for a value:</p><pre class=\"prettyprint linenums\">SQL&gt; accept myv2 char prompt 'Enter a last name: '</pre><p><em>A substitution variable used to prompt for a column name must be enclosed in single quotation marks.</em></p><p>This command causes SQL*Plus to stop and prompt you to enter a character string:</p><pre class=\"prettyprint linenums\">Enter a last name: _</pre><p>What you enter is stored in the variable \"myv2\".</p><p>The DEFINE command can also be used to display known variables. It shows the variable name, value, and type. Any variable that DEFINE list is said to be <em>defined</em>:</p><pre class=\"prettyprint linenums\">SQL&gt; define myv     DEFINE MYV             = \"King\" (CHAR)</pre><p>All variables that are currently defined can be shown by executing the DEFINE command with no arguments:</p><pre class=\"prettyprint linenums\">SQL&gt; define\nDEFINE MYV             = \"King\" (CHAR)\nDEFINE MYV2            = \"Taylor\" (CHAR)\n...</pre><p>Any variable not listed is <em>undefined</em>:</p><pre class=\"prettyprint linenums\">SQL&gt; define abc\nSP2-0135: symbol abc is UNDEFINED</pre><p>Substitution variables can be removed with the UNDEFINE command:</p><pre class=\"prettyprint linenums\">SQL&gt; undefine myv</pre><p><br></p><p><strong>Prompting for Undefined Variables</strong></p><p>If a variable is referenced using an \"&amp;\" prefix, but the variable value is not yet defined, SQL*Plus prompts you for a value:</p><pre class=\"prettyprint linenums\">SQL&gt; define myname\nSP2-0135: symbol myname is UNDEFINED\nSQL&gt; select employee_id from employees where last_name = '&amp;myname';\nEnter value for myname:</pre><p>After you enter a value, SQL*Plus substitutes the variable and executes the query.</p><p>The Oracle Globalization Language setting (e.g., the language component of the NLS_LANG environment variable) determines the exact language used for the \"Enter value for\" prompt. The prompt text cannot otherwise be changed.</p><p><br></p><p><strong>Difference Between \"&amp;\" and \"&amp;&amp;\" Prefixes</strong></p><p>Both single ampersand (&amp;) and double ampersand (&amp;&amp;) can prefix a substitution variable name in a statement. SQL*Plus pre-processes the statement and substitutes the variable's value. The statement is then executed. If the variable was not previously defined, then SQL*Plus prompts you for a value before doing the substitution.</p><p>If a single ampersand prefix is used with an undefined variable, the value you enter at the prompt is not stored. Immediately after the value is substituted in the statement, the variable is discarded and remains undefined. If the variable is referenced twice, even in the same statement, then you are prompted twice. Different values can be entered at each prompt. </p><p>If a double ampersand reference causes SQL*Plus to prompt you for a value, then SQL*Plus defines the variable as that value (i.e., the value is stored until you exit). Any subsequent reference to the variable (even in the same command) using either \"&amp;\" or \"&amp;&amp;\" substitutes the newly defined value. SQL*Plus will not prompt you again.</p><p><br></p><p><strong>You can set substitution variables at these levels:</strong></p><p>Cloud service: Provides access to the variable from all applications and databases on the cloud service instance.</p><p>Application: Provides access to the variable from all databases within the application.</p><p>Database: Provides access to the variable within the specified database.</p>",
                "answers": [
                    "<p>A substitution variable can be used with any clause in a SELECT statement</p>",
                    "<p>A substitution variable used to prompt for a column name must be enclosed in a single quotation marks</p>",
                    "<p>A substitution variable prefixed with &amp; always prompts only once for a value in a session</p>",
                    "<p>A substitution variable can be used only in a SELECT statement</p>",
                    "<p>Substitution variables are global or per-application placeholders that represent variable values. </p>",
                    "<p>A substitution variable prefixed with &amp;&amp; prompts only once for a value in a session unless it is set to undefined in the session</p>"
                ]
            },
            "correct_response": [
                "a",
                "e",
                "f"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following SQL exhibit.Identify the true statements about substitution variables. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306017,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding constraints. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle PRIMARY KEY](https://www.oracletutorial.com/oracle-basics/oracle-primary-key/)",
                    "[Oracle / PLSQL: Primary Keys](https://www.techonthenet.com/oracle/primary_keys.php)"
                ],
                "feedbacks": [
                    "This statement is incorrect. A table can have only one primary key, but it can have multiple foreign keys referencing different tables.",
                    "This statement is correct. A table can have only one primary key, but it can have multiple foreign keys referencing different tables.",
                    "This statement is incorrect. Both primary key and foreign key constraints can be defined at both column and table levels.",
                    "This statement is incorrect. The foreign key and parent table primary key do not have to have the same name, although it is a common practice for clarity.",
                    "This statement is correct. Both primary key and foreign key constraints can be defined at both column and table levels.",
                    "This statement is incorrect. A table can have only one primary key, but it can have multiple foreign keys referencing different tables."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><p><strong>A table can have only one primary key but multiple foreign keys.</strong></p><ul><li><p>The <strong>primary key must be unique</strong>, hence only one per table.</p></li><li><p><strong>Foreign keys</strong> can be many, referencing <strong>different columns or tables</strong>.</p></li></ul><p><strong>Both primary key and foreign key constraints can be defined at both column and table levels.</strong></p><ul><li><p>This is correct. Both types of constraints can be defined:</p><ul><li><p><strong>Column level</strong>: within the column definition.</p></li><li><p><strong>Table level</strong>: separately, after all columns are defined.</p></li></ul></li></ul><p><strong>Incorrect Statements:</strong></p><p><strong>A table can have only one primary key and one foreign key.</strong></p><ul><li><p>A table can have <strong>only one primary key</strong>, but it can have <strong>multiple foreign keys</strong> referencing different parent tables or columns.</p></li></ul><p><strong>Only the primary key can be defined at the column and table levels.</strong></p><ul><li><p><strong>All constraints</strong> (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) can be defined at <strong>both the column level and table level</strong>, except <strong>NOT NULL</strong>, which is only column-level.</p></li></ul><p><strong>The foreign key and parent table primary key must have the same name.</strong></p><ul><li><p>The <strong>constraint names</strong> are independent. The foreign key and the referenced primary key <strong>do not need to share names</strong>.</p></li></ul><p><strong>A table can have multiple primary and foreign keys.</strong></p><ul><li><p>A table can have <strong>only one primary key</strong>.</p></li><li><p>It <strong>can</strong> have <strong>multiple foreign keys</strong>, but the statement says <strong>multiple primary keys</strong>, which is incorrect.</p></li></ul><p><strong>The following are rules that make a column a primary key:</strong></p><p>• A primary key column cannot contain a NULL value or an empty string.</p><p>• A primary key value must be unique within the entire table.</p><p>• A primary key value should not be changed over time.</p><p>• According to these rules, the following are the recommendations for the primary keys:</p><p>First, the primary key should be meaningless. Sometimes, you may want to use meaningful data, which is considered unique, for the primary keys, e.g., social security number (SSN), vehicle identification number (VIN), email, and phone number. However, you don’t know when the email or phone number changes or is reused by another person. In such cases, it will create many data problems. In the database world, the artificial keys are known as <em>surrogate keys,</em> which are in opposition to <em>natural</em> primary keys.</p><p>Second, the primary keys should be compact. The primary keys typically are numeric because Oracle processes numbers faster than any other data type.</p><p>It is considered a best practice to have a primary key in every table, though it is not mandatory in Oracle.</p><p>To create a primary key in a table, you use the <code>PRIMARY KEY</code> constraint.</p><p><br></p><p><strong>Defining </strong><code><strong>PRIMARY&nbsp;KEY</strong></code><strong> at </strong><code><strong>COLUMN&nbsp;LEVEL</strong></code><strong> and </strong><code><strong>TABLE LEVEL</strong></code><strong>:</strong></p><p>a. Column Level</p><pre class=\"prettyprint linenums\">CREATE TABLE table(\n    col1 INT CONSTRAINT pk_col1_pid PRIMARY KEY,\n    col2 VARCHAR(25)\n);</pre><p><br></p><p>b. Table Level</p><pre class=\"prettyprint linenums\">CREATE TABLE table(\n    col1 INT,\n    col2 VARCHAR(25),\n    CONSTRAINT pk_col1_pid PRIMARY KEY(col1)\n);</pre><p><br></p><p>In Oracle, a <code>PRIMARY&nbsp;KEY</code> is a single field or combination of fields that uniquely defines a record. None of the fields that are part of the primary key can contain a null value. A table can have only one primary key.</p><p>There can be a <code>PRIMARY&nbsp;KEY</code> on more than one column, but a <code>TABLE</code>&nbsp;can have only one <code>PRIMARY&nbsp;KEY</code>.</p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE table(\n    col1 NUMBER NOT NULL,\n    col2 NUMBER NOT NULL,\n    ...\n    PRIMARY KEY (col1, col2)\n);</pre><p><br></p><p>In this example, the primary key of the table consists of two columns: <code>col1</code> and <code>col2</code>. It means that the combination of values of these columns uniquely identifies the line item.</p><p>This example did not use the <code>CONSTRAINT</code> clause to explicitly assign the <code>PRIMARY KEY</code> constraint a name. Therefore, Oracle implicitly assigned the primary key constraint a system-generated name such as <code>SYS_C0010617</code>.</p>",
                "answers": [
                    "<p>A table can have only one primary key and one foreign key.</p>",
                    "<p>A table can have only one primary key but multiple foreign keys.</p>",
                    "<p>Only the primary key can be defined at the column and table levels.</p>",
                    "<p>The foreign key and parent table primary key must have the same name.</p>",
                    "<p>Both primary key and foreign key constraints can be defined at both column and table levels.</p>",
                    "<p>A table can have multiple primary and foreign keys.</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding constraints. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306019,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the tasks that can be performed using Oracle SQL statements. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Preparing to Access and Modify Information in Multiple Oracle Databases](https://docs.oracle.com/cd/B28359_01/server.111/b28324/tdpii_distdbs.htm#TDPII018)",
                    "[Connecting to Oracle Database and Exploring It](https://docs.oracle.com/en/database/oracle/oracle-database/23/tdddg/connecting-exploring-database.html)",
                    "[CREATE DATABASE LINK](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CREATE-DATABASE-LINK.html)"
                ],
                "feedbacks": [
                    "Changing the password for an existing database user can be performed using Oracle SQL statements by executing the appropriate ALTER USER command to modify the user's password in the database.",
                    "Connecting to a database instance is not a task that can be directly performed using Oracle SQL statements. It requires external tools or clients to establish a connection to the database instance.",
                    "Querying data from tables in different databases is a task that can be achieved using Oracle SQL statements. By writing SQL queries that include database links, data from tables in different databases can be accessed and queried.",
                    "Starting up a database instance is an administrative task that is typically performed using database management tools or commands specific to the database system, such as SQL*Plus commands or Oracle Enterprise Manager. It is not a task that can be directly executed using Oracle SQL statements.",
                    "Executing operating system (OS) commands in a session is not a task that can be performed using Oracle SQL statements. Oracle SQL is designed to query and manipulate data within the database, not to interact with the operating system directly. Operating system commands are typically executed outside of the database environment."
                ],
                "explanation": "<p><strong>Correct Answers:</strong></p><ol><li><p><strong>Changing the password for an existing database user</strong><br><strong>Yes</strong> – You can do this with the <code>ALTER USER</code> SQL statement.<br>Example:</p><pre class=\"prettyprint linenums\">sql\nALTER USER username IDENTIFIED BY new_password;</pre><p><br></p></li><li><p><strong>Querying data from tables in different databases</strong><br><strong>Yes</strong> – This can be done using <strong>database links</strong> in Oracle.<br>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM employees@hrdb;</pre></li></ol><p> </p><p>The remaining tasks, such as starting up or connecting to a database instance, or executing OS commands, typically fall outside the capabilities of standard SQL statements and require administrative tools or privileges.</p><p><strong>Incorrect Options:</strong></p><p><strong>Connecting to a database instance</strong></p><ul><li><p><strong>No</strong> – Connecting is done via a client tool or interface (like SQL*Plus, SQL Developer), <strong>not</strong> through an SQL statement.</p></li></ul><p><strong>Starting up a database instance</strong></p><ul><li><p><strong>No</strong> – This is an <strong>administrative task</strong>, typically done using <strong>SQL*Plus commands</strong> like <code>STARTUP</code>, not through SQL.</p></li></ul><p><strong>Executing operating system (OS) commands in a session</strong></p><ul><li><p><strong>No</strong> – Oracle SQL does not support executing OS-level commands directly (though PL/SQL with external procedures or tools like DBMS_SCHEDULER can, that's not standard SQL).</p></li></ul><p><br></p><p>To change a user's password in Oracle, you need to execute the <em>ALTER USER</em> command.</p><p><strong>Syntax</strong></p><p>The syntax for changing a password in Oracle is:</p><pre class=\"prettyprint linenums\">ALTER USER user_name IDENTIFIED BY new_password;</pre><p><strong>Parameters or Arguments</strong></p><p>user_name:&nbsp; The user whose password you wish to change. new_password The new password to assign.</p><p><br></p><p><strong>Querying Multiple Oracle Databases</strong></p><p>A distributed query accesses information in two or more databases. In a synonym or in a <code>SELECT</code> statement, you can identify a remote table, view, or materialized view by appending <code>@dblink</code> to the end of its name. The <code>dblink</code> is a database link to the database that contains the remote database object.</p><p>You connect to Oracle Database only through a client program, such as SQL*Plus or SQL Developer (Not Oracle SQL statements).</p><p>Use the <code>CREATE DATABASE LINK</code> statement to create a database link. A database link is a schema object in one database that enables you to access objects on another database. The other database need not be an Oracle Database system. However, to access non-Oracle systems, you must use Oracle Heterogeneous Services.</p><p>After you have created a database link, you can use it in SQL statements to refer to tables, views, and PL/SQL objects in the other database by appending <code>@dblink</code> to the table, view, or PL/SQL object name. You can query a table or view in the other database with the <code>SELECT</code> statement. You can also access remote tables and views using any <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, or <code>LOCK TABLE</code> statement.</p>",
                "answers": [
                    "<p>Changing the password for an existing database user</p>",
                    "<p>Connecting to a database instance</p>",
                    "<p>Querying data from tables in different databases</p>",
                    "<p>Starting up a database instance</p>",
                    "<p>Executing operating system (OS) commands in a session</p>"
                ]
            },
            "correct_response": [
                "a",
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the tasks that can be performed using Oracle SQL statements. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306101,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following SQL statements will correctly retrieve all employees whose salaries are higher than the department's average salary in the <code>EMPLOYEES</code> table?</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL statement correctly retrieves all employees whose salaries are higher than the department's average salary by using a correlated subquery. The subquery calculates the average salary for each department and compares it with the employee's salary in the main query, ensuring that only employees with salaries higher than their department's average are returned.",
                    "This SQL statement retrieves all employees whose salaries are higher than the overall average salary in the EMPLOYEES table. It does not consider the department-wise average salary, so it does not meet the requirement of the question to retrieve employees with salaries higher than their department's average.",
                    "This SQL statement uses the ANY keyword with a subquery to compare each employee's salary with any department's average salary. It does not specifically calculate the average salary for each department, so it does not accurately retrieve employees with salaries higher than their department's average.",
                    "This SQL statement uses the ALL keyword with a subquery to compare each employee's salary with all department average salaries. It does not accurately retrieve employees with salaries higher than their department's average because it compares each employee's salary with all department averages, not just their own department's average."
                ],
                "explanation": "<p><strong>The correct query is:</strong></p><pre class=\"prettyprint linenums\">SELECT e.employee_id, e.first_name, e.salary\nFROM employees e\nWHERE e.salary &gt; (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);</pre><p><br></p><p>It ensures that each employee’s salary is compared only to the average salary within their department. This ensures that employees earning above their department's average salary are correctly identified.</p><p><strong>Why this Option is Correct:</strong></p><ol><li><p>The subquery inside the <code>WHERE</code> clause:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT AVG(salary) \nFROM employees \nWHERE department_id = e.department_id</pre><p><br></p><ul><li><p>This calculates the <strong>average salary for each department</strong>.</p></li><li><p>The crucial part is <code>WHERE department_id = e.department_id</code>, which ensures that the subquery returns the average salary <strong>only for the department of the current employee being evaluated</strong>.</p></li></ul><p><br></p></li><li><p>The main query:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT e.employee_id, e.first_name, e.salary \nFROM employees e \nWHERE e.salary &gt; (subquery);</pre><p><br></p><ul><li><p>This selects employees whose salary is <strong>greater than</strong> the average salary of their department.</p></li></ul><p><br></p></li></ol><p><strong>Incorrect Options:</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary \nFROM employees \nWHERE salary &gt; (\n    SELECT AVG(salary) \n    FROM employees);</pre><p><br></p><ul><li><p>This compares each employee’s salary to the <strong>overall average salary</strong> across the entire <code>employees</code> table.</p></li><li><p>Instead of filtering by department, it treats <strong>all employees as one group</strong>, making it incorrect.</p></li></ul><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE salary &gt; ALL (SELECT AVG(salary) FROM employees GROUP BY department_id);\nWhy Options C and D Are Incorrect:</pre><pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE salary &gt; ANY (SELECT AVG(salary) FROM employees GROUP BY department_id);</pre><p><br></p><ul><li><p><code>ALL</code> and <code>ANY</code> operate differently than what’s needed for this scenario.</p></li><li><p><code>ALL (SELECT AVG(salary) FROM employees GROUP BY department_id);</code> means an employee’s salary must be <strong>higher than every department's average</strong>, which is not what we want.</p></li><li><p><code>ANY (SELECT AVG(salary) FROM employees GROUP BY department_id);</code> checks if an employee’s salary is <strong>higher than at least one department's average</strong>, which is incorrect as well.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT e.employee_id, e.first_name, e.salary\nFROM employees e\nWHERE e.salary &gt; (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE salary &gt; (SELECT AVG(salary) FROM employees);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE salary &gt; ANY (SELECT AVG(salary) FROM employees GROUP BY department_id);</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT employee_id, first_name, salary\nFROM employees\nWHERE salary &gt; ALL (SELECT AVG(salary) FROM employees GROUP BY department_id);</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "Which of the following SQL statements will correctly retrieve all employees whose salaries are higher than the department's average salary in the EMPLOYEES table?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306021,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about defining relations between tables in a relational database. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle PRIMARY KEY](https://www.oracletutorial.com/oracle-basics/oracle-primary-key/)",
                    "[What Is a Relational Database? (RDBMS)?](https://www.oracle.com/uk/database/what-is-a-relational-database/)",
                    "[Can foreign key be NULL?](https://community.oracle.com/thread/1274132)"
                ],
                "feedbacks": [
                    "Primary key columns are used to uniquely identify each record in a table, and by definition, they cannot have null values. This ensures the integrity and uniqueness of the data in the table.",
                    "In a relational database, every primary key or unique key value must have a corresponding foreign key value in another table. This relationship ensures data consistency and integrity across related tables.",
                    "Foreign key columns are used to establish relationships between tables by referencing the primary or unique key in another table. Unlike primary key columns, foreign key columns can allow null values to accommodate optional relationships.",
                    "For a foreign key to maintain referential integrity, every value in the foreign key column must correspond to a valid primary or unique key value in the referenced table. This ensures that data relationships are maintained correctly.",
                    "Unique key columns, like primary key columns, are used to enforce data integrity by ensuring uniqueness. Therefore, unique key columns also do not allow null values to maintain the uniqueness constraint."
                ],
                "explanation": "<p><strong>Correct Options:</strong></p><ol><li><p><strong>Primary key columns do not allow null values.</strong><br><strong>True.</strong> A primary key must uniquely identify each row in a table, so it <strong>cannot contain null values</strong>.</p></li><li><p><strong>Foreign key columns allow null values.</strong> <br><strong>True.</strong> Foreign key columns <strong>can</strong> be null, depending on how the relationship is defined. This indicates optional relationships.</p></li><li><p><strong>Every foreign key value must refer to a matching primary or unique key value.</strong> <br><strong>True.</strong> This is the essence of <strong>referential integrity</strong> — any non-null foreign key value <strong>must</strong> exist in the referenced table as a primary or unique key.</p></li></ol><p><strong>Incorrect Options:</strong></p><p><strong>Every primary or unique key value must refer to a matching foreign key value.</strong> </p><ul><li><p><strong>False.</strong> This is <strong>backwards</strong>. It is the <strong>foreign key</strong> that refers to the <strong>primary or unique key</strong> in another table, not the other way around.</p></li></ul><p><strong>Unique key columns do not allow null values.</strong> </p><ul><li><p><strong>False.</strong> Unique key columns <strong>can allow</strong> nulls, but the nulls must be unique (and in many databases, <strong>multiple nulls are allowed</strong> since null ≠ null).</p></li></ul><p>What is the difference between 'Primary key columns do not allow null values' and 'Unique key columns do not allow null values'? Specifically, why is 'Primary key columns do not allow null values' True, and 'Unique key columns do not allow null values' False? </p><p>In Oracle, the key difference lies in their purpose and how they handle <code>NULL</code> values. A <strong>primary key</strong> is designed to be the definitive, non-negotiable identifier for each row in a table, whereas a <strong>unique key</strong> is used to enforce uniqueness for a column or a set of columns that may not be the main identifier for the table.</p><p><br></p><p><strong>Primary Key Columns Do Not Allow NULL Values</strong></p><p>This statement is <strong>true</strong> because a primary key's fundamental role is to provide a unique and definite identifier for every single row in a table. A <code>NULL</code> value, by definition, represents a missing, unknown, or inapplicable value.</p><p><strong>No Unique Identity:</strong> If a column designated as a primary key were allowed to have a <code>NULL</code> value, that row would not have a unique identifier. You cannot use an \"unknown\" value to refer to a specific record.</p><p><strong>Referential Integrity:</strong> Primary keys are used to enforce <strong>referential integrity</strong> through <strong>foreign keys</strong>. A foreign key in one table references the primary key of another table. If the primary key could be <code>NULL</code>, the foreign key could not reliably point to a specific parent row, breaking the integrity of the data model.</p><p>In essence, the \"not null\" constraint is an inherent and essential part of the primary key constraint.</p><p><br></p><p><strong>Unique Key Columns Do Not Allow NULL Values</strong></p><p>This statement is <strong>false</strong> in Oracle. Unlike a primary key, a unique key constraint is purely about ensuring that no two rows have the same value for the specified column(s). However, Oracle's implementation of the unique constraint allows for <code>NULL</code> values.</p><p><code><strong>NULL</strong></code><strong> Is Not a Value:</strong> In standard SQL and in Oracle, <code>NULL</code> is not considered a value. It represents the absence of a value. When Oracle checks for uniqueness, it does not compare <code>NULL</code> with <code>NULL</code>. Instead, it treats each <code>NULL</code> as a distinct entry.</p><p><strong>Multiple </strong><code><strong>NULL</strong></code><strong>s are Allowed:</strong> This unique behaviour means that a unique key column in Oracle can contain multiple rows with <code>NULL</code> in that column without violating the uniqueness constraint.</p><p><strong>Composite Unique Keys:</strong> The behaviour changes slightly for <strong>composite unique keys</strong> (a unique key made of multiple columns). If a row has non-<code>NULL</code> values for some columns and <code>NULL</code> for others, that combination can only appear once. However, a row where all columns of the composite key are <code>NULL</code> can be duplicated multiple times.</p><p>In summary, a <strong>primary key</strong> must always be unique and non-<code>NULL</code> to fulfill its purpose as a row identifier, while a <strong>unique key</strong> only enforces uniqueness for non-<code>NULL</code> values and allows for multiple <code>NULL</code>s because <code>NULL</code> is not treated as a comparable value.</p><p>A <em>primary key</em> is a column or a combination of columns in a table that uniquely identifies a row in the table.</p><p>The following are rules that make a column a primary key:</p><p>• A primary key column cannot contain a NULL value or an empty string.</p><p>• A primary key value must be unique within the entire table.</p><p>• A primary key value should not be changed over time.</p><p>A <em>relational database</em> is a type of <a href=\"https://www.oracle.com/uk/database/what-is-database.html\">database</a> that stores and provides access to data points that are related to one another. Relational databases are based on the relational model, an intuitive, straightforward way of representing data in tables. In a relational database, each row in the table is a record with a unique ID called the <em>key</em>. The columns of the table hold attributes of the data, and each record usually has a value for each attribute, making it easy to establish the relationships among data points.</p><p>The relational model permits the value of foreign keys either to match the referenced primary or unique key value or to be null. If any column of a composite foreign key is null, then the non-null portions of the key do not have to match any corresponding portion of a parent key.</p><p><strong>A foreign key must reference either the primary key or a unique key of the parent table</strong>. If the primary key has multiple columns, the foreign key must have the same number and order of columns. <strong>Therefore, the foreign key references a unique row in the parent table; there can be no duplicates.</strong></p><p>Any primary key must be unique and non-null. Therefore, if the child table has a foreign key referencing the parent's primary key, it must match a non-null, unique value, and therefore references exactly one row in the parent table. In this case, you can't make a child row that references multiple parent rows.</p><p>You <em>can</em> create a child row whose foreign key column is NULL, in which case it references no row in the parent table.</p><p><a href=\"https://stackoverflow.com/questions/8706073/does-foreign-key-always-reference-to-a-unique-key-in-another-table#8706094\">https://stackoverflow.com/questions/8706073/does-foreign-key-always-reference-to-a-unique-key-in-another-table#8706094</a></p>",
                "answers": [
                    "<p>Primary key columns does not allow null values.</p>",
                    "<p>Every primary or unique key value must refer to a matching foreign key value.</p>",
                    "<p>Foreign key columns allow null values.</p>",
                    "<p>Every foreign key value must refer to a matching primary or unique key value.</p>",
                    "<p>Unique key columns do not allow null values.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements about defining relations between tables in a relational database. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306023,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Scenario: </strong>Your office you are currently located, is in Madrid, Spain.&nbsp; You have connected to a remote database in Toronto, Canada. </p><p>The following SQL query has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT ROUND (sysdate-hiredate,0)\nFROM employees\nWHERE (sysdate-hiredate)/180 =2;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The ROUND function can be used with Date arguments in SQL. It is a valid function to round a date value to the nearest integer, so the query will not result in an error due to the ROUND function.",
                    "The WHERE condition in the query is comparing the current date in Toronto, Canada with the hire date of employees. As long as the WHERE condition is properly structured and the columns being compared exist in the tables, the query will not result in an error due to an invalid WHERE condition expression.",
                    "The query calculates the number of days since the employee was hired based on the current date and time in Toronto, Canada. By using the hire date of employees and the current date in Toronto, the query accurately determines the number of days since the employee was hired.",
                    "The query is based on the current date and time in Toronto, Canada, so it calculates the number of days since the employee was hired using this time zone. If the query was intended to calculate based on the current date and time in Madrid, Spain, it would need to consider the time zone conversion, but in this case, it is based on Toronto, Canada."
                ],
                "explanation": "<p>Scenario Recap:</p><ul><li><p>You're in <strong>Madrid, Spain</strong>.</p></li><li><p>You're <strong>connected to a remote database in Toronto, Canada</strong>.</p></li><li><p>You're running this query:</p></li></ul><pre class=\"prettyprint linenums\">SELECT ROUND (sysdate-hiredate,0)\nFROM employees\nWHERE (sysdate-hiredate)/180 =2;</pre><p><br></p><p>Key Details:</p><ul><li><p><code><strong>SYSDATE</strong></code> returns the <strong>current date and time of the database server</strong>, <strong>not</strong> the client machine.</p></li><li><p>So in this case, <code><strong>SYSDATE</strong></code><strong> will return the current date/time in Toronto, Canada</strong> (where the DB is hosted).</p></li><li><p><code><strong>SYSDATE - HIREDATE</strong></code> returns the number of days between the two dates.</p></li><li><p><code><strong>ROUND(SYSDATE - HIREDATE, 0)</strong></code> rounds the result to the nearest whole number of days — this is valid and does <strong>not</strong> cause an error.</p></li><li><p>The WHERE clause <code>WHERE (SYSDATE - HIREDATE)/180 = 2</code> checks if the employee was hired <strong>360 days ago</strong>, which is also syntactically correct (though may return zero rows depending on data).</p></li></ul><p>The correct interpretation is: <strong>Number of days since the employee was hired based on the current Toronto, Canada date and time.</strong></p><p>The <code>SYSDATE</code> function will take the current time of the database that it is connecting to remotely, in this case, Toronto, Canada. </p><p>It will then calculate the number of days since the employee was hired based on the current Toronto, Canada date and time.</p><p>You must perform basic arithmetic operations to adjust the time zone.</p><p>Why are the other options wrong:</p><ul><li><p><strong>\"An error because the ROUND function cannot be used with Date arguments\"</strong> – Incorrect; <code>ROUND(date - date)</code> is valid, as the result is a <strong>number</strong>.</p></li><li><p><strong>\"An error because the WHERE condition expression is invalid\"</strong> – The expression is valid SQL.</p></li><li><p><strong>\"Based on the Madrid, Spain date and time\"</strong> – SYSDATE uses <strong>server time</strong>, not the client’s local time.</p></li></ul>",
                "answers": [
                    "<p>An error because the ROUND function cannot be used with Date arguments.</p>",
                    "<p>An error because the WHERE condition expression is invalid.</p>",
                    "<p>Number of days since the employee was hired based on the current Toronto Canada date and time.</p>",
                    "<p>Number of days since the employee was hired based on the current Madrid, Spain date and time.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario.Scenario: Your office you are currently located, is in Madrid, Spain.&nbsp; You have connected to a remote database in Toronto, Canada. The following SQL query has been executed.Exhibit: 1SELECT ROUND (sysdate-hiredate,0)\nFROM employees\nWHERE (sysdate-hiredate)/180 =2;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306025,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the tasks that can be performed by DDL statements. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Types of SQL Statements](https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm)",
                    "[CREATE SYNONYM](https://docs.oracle.com/cd/A91202_01/901_doc/server.901/a90125/statements_72a.htm)",
                    "[Guidelines for Securing User Accounts and Privileges](https://docs.oracle.com/cd/B28359_01/network.111/b28531/guidelines.htm#DBSEG98450)"
                ],
                "feedbacks": [
                    "Providing an alternative name for a table is a task that can be performed using Data Definition Language (DDL) statements. This can be achieved by using the RENAME TO clause in an ALTER TABLE statement to change the name of a table.",
                    "Modifying a table to prevent data that violate certain conditions from being entered in a column is a task that can be performed using DDL statements. This can be accomplished by adding constraints such as CHECK constraints to the table definition to enforce data integrity rules.",
                    "Preventing any data modification to a table is a task that can be performed using DDL statements. This can be achieved by using the READ ONLY clause in an ALTER TABLE statement to restrict any modifications to the table's data.",
                    "Preventing data retrieval from a table outside of office hours is not a task that can be performed by DDL statements. DDL statements are used to define the structure of database objects, such as tables, indexes, and constraints, and do not control the access or retrieval of data based on time constraints.",
                    "Creating multiple savepoints to enable partial rollback of a transaction is not a task that can be performed by DDL statements. Savepoints are used in Data Manipulation Language (DML) statements to provide a point within a transaction to which you can roll back."
                ],
                "explanation": "<p>To answer this question correctly, we need to identify which tasks are performed using <strong>Data Definition Language (DDL)</strong> statements. DDL statements are used to define and manage database objects like tables, indexes, and constraints. Common DDL statements include <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>TRUNCATE</code>, <code>RENAME</code>, and <code>COMMENT</code>.</p><p><strong>Correct Answers</strong></p><ol><li><p><strong>Providing an alternative name for a table</strong></p><p>Yes — This is done using the <code>RENAME</code> statement, which is a DDL operation.</p></li><li><p><strong>Modifying a table to prevent data that violates certain conditions from being entered in a column</strong><br>Yes — This involves adding constraints (e.g., <code>ALTER TABLE ... ADD CONSTRAINT</code>), which is a DDL task.</p></li><li><p><strong>Preventing any data modification to a table</strong><br>Yes — This can be achieved by making a table <strong>read-only</strong> using DDL statements or by using constraints or locking the table.</p></li></ol><p><strong>Incorrect Options</strong></p><p><strong>Preventing data retrieval from a table outside of office hours</strong></p><ul><li><p>No — This is related to <strong>data access control</strong>, which typically involves triggers or application logic, not DDL.</p></li></ul><p><strong>Creating multiple savepoints to enable partial rollback of a transaction</strong></p><ul><li><p>No — This is a <strong>transaction control</strong> operation, handled with <code>SAVEPOINT</code>, <code>ROLLBACK</code>, and <code>COMMIT</code>, which are <strong>not DDL</strong> but <strong>TCL (Transaction Control Language)</strong>.</p></li></ul><p><br></p><p><strong>DDL Statements [Oracle]</strong></p><p> DDL stands for <em>data definition language</em>. DDL statements are <a href=\"http://www.adp-gmbh.ch/ora/concepts/sql_stmt.html\">SQL Statements</a> that define or alter a data structure, such as a table. Hence, a typical DDL statement is <a href=\"http://www.adp-gmbh.ch/ora/sql/create_table.html\">create table</a> or <a href=\"http://www.adp-gmbh.ch/ora/sql/alter_table.html\">alter table</a>.</p><p><strong>Implicit commits</strong></p><p> In Oracle, a (successful) DDL statement implicitly <a href=\"http://www.adp-gmbh.ch/ora/sql/commit.html\">commits</a> a transaction;</p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; create table ddl_test_1 (a number);\nSQL&gt; insert into ddl_test_1 values (1);\nSQL&gt; commit;</pre><pre class=\"prettyprint linenums\">SQL&gt; insert into ddl_test_1 values (2);\nSQL&gt; create table ddl_test_2 (a number);\nSQL&gt; rollback;</pre><p><br></p><p> The create table statement implicitly committed the transaction. The insertion of the value 2 into ddl_test_1 cannot be rolled back anymore.</p><p><br></p><pre class=\"prettyprint linenums\">SQL&gt; select * from ddl_test_1;\n\n         A\n----------\n         1\n         2</pre><p><br></p><p><strong>Data dictionary</strong></p><p>Since DDL changes definitions of <a href=\"http://www.adp-gmbh.ch/ora/admin/objects.html\">database objects</a>, DDL is always reflected in the <a href=\"http://www.adp-gmbh.ch/ora/misc/data_dictionary.html\">data dictionary</a>.</p><p><a href=\"http://www.adp-gmbh.ch/ora/sql/ddl.html\">http://www.adp-gmbh.ch/ora/sql/ddl.html</a></p><p><br></p><p><strong>Data definition language (DDL) statements let you perform these tasks:</strong></p><p>• Create, alter, and drop schema objects</p><p>• Grant and revoke privileges and roles</p><p>• Analyze information on a table, index, or cluster</p><p>• Establish auditing options</p><p>• Add comments to the data dictionary</p><p>Use the <code>CREATE SYNONYM</code> statement to create a <strong>synonym</strong>, which is an alternative name for a table, view, sequence, procedure, stored function, package, materialized view, Java class schema object, or another synonym.</p><p>Synonyms provide both data independence and location transparency. Synonyms permit applications to function without modification regardless of which user owns the table or view and regardless of which database holds the table or view.</p><p>A <code>CONSTRAINT</code> clause is an optional part of a <a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj24513.html#rrefsqlj24513\">CREATE TABLE statement</a> or <a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj81859.html#rrefsqlj81859\">ALTER TABLE statement</a>. A constraint is a rule to which data must conform. Constraint names are optional.</p><p>A <code>CONSTRAINT</code> can be one of the following: a column-level constraint</p><p><strong>Column-level constraints</strong> refer to a single column in the table and do not specify a column name (except check constraints). They refer to the column that they follow.</p><p><br></p><pre class=\"prettyprint linenums\">-- column-level primary key constraint named OUT_TRAY_PK\nCREATE TABLE SAMP.OUT_TRAY\n\t(\n\tSENT TIMESTAMP,\n\tDESTINATION CHAR(8),\n\tSUBJECT CHAR(64) NOT NULL CONSTRAINT OUT_TRAY_PK PRIMARY KEY,\n\tNOTE_TEXT VARCHAR(3000) \n   );</pre><p><br></p><p><strong>Table-level constraints</strong> refer to one or more columns in the table. Table-level constraints specify the names of the columns to which they apply. Table-level CHECK constraints can refer to 0 or more columns in the table.</p><p><br></p><pre class=\"prettyprint linenums\">-- the table-level primary key definition allows you to include \n-- two columns in the primary key definition\nCREATE TABLE SAMP.SCHED \n\t(\n\tCLASS_CODE CHAR(7) NOT NULL, \n\tDAY SMALLINT NOT NULL, \n\tSTARTING TIME, \n\tENDING TIME,\n\tPRIMARY KEY (CLASS_CODE, DAY)\n\t);</pre><p><br></p><p><strong>Grant necessary privileges only.</strong></p><p>Do not provide database users or roles with more privileges than are necessary. (If possible, grant privileges to roles, not users.) In other words, the principle of least privilege is that users be given only those privileges that are actually required to efficiently perform their jobs.</p><p>To implement this principle, restrict the following as much as possible:</p><p>• The number of <code>SYSTEM</code> and <code>OBJECT</code> privileges granted to database users.</p><p>• The number of people who are allowed to make <code>SYS</code>-privileged connections to the database.</p><p>• The number of users who are granted the <code>ANY</code> privileges, such as the <code>DROP ANY TABLE</code> privilege. For example, there is generally no need to grant <code>CREATE ANY TABLE</code> privileges to a non-DBA-privileged user.</p><p>• The number of users who are allowed to perform actions that create, modify, or drop database objects, such as the <code>TRUNCATE TABLE</code>, <code>DELETE TABLE</code>, <code>DROP TABLE</code> statements, and so on.</p><p><br></p><p><strong>Use the </strong><code><strong>GRANT</strong></code><strong> statement to grant:</strong></p><p>• System privileges to users and roles.</p><p>• Roles to users and roles. Both privileges and roles are either local, global, or external. </p><p>• Object privileges for a particular object to users, roles, and <code>PUBLIC</code>. </p><p>Examples:</p><p><br></p><pre class=\"prettyprint linenums\">GRANT CREATE SESSION \n   TO hr; </pre><pre class=\"prettyprint linenums\">GRANT dw_manager \n   TO sh \n   WITH ADMIN OPTION; </pre><pre class=\"prettyprint linenums\">GRANT SELECT ON sh.sales \n   TO warehouse_user;</pre><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9013.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9013.htm</a></p>",
                "answers": [
                    "<p>Providing an alternative name for a table</p>",
                    "<p>Modifying a table to prevent data that violate certain conditions from being entered in a column</p>",
                    "<p>Preventing any data modification to a table</p>",
                    "<p>Preventing data retrieval from a table outside of office hours</p>",
                    "<p>Creating multiple savepoints to enable partial rollback of a transaction</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "c"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the tasks that can be performed by DDL statements. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306027,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding indices. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Indexes and types of indexes in oracle with example](https://techgoeasy.com/oracle-indexes/)",
                    "[DROP TABLE](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/DROP-TABLE.html)",
                    "[Does index affect DML operations?](https://community.oracle.com/thread/870102)"
                ],
                "feedbacks": [
                    "This statement is correct because when a non-deferrable PRIMARY KEY or UNIQUE KEY constraint is defined on a table, Oracle automatically creates a unique index to enforce the uniqueness of the values in the specified columns.",
                    "This statement is incorrect because indexes should be created on columns that are frequently used in WHERE clauses, JOIN conditions, or ORDER BY clauses to improve query performance. Creating indexes on columns that are frequently referenced as part of any expression may not always be beneficial.",
                    "This statement is correct as when a table is dropped in Oracle, the corresponding indexes associated with that table are also automatically dropped to maintain data integrity and consistency.",
                    "This statement is correct because for each Data Manipulation Language (DML) operation (such as INSERT, UPDATE, DELETE) performed on a table, Oracle automatically updates the corresponding indexes to reflect the changes made to the data. This ensures that the indexes remain synchronized with the underlying table data."
                ],
                "explanation": "<p><strong>Correct Answers</strong></p><ol><li><p><strong>A non-deferrable PRIMARY KEY or UNIQUE KEY constraint in a table automatically attempts to create a unique index.</strong><br><strong>True</strong> — When you define a <strong>PRIMARY KEY</strong> or <strong>UNIQUE</strong> constraint (non-deferrable), Oracle <strong>automatically creates a unique index</strong> on the specified columns if one doesn’t already exist.</p></li><li><p><strong>When a table is dropped, the corresponding indexes are automatically dropped.</strong><br><strong>True</strong> — In Oracle, <strong>dropping a table</strong> also automatically <strong>drops all its associated indexes</strong> (including those created explicitly and those created via constraints).</p></li><li><p><strong>For each DML operation performed on a table, the corresponding indexes are automatically updated if required.</strong><br><strong>True</strong> — When you perform <strong>INSERT</strong>, <strong>UPDATE</strong>, or <strong>DELETE</strong> operations, the <strong>relevant indexes are automatically maintained</strong> by the database. You don't need to manually update them.</p></li></ol><p><strong>Incorrect Option</strong></p><p><strong>Indexes should be created on columns that are frequently referenced as part of any expression.</strong></p><ul><li><p><strong>False</strong> — Indexes <strong>should be created on columns used in WHERE clauses, JOINs, and ORDER BYs</strong>, but <strong>not necessarily</strong> on columns used in <strong>expressions</strong> (like functions or computations).<br>In fact, indexing columns that are part of expressions <strong>may not be useful</strong> unless <strong>function-based indexes</strong> are explicitly created.</p></li></ul><p><strong>Oracle Indexes</strong></p><p>• Indexes are used to search the rows in the <a href=\"https://techgoeasy.com/oracle-create-table-statement/\">Oracle table</a> quickly. If the index is not present, the select query has to read the whole table and return the rows. With Index, the rows can be retrieved quickly</p><p>• We should create Indexes when selecting a small percentage of rows from a table (less than 2-4%). If the % of rows returned is high, then the index scan will be slow. It also depends on the data distribution, i.e, <a href=\"https://techgoeasy.com/clustering-factor/\">clustering factor</a></p><p>• Indexes are logically and physically independent of the data in the associated table.</p><p>• Indexes are optional structures associated with tables and clusters. You can create indexes on one or more columns of a table to speed <a href=\"https://techgoeasy.com/oracle-sql-tutorial-basic-sql-statement/\">SQL statement</a> execution on that table.</p><p>• Indexes are the primary means of reducing disk I/O when properly used.</p><p>• The query decides at the beginning whether to use an index or not</p><p>• Retrieval performance of indexed data remains almost constant, even as new rows are inserted. However, the presence of many indexes on a table decreases the performance of updates, deletes, and inserts because Oracle must also update the indexes associated with the table.</p><p>• If you are the owner of the table, you can create an index, or if you want to create an index for a table in another schema, then you should either have the CREATE ANY INDEX <a href=\"https://techgoeasy.com/create-user-system-privileges-object-privileges/\">system privilege</a> or the index privilege on that table</p><p><br></p><p><strong>Dropping Tables</strong></p><p>• Dropping a table removes the table definition from the data dictionary. All rows of the table are no longer accessible.</p><p>• All indexes and triggers associated with a table are dropped.</p><p>• All views and PL/SQL program units dependent on a dropped table remain, yet become invalid (not usable). See <a href=\"https://docs.oracle.com/cd/B28359_01/server.111/b28310/general007.htm#i1006919\">\"Managing Object Dependencies\"</a> for information about how the database manages dependencies.</p><p>• All synonyms for a dropped table remain, but return an error when used.</p><p>• All extents allocated for a table that is dropped are returned to the free space of the tablespace and can be used by any other object requiring new extents or new objects. All rows corresponding to a clustered table are deleted from the blocks of the cluster.</p><p>• When a table is dropped, the corresponding indexes are automatically dropped.</p><p>For each data manipulation language (DML) operation performed, the corresponding indexes are automatically updated.</p><p>When you insert a row or update an indexed column in an existing row, if there are indexes on your tables (and assuming those indexes aren't disabled as part of a batch load process), Oracle has to do extra work to maintain the indexes rather than just modifying the table.</p><p>A nondeferrable <code>PRIMARY KEY</code> or <code>UNIQUE KEY</code> constraint in a table automatically creates a unique index.</p><p><strong>Primary key(PK) constraint and unique index are different.</strong> PK constraint is a rule that prohibits multiple rows from having the same value in the same column or combination of columns and prohibits values from being null. An index is a database object that is used for fast retrieval of data. It is created using DDL commands: <code>CREATE INDEX</code> or as part of a <code>CREATE TABLE</code> with PK/UK constraint or an <code>ALTER TABLE</code> command to add these constraints. </p><p><strong>An enabled PK constraint is always associated with an index.</strong> The associated index can be unique or non-unique (discussed later). The corresponding index can be found by querying: </p><p><br></p><pre class=\"prettyprint linenums\">SELECT constraint_name, constraint_type, index_name\n  FROM user_constraints\n WHERE table_name = '&lt;TABLE_NAME&gt;';</pre><p><br></p><p>Also, if we have an enabled PK constraint, the corresponding column(s) will be <code>NOT NULL</code>. Now, if you drop/disable the PK constraint, the column(s) will be changed to the state in which they were before adding the PK constraint.</p><p><strong>If the PK constraint is disabled, there will be no index associated with it.</strong> The “index_name” in the above query would be blank. But the constraint name would still be there. So, a PK constraint exists (with status as disabled), but there is no associated index.</p><p><strong>Once the PK constraint is disabled, the index left on that column can be dropped.</strong> If the index was created by Oracle with the creation of a PK constraint, it will be dropped automatically. If some existing index was associated with the PK constraint, it will not be dropped by Oracle (refer to point 6 for details). But it's now possible to drop that index manually.</p><p><strong>Enabling the PK constraint requires association with an index.</strong> If we now try to enable the PK constraint again, it will pick up the first index it found on that column and will get associated with it. In case there is no index to get associated, Oracle will create a new index with the same name as the PK constraint.</p><p><strong>Use the </strong><code><strong>USING INDEX</strong></code><strong> clause to associate a particular index with the PK.</strong> If there is more than one index on the column on which you want to add a PK constraint, we can selectively choose the index to be associated with the PK using <code>USING INDEX</code>. This clause can be used while: a) Adding the PK constraint for the first time (using the <code>ALTER TABLE</code> command).</p><p><strong>The index associated with the PK constraint needn’t be unique.</strong> A non-unique index can also be associated with the PK constraints.</p><p><strong>Dropping the PK may or may not drop the associated index.</strong> If you drop a PK constraint, the associated index may or may not be dropped, depending on the association of the PK constraint and index. Two scenarios arise: a) The PK constraint is associated with an already present index (either by using the <code>USING INDEX</code> clause or by default association if not specifically specified). In that case, the index will not be dropped with the dropping of the PK constraint.</p><p><a href=\"http://viralpatel.net/blogs/understanding-primary-keypk-constraint-in-oracle/\">http://viralpatel.net/blogs/understanding-primary-keypk-constraint-in-oracle/</a></p>",
                "answers": [
                    "<p>A non-deferrable PRIMARY KEY or UNIQUE KEY constraint in a table automatically attempts to create a unique index.</p>",
                    "<p>Indexes should be created on columns that are frequently referenced as part of any expression.</p>",
                    "<p>When a table is dropped, corresponding indexes are automatically dropped.</p>",
                    "<p>For each DML operation performed on a table, the corresponding indexes are automatically updated if required.</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding indices. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306029,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the exhibit and examine the descriptions of the DEPT and LOCATIONS tables. </p><p><strong>Table: DEPT</strong></p><pre class=\"prettyprint linenums\">Name                   Null??              Type\nDEPARTMENT_ID          NOT NULL            NUMBER(4)\nDEPARTMENT_NAME        NOT NULL            VARCHAR2(30)\nMANAGER_ID                                 NUMBER(6)\nLOCATION_ID&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NUMBER(4)\nCITY                                       VARCHAR2(30)</pre><p>&nbsp; </p><p><strong>Table: LOCATIONS</strong> </p><pre class=\"prettyprint linenums\">Name                   Null??              Type\nLOCATION_ID            NOT NULL            NUMBER(4)\nSTREET_ADDRESS                             VARCHAR2(40)\nPOSTAL_CODE                                VARCHAR2(12)\nCITY                   NOT NULL            VARCHAR2(30)\nSTATE_PROVINCE                             VARCHAR2(25)\nCOUNTRY_ID                                 CHAR(2)</pre><p><br></p><p><strong>Required:</strong> Update the CITY column of the DEPT table for all the rows with the corresponding value in the CITY column of the LOCATIONS table for each department.&nbsp; </p><p>What is the SQL query that would give you the required output?</p><p>Identify the SQL query that would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL query correctly updates the CITY column in the DEPT table by setting it to the corresponding CITY value from the LOCATIONS table based on the LOCATION_ID. The WHERE EXISTS clause ensures that the update is performed only for rows where a matching LOCATION_ID exists in the LOCATIONS table.",
                    "This SQL query is incorrect because the WHERE clause is used instead of WHERE EXISTS, which does not guarantee that the subquery will return a value for each row in the DEPT table. This may lead to incorrect updates or errors during execution.",
                    "This SQL query is incorrect because the ON keyword is not valid for UPDATE statements in Oracle SQL. The correct syntax for filtering rows in an UPDATE statement is using the WHERE clause, as shown in the correct choice.",
                    "This SQL query is incorrect because the UNION operator is used, which combines the result sets of two SELECT statements. In this context, it does not serve the purpose of updating the CITY column in the DEPT table based on the corresponding CITY value from the LOCATIONS table."
                ],
                "explanation": "<p>To update the <code>CITY</code> column in the <code>DEPT</code> table with the corresponding <code>CITY</code> value from the <code>LOCATIONS</code> table based on <code>LOCATION_ID</code>,&nbsp; use the following <code>UPDATE</code> statement with a correlated subquery:</p><p><br></p><pre class=\"prettyprint linenums\">UPDATE DEPT d\nSET CITY = (SELECT l.CITY \n            FROM LOCATIONS l \n            WHERE l.LOCATION_ID = d.LOCATION_ID)\nWHERE EXISTS (SELECT 1 \n              FROM LOCATIONS l \n              WHERE l.LOCATION_ID = d.LOCATION_ID);</pre><p><br></p><ul><li><p>The <code>UPDATE</code> statement modifies the <code>CITY</code> column in the <code>DEPT</code> table.</p></li><li><p>The subquery retrieves the <code>CITY</code> value from the <code>LOCATIONS</code> table where the <code>LOCATION_ID</code> matches.</p></li><li><p>The <code>WHERE EXISTS</code> clause ensures the update only occurs for departments with a valid <code>LOCATION_ID</code> in the <code>LOCATIONS</code> table.</p></li></ul><p>This will ensure that all departments have their <code>CITY</code> column updated with the correct value from the <code>LOCATIONS</code> table.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">UPDATE DEPT d\nSET CITY = (SELECT l.CITY \n            FROM LOCATIONS l \n            WHERE l.LOCATION_ID = d.LOCATION_ID)\nWHERE EXISTS (SELECT 1 \n              FROM LOCATIONS l \n              WHERE l.LOCATION_ID = d.LOCATION_ID);</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE DEPT d\nSET CITY = (SELECT l.CITY \n            FROM LOCATIONS l \n            WHERE l.LOCATION_ID = d.LOCATION_ID)\nWHERE      (SELECT 1 \n              FROM LOCATIONS l \n              WHERE l.LOCATION_ID = d.LOCATION_ID);</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE DEPT d\nSET CITY = (SELECT l.CITY \n            FROM LOCATIONS l \n            WHERE l.LOCATION_ID = d.LOCATION_ID)\nON         (SELECT 1 \n              FROM LOCATIONS l \n              WHERE l.LOCATION_ID = d.LOCATION_ID);</pre>",
                    "<pre class=\"prettyprint linenums\">UPDATE DEPT d\nSET CITY = (SELECT l.CITY \n            FROM LOCATIONS l \n            WHERE l.LOCATION_ID = d.LOCATION_ID)\nUNION       (SELECT 1 \n              FROM LOCATIONS l \n              WHERE l.LOCATION_ID = d.LOCATION_ID);</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View the exhibit and examine the descriptions of the DEPT and LOCATIONS tables. Table: DEPTName                   Null??              Type\nDEPARTMENT_ID          NOT NULL            NUMBER(4)\nDEPARTMENT_NAME        NOT NULL            VARCHAR2(30)\nMANAGER_ID                                 NUMBER(6)\nLOCATION_ID&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NUMBER(4)\nCITY                                       VARCHAR2(30)&nbsp; Table: LOCATIONS Name                   Null??              Type\nLOCATION_ID            NOT NULL            NUMBER(4)\nSTREET_ADDRESS                             VARCHAR2(40)\nPOSTAL_CODE                                VARCHAR2(12)\nCITY                   NOT NULL            VARCHAR2(30)\nSTATE_PROVINCE                             VARCHAR2(25)\nCOUNTRY_ID                                 CHAR(2)Required: Update the CITY column of the DEPT table for all the rows with the corresponding value in the CITY column of the LOCATIONS table for each department.&nbsp; What is the SQL query that would give you the required output?Identify the SQL query that would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306031,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View the Exhibit and examine the structure of the PRODUCTS table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-19-09-4b4b1f64dfca9a093849a92df29b85ec.png\"></p><p><br></p><p><strong>Required</strong>: Display the category with the maximum number of items.</p><p><strong>Given:</strong> The following query has been executed.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT COUNT (*), prod_category_id\n\tFROM products\n\tGROUP BY prod_category_id\n\tHAVING COUNT (*) = (\n\t\tSELECT MAX(COUNT(*))\n\t\tFROM products\n                GROUP BY prod_category_id);</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Aggregate Functions](https://www.oracletutorial.com/oracle-aggregate-functions/)"
                ],
                "feedbacks": [
                    "The query uses the correct syntax for comparing the count of items in each category with the maximum count. The = operator is valid in this context and does not need to be replaced by the IN operator.",
                    "The query is designed to display the category with the maximum number of items by comparing the count of items in each category with the maximum count. If the query executes successfully but does not give the correct output, it may be due to data inconsistencies or errors in the data.",
                    "The query executes successfully and gives the correct output by identifying the category with the maximum number of items. It uses a subquery to find the maximum count of items in a category and then compares it with the count of items in each category to determine the category with the maximum count.",
                    "The query does not generate an error because the subquery does not have a GROUP BY clause. The subquery is used to find the maximum count of items in a category, and it does not require a GROUP BY clause as it is only used for comparison purposes."
                ],
                "explanation": "<p><strong>What the query is trying to do:</strong></p><ul><li><p>Count how many products are in each <code>prod_category_id</code>.</p></li><li><p>From that, <strong>identify the category (or categories)</strong> with the <strong>maximum number of products</strong>.</p></li></ul><p><strong>Key points to notice:</strong></p><ul><li><p>The <strong>outer query</strong> groups products by <code>prod_category_id</code> and counts them.</p></li><li><p>The <strong>subquery</strong> is doing:</p><pre class=\"prettyprint linenums\">sql\nSELECT MAX(COUNT(*))\nFROM products\nGROUP BY prod_category_id</pre><p>This is a <strong>correlated aggregation</strong> — grouping first, and then applying <code>MAX()</code> over those group counts.</p></li></ul><p><strong>Is this valid syntax?</strong></p><ul><li><p>YES — A subquery <strong>with a GROUP BY and an aggregate (MAX(COUNT(*)))</strong> is <strong>valid</strong>.</p></li><li><p>The <code><strong>=</strong></code><strong> operator</strong> is fine <strong>if only one result</strong> is returned — and since <code>MAX(...)</code> always returns a <strong>single value</strong>, <code>=</code> is correct here.</p></li><li><p>So, using <code>=</code> instead of <code>IN</code> is <strong>not an error</strong>.</p></li></ul><p>The correct answer is:</p><p><strong>It executes successfully and gives the correct output.</strong></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-18_15-20-59-98a65981ff9ef71181c45efe9a47376d.png\"></p><p><br></p><p>The Oracle <code>COUNT()</code> function is an <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate function</a> that returns the number of items in a group.</p><p>The syntax of the <code>COUNT()</code> function is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">COUNT( [ALL | DISTINCT | * ] expression)</pre><p><br></p><p>The <code>COUNT()</code> function accepts a clause which can be either <code>ALL</code>, <code>DISTINCT</code>, or <code>*</code>:</p><p>• <code>COUNT(*)</code> function returns the number of items in a group, including <code>NULL</code> and duplicate values.</p><p>• <code>COUNT(DISTINCT expression)</code> function returns the number of unique and non-null items in a group.</p><p>• <code>COUNT(ALL expression)</code> evaluates the expression and returns the number of non-null items in a group, including duplicate values.</p><p>If you don’t explicitly specify <code>DISTINCT</code> or <code>ALL</code>, the <code>COUNT()</code> function uses <code>ALL</code> by default.</p><p>Note that, unlike other <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>, the <code>COUNT(*)</code> function does not ignore <code>NULL</code> values.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT COUNT (*), prod_category_id\n\tFROM products\n\tGROUP BY prod_category_id\n\tHAVING COUNT (*) = (\n\t\tSELECT MAX(COUNT(*))\n\t\tFROM products\n                GROUP BY prod_category_id);</pre>",
                "answers": [
                    "<p>It generates an error because = is not valid and should be replaced by the IN operator.</p>",
                    "<p>It executes successfully but does not give the correct output.</p>",
                    "<p>It executes successfully and gives the correct output.</p>",
                    "<p>It generate an error because the subquery does not have a GROUP BY clause.</p>"
                ]
            },
            "correct_response": [
                "c"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View the Exhibit and examine the structure of the PRODUCTS table. Required: Display the category with the maximum number of items.Given: The following query has been executed.Exhibit: 1SELECT COUNT (*), prod_category_id\n\tFROM products\n\tGROUP BY prod_category_id\n\tHAVING COUNT (*) = (\n\t\tSELECT MAX(COUNT(*))\n\t\tFROM products\n                GROUP BY prod_category_id);Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306033,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Examine the description of the SALES table: </p><p><strong>Table: SALES</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nPRODUCT_ID              NOT NULL          NUMBER(2)\nCUSTOMER_ID             NOT NULL          NUMBER(10)\nTIME_ID                 NOT NULL          DATE\nCHANNEL_ID              NOT NULL          NUMBER(5)\nPROMO_ID                NOT NULL          NUMBER(5)\nQUANTITY_SOLD           NOT NULL          NUMBER(10,2)\nPRICE                                     NUMBER(10,2)\nAMOUNT_SOLD             NOT NULL          NUMBER(10,2)</pre><p><br></p><p><strong>Given:</strong> The SALES table has 55,000 rows.</p><p>Examine this statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE sales1 (prod_id, cust_id, quantity_sold, price)\nAS\nSELECT product_id, customer_id, quantity_sold, price\nFROM sales\nWHERE 1 = 1;</pre><p><br></p><p>Identify the true statements regarding the result. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: CREATE TABLE AS Statement](https://www.techonthenet.com/oracle/tables/create_table2.php)"
                ],
                "feedbacks": [
                    "The statement creates the SALES1 table by selecting columns from the SALES table. Since the NOT NULL constraints are inherited from the SALES table, SALES1 will have the same constraints on the selected columns.",
                    "The statement uses a SELECT query to populate the SALES1 table with data from the SALES table. Since the WHERE clause condition is always true (1=1), all 55,000 rows from the SALES table will be inserted into the SALES1 table.",
                    "The statement does not mention any PRIMARY KEY or UNIQUE constraints being applied to the SALES1 table. Therefore, it cannot be assumed that SALES1 has these constraints based on the SELECT query from the SALES table.",
                    "Since the SELECT query from the SALES table retrieves all 55,000 rows and inserts them into the SALES1 table, SALES1 will be created with the same number of rows as the SALES table, not with no rows.",
                    "The SELECT query from the SALES table inserts all 55,000 rows into the SALES1 table. Therefore, SALES1 will be created with 55,000 rows, not with only 1 row."
                ],
                "explanation": "<p>In most modern, enterprise-level SQL databases, particularly <strong>Oracle</strong> (which the <code>NUMBER(x,y)</code> data types and common schema design strongly suggest), the behaviour is as follows:</p><ol><li><p><code><strong>NOT NULL</strong></code><strong> constraints → ARE INHERITED.</strong></p></li><li><p><strong>All other constraints (</strong><code><strong>PRIMARY KEY</strong></code><strong>, </strong><code><strong>UNIQUE</strong></code><strong>, </strong><code><strong>CHECK</strong></code><strong>, </strong><code><strong>FOREIGN KEY</strong></code><strong>) → ARE NOT INHERITED.</strong></p></li></ol><p>This means that out of the two statements you identified:</p><ul><li><p><code><strong>SALES1</strong></code><strong> is created with 55,000 rows.</strong> → <strong>TRUE</strong> (Since <code>WHERE 1=1</code> selects all rows and the source table has 55,000 rows).</p></li><li><p><code><strong>SALES1</strong></code><strong> does not inherit NOT NULL constraints.</strong> → <strong>FALSE</strong> (In the context of the likely SQL environment, <code>NOT NULL</code> constraints <strong>are</strong> inherited).</p></li></ul><p><br></p><p>Correct True Statements</p><p>The true statements regarding the result of the <code>CREATE TABLE sales1 AS SELECT ...</code> statement are:</p><ol><li><p><code><strong>SALES1</strong></code><strong> is created with 55,000 rows.</strong></p></li><li><p><code><strong>SALES1</strong></code><strong> has NOT NULL constraints on any selected columns that had that constraint in the </strong><code><strong>SALES</strong></code><strong> table.</strong></p></li></ol><p>The statement uses the <code>CREATE TABLE ... AS SELECT ...</code> (CTAS) syntax, which creates a new table (<code>sales1</code>) based on the results of a query (<code>SELECT ... FROM sales WHERE 1 = 1</code>).</p><p><br></p><p>Row Count</p><p>The <code>SELECT product_id, customer_id, quantity_sold, price FROM sales WHERE 1 = 1</code> query will select all rows from the <code>SALES</code> table because the condition <code>WHERE 1 = 1</code> is always true and does not filter any data. Since the <code>SALES</code> table has <strong>55,000 rows</strong>, the new table <code>SALES1</code> will be created and populated with <strong>55,000 rows</strong>.</p><p><br></p><p>Constraints</p><p>When using the CTAS syntax in most SQL databases (like Oracle, which this schema strongly resembles), the following rules for constraints generally apply to the newly created table:</p><ul><li><p><code><strong>NOT NULL</strong></code><strong> Constraints:</strong> These constraints are inherited from the source table to the new table for the selected columns. In the <code>SALES</code> table, <code>PRODUCT_ID</code>, <code>CUSTOMER_ID</code>, and <code>QUANTITY_SOLD</code> are defined as <code>NOT NULL</code>. Therefore, <code>SALES1</code> will have <code>NOT NULL</code> constraints on <code>prod_id</code>, <code>cust_id</code>, and <code>quantity_sold</code>. The column <code>price</code> in <code>SALES</code> is nullable, so it will also be nullable in <code>SALES1</code>.</p><ul><li><p><em>Therefore, the statement \"SALES1 has NOT NULL constraints on any selected columns which had that constraint in the SALES table\" is true.</em></p></li></ul></li><li><p><strong>Other Constraints (</strong><code><strong>PRIMARY KEY</strong></code><strong>, </strong><code><strong>UNIQUE</strong></code><strong>, </strong><code><strong>CHECK</strong></code><strong>, </strong><code><strong>FOREIGN KEY</strong></code><strong>):</strong> These constraints are <strong>not</strong> automatically copied to the new table. They must be explicitly defined after the table is created using <code>ALTER TABLE</code>.</p><ul><li><p><em>Therefore, the statement \"SALES1 has PRIMARY KEY and UNIQUE constraints on any selected columns which had those constraints in the SALES table\" is false.</em></p></li></ul></li></ul>",
                "answers": [
                    "<p>SALES1 has NOT NULL constraints on any selected columns which had that constraint in the SALES table.</p>",
                    "<p>SALES1 is created with 55,000 rows.</p>",
                    "<p>SALES1 has PRIMARY KEY and UNIQUE constraints on any selected columns which had those constraints in the SALES table.</p>",
                    "<p>SALES1 is created with no rows.</p>",
                    "<p>SALES1 is created with 1 row.</p>"
                ]
            },
            "correct_response": [
                "b",
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "Examine the description of the SALES table: Table: SALESName                    Null??            Type\nPRODUCT_ID              NOT NULL          NUMBER(2)\nCUSTOMER_ID             NOT NULL          NUMBER(10)\nTIME_ID                 NOT NULL          DATE\nCHANNEL_ID              NOT NULL          NUMBER(5)\nPROMO_ID                NOT NULL          NUMBER(5)\nQUANTITY_SOLD           NOT NULL          NUMBER(10,2)\nPRICE                                     NUMBER(10,2)\nAMOUNT_SOLD             NOT NULL          NUMBER(10,2)Given: The SALES table has 55,000 rows.Examine this statement.Exhibit: 1CREATE TABLE sales1 (prod_id, cust_id, quantity_sold, price)\nAS\nSELECT product_id, customer_id, quantity_sold, price\nFROM sales\nWHERE 1 = 1;Identify the true statements regarding the result. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306035,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following SQL exhibit.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">INSERT ALL\n  WHEN order_total &lt; 10000 THEN\n    INTO small_orders\n  WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n    INTO medium_orders\n  WHEN order_total &gt; 20000 THEN\n    INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;</pre><p><br></p><p>Identify the true statement regarding the rows returned by the subquery in the INSERT statement.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[INSERT](https://docs.oracle.com/cd/B10500_01/server.920/a96540/statements_913a.htm)",
                    "[Oracle Subquery](https://www.oracletutorial.com/oracle-basics/oracle-subquery/)",
                    "[The Oracle WHEN Clause](http://psoug.org/definition.htm/WHEN.htm)"
                ],
                "feedbacks": [
                    "This statement is incorrect because in a CASE statement, once a condition is met, the corresponding result is returned, and the subsequent WHEN clauses are not evaluated for that particular row.",
                    "This statement is correct because in a CASE statement, all rows are evaluated by all the WHEN clauses to determine the appropriate result based on the conditions specified.",
                    "This statement is incorrect because in a CASE statement, once a condition is true, the corresponding result is returned, and the subsequent WHEN clauses are not evaluated for that particular row.",
                    "This statement is incorrect because the presence or absence of an ELSE clause does not affect the evaluation of rows in the subquery. The absence of an ELSE clause would only result in a NULL value if none of the WHEN conditions are met."
                ],
                "explanation": "<p><strong>Correct Answer:</strong> <strong>All rows are evaluated by all three WHEN clauses.</strong></p><p>Explanation:</p><p>This is an <code><strong>INSERT ALL</strong></code> statement (not <code>INSERT FIRST</code>), which means:</p><ul><li><p>Oracle will evaluate <strong>each row returned by the </strong><code><strong>SELECT</strong></code> against <strong>all </strong><code><strong>WHEN</strong></code><strong> conditions</strong>.</p></li><li><p>If a row satisfies more than one <code>WHEN</code> condition (e.g., overlapping logic), it could be inserted into <strong>multiple</strong> tables.</p></li><li><p>In your corrected query, the ranges are mutually exclusive, so each row will go into <strong>only one table</strong> — but <strong>all </strong><code><strong>WHEN</strong></code><strong> clauses are still evaluated</strong>.</p></li></ul><p>If it were <code>INSERT FIRST</code>, Oracle would stop evaluating once it finds a matching <code>WHEN</code>.</p><p><br></p><p>If you were thinking that <em>all rows won't be evaluated by all 3 WHEN clauses</em> is incorrect when a row meets the condition in the 1st WHEN clause, it won't be evaluated by other WHEN clauses, consider.</p><p>The behaviour of a <code><strong>CASE</strong></code><strong> statement</strong> or a <strong>conditional </strong><code><strong>INSERT</strong></code><strong> with </strong><code><strong>WHERE</strong></code><strong> clauses</strong> that are mutually exclusive, or specifically, the behaviour of an <code>INSERT FIRST</code> statement.</p><p>However, the exhibit provided is an <code><strong>INSERT ALL</strong></code> statement.</p><p>That would actually apply to <code>INSERT FIRST</code>, <strong>not</strong> <code>INSERT ALL</code>.</p><p>Let’s clarify the difference, because this is a common point of confusion in Oracle SQL.</p><p><code>INSERT ALL</code> vs <code>INSERT FIRST</code></p><p><code>INSERT ALL</code></p><ul><li><p><strong>Each row</strong> returned by the <code>SELECT</code> is <strong>evaluated against <em>every</em> </strong><code><strong>WHEN</strong></code><strong> condition</strong>.</p></li><li><p>If <strong>multiple conditions are true</strong>, the row is <strong>inserted into multiple tables</strong>.</p></li><li><p>It does <strong>not stop</strong> after the first match.</p></li></ul><p><code>INSERT FIRST</code></p><ul><li><p>Each row is <strong>evaluated conditionally</strong>.</p></li><li><p>As soon as the <strong>first matching </strong><code><strong>WHEN</strong></code> condition is found, that row is <strong>inserted only once</strong>, and <strong>no further conditions are checked</strong>.</p></li></ul><p>Original Statement</p><pre class=\"prettyprint linenums\">INSERT ALL\n  WHEN order_total &lt; 10000 THEN\n    INTO small_orders\n  WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n    INTO medium_orders\n  WHEN order_total &gt; 20000 THEN\n    INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;\n</pre><p>This is an <code>INSERT ALL</code>, so: <strong>Every row</strong> from the <code>SELECT</code> is evaluated against <strong>all three WHEN conditions</strong>.<br>If more than one condition is true, the row is inserted into <strong>multiple tables</strong>.</p><p><strong>Key characteristic of </strong><code><strong>INSERT ALL</strong></code><strong> (without </strong><code><strong>FIRST</strong></code><strong>):</strong></p><p>When you use <code>INSERT ALL</code> (without the <code>FIRST</code> keyword), every row returned by the subquery is evaluated against <em>all</em> the <code>WHEN</code> clauses. If a row satisfies the condition of a <code>WHEN</code> clause, it is inserted into the corresponding table. A single row can be inserted into multiple tables if it meets the criteria of more than one <code>WHEN</code> clause.</p><p><strong>Example to illustrate </strong><code><strong>INSERT ALL</strong></code><strong> behaviour:</strong></p><p>Let's say you have an <code>order_total</code> of <code>5000</code>.</p><ul><li><p><code>WHEN order_total &lt; 10000 THEN INTO small_orders</code> (True - inserted into <code>small_orders</code>)</p></li><li><p><code>WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN INTO medium_orders</code> (False)</p></li><li><p><code>WHEN order_total &gt; 20000 THEN INTO large_orders</code> (False)</p></li></ul><p>In this case, it's only inserted into <code>small_orders</code>.</p><p>Now consider an <code>order_total</code> of <code>15000</code>.</p><ul><li><p><code>WHEN order_total &lt; 10000 THEN INTO small_orders</code> (False)</p></li><li><p><code>WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN INTO medium_orders</code> (True - inserted into <code>medium_orders</code>)</p></li><li><p><code>WHEN order_total &gt; 20000 THEN INTO large_orders</code> (False)</p></li></ul><p>Again, only inserted into one table.</p><p><strong>However, let's modify the </strong><code><strong>WHEN</strong></code><strong> clauses slightly to demonstrate the \"all clauses evaluated\" point more clearly, although the original example's conditions are mutually exclusive in practice.</strong></p><p>Imagine this (hypothetical, poorly designed) <code>INSERT ALL</code> example:</p><pre class=\"prettyprint linenums\">INSERT ALL\n&nbsp; WHEN order_total &lt; 15000 THEN -- Condition 1\n&nbsp; &nbsp; INTO table_a\n&nbsp; WHEN order_total &gt; 10000 THEN -- Condition 2\n&nbsp; &nbsp; INTO table_b\nSELECT order_id, order_total FROM orders;\n</pre><p>If <code>order_total = 12000</code>:</p><ul><li><p>It is evaluated by <code>WHEN order_total &lt; 15000</code> (True) -&gt; inserted into <code>table_a</code>.</p></li><li><p>It is <strong>also</strong> evaluated by <code>WHEN order_total &gt; 10000</code> (True) -&gt; inserted into <code>table_b</code>.</p></li></ul><p>In this modified example, a single row (<code>order_total = 12000</code>) would be inserted into <em>both</em> <code>table_a</code> and <code>table_b</code> because both <code>WHEN</code> clauses were evaluated and found to be true. This demonstrates that <code>INSERT ALL</code> does not short-circuit. Every row is processed against every <code>WHEN</code> clause.</p><p><strong>Contrast with </strong><code><strong>INSERT FIRST</strong></code><strong>:</strong></p><p>If the statement were <code>INSERT FIRST</code>, then your understanding would be correct:</p><pre class=\"prettyprint linenums\">INSERT FIRST -- Note the \"FIRST\" keyword\n&nbsp; WHEN order_total &lt; 10000 THEN\n&nbsp; &nbsp; INTO small_orders\n&nbsp; WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n&nbsp; &nbsp; INTO medium_orders\n&nbsp; WHEN order_total &gt; 20000 THEN\n&nbsp; &nbsp; INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;\n</pre><p>With <code>INSERT FIRST</code>, once a <code>WHEN</code> condition is met for a row, that row is inserted into the corresponding table, and <strong>no further </strong><code><strong>WHEN</strong></code><strong> clauses are evaluated for that specific row.</strong> This provides a \"first match wins\" behaviour.</p><p><br></p><p>Use the <code>INSERT</code> statement to add rows to a table, a view's base table, a partition of a partitioned table, or a subpartition of a composite-partitioned table, or an object table or an object view's base table.</p><p>A subquery is a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement nested inside another statement, such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-insert/\"><code>INSERT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>. Typically, you can use a subquery anywhere that you use an expression.</p><p><strong>Main advantages of subqueries:</strong></p><p>• Provide an alternative way to query data that would require complex <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-inner-join/\">joins</a> and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-union/\">unions</a>.</p><p>• Make the complex queries more readable.</p><p>• Allow a complex query to be structured in a way that it is possible to isolate each part.</p><p><strong>Using WHEN</strong></p><p>The Oracle <code>WHEN</code> keyword is used in two ways. One use is in the <code>CASE</code> statement to pick among given values. The other use of <code>WHEN</code> is in a conditional <a href=\"http://psoug.org/definition/INSERT.htm\" title=\"View INSERT information\"><code>INSERT</code></a> statement.</p><p><strong>Using WHEN in a conditional </strong><a href=\"http://psoug.org/definition/INSERT.htm\" title=\"View INSERT information\"><strong>INSERT</strong></a><strong> statement</strong></p><p>There are two modes for conditional insert: <code>ALL</code> and <code>FIRST</code>.</p><p>If you specify <code>ALL</code>, the default value, then the database evaluates each <code>WHEN</code> clause regardless of the results of the evaluation of any other <code>WHEN</code> clause. \"<em>All rows are evaluated by all three WHEN clauses\". </em>For each <code>WHEN</code> clause whose condition evaluates to true, the database executes the corresponding <code>INTO</code> clause list.</p><p>If you specify <code>FIRST</code>, then the database evaluates each <code>WHEN</code> clause in the order in which it appears in the statement. For the first <code>WHEN</code> clause that evaluates to true, the database executes the corresponding <code>INTO</code> clause and skips subsequent <code>WHEN</code> clauses for the given row.</p><p><strong>Using WHEN in the CASE statement</strong></p><p>The <code>CASE</code> statement operates like a series of <code>IF</code> statements, only using the keyword <code>WHEN</code>.</p><p>In a simple <code>CASE</code> expression, Oracle Database searches for the first <code>WHEN</code> ... <code>THEN</code> pair for which <code>expr</code> is equal to <code>comparison_expr</code> and returns <code>return_expr</code>. If none of the <code>WHEN</code> ... <code>THEN</code> pairs meet this condition, and an <code>ELSE</code> clause exists, then Oracle returns <code>else_expr</code>. Otherwise, Oracle returns null. You cannot specify the literal <code>NULL</code> for every <code>return_expr</code> and the <code>else_expr</code>.</p><p><a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14200/expressions004.htm\">https://docs.oracle.com/cd/B19306_01/server.102/b14200/expressions004.htm</a></p>",
                "answers": [
                    "<p>Each row is evaluated by the first WHEN clause and if the condition is false then the row would be evaluated by the subsequent WHEN clauses.</p>",
                    "<p>All rows are evaluated by all the three WHEN clauses.</p>",
                    "<p>Each row is evaluated by the first WHEN clause and if the condition is true, then the row would be evaluated by the subsequent WHEN clauses.</p>",
                    "<p>The INSERT statement will return an error because the ELSE clause is missing.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following SQL exhibit.Exhibit: 1INSERT ALL\n  WHEN order_total &lt; 10000 THEN\n    INTO small_orders\n  WHEN order_total &gt; 10000 AND order_total &lt; 20000 THEN\n    INTO medium_orders\n  WHEN order_total &gt; 20000 THEN\n    INTO large_orders\nSELECT order_id, order_total, customer_id\nFROM orders;Identify the true statement regarding the rows returned by the subquery in the INSERT statement.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306037,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the SALES1 and SALES2 tables.</p><p><strong>Table: SALES1</strong></p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nSALES_ID                                   NUMBER\nSTORE_ID                                   NUMBER\nITEMS_ID                                   NUMBER\nQUANTITY                                   NUMBER\nSALES_DATE                                 NUMBER</pre><p><br></p><p><strong>Table: SALES2</strong>&nbsp; &nbsp; </p><pre class=\"prettyprint linenums\">Name                    Null??            Type\nSALES_ID                                   NUMBER\nSTORE_ID                                   NUMBER\nITEMS_ID                                   NUMBER\nQUANTITY                                   NUMBER\nSALES_DATE                                 NUMBER</pre><p><br></p><p><strong>Given: </strong>Sales data of a company is stored in two tables, SALES1 and SALES2, with some data being duplicated across the tables. </p><p><strong>Required: </strong>Display the results from the SALES1 table, which are not present in the SALES2 table.&nbsp; </p><p>Identify the set operator that generates the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: MINUS Operator](https://www.techonthenet.com/oracle/minus.php)"
                ],
                "feedbacks": [
                    "The INTERSECT set operator retrieves the common rows between two result sets. It does not provide the results from one table that are not present in the other table, which is the requirement in this scenario.",
                    "The UNION set operator combines the results of two queries, including duplicates. It does not filter out the results from one table that are not present in the other table, so it is not suitable for this specific requirement.",
                    "The PLUS set operator is not a valid set operator in Oracle Database SQL. It does not exist as a set operator, so it cannot be used to generate the required output in this scenario.",
                    "The MINUS set operator in Oracle Database SQL is used to retrieve the rows from the first query that are not present in the result set of the second query. This is the correct set operator to use in this scenario to display the results from the SALES1 table that are not present in the SALES2 table.",
                    "The SUBTRACT set operator is not a valid set operator in Oracle Database SQL. It does not exist as a set operator, so it cannot be used to generate the required output in this scenario."
                ],
                "explanation": "<p>To display the rows from the <code>SALES1</code> table that are <strong>not present in the </strong><code><strong>SALES2</strong></code> table, you need a <strong>set operator</strong> that performs a <strong>\"set difference\"</strong> operation.</p><p><strong>Correct Answer: </strong><code><strong>MINUS</strong></code></p><p>Explanation:</p><p>The <code>MINUS</code> operator in Oracle SQL returns <strong>all rows from the first query</strong> that <strong>do not exist in the second query</strong>.</p><p>Example:</p><pre class=\"prettyprint linenums\">sql\nSELECT * FROM SALES1\nMINUS\nSELECT * FROM SALES2;</pre><p><br></p><p>This returns only the rows that are <strong>in </strong><code><strong>SALES1</strong></code><strong> but not in </strong><code><strong>SALES2</strong></code> — exactly what the question asks for.</p><p>Here's what the other options do:</p><ul><li><p><strong>INTERSECT</strong> → returns common rows from both tables</p></li><li><p><strong>UNION</strong> → combines rows from both tables, removing duplicates</p></li><li><p><strong>PLUS</strong> → Not a valid SQL set operator</p></li><li><p><strong>SUBTRACT</strong> → Also not a valid SQL set operator in Oracle</p></li></ul><p><strong>Oracle MINUS</strong></p><p>The Oracle <code>MINUS</code> operator is used to return all rows in the first <code>SELECT</code> statement that are not returned by the second <code>SELECT</code> statement. Each <code>SELECT</code> statement will define a dataset. The <code>MINUS</code> operator will retrieve all records from the first dataset and then remove from the results all records from the second dataset.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-18_17-24-21-4af5957cedd0f1410fdc3abcfb9735c6.png\"></p><p><br></p><p><strong>Explanation:</strong> The <code>SELECT</code> query will return the records in the blue shaded area. These are the records that exist in Table1 and not in Table2.</p><p>Each <code>SELECT</code> statement within the MINUS query must have the same number of fields in the result sets with similar data types.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>MINUS</code> operator in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nMINUS\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n The columns or calculations that you wish to retrieve. Tables: The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause. <code>WHERE</code> conditions are Optional. The conditions that must be met for the records to be selected.</p><p><strong>Note:</strong> There must be the same number of expressions in both <code>SELECT</code> statements and have similar data types.</p><p><br></p><p><strong>Example - With Single Expression</strong></p><p>The following is an Oracle <code>MINUS</code> operator example that returns one field with the same data type:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT supplier_id\nFROM suppliers\nMINUS\nSELECT supplier_id\nFROM orders;</pre><p><br></p><p>This Oracle <code>MINUS</code> example returns all <em>supplier_id</em> values that are in the <em>suppliers</em> table and not in the <em>orders</em> table. What this means is that if a <em>supplier_id</em> value existed in the <em>suppliers</em> table and also existed in the <em>orders</em> table, the <em>supplier_id</em> value would not appear in this result set.</p><p><br></p><p><strong>Example - Using </strong><code><strong>ORDER BY</strong></code></p><p>The following is a MINUS operator example that uses an <code>ORDER BY</code> clause:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT supplier_id, supplier_name\nFROM suppliers\nWHERE state = 'Florida'\nMINUS\nSELECT company_id, company_name\nFROM companies\nWHERE company_id &lt;= 400\nORDER BY 2;</pre><p><br></p><p>In this <code>MINUS</code> example, since the column names are different between the two <code>SELECT</code> statements, it is more advantageous to reference the columns in the <code>ORDER BY</code> clause by their position in the result set. In this example, we've sorted the results by <em>supplier_name</em> / <em>company_name</em> in ascending order, as denoted by the <code>ORDER BY 2</code>.</p>",
                "answers": [
                    "<p><code>INTERSECT</code> </p>",
                    "<p><code>UNION</code> </p>",
                    "<p><code>PLUS</code> </p>",
                    "<p><code>MINUS</code> </p>",
                    "<p><code>SUBTRACT</code> </p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the SALES1 and SALES2 tables.Table: SALES1Name                    Null??            Type\nSALES_ID                                   NUMBER\nSTORE_ID                                   NUMBER\nITEMS_ID                                   NUMBER\nQUANTITY                                   NUMBER\nSALES_DATE                                 NUMBERTable: SALES2&nbsp; &nbsp; Name                    Null??            Type\nSALES_ID                                   NUMBER\nSTORE_ID                                   NUMBER\nITEMS_ID                                   NUMBER\nQUANTITY                                   NUMBER\nSALES_DATE                                 NUMBERGiven: Sales data of a company is stored in two tables, SALES1 and SALES2, with some data being duplicated across the tables. Required: Display the results from the SALES1 table, which are not present in the SALES2 table.&nbsp; Identify the set operator that generates the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306039,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements regarding primary and foreign key constraints and the effect they can have on table data. (Choose four)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle PRIMARY KEY](https://www.oracletutorial.com/oracle-basics/oracle-primary-key/)",
                    "[Does foreign key always reference to a unique key in another table?](https://stackoverflow.com/questions/8706073/does-foreign-key-always-reference-to-a-unique-key-in-another-table)",
                    "[Difference between Table level and Column level constraints?](https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293)"
                ],
                "feedbacks": [
                    "This statement is incorrect. Both primary key and foreign key constraints can be defined at both the column and table level, not just the primary key.",
                    "This statement is correct. A foreign key must reference either the primary key or a unique key of the parent table to maintain data integrity.",
                    "This statement is correct. A table can have only one primary key, but it can have multiple foreign keys to establish relationships with other tables.",
                    "This statement is correct. Both primary key and foreign key constraints can be defined at both the column and table level to enforce data integrity rules.",
                    "This statement is correct. It is possible for child rows that have a foreign key to be deleted automatically from the child table at the time the parent row is deleted, depending on the referential actions specified in the foreign key constraint."
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><ol><li><p><strong>A foreign key must reference either the primary key or a unique key of the parent table</strong><br><strong>True</strong> – In Oracle, a foreign key must reference a column (or combination of columns) in the parent table that is either a primary key or has a unique constraint.</p></li><li><p><strong>A table can have only one primary key, but multiple foreign keys</strong><br><strong>True</strong> – A table can have <strong>only one primary key</strong>, but can have <strong>many foreign keys</strong> pointing to different parent tables or different keys in the same table.</p></li><li><p><strong>Primary key and foreign key constraints can be defined at both the column and table levels</strong><br><strong>True</strong> – You can define both types of constraints inline (column level) or as a separate <code>CONSTRAINT</code> clause (table level).</p></li><li><p><strong>It is possible for child rows that have a foreign key to be deleted automatically from the child table at the time the parent row is deleted</strong><br><strong>True</strong> – This is possible <strong>if</strong> the foreign key constraint is defined with <code><strong>ON DELETE CASCADE</strong></code>.</p></li></ol><p><strong>Incorrect Statement:</strong></p><p><strong>Only the primary key can be defined at the column and table levels</strong></p><ul><li><p><strong>False</strong> – Not only primary keys but also <strong>foreign keys, unique constraints, and check constraints</strong> can be defined at both the column and table level.</p></li></ul><p><br></p><p>A <code>PRIMARY KEY</code> is a column or a combination of columns in a table that uniquely identifies a row in the table.</p><p>The following are rules that make a column a <code>PRIMARY KEY</code>:</p><p>• A <code>PRIMARY KEY</code> column cannot contain a NULL value or an empty string.</p><p>• A <code>PRIMARY KEY</code> value must be unique within the entire table.</p><p>• A <code>PRIMARY KEY</code> value should not be changed over time.</p><p><br></p><p><strong>Recommendations for a PRIMARY KEY</strong></p><p>• First, the <code>PRIMARY KEY</code> should be meaningless. Sometimes, you may want to use meaningful data, which is considered unique, for the primary keys, e.g., social security number (SSN), vehicle identification number (VIN), email, and phone number. However, you don’t know when the email or phone number changes or is reused by another person. In such cases, it will create many data problems. In the database world, the artificial keys are known as <em>surrogate keys,</em> which are in opposition to <em>natural</em> primary keys.</p><p>• Second, a <code>PRIMARY KEY</code> should be compact. The primary keys typically are numeric because Oracle processes numbers faster than any other data type.</p><p>It is considered a best practice to have a <code>PRIMARY KEY</code> in every table, though it is not mandatory in Oracle.</p><p>To create a <code>PRIMARY KEY</code> in a table, you use the <code>PRIMARY KEY</code> constraint.</p><p>Typically, you create a <code>PRIMARY KEY</code> for a table when you create that table. In addition, you can add a <code>PRIMARY KEY</code> to a table after the fact by using the <code>ALTER TABLE</code> statement.</p><p><br></p><p>A <code>FOREIGN KEY</code> is all about the relationship. Oracle allows you to create, add, drop, disable, and enable a foreign key constraint.</p><p><strong>Syntax: Creating a foreign key constraint when you create a table</strong></p><p><br></p><pre class=\"prettyprint linenums\">CREATE TABLE child_table (\n ...\nCONSTRAINT fk_name\nFOREIGN KEY(col1, col2,...) REFERENCES parent_table(col1,col2) \nON DELETE [ CASCADE | SET NULL ]\n);</pre><p><br></p><p>• First, to explicitly assign the foreign key constraint a name, you use the <code>CONSTRAINT</code> clause followed by the name. The <code>CONSTRAINT</code> clause is optional. If you omit it, Oracle will assign a system-generated name to the foreign key constraint.</p><p>• Second, specify the <code>FOREIGN KEY</code> clause to define one or more columns as a foreign key and the parent table with columns to which the foreign key columns reference.</p><p>• Third, use the <code>ON DELETE</code> clause to specify the consequence when the rows in the parent table are deleted.</p><p><br></p><p><code>ON DELETE CASCADE</code>: if a row in the parent is deleted, then all the rows in the child table that reference that row will be deleted.</p><p><code>ON DELETE SET NULL</code>: if a row in the parent is deleted, then all the rows in the child table that reference that row will be set to NULL for the foreign key columns.</p><p>Unlike the primary key constraint, a table may have more than one foreign key constraint.</p><p>A <strong>foreign key </strong>must reference either the primary key or a unique key of the parent table. If the primary key has multiple columns, the foreign key must match (have the same number and order of columns). Therefore, the foreign key references a unique row in the parent table; there can be no duplicates.</p><p><strong>Constraints </strong>can be specified for individual columns as part of the column specification (column-level constraints) or for groups of columns as part of the table definition (table-level constraints).</p><p>A column-level constraint has scope only to the column it is defined on. A table-level constraint can see every column in the table.</p><p>That is the major difference between the two - that of \"scoping\".</p><p>Any column-level constraint (exception: not null) can be expressed at the table level - but the opposite is not true.</p><p>A column-level constraint is syntactically clearer - it is OBVIOUS it applies to that single column. It is more meaningful, therefore.</p><p>Use a column-level constraint if your constraint is in fact a column constraint. You would use a table constraint otherwise.</p><p><strong>Column constraints include: </strong></p><p><code>NOT NULL</code>: Specifies that this column cannot hold NULL values (constraints of this type are not nameable).</p><p><code>PRIMARY KEY</code>: Specifies the column that uniquely identifies a row in the table. The identified columns must be defined as NOT NULL.</p><p>Note: If you attempt to add a primary key using ALTER TABLE and any of the columns included in the primary key contain null values, an error will be generated and the primary key will not be added. See <a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj81859.html#rrefsqlj81859\">ALTER TABLE statement</a> for more information.</p><p><code>UNIQUE</code>: Specifies that values in the column must be unique.</p><p><code>FOREIGN KEY</code>: Specifies that the values in the column must correspond to values in a referenced primary key or unique key column or that they are NULL.</p><p><code>CHECK</code>: Specifies rules for values in the column.</p><p><strong>Table constraints include: </strong></p><p><code>PRIMARY KEY</code>: Specifies the column or columns that uniquely identify a row in the table. NULL values are not allowed.</p><p><code>UNIQUE</code>: Specifies that values in the columns must be unique.</p><p><code>FOREIGN KEY</code>: Specifies that the values in the columns must correspond to values in the referenced primary key or unique columns or that they are NULL.</p><p>Note: If the foreign key consists of multiple columns, and <em>any</em> column is NULL, the whole key is considered NULL. The insert is permitted, no matter what is in the non-null columns.</p><p><code>CHECK</code>: Specifies a wide range of rules for values in the table.</p><p><a href=\"https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj13590.html\">https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj13590.html</a></p><p><br></p><p><code>CASCADE DELETE</code></p><p>A foreign key with <code>CASCADE DELETE</code> means that if a record in the parent table is deleted, then the corresponding records in the child table will automatically be deleted. This is called a <code>CASCADE DELETE</code> in Oracle.</p><p>A foreign key with a <code>CASCADE DELETE</code> can be defined in either a <code>CREATE TABLE</code> statement or an <code>ALTER TABLE</code> statement.</p><p><a href=\"https://www.techonthenet.com/oracle/foreign_keys/foreign_delete.php\">https://www.techonthenet.com/oracle/foreign_keys/foreign_delete.php</a></p>",
                "answers": [
                    "<p>Only the primary key can be defined at the column and table level</p>",
                    "<p>A foreign key must reference either the primary key or a unique key of the parent table</p>",
                    "<p>A table can have only one primary key but multiple foreign keys</p>",
                    "<p>Primary key and foreign key constraints can be defined at both the column and table level</p>",
                    "<p>It is possible for child rows that have a foreign key to be deleted automatically from the child table at the time the parent row is deleted</p>"
                ]
            },
            "correct_response": [
                "b",
                "c",
                "d",
                "e"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements regarding primary and foreign key constraints and the effect they can have on table data. (Choose four)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306041,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>Which of the following is not a valid Oracle built-in data type?</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Is there any boolean type in Oracle databases?](https://stackoverflow.com/questions/3726758/is-there-any-boolean-type-in-oracle-databases)",
                    "[Oracle Built-In Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlqr/Data-Types.html#GUID-219C338B-FE60-422A-B196-2F0A01CAD9A4)"
                ],
                "feedbacks": [
                    "BOOLEAN is not a valid Oracle built-in data type. Oracle does not support the BOOLEAN data type, but instead uses CHAR(1) with a constraint to represent boolean values.",
                    "CHAR is a valid Oracle built-in data type that stores fixed-length character data.",
                    "UROWID is a valid Oracle built-in data type that stores the unique row identifier for a row of a table.",
                    "NCHAR is a valid Oracle built-in data type that stores fixed-length Unicode character data.",
                    "FLOAT is a valid Oracle built-in data type that stores double-precision floating-point numbers.",
                    "RAW is a valid Oracle built-in data type that stores variable-length binary data.",
                    "CLOB is a valid Oracle built-in data type that stores character data of variable length up to 4 GB.",
                    "BINARY_DOUBLE is a valid Oracle built-in data type that stores double-precision floating-point numbers in binary format.",
                    "BINARY_FLOAT is a valid Oracle built-in data type that stores single-precision floating-point numbers in binary format."
                ],
                "explanation": "<p><strong>Correct Answer:</strong> <code>BOOLEAN</code></p><p><code>**BOOLEAN**</code> is <strong>not a valid SQL data type</strong> in <strong>Oracle SQL</strong> (at least not in standard table columns).</p><ul><li><p>You <strong>can use BOOLEAN</strong> in <strong>PL/SQL blocks</strong> (procedures, functions), but <strong>not in table definitions</strong>.</p></li></ul><p>The Boolean datatype is missing in Oracle's SQL (not PL/SQL); there is no clear recommendation about what to use instead.</p><p>If you tried something like:</p><pre class=\"prettyprint linenums\">CREATE TABLE test_table (\n  status BOOLEAN);</pre><p><br></p><p>Oracle would throw an error like:</p><pre class=\"prettyprint linenums\">ORA-00902: invalid datatype</pre><p><br></p><p><strong>Oracle Built-In Data Types</strong></p><pre class=\"prettyprint linenums\">Data Type                         Description\nCHAR                              Fixed-length character data\nNCHAR                             Unicode character data\nFLOAT                             Approximate numeric data\nRAW                               Binary data\nCLOB                              Character large object\nUROWID                            Universal ROWID type\nBINARY_FLOAT                      Floating-point number\nBINARY_DOUBLE                     Higher-precision floating-point number</pre><p><br></p><p><strong>character_datatypes</strong></p><pre class=\"prettyprint linenums\">{ CHAR [ (size [ BYTE | CHAR ]) ]\n| VARCHAR2 (size [ BYTE | CHAR ])\n| NCHAR [ (size) ]\n| NVARCHAR2 (size)\n}</pre><p><br></p><p><strong>datetime_datatypes</strong></p><pre class=\"prettyprint linenums\">{ DATE\n| TIMESTAMP [ (fractional_seconds_precision) ]\n     [ WITH [ LOCAL ] TIME ZONE ]\n| INTERVAL YEAR [ (year_precision) ] TO MONTH\n| INTERVAL DAY [ (day_precision) ] TO SECOND\n     [ (fractional_seconds_precision) ]\n}</pre><p><br></p><p><strong>large_object_datatypes</strong></p><pre class=\"prettyprint linenums\">{ BLOB | CLOB | NCLOB | BFILE }</pre><p><br></p><p><strong>long_and_raw_datatypes</strong></p><pre class=\"prettyprint linenums\">{ LONG | LONG RAW | RAW (size) }</pre><p><br></p><p><strong>number_datatypes</strong></p><pre class=\"prettyprint linenums\">{ NUMBER [ (precision [, scale ]) ]\n| FLOAT [ (precision) ]\n| BINARY_FLOAT\n| BINARY_DOUBLE\n}</pre><p><br></p><p><strong>rowid_datatypes</strong></p><pre class=\"prettyprint linenums\">{ ROWID | UROWID [ (size) ] }\n</pre>",
                "answers": [
                    "<p><code>BOOLEAN</code> </p>",
                    "<p><code>CHAR </code> </p>",
                    "<p><code>UROWID </code> </p>",
                    "<p><code>NCHAR </code> </p>",
                    "<p><code>FLOAT </code> </p>",
                    "<p><code>RAW</code> </p>",
                    "<p><code>CLOB</code> </p>",
                    "<p><code>BINARY_DOUBLE</code> </p>",
                    "<p><code>BINARY_FLOAT</code> </p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Database SQL Reference",
            "question_plain": "Which of the following is not a valid Oracle built-in data type?",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306043,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Given:</strong> Each student can work on multiple projects, and each project can have multiple students. </p><p><strong>Required:</strong> Design an Entity Relationship Model (ERD) for optimal data storage and allow for generating reports in this format: </p><pre class=\"prettyprint linenums\">STUDENT_ID, FIRST_NAME, LAST_NAME, PROJECT_ID, PROJECT_NAME, PROJECT_TASK&nbsp; </pre><p><br></p><p>Identify the true statements about this scenario. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[What is ER Modeling? ](https://www.guru99.com/er-modeling.html)",
                    "[Modelling and Accessing Relational Data](http://www.oracle.com/technetwork/issue-archive/2011/11-nov/o61sql-512018.html)"
                ],
                "feedbacks": [
                    "In this scenario, each student can work on multiple projects, indicating a 1:M relationship between the STUDENTS and PROJECTS entities is not sufficient.",
                    "A M:M relationship between the STUDENTS and PROJECTS entities is required, but it must be resolved into 1:M relationships using an associative table to accurately represent the relationship between students and projects.",
                    "While STUDENT_ID should be the primary key in the STUDENTS entity, it should not be a foreign key in the PROJECTS entity as it does not directly link the two entities.",
                    "PROJECT_ID should be the primary key in the PROJECTS entity, but it should not be a foreign key in the STUDENTS entity as it does not directly link the two entities.",
                    "An associative table with a composite key of STUDENT_ID and PROJECT_ID is necessary to establish the M:M relationship between students and projects. This table acts as a bridge between the STUDENTS and PROJECTS entities, allowing for the optimal storage of data and generation of reports in the required format."
                ],
                "explanation": "<p>To design a proper <strong>Entity Relationship Diagram (ERD)</strong> for the given scenario:</p><p><strong>\"Each student can work on multiple projects, and each project can have multiple students.\"</strong></p><p>This describes a <strong>many-to-many (M: M)</strong> relationship.</p><p><strong>Correct Answers:</strong></p><ol><li><p><strong>The ERD must have an M: M relationship between the STUDENTS and PROJECTS entities that must be resolved into 1:M relationships.</strong></p><p><strong>True</strong> – A <strong>many-to-many relationship</strong> must be resolved by introducing a <strong>junction (associative) table</strong>, which breaks it into two <strong>one-to-many (1:M)</strong> relationships.</p></li><li><p><strong>An associative table must be created with a composite key of STUDENT_ID and PROJECT_ID, which is the foreign key linked to the STUDENTS and PROJECTS entities.</strong></p><p><strong>True</strong> – This <strong>junction table</strong> stores the relationships and may also contain additional attributes like <code>PROJECT_TASK</code>.</p></li></ol><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>The ERD must have a 1:M relationship between the STUDENTS and PROJECTS entities.</strong><br>Incorrect – It’s <strong>M: M</strong>, not 1:M.</p></li><li><p><strong>STUDENT_ID must be the primary key in the STUDENTS entity and a foreign key in the PROJECTS entity.</strong><br>Incorrect – This implies a 1:M from STUDENTS → PROJECTS, which violates the M: M requirement.</p></li><li><p><strong>PROJECT_ID must be the primary key in the PROJECTS entity and a foreign key in the STUDENTS entity.</strong><br>Incorrect – Same issue in reverse.</p></li></ul><p>Summary ERD Design:</p><ul><li><p><strong>STUDENTS</strong> (<code>STUDENT_ID</code>, <code>FIRST_NAME</code>, <code>LAST_NAME</code>)</p></li><li><p><strong>PROJECTS</strong> (<code>PROJECT_ID</code>, <code>PROJECT_NAME</code>)</p></li><li><p><strong>STUDENT_PROJECT</strong> (<code>STUDENT_ID</code>, <code>PROJECT_ID</code>, <code>PROJECT_TASK</code>)</p><ul><li><p>Composite Primary Key: (<code>STUDENT_ID</code>, <code>PROJECT_ID</code>)</p></li><li><p>Foreign Keys: <code>STUDENT_ID</code> → STUDENTS, <code>PROJECT_ID</code> → PROJECTS</p></li></ul></li></ul><p><br></p><p><strong>Entity Relationship Model </strong>(ER Modelling) is a graphical approach to database design. It is a high-level data model that defines data elements and their relationship for a specified software system. An ER model is used to represent real-world objects.</p><p>• An <strong>Entity </strong>is a thing or object in the real world that is distinguishable from the surrounding environment. For example, each employee of an organization is a separate entity. The following are some of the major characteristics of entities.</p><p>• An entity has a set of properties.</p><p>• Entity properties can have values.</p><p>One of the challenges faced when designing a database is the fact that designers, developers, and end-users tend to view data and its usage differently. If this situation is left unchecked, we can end up producing a database system that does not meet the requirements of the users.</p><p>Communication tools understood by all stakeholders(technical as well as non-technical users) are critical in producing database systems that meet the requirements of the users. ER models are examples of such tools.</p><p>ER diagrams also increase user productivity as they can be easily translated into relational tables.</p><p><strong>Steps to develop an ER Diagram for a database:</strong></p><p>1. Identify the entities and determine the relationships that exist among them.</p><p>2. Each entity, attribute, and relationship should have appropriate names that can be easily understood by non-technical people as well.</p><p>3. Relationships should not be connected directly to each other. Relationships should connect entities.</p><p>4. Each attribute in a given entity should have a unique name.</p><p><strong>Relationship Types</strong></p><p><strong>One-to-many (1:M).</strong> The most common type of relationship carnality is a 1:M (one-to-many) relationship. One record of an entity is related to one or more records of another entity. Entities that must be resolved are in 1:M relationships.</p><p><strong>One-to-one (1:1).</strong> A 1:1 (one-to-one) monogamous relationship between both entities in the relationship. One record of an entity is directly related to another record of an entity.</p><p><strong>Many-to-many (M: M).</strong> Many records of one entity can be related to many records of another entity.</p><p>Consider the <strong>STUDENT </strong>and <strong>PROJECT</strong> scenario. The business rule is as follows: <em>One student can be assigned to multiple projects, and one project can be supported by multiple students. </em>Therefore, it is necessary to create an M: M relationship to link these two tables.</p><p><br></p><p><strong>Associative PROJECT_TASKS table that resolves the M: M relationship</strong></p><p>In this scenario, the associative table’s primary key—a composite of its Student_ID and Project_ID columns—is foreign-key-linked to the tables for which it is resolving an M: M relationship. It reflects that one student can be assigned to multiple projects—and, in this example, that one student can be assigned multiple and different responsibilities for each project to which that person is assigned. Note that a student with a Student_ID value of 1234 can be assigned to two projects, but that their responsibilities will be different for each project.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-18_20-36-13-a2f3225b97a47cb5c6ff8d6f1692f4bf.png\"></p>",
                "answers": [
                    "<p>The ERD must have a 1:M relationship between the STUDENTS and PROJECTS entities.</p>",
                    "<p>The ERD must have a M:M relationship between the STUDENTS and PROJECTS entities that must be resolved into 1:M relationships.</p>",
                    "<p>STUDENT_ID must be the primary key in the STUDENTS entity and foreign key in the PROJECTS entity.</p>",
                    "<p>PROJECT_ID must be the primary key in the PROJECTS entity and foreign key in the STUDENTS entity.</p>",
                    "<p>An associative table must be created with a composite key of STUDENT_ID and PROJECT_ID, which is the foreign key linked to the STUDENTS and PROJECTS entities.</p>"
                ]
            },
            "correct_response": [
                "b",
                "e"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following scenario.Given: Each student can work on multiple projects, and each project can have multiple students. Required: Design an Entity Relationship Model (ERD) for optimal data storage and allow for generating reports in this format: STUDENT_ID, FIRST_NAME, LAST_NAME, PROJECT_ID, PROJECT_NAME, PROJECT_TASK&nbsp; Identify the true statements about this scenario. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306045,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCT_INFORMATION table. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-10-58-3a15d5c20ea5685bc55f03f6099c8df6.png\"></p><p><br></p><p><strong>Given: </strong></p><ul><li><p>The PRODUCT_ID column is the primary key. </p></li><li><p>No other indexes exist on the PRODUCT_INFORMATION table.</p></li></ul><p>Identify the query that would create the UPPER_NAME_IDX index. (Choose the best answer)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: Indexes](https://www.techonthenet.com/oracle/indexes.php)",
                    "[CREATE INDEX](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/CREATE-INDEX.html)"
                ],
                "feedbacks": [
                    "The syntax for creating an index is incorrect. The index name and table name should not be enclosed in single quotes. The WHERE clause is also not used correctly in this context.",
                    "The query is attempting to select and transform data using the UPPER function before creating an index. This is not the correct syntax for creating an index in Oracle Database SQL. The SELECT statement is unnecessary in this context.",
                    "The query is attempting to combine a SELECT statement with the CREATE INDEX statement, which is not valid syntax in Oracle Database SQL. The correct way to create an index is to use the CREATE INDEX statement directly.",
                    "This query correctly uses the CREATE INDEX statement to create the UPPER_NAME_IDX index on the PRODUCT_INFORMATION table based on the UPPER function applied to the PRODUCT_NAME column. This is the appropriate syntax for creating an index in Oracle Database SQL."
                ],
                "explanation": "<p>The correct query to create a function-based index on the <code>UPPER(product_name)</code> expression is:</p><pre class=\"prettyprint linenums\">CREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));</pre><p><br></p><ul><li><p>This creates a <strong>function-based index</strong> that stores the <strong>uppercase version</strong> of <code>product_name</code>, which is useful for <strong>case-insensitive searches</strong>, like:</p></li></ul><pre class=\"prettyprint linenums\">SELECT * \nFROM product_information\nWHERE UPPER(product_name) = 'LAPTOP';</pre><p><br></p><p>Why are the other options incorrect:</p><ol><li><pre class=\"prettyprint linenums\">sql\nCREATE INDEX 'upper_name_idx'\nON 'product_information'\nWHERE (UPPER(product_name));</pre><p>Uses <strong>incorrect quotes</strong> and <strong>invalid syntax</strong> – <code>'</code> is for string literals, not object names.</p><p><br></p></li><li><pre class=\"prettyprint linenums\">sql\nSELECT UPPER(product_name) \nCREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));\nFROM product_information;</pre><p>This is a mix of <code><strong>SELECT</strong></code><strong> and </strong><code><strong>CREATE INDEX</strong></code>, which is syntactically invalid.</p><p><br></p></li><li><pre class=\"prettyprint linenums\">sql\nSELECT CREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));</pre><p><code>CREATE INDEX</code> is a <strong>DDL statement</strong>, not valid inside a <code>SELECT</code>.</p></li></ol><p><br></p><p>An index is a performance-tuning method of allows faster retrieval of records. An index creates an entry for each value that appears in the indexed columns. By default, Oracle creates B-tree indexes.</p><p><strong>Create an Index</strong></p><p><strong>Syntax</strong></p><p>The syntax for creating an index in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE [UNIQUE] INDEX index_name\n  ON table_name (column1, column2, ... column_n)\n  [ COMPUTE STATISTICS ];</pre><p><br></p><p><code>UNIQUE</code>&nbsp; indicates that the combination of values in the indexed columns must be unique. index_name The name to assign to the index. table_name The name of the table in which to create the index. column1, column2, ... column_n The columns to use in the index. </p><p><code>COMPUTE STATISTICS</code>&nbsp; tells Oracle to collect statistics during the creation of the index. The statistics are then used by the optimizer to choose a \"plan of execution\" when SQL statements are executed.</p><p><strong>CREATE INDEX statement</strong></p><p>Use the <code>CREATE INDEX</code> statement to create an index on:</p><p>• One or more columns of a table, a partitioned table, an index-organized table, or a cluster</p><p>• One or more scalar-typed object attributes of a table or a cluster</p><p>• A nested table storage table for indexing a nested table column</p><p>• An index is a schema object that contains an entry for each value that appears in the indexed column(s) of the table or cluster and provides direct, fast access to rows.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-18_22-01-16-487689af5726831f2288293aef3aa5f0.png\"></p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE INDEX 'upper_name_idx'\nON 'product_information'\nWHERE (UPPER(product_name));</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT UPPER(product_name) \nCREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));\nFROM product_information;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT CREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE INDEX upper_name_idx\nON product_information (UPPER(product_name));</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the structure of the PRODUCT_INFORMATION table. Given: The PRODUCT_ID column is the primary key. No other indexes exist on the PRODUCT_INFORMATION table.Identify the query that would create the UPPER_NAME_IDX index. (Choose the best answer)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306047,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about INTERVAL data types. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle INTERVAL](https://www.oracletutorial.com/oracle-basics/oracle-interval/)",
                    "[ROUND (number)](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/ROUND-number.html)"
                ],
                "feedbacks": [
                    "The YEAR field in an INTERVAL YEAR TO MONTH column must be a positive value. This statement is incorrect as the YEAR field in an INTERVAL YEAR TO MONTH column can be both positive and negative, allowing for intervals that span multiple years.",
                    "INTERVAL DAY TO SECOND columns support fractions of seconds. This statement is correct as INTERVAL DAY TO SECOND columns can represent intervals with precision down to fractions of a second, making them suitable for precise time measurements.",
                    "INTERVAL YEAR TO MONTH columns only support monthly intervals within a single year. This statement is incorrect as INTERVAL YEAR TO MONTH columns can represent intervals that span multiple years, not just intervals within a single year.",
                    "INTERVAL YEAR TO MONTH columns support yearly intervals. This statement is correct as INTERVAL YEAR TO MONTH columns can represent intervals in terms of years, allowing for calculations and comparisons based on yearly intervals.",
                    "INTERVAL YEAR TO MONTH columns support monthly intervals within a range of years. This statement is correct as INTERVAL YEAR TO MONTH columns can represent intervals in terms of months within a range of years, providing flexibility in representing time spans.",
                    "The value in an INTERVAL DAY TO SECOND column can be copied into an INTERVAL YEAR TO MONTH column. This statement is incorrect as INTERVAL DAY TO SECOND and INTERVAL YEAR TO MONTH are different data types with distinct purposes, and their values cannot be directly copied between each other."
                ],
                "explanation": "<p>Oracle supports two <strong>INTERVAL</strong> data types:</p><ol><li><p><strong>INTERVAL YEAR TO MONTH</strong> – used to represent a span of <strong>years and months</strong></p></li><li><p><strong>INTERVAL DAY TO SECOND</strong> – used to represent a span of <strong>days, hours, minutes, seconds, and fractional seconds</strong></p></li></ol><p><strong>Correct Statements:</strong></p><ol><li><p><strong>INTERVAL DAY TO SECOND columns support fractions of seconds.</strong><br><strong>True</strong> – The <code>SECOND</code> part can have <strong>fractional precision</strong>, like <code>INTERVAL DAY TO SECOND(3)</code> allowing milliseconds.</p></li><li><p><strong>INTERVAL YEAR TO MONTH columns support yearly intervals.</strong><br><strong>True</strong> – These columns can store intervals that include <strong>years</strong>, such as <code>INTERVAL '2-0' YEAR TO MONTH</code>.</p></li><li><p><strong>INTERVAL YEAR TO MONTH columns support monthly intervals within a range of years.</strong><br><strong>True</strong> – For example, <code>INTERVAL '1-6' YEAR TO MONTH</code> represents <strong>1 year and 6 months</strong>.</p></li></ol><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>The YEAR field in an INTERVAL YEAR TO MONTH column must be a positive value.</strong><br>False – Interval values can be <strong>negative</strong>, e.g., <code>INTERVAL '-2-3' YEAR TO MONTH</code>.</p></li><li><p><strong>INTERVAL YEAR TO MONTH columns only support monthly intervals within a single year.</strong><br>False – They can span <strong>multiple years</strong> and months (e.g., 3 years and 11 months).</p></li><li><p><strong>The value in an INTERVAL DAY TO SECOND column can be copied into an INTERVAL YEAR TO MONTH column.</strong><br>False – These are <strong>distinct types</strong>, and cannot be directly converted without explicit transformation logic.</p></li></ul><p><br></p><p>Oracle provides you with two date-time data types: <code>DATE</code>and <code>TIMESTAMP</code> for storing point-in-time data. In addition, it provides the <code>INTERVAL</code> data type that allows you to store periods of time.</p><p>There are two types of <code>INTERVAL</code>:</p><p><code>INTERVAL YEAR TO MONTH</code> – stores intervals using of year and month.</p><p><code>INTERVAL DAY TO SECOND</code> – stores intervals using days, hours, minutes, and seconds, including fractional seconds.</p><p><br></p><p><strong>Oracle INTERVAL YEAR TO MONTH</strong></p><p>The <code>INTERVAL YEAR TO MONTH</code> data type allows you to store a period of time using the <code>YEAR</code> and <code>MONTH</code> fields.</p><p>The following illustrates an <code>INTERVAL YEAR TO MONTH</code>:</p><p><br></p><pre class=\"prettyprint linenums\">INTERVAL YEAR [(year_precision)] TO MONTH</pre><p><br></p><p><em>INTERVAL YEAR TO MONTH columns support monthly intervals within a range of years.</em></p><p><br></p><p>The <code>year_precision</code> represents the number of digits in the <code>YEAR</code> field. It ranges from 0 to 9.</p><p>The <code>year_precision</code> is optional. If you omit the <code>year_precision</code> argument, it defaults to 2. In other words, by default, you can store up to a period of 99 years and 11 months, which must be less than 100 years.</p><p>The <code>INTERVAL DAY TO SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds.</p><p><br></p><p>The following shows the syntax of the <code>INTERVAL DAY TO SECOND</code> data type:</p><p><br></p><pre class=\"prettyprint linenums\">INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]</pre><p><br></p><p><em>INTERVAL DAY TO SECOND columns support fractions of seconds.</em></p><p><br></p><p>In this syntax:<br>– <code>day_precision</code> is the number of digits in the <code>DAY</code> field. It ranges from 0 to 9. By default, its value is set to 2.<br>– <code>fractional_seconds_precision</code> is the number of digits in the fractional part of the <code>SECOND</code> field. It ranges from 0 through 9. If you omit the <code>fractional_seconds_precision</code>, it defaults to 6.</p><p><br></p><p><code>INTERVAL '120-3' YEAR(3) TO MONTH</code> An interval of 120 years, 3 months; Must specify the leading field precision <code>YEAR(3)</code> because the value of the leading field is greater than the default precision (2 digits).</p><p><br></p><p><strong>Oracle INTERVAL YEAR TO SECOND literals</strong></p><p>The literal form of <code>INTERVAL YEAR TO SECOND</code> is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">INTERVAL leading (leading_precision) to trailing(fractional_seconds_precision)</pre><p><br></p><p>The following table shows some examples of <code>INTERVAL YEAR TO SECOND</code> literals:</p><p><code>INTERVAL '11 10:09:08.555' DAY TO SECOND(3)</code>11 days, 10 hours, 09 minutes, 08 seconds, and 555 thousandths of a second.</p><p><code>INTERVAL '11 10:09' DAY TO MINUTE</code>11 days, 10 hours, and 09 minutes.</p><p><code>INTERVAL '100 10' DAY(3) TO HOUR</code>100 days 10 hours.</p><p><code>INTERVAL '999' DAY(3)</code>999 days.</p><p><code>INTERVAL '15:30' MINUTE TO SECOND </code>15 minutes 30 seconds.</p><p><code>INTERVAL '30' MINUTE</code>30 minutes.</p><p><code>INTERVAL '15.6789' SECOND(2,3)</code>Rounded to 15.679 seconds. Because the precision is 3, the fractional second ‘6789’ is rounded to ‘679’</p><p><strong>ROUND</strong></p><p>When there are numbers in parentheses following an interval literal (example <code>SECOND(2,3)</code>), this is for precision in rounding the number, as when using <code>ROUND</code>.</p><p><code>ROUND</code> returns <code>n</code> rounded to <code>integer</code> places to the right of the decimal point. If you omit the <code>integer</code>, then <code>n</code> is rounded to 0 places. The argument <code>integer</code> can be negative to round off digits left of the decimal point. </p>",
                "answers": [
                    "<p>The YEAR field in an INTERVAL YEAR TO MONTH column must be a positive value.</p>",
                    "<p>INTERVAL DAY TO SECOND columns support fractions of seconds.</p>",
                    "<p>INTERVAL YEAR TO MONTH columns only support monthly intervals within a single year.</p>",
                    "<p>INTERVAL YEAR TO MONTH columns support yearly intervals.</p>",
                    "<p>INTERVAL YEAR TO MONTH columns support monthly intervals within a range of years.</p>",
                    "<p>The value in an INTERVAL DAY TO SECOND column can be copied into an INTERVAL YEAR TO MONTH column.</p>"
                ]
            },
            "correct_response": [
                "b",
                "d",
                "e"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements about INTERVAL data types. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306049,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure in the EMPLOYEES tables as well as the exhibit. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-15-53-f476e5490991bf584fcdeecb839582b4.png\"></p><p><br></p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT employee_id, department_id\nFROM employees\nWHERE department_id = 50 ORDER&nbsp;BY&nbsp;department_id\nUNION\nSELECT employee_id, department_id\nFROM&nbsp;employees\nWHERE department_id = 90\nUNION\nSELECT employee_id, department_id\nFROM&nbsp;employees\nWHERE department_id = 10;</pre><p><br></p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: ORDER BY Clause](https://www.techonthenet.com/oracle/order_by.php)"
                ],
                "feedbacks": [
                    "The statement would not execute because the use of positional notation instead of column names in the ORDER BY clause is incorrect in SQL. Column names should be used to specify the sorting order in the ORDER BY clause.",
                    "The statement would execute successfully and display all the rows in the ascending order of DEPARTMENT_ID. The ORDER BY clause is correctly used to sort the result set in ascending order based on the DEPARTMENT_ID column.",
                    "The statement would execute successfully, but it will ignore the ORDER BY clause and display the rows in a random order. This is incorrect because the ORDER BY clause is not applied correctly in the SQL statement.",
                    "The statement would not execute because the ORDER BY clause should appear only at the end of the SQL statement, specifically in the last SELECT statement. Placing the ORDER BY clause in any other position in the SQL statement would result in an error."
                ],
                "explanation": "<p><strong>Correct Answer: The statement would not execute because the ORDER BY clause should appear only at the end of the SQL statement, that is, in the last SELECT statement.</strong></p><p><br></p><p>When using <strong>set operators</strong> like <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, or <code>MINUS</code> in Oracle:</p><ul><li><p>The <code><strong>ORDER BY</strong></code><strong> clause</strong> can <strong>only appear once</strong>, and it <strong>must be at the very end</strong> of the <strong>entire query</strong>, not in individual <code>SELECT</code> blocks.</p></li></ul><p>What's wrong with the query?</p><p>The query shown includes this:</p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 50 \nORDER BY department_id\nUNION\nSELECT ...</pre><p><br></p><p>This is <strong>invalid syntax</strong> — Oracle will raise an error like:</p><pre class=\"prettyprint linenums\">ORA-00933: SQL command not properly ended</pre><p><br></p><p>Correct Version of the Query:</p><pre class=\"prettyprint linenums\">sql\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 50\nUNION\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 90\nUNION\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 10\nORDER BY department_id;</pre><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-18_23-55-08-8541a0168c8ded5bcfe4c0961c7efd02.png\"></p><p><br></p><p>The Oracle <code>ORDER BY</code> clause is used to sort the records in your result set. The ORDER BY clause can only be used in<a href=\"https://www.techonthenet.com/oracle/select.php\"> SELECT statements</a>.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>ORDER BY</code> clause in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expressions\nFROM tables\n[WHERE conditions]\nORDER BY expression [ ASC | DESC ];</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expressions - The columns or calculations that you wish to retrieve. </p><p>Tables - The tables that you wish to retrieve records from. There must be at least one table listed in the <code>FROM</code> clause.</p><p><code>WHERE</code> conditions - Optional. The conditions that must be met for the records to be selected. </p><p><code>ASC</code> - Optional. It sorts the result set in ascending order by <em>expression</em> (default, if no modifier is provided).</p><p><code>DESC</code> - Optional. It sorts the result set in descending order by <em>expression</em>.</p><p>Note:&nbsp; If the ASC or DESC modifier is not provided in the <code>ORDER BY</code> clause, the results will be sorted by <em>expression</em> in ascending order (which is equivalent to <code>ORDER BY <em>expression</em> ASC</code>).</p>",
                "answers": [
                    "<p>The statement would not execute because the positional notation instead of the column name should be used with the ORDER BY clause.</p>",
                    "<p>The statement would execute successfully and display all the rows in the ascending order of DEPARTMENT_ID.</p>",
                    "<p>The statement would execute successfully but it will ignore the ORDER BY clause and display the rows in random order.</p>",
                    "<p>The statement would not execute because the ORDER BY clause should appear only at the end of the SQL statement, that is, in the last SELECT statement.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure in the EMPLOYEES tables as well as the exhibit. Evaluate the following SQL statement.Exhibit: 1SELECT employee_id, department_id\nFROM employees\nWHERE department_id = 50 ORDER&nbsp;BY&nbsp;department_id\nUNION\nSELECT employee_id, department_id\nFROM&nbsp;employees\nWHERE department_id = 90\nUNION\nSELECT employee_id, department_id\nFROM&nbsp;employees\nWHERE department_id = 10;Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306051,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Contents of the Data Dictionary](https://docs.oracle.com/cd/E11882_01/server.112/e40540/datadict.htm#CNCPT1209)",
                    "[The Complete Guide to Oracle Synonyms](https://www.databasestar.com/oracle-synonym/)",
                    "[USER_SYNONYMS](https://docs.oracle.com/search/?q=USER_SYNONYMS&product=en%252Fdatabase%252Foracle%252Foracle-database%252F23&pmode=ALL&lang=en)"
                ],
                "feedbacks": [
                    "The USER_SYNONYMS view in Oracle Database SQL provides information about private synonyms that are created by the user who queries the view. It does not include public synonyms or synonyms created by other users.",
                    "<p>Not all dynamic performance views prefixed with v$ are accessible to all database users in Oracle Database SQL. Some of these views may require specific privileges or roles to access, and not all users may have the necessary permissions to view the data in these views.</p>",
                    "<p>The <code>USER_OBJECTS</code> view provides metadata about all objects (including tables, views, indexes, procedures, etc.) owned by the user who runs the query.</p>",
                    "<p>The DICTIONARY view in Oracle Database SQL contains the names of all the data dictionary views that the user can access. It provides a convenient way to see the available data dictionary views that can be queried for information about the database schema and objects.</p>"
                ],
                "explanation": "<p><strong>Correct Statements:</strong></p><ol><li><p><strong>The USER_SYNONYMS view can provide information about private synonyms.</strong><br><strong>True</strong> – <code>USER_SYNONYMS</code> displays <strong>private synonyms</strong> owned by the current user.</p></li><li><p><strong>The USER_OBJECTS view provides metadata about all objects owned by the user who runs the query.</strong><br><strong>True</strong> – <code>USER_OBJECTS</code> lists all <strong>objects owned by the current user</strong>, including tables, views, indexes, procedures, etc.</p></li><li><p><strong>DICTIONARY is a view that contains the names of all the data dictionary views that the user can access.</strong><br><strong>True</strong> – The <code>DICTIONARY</code> view (also known as <code>DICT</code>) shows <strong>descriptions and names of all dictionary views</strong> available to the user.</p></li></ol><p>Incorrect Statement:</p><ul><li><p><strong>All the dynamic performance views prefixed with v$ are accessible to all the database users.</strong><br><strong>False</strong> – Access to <code>V$</code> views (like <code>V$SESSION</code>, <code>V$DATABASE</code>, etc.) is <strong>restricted</strong>, usually granted via roles like <code>SELECT_CATALOG_ROLE</code> or specific privileges. They are <strong>not accessible by default to all users</strong>.</p></li></ul><p><br></p><p>A synonym is an alias or alternative name for an object.</p><p><strong>Synonym vs. View</strong></p><p>A view object is an SQL query that is saved and run when other queries use that view. It works like a table.</p><p>A view contains more complicated logic. If you just want to provide an alias for a table or another object, you can use a synonym. If you want to <code>SELECT</code> data from a table and use <code>WHERE</code> conditions or other logic, then a view is better.</p><p><strong>Types of synonyms</strong></p><p>A <strong>public</strong> synonym can be accessed by any user on the database. The user who creates the synonym does not own it – it’s owned by the PUBLIC user group.</p><p>A <strong>private</strong> synonym can only be accessed by the person who created the synonym. This user is also the owner. The synonym name must be unique within the schema.</p><p>To create a synonym in Oracle (either private or public), we use the <code>CREATE SYNONYM</code> command.</p><p><strong>Syntax</strong></p><p><br></p><pre class=\"prettyprint linenums\">CREATE [OR REPLACE] [PUBLIC] SYNONYM [schema.] synonym_name FOR [schema.] object_name [@dblink_name];</pre><p><br></p><p>To find a list of synonyms in the database, you can run these queries.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * FROM all_synonyms;</pre><p><br></p><p>This shows us a list of all synonyms available to the current user.</p><p>A query on the dba_synonyms view will show us all synonyms in the database:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * FROM dba_synonyms;</pre><p><br></p><p>And finally, a query on user_synonyms will show us all private synonyms owned by the current user:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * FROM user_synonyms;</pre><p><br></p><p><em>The USER_SYNONYMS view can provide information about private synonyms.</em></p><p><br></p><p><br></p><p><code>USER_SYNONYMS</code> describes the private synonyms (synonyms owned by the current user). Its <code>COLUMNS ()</code> are the same as those in <code>ALL_SYNONYMS</code>.</p><p><br></p><pre class=\"prettyprint linenums\">CREATE PUBLIC SYNONYM synonym_name FOR object_name</pre><p><br></p><p><code>USER_OBJECTS</code> describes all objects owned by the current user. Its columns are the same as those in <a href=\"https://docs.oracle.com/cd/B19306_01/server.102/b14237/statviews_2005.htm#i1583352\">\"ALL_OBJECTS\"</a>.</p><p><em>The USER_OBJECTS view can provide information about the tables and views created by the user who queries the view.</em></p><p><br></p><pre class=\"prettyprint linenums\">SELECT owner, object_name, object_type\nFROM   user_objects\nORDER BY owner, object_name;</pre><p><br></p><p><strong>Contents of the Data Dictionary</strong></p><p>The data dictionary consists of the following types of objects:</p><p><strong>Base tables</strong></p><p>These underlying tables store information about the database. Only Oracle Database should write to and read these tables. Users rarely access the base tables directly because they are normalized, and most data is stored in a cryptic format.</p><p><strong>Views</strong></p><p>These views decode the base table data into useful information, such as user or table names, using <a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e40540/glossary.htm#CHDICCFG\">joins</a> and <code>WHERE</code> clauses to simplify the information. These views contain the names and descriptions of all objects in the data dictionary. Some views are accessible to all database users, whereas others are intended for administrators only.</p><p>Typically, data dictionary views are grouped in sets. In many cases, a set consists of three views containing similar information and distinguished from each other by their prefixes. By querying the appropriate views, you can access only the information relevant to you.</p><p><code>DBA_</code> - Database administrators can view all objects. Some <code>DBA_</code> views have additional columns containing information useful to the administrator.</p><p><code>ALL_</code> - All users can view objects to which the user has privileges including objects owned by user. These views obey the current set of enabled roles.</p><p><code>USER_</code> - All users can view objects owned by user. Views with the prefix <code>USER_</code> usually exclude the column <code>OWNER</code>. This column is implied in the <code>USER_</code> views to be the user issuing the query.</p><p>The system-supplied <code>DICTIONARY</code> view contains the names and abbreviated descriptions of all data dictionary views.</p><p><br></p><pre class=\"prettyprint linenums\">SELECT * FROM DICTIONARY</pre><p><br></p><p><em>DICTIONARY is a view that contains the names of all the data dictionary views that the user can access.</em></p>",
                "answers": [
                    "<p>The USER_SYNONYMS view can provide information about private synonyms.</p>",
                    "<p>All the dynamic performance views prefixed with v$ are accessible to all the database users.</p>",
                    "<p>The USER_OBJECTS view provides metadata about all objects owned by the user who runs the query.</p>",
                    "<p>DICTIONARY is a view that contains the names of all the data dictionary views that the user can access.</p>"
                ]
            },
            "correct_response": [
                "a",
                "d",
                "e",
                "c"
            ],
            "section": "Data Dictionary and Dynamic Performance Views",
            "question_plain": "View and examine the following available responses.Identify the true statements. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306053,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the ORDERS table and the exhibit. </p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-18-07-0eab527b303e07873063d6b4343a3488.png\"></p><p><br></p><p><strong>Given:</strong> The ORDER_ID column is the PRIMARY KEY in the ORDERS table.</p><p>Evaluate the following CREATE TABLE command.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE new_orders(ord_id, ord_date DEFAULT SYSDATE, cus_id)\nAS\nSELECT order_id, order_date, customer_id\nFROM&nbsp;orders;</pre><p><br></p><p>Identify the true statement the above command.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The statement is incorrect because the DEFAULT value can be specified in the column definition. It is a valid feature in SQL when creating a new table.",
                    "This statement is correct because the NOT NULL constraint defined on the specified columns in the CREATE TABLE command would be passed to the new table. Other constraints, such as PRIMARY KEY, would not be automatically transferred.",
                    "This statement is incorrect because the column names in the CREATE TABLE command and the SELECT clause do not necessarily have to match when creating a new table. As long as the data types and constraints are compatible, the new table can be created.",
                    "This statement is incorrect because only the constraints explicitly defined in the CREATE TABLE command, such as NOT NULL, would be passed to the new table. Other constraints, like PRIMARY KEY, would not be automatically transferred."
                ],
                "explanation": "<p>Let's break down the <code>CREATE TABLE</code> command provided and evaluate the true statement.</p><pre class=\"prettyprint linenums\">CREATE TABLE new_orders(ord_id, ord_date DEFAULT SYSDATE, cus_id)\nAS\nSELECT order_id, order_date, customer_id\nFROM orders;</pre><p><br></p><p><strong>Explanation of the command:</strong></p><ul><li><p>The <code><strong>CREATE TABLE AS</strong></code> statement creates a new table (<code>new_orders</code>) based on the result of a <code>SELECT</code> query from the <code>orders</code> table.</p></li><li><p>In the <strong>column definition</strong> part of the <code>CREATE TABLE</code> command (<code>ord_id, ord_date DEFAULT SYSDATE, cus_id</code>), only <code>ord_date</code> has a <code><strong>DEFAULT</strong></code> value (<code>SYSDATE</code>), and no constraints are explicitly mentioned.</p></li><li><p>The <code><strong>SELECT</strong></code><strong> clause</strong> specifies the columns (<code>order_id</code>, <code>order_date</code>, <code>customer_id</code>) from the <code>orders</code> table, which will populate the <code>new_orders</code> table.</p></li></ul><p>Key points:</p><ul><li><p>The <code>DEFAULT SYSDATE</code> is <strong>not passed</strong> from the source table (<code>orders</code>) but is specified in the <code>CREATE TABLE</code> command. This will be applied to the <code>ord_date</code> column of <code>new_orders</code>.</p></li><li><p><strong>Constraints</strong> (such as NOT NULL or primary key) defined on columns in <code>ORDERS</code> will <strong>not</strong> be transferred to <code>new_orders</code> when using <code>CREATE TABLE AS</code> — only the data is transferred, not the constraints.</p></li></ul><p><strong>Correct Answer: The NEW_ORDERS table would not be created because the column names in the CREATE TABLE command and the SELECT clause do not match.</strong></p><p><strong>Explanation for this Answer:</strong></p><ul><li><p>The <strong>column names</strong> in the <code>CREATE TABLE</code> command do not match the <strong>columns selected</strong> in the <code>SELECT</code> statement.</p><ul><li><p><code>ord_id</code> is specified in <code>CREATE TABLE</code> but should correspond to <code>order_id</code> in the <code>SELECT</code> statement.</p></li><li><p>Similarly, <code>cus_id</code> in <code>CREATE TABLE</code> should correspond to <code>customer_id</code> in the <code>SELECT</code> clause.</p></li></ul></li><li><p><strong>Mismatch in column names</strong> causes the error because <strong>column names in the </strong><code><strong>CREATE TABLE</strong></code><strong> clause</strong> must align with the selected columns in the <code>SELECT</code> clause.</p></li></ul><p><strong>Why the other answers are incorrect:</strong></p><ul><li><p><strong>\"The NEW_ORDERS table would be created and only the NOT NULL constraint defined on the specified columns would be passed to the new table.\"</strong><br>Incorrect – <strong>No constraints</strong> (e.g., NOT NULL) are copied over when using <code>CREATE TABLE AS</code>. Only the data is copied, not the constraints.</p></li><li><p><strong>\"The NEW_ORDERS table would not be created because the DEFAULT value cannot be specified in the column definition.\"</strong><br>Incorrect – You <strong>can</strong> specify default values in the column definition, so this is not the issue.</p></li><li><p><strong>\"The NEW_ORDERS table would be created and all the constraints defined on the specified columns in the ORDERS table would be passed to the new table.\"</strong><br>Incorrect – Constraints <strong>do not</strong> transfer with <code>CREATE TABLE AS</code>. The new table will not automatically inherit any constraints from the source table.</p></li></ul>",
                "answers": [
                    "<p>The NEW_ORDERS table would not be created because the DEFAULT value cannot be specified in the column definition.</p>",
                    "<p>The NEW_ORDERS table would be created and only the NOT NULL constraint defined on the specified columns would be passed to the new table.</p>",
                    "<p>The NEW_ORDERS table would not be created because the column names in the CREATE TABLE command and the SELECT clause do not match.</p>",
                    "<p>The NEW_ORDERS table would be created and all the constraints defined on the specified columns in the ORDERS table would be passed to the new table.</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the ORDERS table and the exhibit. Given: The ORDER_ID column is the PRIMARY KEY in the ORDERS table.Evaluate the following CREATE TABLE command.Exhibit: 1CREATE TABLE new_orders(ord_id, ord_date DEFAULT SYSDATE, cus_id)\nAS\nSELECT order_id, order_date, customer_id\nFROM&nbsp;orders;Identify the true statement the above command.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306055,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of CUSTOMERS table as well as the exhibit.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-21-32-b4c4963783cd138a8767800d4c976df0.png\"></p><p><br></p><p>Evaluate the following query.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT cust_id, cust_city\nFROM&nbsp;customers\nWHERE cust_first_name NOT LIKE 'A_%_%'\nAND cust_credit_limit BETWEEN 5000 AND 15000\nAND&nbsp;cust_credit_limit NOT IN (7000, 11000)\nAND&nbsp;cust_city NOT&nbsp;BETWEEN&nbsp;'A' AND 'B';</pre><p><br></p><p>Identify the true statement regarding the above query.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The query does not produce an error because the condition on the CUST_CITY column is valid. The WHERE clause is checking for customers whose city is 'Seattle'.",
                    "The query does not produce an error because the condition on the CUST_FIRST_NAME column is valid. The WHERE clause is checking for customers whose first name starts with 'J'.",
                    "The query does not produce an error because the conditions on the CUST_CREDIT_LIMIT column are valid. The WHERE clause is checking for customers with a credit limit greater than 5000.",
                    "The query executes successfully because all the conditions in the WHERE clause are valid and do not cause any errors in the SQL statement."
                ],
                "explanation": "<p>Let's break down the query and evaluate each condition:</p><pre class=\"prettyprint linenums\">SELECT cust_id, cust_city\nFROM&nbsp;customers\nWHERE cust_first_name NOT LIKE 'A_%_%'\nAND cust_credit_limit BETWEEN 5000 AND 15000\nAND&nbsp;cust_credit_limit NOT IN (7000, 11000)\nAND&nbsp;cust_city NOT&nbsp;BETWEEN&nbsp;'A' AND 'B';</pre><p><br></p><p>1. <code>cust_first_name NOT LIKE 'A_%_%'</code></p><ul><li><p>This is <strong>valid SQL syntax</strong>.</p></li><li><p>The pattern <code>'A_%_%'</code> matches strings that:</p><ul><li><p>Start with <strong>A</strong></p></li><li><p>Have at least <strong>two underscores</strong> (each underscore means a single character)</p></li><li><p>So it's looking for names starting with A followed by at least two characters.</p></li></ul></li></ul><p>2. <code>cust_credit_limit BETWEEN 5000 AND 15000</code></p><ul><li><p>Valid condition.</p></li><li><p>It checks for values between 5000 and 15000 inclusive.</p></li></ul><p>3. <code>cust_credit_limit NOT IN (7000, 11000)</code></p><ul><li><p>Also valid.</p></li><li><p>Excludes those two specific values.</p></li></ul><p>4. <code>cust_city NOT BETWEEN 'A' AND 'B'</code></p><ul><li><p>This is <strong>valid</strong>, although it may be <strong>logically limited</strong>.</p></li><li><p>It evaluates lexicographically (alphabetical string comparison).</p></li><li><p>This condition means it will exclude cities where names are alphabetically between 'A' and 'B' (inclusive).</p></li><li><p>But this is syntactically valid SQL.</p></li></ul><p>Conclusion: There is <strong>no syntax error</strong> in this query. All conditions are <strong>valid</strong>.</p><p><strong>Correct Answer:</strong> <strong>It executes successfully.</strong></p>",
                "answers": [
                    "<p>It produces an error because the condition on the CUST_CITY column is not valid.</p>",
                    "<p>It produces an error because the condition on the CUST_FIRST_NAME column is not valid.</p>",
                    "<p>It produces an error because conditions on the CUST_CREDIT_LIMIT column are not valid.</p>",
                    "<p>It executes successfully.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of CUSTOMERS table as well as the exhibit.Evaluate the following query.Exhibit: 1SELECT cust_id, cust_city\nFROM&nbsp;customers\nWHERE cust_first_name NOT LIKE 'A_%_%'\nAND cust_credit_limit BETWEEN 5000 AND 15000\nAND&nbsp;cust_credit_limit NOT IN (7000, 11000)\nAND&nbsp;cust_city NOT&nbsp;BETWEEN&nbsp;'A' AND 'B';Identify the true statement regarding the above query.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306057,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about single-row functions. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[ARGUMENT statement](https://docs.oracle.com/cd/B28359_01/olap.111/b28126/dml_commands_1014.htm#OLADM753)"
                ],
                "feedbacks": [
                    "Single-row functions can be nested, meaning that one single-row function can be used as an argument for another single-row function, allowing for complex data transformations and manipulations.",
                    "The data type returned by a single-row function can indeed be different from the data type of the argument provided. This flexibility allows for versatile data processing and manipulation within SQL queries.",
                    "Single-row functions can actually accept multiple arguments, not just one. This allows for more dynamic and customizable data processing within SQL queries.",
                    "Single-row functions can accept various types of arguments, including column names, variables, literals, and expressions. This versatility in argument types allows for a wide range of data manipulation possibilities.",
                    "Single-row functions can be used in various parts of a SQL query, not just in the WHERE clause. They can be used in the SELECT list, ORDER BY clause, GROUP BY clause, and more, to perform data transformations and calculations.",
                    "Single-row functions do not necessarily return a single result row per table. Depending on how they are used in a query, they can return multiple result rows or even no result rows at all, depending on the data and logic applied."
                ],
                "explanation": "<p><strong>True Statements:</strong></p><ol><li><p><strong>Single row functions can be nested.</strong><br><strong>True</strong> – You can nest one single-row function inside another (e.g., <code>UPPER(SUBSTR(name, 1, 3))</code>).</p></li><li><p><strong>The data type returned can be different from the data type of the argument.</strong><br><strong>True</strong> – For example, <code>TO_CHAR(SYSDATE)</code> returns a string even though the argument is a date.</p></li><li><p><strong>The argument can be a column name, variable, literal or an expression.</strong><br><strong>True</strong> – Functions can take various inputs including literals (<code>'abc'</code>), column names, or expressions like <code>(salary + bonus)</code>.</p></li></ol><p><strong>False Statements:</strong></p><p><strong>They can accept only one argument.</strong></p><ul><li><p><strong>False</strong> – Many single-row functions can accept <strong>multiple arguments</strong> (e.g., <code>REPLACE('jack', 'j', 'bl')</code>).</p></li></ul><p><strong>They can be used only in the WHERE clause of a SELECT statement.</strong></p><ul><li><p><strong>False</strong> – They can be used in <strong>SELECT</strong>, <strong>WHERE</strong>, <strong>ORDER BY</strong>, <strong>GROUP BY</strong>, <strong>HAVING</strong>, etc.</p></li></ul><p><strong>They return a single result row per table.</strong></p><ul><li><p><strong>False</strong> – They return <strong>one result per row</strong>, not per table.</p></li></ul><p><br></p><p>The single-row functions operate on single rows and return only one result per row. In general, the functions take one or more inputs as arguments and return a single value as output. The arguments can be a user-supplied constant, variable, column name and an expression.</p><p><strong>The features of single row functions are:</strong></p><p>• Act on each row returned in the query.</p><p>• Perform calculations on data. </p><p>• Modify the data items. </p><p>• Manipulate the output for groups of rows. </p><p>• Format numbers and dates. </p><p>• Converts column data types. </p><p>• Returns one result per row. </p><p>• Used in <code>SELECT</code>, <code>WHERE</code>, <code>START WITH</code> , <code>CONNECT BY</code>, <code>HAVING</code> and <code>ORDER BY</code> clauses. </p><p>• <em>Single row functions can be nested.</em></p><p><br></p><p><strong>The single row functions are categorized into:</strong></p><p><strong>Character Functions:</strong> Character functions accept character inputs and can return either character or number values as output.</p><p> <strong>Number Functions:</strong> Number functions accepts numeric inputs and returns only numeric values as output. </p><p><strong>Date Functions:</strong> Date functions operate on date data type and returns a date value or numeric value. </p><p><strong>Conversions Functions:</strong> Converts from one data type to another data type. Generally, the form of the function names follows the convention <code>datatype</code> <code>TO</code> <code>datatype</code>. The first data type is the input data type. The second data type is the output data type.</p><p><em>The data type returned can be different from the data type of the argument.</em></p><p>• If the input argument is <code>CHAR</code> or <code>VARCHAR2</code>, then the value returned is <code>VARCHAR2</code>.</p><p>• If the input argument is <code>NCHAR</code> or <code>NVARCHAR2</code>, then the value returned is <code>NVARCHAR2</code>.</p><p>• The length of the value returned by the function is limited by the maximum length of the data type returned.</p><p>• For functions that return <code>CHAR</code> or <code>VARCHAR2</code>, if the length of the return value exceeds the limit, then Oracle Database truncates it and returns the result without an error message.</p><p>• For functions that return <code>CLOB</code> values, if the length of the return values exceeds the limit, then Oracle raises an error and returns no data.</p><p><strong>General Functions</strong></p><p>The <code>ARGUMENT</code> statement declares an argument that is expected by the program. Within the program, the argument is stored in a structure similar to a variable or valueset. The argument is initialized with the value that was passed when the program was invoked. An argument exists only while the program is running.</p><p>An expression is an arbitrarily complex combination of operands (variables, constants, literals, operators, function calls, and placeholders) and operators. The simplest expression is a single variable.</p><p><em>The argument can be a column name, variable, literal or an expression.</em></p>",
                "answers": [
                    "<p>Single row functions can be nested.</p>",
                    "<p>The data type returned can be different from the data type of the argument.</p>",
                    "<p>They can accept only one argument.</p>",
                    "<p>The argument can be a column name, variable, literal or an expression.</p>",
                    "<p>They can be used only in the WHERE clause of a SELECT statement.</p>",
                    "<p>They return a single result row per table.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b",
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify the true statements about single-row functions. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306059,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PROMOTIONS table.</p><p><strong>Table: PROMOTIONS </strong></p><pre class=\"prettyprint linenums\">Name                  Null??            Type\nPROMO_ID              NOT NULL          NUMBER(6)\nPROMO_NAME            NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY        NOT NULL          VARCHAR2(30)\nPROMO_COST            NOT NULL          NUMBER(10,2)</pre><p><br></p><p><strong>Required:</strong> Create a report of unique promotion costs in each promotion category.&nbsp; </p><p>Identify the SQL query which would give you the required output.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle SELECT DISTINCT](https://www.oracletutorial.com/oracle-basics/oracle-select-distinct/)"
                ],
                "feedbacks": [
                    "This SQL query selects distinct values of promotion category and promotion cost from the PROMOTIONS table and orders the result by the first column. This query correctly retrieves unique promotion costs in each promotion category.",
                    "This SQL query uses incorrect syntax by combining UNIQUE and DISTINCT keywords in the SELECT statement. The correct syntax is to use either DISTINCT or UNIQUE, not both. Additionally, the order of columns in the SELECT statement is incorrect for the required output.",
                    "This SQL query selects unique values of promo_id and promo_category from the PROMOTIONS table and groups the result by promo_id. However, the required output is to display unique promotion costs in each promotion category, not promo_id and promo_category.",
                    "This SQL query incorrectly uses the DISTINCT keyword for both promo_cost and promo_category in the SELECT statement. The correct syntax is to use DISTINCT once for each column. Additionally, the order of columns in the SELECT statement is incorrect for the required output."
                ],
                "explanation": "<p>To <strong>create a report of unique promotion costs in each promotion category</strong>, you need a query that:</p><ul><li><p>Selects both <code>promo_category</code> and <code>promo_cost</code>.</p></li><li><p>Ensures each combination of <code>promo_category</code> and <code>promo_cost</code> is <strong>unique</strong>.</p></li><li><p>Sorts the result (optional but useful).</p></li></ul><p><strong>Correct SQL&nbsp;Query:</strong></p><pre class=\"prettyprint linenums\">SELECT DISTINCT promo_category, promo_cost&nbsp; \nFROM promotions&nbsp; \nORDER BY 1;</pre><p><br></p><p>Why this is correct:</p><ul><li><p><code>SELECT DISTINCT promo_category, promo_cost</code> ensures only <strong>unique pairs</strong> of promotion category and promotion cost are selected.</p></li><li><p><code>ORDER BY 1</code> sorts the output by <code>promo_category</code>.</p></li></ul><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-19_20-40-40-df91ca6359ee79fe4d6f8c472c4764e1.png\"></p><p><br></p><p>Why the others are incorrect:</p><ol><li><p><code><strong>SELECT UNIQUE promo_category, DISTINCT promo_cost</strong></code> – This is invalid syntax. You cannot use both <code>UNIQUE</code> and <code>DISTINCT</code> like this, and <code>UNIQUE</code> is just a synonym for <code>DISTINCT</code> in Oracle but not used this way.</p></li><li><p><code><strong>SELECT UNIQUE promo_id, promo_category FROM promotions GROUP BY promo_id</strong></code> – This selects by <code>promo_id</code>, not relevant to the requirement of grouping by category and cost.</p></li><li><p><code><strong>SELECT DISTINCT promo_cost, DISTINCT promo_category</strong></code> – Invalid syntax; you can only use <code>DISTINCT</code> once on the full row selection.</p></li></ol><p><br></p><p>The <code>DISTINCT</code> clause is used in a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement to filter duplicate rows in the result set. It ensures that rows returned are unique for the column or columns specified in the <code>SELECT</code> clause.</p><p>The following illustrates the syntax of the <code>SELECT DISTINCT</code> statement:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT DISTINCT\n  column_1\nFROM\n  table;</pre><p><br></p><p>In this statement, the values in the <code>column_1</code> of the <code>table</code> are compared to determine the duplicates.</p><p>To retrieve unique data based on multiple columns, you just need to specify the column list in the <code>SELECT</code> clause as follows:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n    DISTINCT column_1,\n    column_2,\n        ...\nFROM\n    table_name;</pre><p><br></p><p>In this syntax, the combination of values in the <code>column_1</code><em>, </em><code>column_2</code>, and <code>column_3</code> are used to determine the uniqueness of the data.</p><p>The <code>DISTINCT</code> clause can be used only in the <code>SELECT</code> statement.</p><p>Note that <code>DISTINCT</code> is synonym of <code>UNIQUE</code> which is not SQL standard. It is a good practice to always use <code>DISTINCT</code> instead of <code>UNIQUE</code>.</p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT promo_category, promo_cost&nbsp; \nFROM promotions&nbsp; \nORDER BY 1;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT UNIQUE promo_category, \nDISTINCT promo_cost&nbsp; \nFROM promotions;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT UNIQUE promo_id, promo_category&nbsp; \nFROM promotions\nGROUP BY promo_id;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT DISTINCT promo_cost, \nDISTINCT promo_category&nbsp; \nFROM promotions;</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the PROMOTIONS table.Table: PROMOTIONS Name                  Null??            Type\nPROMO_ID              NOT NULL          NUMBER(6)\nPROMO_NAME            NOT NULL          VARCHAR2(30)\nPROMO_CATEGORY        NOT NULL          VARCHAR2(30)\nPROMO_COST            NOT NULL          NUMBER(10,2)Required: Create a report of unique promotion costs in each promotion category.&nbsp; Identify the SQL query which would give you the required output.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306061,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structure of the PRODUCTS table as well as the exhibits.</p><p><strong>Table: PRODUCTS </strong> </p><pre class=\"prettyprint linenums\">Name                   Null??              Type\nPROMO_ID               NOT NULL            NUMBER(4)\nPROMO_NAME                                 VARCHAR(25)\nPROMO_EXPIRY                               DATE</pre><p><br></p><p>Evaluate the following two SQL statements.</p><p><strong>Exhibit 1.</strong></p><pre class=\"prettyprint linenums\">SELECT promo_id, NVL2 (promo_expiry, promo_expiry_date + 15, ' ')\nFROM products;</pre><p><br></p><p><strong>Exhibit 2.</strong></p><pre class=\"prettyprint linenums\">SELECT promo_id, NVL (promo_expiry, promo_expiry_date + 15)\nFROM products;</pre><p><br></p><p>Identify the statement which is true regarding the result.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "<p><strong>\"Only the second SQL statement executes successfully\"</strong></p><ul><li><p><strong>Exhibit 1 fails</strong> due to a <strong>data type mismatch</strong> (<code>DATE</code> vs. <code>VARCHAR2</code>).</p></li><li><p><strong>Exhibit 2 executes successfully</strong>, though it may not give the expected results if <code>PROMO_EXPIRY</code> is NULL.</p></li></ul>",
                    "<p><strong>\"Only the second SQL statement executes successfully\"</strong></p><ul><li><p><strong>Exhibit 1 fails</strong> due to a <strong>data type mismatch</strong> (<code>DATE</code> vs. <code>VARCHAR2</code>).</p></li><li><p><strong>Exhibit 2 executes successfully</strong>, though it may not give the expected results if <code>PROMO_EXPIRY</code> is NULL.</p></li></ul>",
                    "<p><strong>\"Only the second SQL statement executes successfully\"</strong></p><ul><li><p><strong>Exhibit 1 fails</strong> due to a <strong>data type mismatch</strong> (<code>DATE</code> vs. <code>VARCHAR2</code>).</p></li><li><p><strong>Exhibit 2 executes successfully</strong>, though it may not give the expected results if <code>PROMO_EXPIRY</code> is NULL.</p></li></ul>",
                    "<p><strong>\"Only the second SQL statement executes successfully\"</strong></p><ul><li><p><strong>Exhibit 1 fails</strong> due to a <strong>data type mismatch</strong> (<code>DATE</code> vs. <code>VARCHAR2</code>).</p></li><li><p><strong>Exhibit 2 executes successfully</strong>, though it may not give the expected results if <code>PROMO_EXPIRY</code> is NULL.</p></li></ul>"
                ],
                "explanation": "<p><strong>Analysis of the SQL Statements</strong></p><p><strong>Observations about the Table </strong><code><strong>PRODUCTS</strong></code></p><ul><li><p><code><strong>PROMO_EXPIRY</strong></code> is of <strong>DATE</strong> type and can contain NULL values.</p></li></ul><p><br></p><p><strong>Exhibit 1: Using </strong><code><strong>NVL2</strong></code></p><pre class=\"prettyprint linenums\">sql\nSELECT promo_id, NVL2(promo_expiry, promo_expiry + 15, ' ')\nFROM products;\n</pre><ul><li><p><code><strong>NVL2(expr1, expr2, expr3)</strong></code>:</p><ul><li><p>If <code>expr1</code> (<code><strong>promo_expiry</strong></code>) is <strong>NOT NULL</strong>, it returns <code>expr2</code> (<code><strong>promo_expiry + 15</strong></code>, which adds 15 days).</p></li><li><p>If <code>expr1</code> is <strong>NULL</strong>, it returns <code>expr3</code> (<code>' '</code>).</p></li></ul></li></ul><p><strong>Errors in this statement:</strong></p><ol><li><p><strong>Data Type Mismatch:</strong></p><ul><li><p><code>promo_expiry + 15</code> is a <strong>DATE</strong>.</p></li><li><p><code>' '</code> is a <strong>VARCHAR2</strong>.</p></li><li><p>Oracle does <strong>not allow mixed return types</strong> in <code>NVL2()</code>, so this will cause an error.</p></li></ul></li></ol><p><strong>Correction:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT promo_id, NVL2(promo_expiry, promo_expiry + 15, NULL)\nFROM products;\n</pre><p>This ensures both return values are <strong>DATE</strong>.</p><p><br></p><p><strong>Exhibit 2: Using </strong><code><strong>NVL</strong></code></p><pre class=\"prettyprint linenums\">sql\nSELECT promo_id, NVL (promo_expiry, promo_expiry + 15)\nFROM products;</pre><ul><li><p><code><strong>NVL(expr1, expr2)</strong></code>:</p><ul><li><p>If <code>expr1</code> (<code>promo_expiry</code>) is <strong>NOT NULL</strong>, it returns <code>expr1</code> (<code>promo_expiry</code>).</p></li><li><p>If <code>expr1</code> is <strong>NULL</strong>, it returns <code>expr2</code> (<code>promo_expiry + 15</code>).</p></li></ul></li></ul><p><strong>Issue in this statement:</strong></p><ul><li><p>If <code>promo_expiry</code> is <strong>NULL</strong>, then <code>promo_expiry + 15</code> will also be <strong>NULL</strong> because:</p><ul><li><p><strong>NULL + any number = NULL</strong>.</p></li><li><p>This makes the use of <code>NVL()</code> ineffective.</p></li></ul></li></ul><p><strong>Correction:</strong></p><pre class=\"prettyprint linenums\">sql\nSELECT promo_id, NVL(promo_expiry, SYSDATE + 15)\nFROM products;</pre><ul><li><p>If <code>promo_expiry</code> is NULL, it assigns a default value (<code>SYSDATE + 15</code>).</p></li></ul><p><strong>Final Answer</strong></p><p><strong>\"Only the second SQL statement executes successfully\"</strong></p><ul><li><p><strong>Exhibit 1 fails</strong> due to a <strong>data type mismatch</strong> (<code>DATE</code> vs. <code>VARCHAR2</code>).</p></li><li><p><strong>Exhibit 2 executes successfully</strong>, though it may not give the expected results if <code>PROMO_EXPIRY</code> is NULL.</p></li></ul>",
                "answers": [
                    "<p>Both the statements execute and give different results</p>",
                    "<p>Only the second SQL statement executes successfully</p>",
                    "<p>Both the statements execute and give the same result</p>",
                    "<p>Only the first SQL statement executes successfully</p>"
                ]
            },
            "correct_response": [
                "b"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structure of the PRODUCTS table as well as the exhibits.Table: PRODUCTS  Name                   Null??              Type\nPROMO_ID               NOT NULL            NUMBER(4)\nPROMO_NAME                                 VARCHAR(25)\nPROMO_EXPIRY                               DATEEvaluate the following two SQL statements.Exhibit 1.SELECT promo_id, NVL2 (promo_expiry, promo_expiry_date + 15, ' ')\nFROM products;Exhibit 2.SELECT promo_id, NVL (promo_expiry, promo_expiry_date + 15)\nFROM products;Identify the statement which is true regarding the result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306063,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify two true statements about transactions in the Oracle Database server. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Types of SQL Statements](https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm)",
                    "[Data Manipulation Language (DML) Statements](https://docs.oracle.com/en/database/oracle/oracle-database/12.2/cncpt/sql.html#GUID-90EA5D9B-76F2-4916-9F7E-CF0D8AA1A09D)",
                    "[About DML Statements and Transactions](https://docs.oracle.com/database/121/TDDDG/tdddg_dml.htm#TDDDG99941)"
                ],
                "feedbacks": [
                    "In Oracle Database, if a session has an uncommitted transaction and a Data Definition Language (DDL) statement is issued, the database automatically issues a COMMIT before starting the new transaction. This ensures that any changes made in the previous transaction are committed before executing the DDL statement.",
                    "<p>In <strong>SQL*Plus</strong>, if a user exits without explicitly committing or rolling back a transaction, the transaction is <strong>automatically rolled back</strong>. This prevents any uncommitted changes from being saved to the database.</p><p>To ensure changes are committed before exiting, the user must explicitly execute:</p><pre class=\"prettyprint linenums\">SQL\nCOMMIT;</pre><p><br></p><pre class=\"prettyprint linenums\">SQL\nROLLBACK;</pre>",
                    "Data Manipulation Language (DML) statements in Oracle Database do not always start a new transaction. DML statements operate within the context of the current transaction and can be part of an existing transaction that may have started earlier.",
                    "In Oracle Database, a user cannot always see uncommitted updates made by the same user in a different session. Uncommitted changes are isolated to the session in which they are made and are not visible to other sessions until they are committed.",
                    "A Data Definition Language (DDL) statement in Oracle Database does not automatically issue a COMMIT for all data dictionary updates caused by the DDL. Only the changes related to the data dictionary are committed automatically, while any other changes made in the same transaction require an explicit COMMIT statement.",
                    "In Oracle Database, a session can always see uncommitted updates made by itself. This means that changes made within the same session are immediately visible to the session itself, even if they have not been committed yet."
                ],
                "explanation": "<p>The two true statements about transactions in the Oracle Database server are:</p><ol><li><p><strong>If a session has an uncommitted transaction, then a DDL statement issues a COMMIT before starting a new transaction.</strong></p><ul><li><p>Oracle Database automatically issues an implicit COMMIT before executing any Data Definition Language (DDL) statement (e.g., <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>). This commits any pending transactions in the current session. The DDL statement itself is then executed as a new, separate transaction, which is also implicitly committed upon successful completion.</p></li></ul></li><li><p><strong>A session can always see uncommitted updates made by itself.</strong></p><ul><li><p>Within the context of a single session, any Data Manipulation Language (DML) changes (e.g., <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) are visible to subsequent queries in that same session, even before the transaction is committed. Other sessions will not see these uncommitted changes until the transaction is committed.</p><p><br></p></li></ul></li></ol><p>Let's examine why the other statements are not unequivocally true:</p><ul><li><p><strong>An uncommitted transaction commits automatically if the user exits SQL*Plus.</strong></p><ul><li><p>While it's true that SQL<em>Plus, by default (with the </em><code><em>EXITCOMMIT</em></code><em> parameter set to </em><code><em>ON</em></code><em>), will issue a </em><code><em>COMMIT</em></code><em> statement when a user exits normally, this is a behaviour of the SQL</em>Plus client tool, not an inherent server-side rule for all session terminations. If the SQL*Plus session terminates abnormally, or if <code>EXITCOMMIT</code> is set to <code>OFF</code>, the uncommitted transaction will be rolled back by the server.</p></li></ul></li><li><p><strong>Data Manipulation Language (DML) statements always start a new transaction.</strong></p><ul><li><p>The <em>first</em> DML statement executed after a session starts or after a <code>COMMIT</code> or <code>ROLLBACK</code> will implicitly start a new transaction. However, subsequent DML statements within that session become part of the <em>current, active</em> transaction. They do not each start a new transaction.</p></li></ul></li><li><p><strong>A user can always see uncommitted updates made by the same user in a different session.</strong></p><ul><li><p>This is false. Oracle maintains transaction isolation between sessions. Uncommitted changes made in one session are not visible to any other session, regardless of whether the sessions are initiated by the same database user or different users, until those changes are committed.</p></li></ul></li><li><p><strong>A Data Definition Language (DDL) statement does a COMMIT automatically only for the data dictionary updates caused by the DDL.</strong></p><ul><li><p>This is false. As mentioned earlier, a DDL statement first causes an implicit <code>COMMIT</code> of the <em>entire current transaction</em> (which may include DML operations unrelated to the data dictionary). Then, the DDL operation itself is performed and committed. The initial commit is not restricted to only data dictionary updates.</p></li></ul></li></ul><p><strong>Data definition language (DDL) statements </strong>let you to perform these tasks:</p><p>• Create, alter, and drop schema objects</p><p>• Grant and revoke privileges and roles</p><p>• Analyze information on a table, index, or cluster</p><p>• Establish auditing options</p><p>• Add comments to the data dictionary</p><p><strong>The DDL statements are:</strong></p><p><code>ALTER</code>&nbsp; <code>ANALYZE</code>&nbsp; <code>ASSOCIATE STATISTICS</code>&nbsp; <code>AUDIT</code>&nbsp; <code>COMMENT</code>&nbsp; <code>CREATE</code>&nbsp; &nbsp;<code>DISASSOCIATE STATISTICS</code>&nbsp; <code>DROP</code>&nbsp; <code>FLASHBACK</code>&nbsp; <code>GRANT</code>&nbsp; <code>NOAUDIT</code>&nbsp; <code>PURGE</code>&nbsp; <code>RENAME</code>&nbsp; <code>REVOKE</code>&nbsp; <code>TRUNCATE</code>&nbsp; <code>UNDROP</code></p><p><br></p><p>An implicit <code>COMMIT</code> occurs immediately before the database executes a DDL statement and a <code>COMMIT</code> or <code>ROLLBACK</code> occurs immediately afterward. In the preceding example, two <code>INSERT</code> statements are followed by an <code>ALTER TABLE</code> statement, so the database commits the two <code>INSERT</code> statements. If the <code>ALTER TABLE</code> statement succeeds, then the database commits this statement; otherwise, the database rolls back this statement. In either case, the two <code>INSERT</code> statements have already been committed.</p><p><em>If a session has an uncommitted transaction, then a DDL statement issues a COMMIT before starting a new transaction.</em></p><p>DDL statements do a commit before starting their transaction.</p><p><br></p><p><strong>Data manipulation language (DML) </strong>statements access and manipulate data in existing schema objects. These statements do not implicitly commit the current transaction.</p><p>The <code>SELECT</code> statement is a limited form of DML statement in that it can only access data in the database.</p><p><code>CALL</code>&nbsp; <code>DELETE</code>&nbsp; <code>EXPLAIN PLAN</code>&nbsp; <code>INSERT</code>&nbsp; <code>LOCK TABLE</code>&nbsp; <code>MERGE</code>&nbsp; <code>SELECT</code>&nbsp; <code>UPDATE</code></p><p>Data manipulation language (DML) statements access and manipulate data in existing tables.</p><p>In the SQL*Plus environment, you can enter a DML statement after the <code>SQL&gt;</code> prompt.</p><p>In the SQL Developer environment, you can enter a DML statement in the Worksheet. Alternatively, you can use the SQL Developer Connections frame and tools to access and manipulate data.</p><p>To see the effect of a DML statement in SQL Developer, you might have to select the schema object type of the changed object in the Connections frame and then click the Refresh icon.</p><p>The effect of a DML statement is not permanent until you commit the transaction that includes it. A transaction is a sequence of SQL statements that Oracle Database treats as a unit (it can be a single DML statement). Until a transaction is committed, it can be rolled back (undone).</p><p>It is possible to INSERT INTO a table and SELECT those new rows even if the changes have not yet been committed.</p><p><em>A session can always see uncommitted updates made by itself.</em></p><p><br></p><p>✗ An uncommitted transaction commits automatically if the user exits SQL*Plus.</p><p>SQL*Plus can <code>COMMIT</code> or <code>ROLLBACK</code> on exit, not only <code>COMMIT</code></p><p><a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e16604/ch_twelve040.htm#SQPUG079\">https://docs.oracle.com/cd/E11882_01/server.112/e16604/ch_twelve040.htm#SQPUG079</a></p>",
                "answers": [
                    "<p>If a session has an uncommitted transaction, then a DDL statement issues a COMMIT before starting a new transaction.</p>",
                    "<p>An uncommitted transaction commits automatically if the user exits SQL*Plus.</p>",
                    "<p>Data Manipulation Language (DML) statements always start a new transaction.</p>",
                    "<p>A user can always see uncommitted updates made by the same user in a different session.</p>",
                    "<p>A Data Definition Language (DDL) statement does a COMMIT automatically only for the data dictionary updates caused by the DDL.</p>",
                    "<p>A session can always see uncommitted updates made by itself.</p>"
                ]
            },
            "correct_response": [
                "a",
                "f"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following available responses.Identify two true statements about transactions in the Oracle Database server. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306065,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the true statements about GLOBAL TEMPORARY TABLES. (Select three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle Global Temporary Table](https://www.oracletutorial.com/oracle-basics/oracle-global-temporary-table/)"
                ],
                "feedbacks": [
                    "This statement is incorrect. GLOBAL TEMPORARY TABLE rows inserted by a session are only available to that specific session and are not visible to other sessions, even if they have select privileges on the table.",
                    "This statement is incorrect. GLOBAL TEMPORARY TABLE space allocation occurs when the table is created, not at session start. The space is allocated in the temporary tablespace defined for the database.",
                    "This statement is incorrect. A DELETE command on a GLOBAL TEMPORARY TABLE can be rolled back like any other DML operation. The data in a GLOBAL TEMPORARY TABLE is session-specific and behaves like a regular table in terms of transaction control.",
                    "This statement is correct. A GLOBAL TEMPORARY TABLE's definition is available to multiple sessions. However, the data within the table is session-specific and isolated from other sessions.",
                    "This statement is correct. Any rows existing in a GLOBAL TEMPORARY TABLE at session termination will be automatically deleted. This behavior ensures that each session has its isolated data within the temporary table.",
                    "This statement is correct. A TRUNCATE command issued in a session will delete all rows in a GLOBAL TEMPORARY TABLE specific to that session. This operation is session-specific and does not affect other sessions' data in the table."
                ],
                "explanation": "<p>The true statements about GLOBAL TEMPORARY TABLES are:</p><ol><li><p><strong>A GLOBAL TEMPORARY TABLE's definition is available to multiple sessions.</strong></p><ul><li><p>The structure (metadata) of a Global Temporary Table (GTT) is stored in the database's data dictionary and is visible to all sessions that have appropriate privileges, just like a regular table. However, the data within a GTT is session-specific.</p></li></ul></li><li><p><strong>Any GLOBAL TEMPORARY TABLE rows existing at session termination will be deleted.</strong></p><ul><li><p>Regardless of whether the GTT is defined with <code>ON COMMIT DELETE ROWS</code> or <code>ON COMMIT PRESERVE ROWS</code>, the actual data inserted by a specific session is held in temporary segments private to that session. When the session ends (either normally or abnormally), Oracle automatically cleans up these session-specific rows.</p></li></ul></li><li><p><strong>A TRUNCATE command issued in a session causes all rows in a GLOBAL TEMPORARY TABLE for the issuing session to be deleted.</strong></p><ul><li><p>When <code>TRUNCATE</code> is used on a GTT, it only affects the data belonging to the session that issues the command. Other sessions using the same GTT will not have their data affected. This is consistent with the session-specific nature of GTT data.</p></li></ul></li></ol><p>The other statements are false:</p><ul><li><p><strong>GLOBAL TEMPORARY TABLE rows inserted by a session are available to any other session whose user has been granted select on the table.</strong></p><ul><li><p>False. Data in a GTT is private to the session that inserted it. Other sessions, even if the same user opens them or if they have <code>SELECT</code> privileges on the GTT, cannot see the data inserted by a different session.</p></li></ul></li><li><p><strong>GLOBAL TEMPORARY TABLE space allocation occurs at session start.</strong></p><ul><li><p>False. Space for a GTT's data is typically allocated from the temporary tablespace only when a session first inserts data into it (i.e., upon the first DML operation that requires space), not at the moment the session begins.</p></li></ul></li><li><p><strong>A DELETE command on a GLOBAL TEMPORARY TABLE cannot be rolled back.</strong></p><ul><li><p>False. <code>DELETE</code> is a Data Manipulation Language (DML) statement. Like DML operations on permanent tables, a <code>DELETE</code> operation on a GTT can be rolled back within the current transaction (before a <code>COMMIT</code> or <code>ROLLBACK</code> that ends the transaction). The <code>ON COMMIT</code> clause of the GTT definition determines what happens to the rows at the end of a transaction, but individual DML statements within the transaction are subject to rollback.</p></li></ul></li></ul><p><strong>GLOBAL TEMPORARY </strong>specifies that the table is temporary. Its definition is visible to all sessions with appropriate privileges. The data in a temporary table is visible only to the session that inserts the data into the table. </p><p>When you first create a temporary table, its table metadata is stored in the data dictionary, but no space is allocated for table data. Space is allocated for the table segment at the time of the first DML operation on the table. The temporary table definition persists in the same way as the definitions of regular tables, but the table segment and any data the table contains are either session-specific or transaction-specific data. You specify whether the table segment and data are session- or transaction-specific with the <code>ON COMMIT</code> keywords. </p><p>You can perform DDL operations (such as <code>ALTER TABLE</code>, <code>DROP TABLE</code>, <code>CREATE INDEX</code>) on a temporary table only when no session is bound to it. A session becomes bound to a temporary table by performing an <code>INSERT</code> operation on the table. A session becomes unbound to the temporary table by issuing a <code>TRUNCATE</code> statement or at session termination, or, for a transaction-specific temporary table, by issuing a <code>COMMIT</code> or <code>ROLLBACK</code> statement.</p><p><br></p><p>A temporary table is a table that holds data only for the duration of a session or transaction.</p><p>Oracle introduced the global temporary table concept since version 8i.</p><p>Unlike temporary tables from other database products such as <a href=\"http://www.mysqltutorial.org/mysql-temporary-table/\" title=\"MySQL Temporary Tables\">MySQL</a> and <a href=\"http://www.sqlservertutorial.net/sql-server-basics/sql-server-temporary-tables/\" title=\"SQL Server Temporary Tables\">SQL Server</a>, global temporary tables in Oracle are <strong>permanent</strong> database objects that store data on disk and <strong>visible</strong> to all sessions.</p><p>However, the data stored in the global temporary table is <strong>private</strong> to the session. In other words, each session can only access its own data in the global temporary table.</p><p>Note that Oracle 18c introduced the <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-private-temporary-table/\">private temporary table</a>, which is a memory-based temporary table that is automatically <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-drop-table/\">dropped</a> at the end of a session or transaction.</p><p><br></p><p><strong>CREATE GLOBAL TEMPORARY TABLE statement</strong></p><p>To create a global temporary table, you use the <code>CREATE GLOBAL TEMPORARY TABLE</code> statement as follows:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE GLOBAL TEMPORARY TABLE table_name (\n    column_definition,\n    ...,\n    table_constraints\n) ON COMMIT [DELETE ROWS | PRESERVE ROWS];</pre><p><br></p><p>The syntax of creating a global temporary table and a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-create-table/\">permanent table</a> are the same except for the keyword <code>GLOBAL TEMPORARY</code> and the clause <code>ON COMMIT [DELETE ROWS | PRESERVE ROWS]</code>.</p><p>The <code>ON COMMIT</code> clause specifies whether data in the table is transaction-specific or session-specific:</p><p>The <code>ON COMMIT DELETE ROWS</code> clause specifies that the global temporary table is transaction-specific. It means that Oracle <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-truncate-table/\">truncates</a> the table (remove all rows) after each commit.</p><p>The <code>ON COMMIT PRESERVE ROWS</code> clause specifies that the global temporary table is session-specific, meaning that Oracle truncates the table when you terminate the session, not when you commit a transaction.</p><p>Oracle uses the <code>ON COMMIT DELETE ROWS</code> option by default if you omit the <code>ON COMMIT</code> clause.</p><p><br></p><p><strong>Create a global temporary table</strong></p><p>These are the most important points to consider before you create a global temporary table.</p><p>1) DDL operation on global temporary tables</p><p>It is not possible to perform a DDL operation (except <code>TRUNCATE</code>) on an existing global temporary table if one or more sessions are currently bound to that table.</p><p>First, create a temporary table named <code>temp3</code>:</p><p><br></p><pre class=\"prettyprint linenums\">CREATE GLOBAL TEMPORARY TABLE temp3(\n    id INT\n) ON COMMIT DELETE ROWS;</pre><p><br></p><p>Next, insert a new row into the <code>temp3</code> table:</p><p><br></p><pre class=\"prettyprint linenums\">INSERT INTO temp3(id) VALUES(1);</pre><p><br></p><p>Then, log in to the database in a separate session e.g., using SQL*Plus and add a column to the <code>temp3</code> table:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE temp3 \nADD description VARCHAR2(100);</pre><p><br></p><p>Oracle issued the following error:</p><p><br></p><pre class=\"prettyprint linenums\">ORA-14450: attempt to access a transactional temp table already in use</pre><p><br></p><p>After that, commit the transaction in the first session:</p><p><br></p><pre class=\"prettyprint linenums\"> COMMIT;</pre><p><br></p><p>Finally, perform the DDL operation in the second transaction:</p><p><br></p><pre class=\"prettyprint linenums\">ALTER TABLE temp3 \nADD description VARCHAR2(100);</pre><p><br></p><p>This time it worked because no session is currently bound to the <code>temp3</code> table.</p><p>2) Transactions on transaction-specific global temporary tables</p><p>Oracle only allows one transaction at a time on a transaction-specific temporary table.</p><p>If you have several autonomous transactions in a single transaction scope, you must commit the previous autonomous transaction before the next transaction can use the table.</p><p>3) Rollback on transaction-specific global temporary tables</p><p>Rolling back (<code>ROLLBACK</code>) on the global temporary table will cause all data entered lost.</p><p>4) Backup &amp; recovery on global temporary tables</p><p>Due to the nature of temporary tables, backup and recovery are not available in case of a system failure.</p>",
                "answers": [
                    "<p>GLOBAL TEMPORARY TABLE rows inserted by a session are available to any other session whose user has been granted select on the table.</p>",
                    "<p>GLOBAL TEMPORARY TABLE space allocation occurs at session start.</p>",
                    "<p>A DELETE command on a GLOBAL TEMPORARY TABLE cannot be rolled back.</p>",
                    "<p>A GLOBAL TEMPORARY TABLE's definition is available to multiple sessions.</p>",
                    "<p>Any GLOBAL TEMPORARY TABLE rows existing at session termination will be deleted.</p>",
                    "<p>A TRUNCATE command issued in a session causes all rows in a GLOBAL TEMPORARY TABLE for the issuing session to be deleted.</p>"
                ]
            },
            "correct_response": [
                "d",
                "e",
                "f"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the true statements about GLOBAL TEMPORARY TABLES. (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306067,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the actions can you perform by using the ORACLE_DATAPUMP access driver. (Select two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Using the ORACLE_DATAPUMP Access Driver](https://docs.oracle.com/en/database/oracle/oracle-database/19/sutil/oracle_datapump-access-driver.html#GUID-0811F362-161A-4D4B-B480-845CADA0D372)"
                ],
                "feedbacks": [
                    "The ORACLE_DATAPUMP access driver allows you to read data from a table in the database and insert it into an external table. This action is useful for exporting data from the database to an external source.",
                    "With the ORACLE_DATAPUMP access driver, you can read data from an external table and load it into a table in the database. This functionality is essential for importing data into the database from an external source.",
                    "Creating a directory object for an external table is not an action that can be performed using the ORACLE_DATAPUMP access driver. Directory objects are typically used for managing file locations in Oracle Database, but they are not directly related to the data pump functionality.",
                    "Creating a directory object for a flat file is not a specific action that can be performed using the ORACLE_DATAPUMP access driver. Directory objects are used for file management in Oracle Database, but they are not directly tied to the data pump capabilities.",
                    "Executing DML statements on an external table is not a functionality provided by the ORACLE_DATAPUMP access driver. DML statements are typically used for manipulating data in database tables, not for interacting with external tables.",
                    "Querying data from an external table is not an action that can be directly performed using the ORACLE_DATAPUMP access driver. External tables are typically queried using SQL statements, but the data pump driver is focused on data import and export operations."
                ],
                "explanation": "<p>The actions you can perform by using the <code>ORACLE_DATAPUMP</code> access driver are:</p><ol><li><p><strong>Read data from a table in the database and insert it into an external table.</strong></p><ul><li><p>This describes an <strong>unload</strong> operation. The <code>ORACLE_DATAPUMP</code> access driver is used when you create an external table using a <code>CREATE TABLE ... AS SELECT</code> statement from an existing database table. The driver formats and writes the data from the internal table into one or more external binary dump files associated with the newly created external table.</p></li></ul></li><li><p><strong>Read data from an external table and load it into a table in the database.</strong></p><ul><li><p>This describes a <strong>load</strong> operation. You can define an external table that points to existing Oracle Data Pump dump files. The <code>ORACLE_DATAPUMP</code> access driver is then used to read these dump files when you query the external table. The data read from the external table can then be inserted into a regular table in the database (e.g., using an <code>INSERT INTO ... SELECT ... FROM external_table</code> statement).</p></li></ul></li></ol><p>Let's look at why the other options are not the best fit:</p><ul><li><p><strong>Create a directory object for an external table.</strong> Directory objects (which map a name to a file system path) are prerequisites for defining the location of external table files. However, directory objects are created using the SQL DDL statement <code>CREATE DIRECTORY</code>, not by the access driver itself.</p></li><li><p><strong>Create a directory object for a flat file.</strong> Similar to the point above, <code>CREATE DIRECTORY</code> is used regardless of whether the external file is a Data Pump dump file or a flat text file (which would typically use the <code>ORACLE_LOADER</code> driver).</p></li><li><p><strong>Execute DML statements on an external table.</strong> External tables, including those using the <code>ORACLE_DATAPUMP</code> driver, are generally read-only once the underlying file is created (for unload) or defined (for load). You cannot execute standard <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statements directly on an external table to modify the external file after its initial creation or definition, as you would with a regular database table. The \"insertion\" into an external table occurs during an unload operation (typically via <code>CREATE TABLE AS SELECT</code>).</p></li><li><p><strong>Query data from an external table.</strong> This is indeed a primary capability. When an external table is defined to use the <code>ORACLE_DATAPUMP</code> driver and points to valid Data Pump dump files, you can query it using <code>SELECT</code> statements. This is the mechanism through which data is read from the external files, whether for direct analysis or for loading into another table (as described in the second correct option). While true, the option \"Read data from an external table and load it into a table in the database\" is a more encompassing description of a common end-to-end action facilitated by the driver. The Oracle documentation often refers to the driver's capabilities in terms of \"loads and unloads.\"</p></li></ul><p><br></p><p>Oracle Data Pump technology enables very high-speed movement of data and metadata from one database to another.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-47B26B0B-3C95-4182-ACDF-2EEDD577FC9E\">Data Pump Components</a><br>Oracle Data Pump is made up of three distinct components. They are the command-line clients, <code>expdp</code> and <code>impdp</code>, the <code>DBMS_DATAPUMP</code> PL/SQL package (also known as the Data Pump API), and the <code>DBMS_METADATA</code> PL/SQL package (also known as the Metadata API).</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-3F418F02-5FE2-455A-B5AD-C1910DB3B5E0\">How Does Data Pump Move Data?</a><br>This the methods that Data Pump uses to move data in and out of databases, and when each of the methods is used.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-45B17B65-20F2-4128-9A39-B1B0F5E323BB\">Using Data Pump With CDBs</a><br>Data Pump can migrate all, or portions of, a database from a non-CDB into a PDB, between PDBs within the same or different CDBs, and from a PDB into a non-CDB.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-8B6975D3-3BEC-4584-B416-280125EEC57E\">Required Roles for Data Pump Export and Import Operations</a><br>Many Data Pump Export and Import operations require the user to have the <code>DATAPUMP_EXP_FULL_DATABASE</code> role or the <code>DATAPUMP_IMP_FULL_DATABASE</code> role or both.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-6BDC1CC8-8596-402D-B016-602985B97AB6\">What Happens During Execution of a Data Pump Job?</a><br>Data Pump jobs use a master table, a master process, and worker processes to perform the work and keep track of progress.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-E365D74E-12CD-495C-BA23-5A55F679C7E7\">Monitoring Job Status</a><br>The Data Pump Export and Import client utilities can attach to a job in either logging mode or interactive-command mode.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-FE7E746D-A343-463E-A4E2-A6AD1349FE4B\">File Allocation</a><br>Understanding how Data Pump allocates and handles files will help you to use Export and Import to their fullest advantage.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-BAA3B679-A758-4D55-9820-432D9EB83C68\">Exporting and Importing Between Different Database Releases</a><br>Data Pump can be used to migrate all or any portion of a database between different releases of the database software.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-9030BC32-193B-4455-8DBB-4271DD44FA7A\">SecureFiles LOB Considerations</a><br>When you use Data Pump Export to export SecureFiles LOBs, the resulting behavior depends on several things, including the value of the Export <code>VERSION</code> parameter, whether ContentType is present, and whether the LOB is archived and data is cached.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-34D0DEE7-3530-42DC-BE01-C2588CC73CE5\">Data Pump Exit Codes</a><br>Data Pump reports the results of export and import operations in a log file and in a process exit code.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-4443B80B-0446-4010-B8CA-2524659516BC\">Auditing Data Pump Jobs</a><br>Perform auditing on Data Pump jobs to monitor and record specific user database actions.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-7EE60BAB-0D3D-46EB-8E11-4FDDA68EF14E\">How Does Data Pump Handle Timestamp Data?</a><br>This section describes factors that can affect successful completion of export and import jobs that involve the timestamp data types <code>TIMESTAMP WITH TIMEZONE</code> and <code>TIMESTAMP WITH LOCAL TIMEZONE</code>.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-72F01BF0-61F5-4775-8C7B-4E227F244866\">Character Set and Globalization Support Considerations</a><br>Globalization support behavior of Data Pump Export and Import.</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-B1A6BBA2-0269-48CC-8A0E-8E3955A231C0\">Oracle Data Pump Behavior with Data-Bound Collation</a><br>Oracle Data Pump supports data-bound collation (DBC).</p><p><a href=\"https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-47B26B0B-3C95-4182-ACDF-2EEDD577FC9E\">https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sutil/oracle-data-pump-overview.html#GUID-47B26B0B-3C95-4182-ACDF-2EEDD577FC9E</a></p><p><br></p><p>As part of creating an external table with a SQL <code>CREATE TABLE AS SELECT</code> statement, the <code>ORACLE_DATAPUMP</code> access driver can write data to a dump file.</p><p>The data in the file is written in a binary format that can only be read by the <code>ORACLE_DATAPUMP</code> access driver. Once the dump file is created, it cannot be modified (that is, no data manipulation language (DML) operations can be performed on it). However, the file can be read any number of times and used as the dump file for another external table in the same database or in a different database.</p>",
                "answers": [
                    "<p>Read data from a table in the database and insert it into an external table.</p>",
                    "<p>Read data from an external table and load it into a table in the database.</p>",
                    "<p>Create a directory object for an external table.</p>",
                    "<p>Create a directory object for a flat file.</p>",
                    "<p>Execute DML statements on an external table.</p>",
                    "<p>Query data from an external table.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the actions can you perform by using the ORACLE_DATAPUMP access driver. (Select two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306069,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the structures of the COSTS and PROMOTIONS tables as well as the exhibits.</p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-08-41-4767ad5abc4cde06a09acec9b2e3230a.png\"></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-05_18-09-01-edaa5041d4104c499acaa723c14ecb11.png\"></p><p><br></p><p>Evaluate the following SQL statement.</p><p><strong>Exhibit: 1</strong></p><pre class=\"prettyprint linenums\">SELECT prod_id\nFROM&nbsp;costs\nWHERE&nbsp;promo_id IN (\nSELECT promo_id FROM promotions\nWHERE promo_cost &lt; ALL&nbsp;(\nSELECT MAX(promo_cost) FROM&nbsp;promotions\nGROUP&nbsp;BY&nbsp;(promo_end_date - promo_begin_date))</pre><p> </p><p>Identify the result of the query execution.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This choice is incorrect because the SQL statement in the exhibit is not filtering or selecting the promo with the highest cost. It is comparing the cost of each promo with the highest cost in the same time interval.",
                    "This choice is incorrect because the SQL statement in the exhibit is not filtering or selecting the promo with the lowest cost. It is comparing the cost of each promo with the highest cost in the same time interval.",
                    "This choice is incorrect because the SQL statement in the exhibit is not filtering or selecting the promo with the highest cost. It is comparing the cost of each promo with the highest cost in the same time interval.",
                    "This choice is correct because the SQL statement in the exhibit is selecting the prod IDs in the promos which cost less than the highest cost in the same time interval. It is filtering the results based on the condition specified in the WHERE clause."
                ],
                "explanation": "<p>The most fitting description among the choices, recognizing its limitations, is: <strong>It displays prod IDs in the promos which cost less than the highest cost in the same time interval.</strong></p><p>Let's break down the SQL query:</p><ol><li><p><strong>Innermost Subquery:</strong></p><pre class=\"prettyprint linenums\">SQL\nSELECT MAX(promo_cost)\nFROM promotions\nGROUP BY (promo_end_date - promo_begin_date)</pre><ul><li><p><code>promo_end_date - promo_begin_date</code> calculates the duration of each promotion (let's call this <code>promo_duration</code>).</p></li><li><p><code>GROUP BY (promo_duration)</code> groups promotions that have the same duration.</p></li><li><p><code>SELECT MAX(promo_cost)</code> then finds the highest <code>promo_cost</code> for each distinct promotion duration.</p></li><li><p>The result of this subquery is a list of values, where each value is the maximum promotion cost for a specific duration. For example, if promotions last 7, 14, or 30 days, this subquery might return three values: the max cost among all 7-day promotions, the max cost among all 14-day promotions, and the max cost among all 30-day promotions.</p></li></ul></li><li><p><strong>Middle Subquery:</strong></p><pre class=\"prettyprint linenums\">SQL\nSELECT promo_id\nFROM promotions\nWHERE promo_cost &lt; ALL (\n    -- List of maximum promo costs, one for each distinct promotion duration\n)</pre><ul><li><p>The <code>WHERE promo_cost &lt; ALL (list_of_values)</code> condition means that the <code>promo_cost</code> of a given promotion must be less than <em>every single value</em> in the list returned by the innermost subquery.</p></li><li><p>This is equivalent to saying that <code>promo_cost</code> must be less than the <em>minimum value</em> in that list.</p></li><li><p>So, this middle subquery selects <code>promo_id</code>s for promotions whose <code>promo_cost</code> is less than the minimum of all the \"maximum costs for each duration group\". For instance, if the maximum costs for different durations were $100, $150, and $200, then this subquery would select promotions where `promo_cost &lt; 100$.</p></li></ul></li><li><p><strong>Outer Query:</strong></p><pre class=\"prettyprint linenums\">SQL\nSELECT prod_id\nFROM costs\nWHERE promo_id IN (\n    -- List of promo_ids selected by the middle subquery\n)</pre><ul><li><p>This query retrieves <code>prod_id</code>s from the <code>costs</code> table for those promotions whose <code>promo_id</code>s were selected by the middle subquery.</p></li></ul></li></ol><p><strong>Overall Logic:</strong> The query identifies promotions that are exceptionally inexpensive. Specifically, a promotion is selected if its cost is less than the maximum cost of <em>any</em> promotion duration group, including the duration group that has the overall lowest maximum cost. For example, if 7-day promotions have a max cost of $100, 14-day promotions have a max cost of $200, and 30-day promotions have a max cost of $120, the query will select promotions whose cost is less than $MIN($100, $200, $120) = $100$.</p><p>Now let's evaluate the given options:</p><ul><li><p><strong>\"It displays prod IDs in the promos which cost less than the highest cost in the same time interval.\"</strong></p><ul><li><p>Let's analyze this option. If a promotion <code>P</code> has a cost <code>C_P</code> and its duration (time interval) is <code>D_P</code>. The highest cost in that same time interval is <code>MaxCost_DP</code>. This option suggests the condition is <code>C_P &lt; MaxCost_DP</code>.</p></li><li><p>The query's actual condition for selecting promotion <code>P</code> is <code>C_P &lt; MIN(MaxCost_D1, MaxCost_D2, ..., MaxCost_DP, ...)</code>, where <code>D1, D2, ...</code> are all possible promotion durations.</p></li><li><p>If <code>C_P &lt; MIN(MaxCost_D1, ..., MaxCost_DP, ...)</code>, then it is necessarily true that <code>C_P &lt; MaxCost_DP</code> (since <code>MIN(set)</code> is less than or equal to any element in the set).</p></li><li><p>Therefore, any promotion selected by the SQL query will indeed have a cost that is less than the highest cost in its own time interval.</p></li><li><p>However, the query is more restrictive. It doesn't select <em>all</em> such promos. For example, if <code>MaxCost_DP</code> is $200, and <code>MIN(all MaxCosts)</code> is $100, a promo with cost $150 in duration <code>D_P</code> satisfies \"cost less than highest cost in its interval\" ($150 &lt; $200) but does not satisfy the query's condition ($150 &lt; $100 is false).</p></li><li><p>Despite not being the most precise definition of the filter, this statement describes a property that all results <em>will</em> have. Given typical multiple-choice constraints, this is often the intended type of answer if other options are clearly incorrect.</p></li></ul></li><li><p><strong>\"It displays prod IDs in the promo with the highest cost.\"</strong></p><ul><li><p>This is incorrect, as the query uses a <code>promo_cost &lt; ...</code> condition.</p></li></ul></li><li><p><strong>\"It displays prod IDs in the promos with the lowest cost in the same time interval.\"</strong></p><ul><li><p>This implies selecting promotions whose cost is the minimum for their specific duration. The query does not do this; it compares against maximums.</p></li></ul></li><li><p><strong>\"It displays prod IDs in the promos with the highest cost in the same time interval.\"</strong></p><ul><li><p>This is incorrect, as the query uses a <code>promo_cost &lt; ...</code> condition.</p></li></ul></li></ul><p>Considering the options, Option A is the only one that describes a characteristic that all selected promotions will satisfy, even if it's not the complete and most precise filtering logic. The query selects a subset of the promos described by Option A. In many testing scenarios, if a statement is true for all results of a query, it can be considered a correct description of \"the result,\" especially if other options are definitively false.</p><p>Final choice based on the property fulfilled by the selected items: The query identifies promotions that are cheaper than the lowest of all the \"maximum costs per duration.\" Any such promotion will inherently also be cheaper than the maximum cost within its own duration category.</p><p>The output is the highest promo_cost in each interval defined by <code>(promo_end_date – promo_begin_date)</code>.</p><p>Note that some promotions may have the same promo_begin_date and promo_end_date, in that case they will be grouped into one set and maximum promo_cost will be defined out from this set.</p><p>If all promotions have different promo_begin_date and promo_end_date, they still produce <code>MAX(promo_cost)</code> per interval associated with individual promotion.</p><p>The <code>&lt; ALL</code> means select all but not the highest.</p><p>√&nbsp; <em>It displays prod IDs in the promos which cost less than the highest cost in the same time interval.</em></p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/2020-04-16_02-01-18-4727233724a3ce75fb7d3aab5965ece8.png\"></p>",
                "answers": [
                    "<p>It displays prod IDs in the promo with the highest cost.</p>",
                    "<p>It displays prod IDs in the promos with the lowest cost in the same time interval.</p>",
                    "<p>It displays prod IDs in the promos with the highest cost in the same time interval.</p>",
                    "<p>It displays prod IDs in the promos which cost less than the highest cost in the same time interval.</p>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the structures of the COSTS and PROMOTIONS tables as well as the exhibits.Evaluate the following SQL statement.Exhibit: 1SELECT prod_id\nFROM&nbsp;costs\nWHERE&nbsp;promo_id IN (\nSELECT promo_id FROM promotions\nWHERE promo_cost &lt; ALL&nbsp;(\nSELECT MAX(promo_cost) FROM&nbsp;promotions\nGROUP&nbsp;BY&nbsp;(promo_end_date - promo_begin_date)) Identify the result of the query execution.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306071,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the following scenario.</p><p><strong>Required:</strong> Create a SALES table with these column specifications and data types: </p><ul><li><p>SALESID: Number </p></li><li><p>STOREID: Number </p></li><li><p>ITEMID: Number </p></li><li><p>QTY: Number, should be set to 1 when no value is specified </p></li><li><p>SLSDATE: Date, should be set to current date when no value is specified&nbsp; </p></li><li><p>PAYMENT: Characters up to 30 characters, should be set to CASH when no value is specified.&nbsp; &nbsp;</p></li></ul><p>Identify the statement would best create the table. (Choose the best answer)</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "The DEFAULT keyword should be followed by the default value without the equal sign. Also, default values for numeric columns should not be enclosed in quotation marks.",
                    "The DEFAULT keyword should be followed by the default value without the equal sign. Additionally, the default value for the DATE column should not be enclosed in single quotes.",
                    "The DEFAULT keyword should be followed by the default value without the equal sign. Also, default values for numeric columns should not be enclosed in quotation marks.",
                    "This statement correctly sets default values for the columns as specified in the question. The DEFAULT keyword is used without the equal sign, and the default value for the VARCHAR2 column is enclosed in single quotes."
                ],
                "explanation": "<p>The <strong>best and correct SQL statement</strong> to create the <code>SALES</code> table according to the specified requirements is:</p><p><strong>Correct Answer:</strong></p><pre class=\"prettyprint linenums\">CREATE TABLE sales( \n  salesid NUMBER(4), \n  storeid NUMBER(4), \n  itemid NUMBER(4), \n  qty NUMBER DEFAULT 1, \n  slsdate DATE DEFAULT SYSDATE, \n  payment VARCHAR2(30) DEFAULT 'CASH' \n);</pre><p><br></p><p><strong>Why this is correct:</strong></p><ul><li><p><code>qty NUMBER DEFAULT 1</code> — sets <code>qty</code> to <code>1</code> when not specified</p></li><li><p><code>slsdate DATE DEFAULT SYSDATE</code> — uses the current system date as default</p></li><li><p><code>payment VARCHAR2(30) DEFAULT 'CASH'</code> — correctly uses single quotes for string literal <code>'CASH'</code></p></li><li><p>No syntax errors</p></li></ul><p>Why the other options are incorrect:</p><pre class=\"prettyprint linenums\">qty NUMBER DEFAULT = 1  \npayment VARCHAR2(30) DEFAULT = \"CASH\"</pre><ul><li><p><code>DEFAULT = 1</code> is <strong>invalid syntax</strong> (Oracle does not use <code>=</code> in <code>DEFAULT</code>)</p></li><li><p><code>\"CASH\"</code> uses double quotes — invalid for string literals</p></li><li><p>invalid <code>=</code> and invalid use of double quotes.</p><p><br></p></li></ul><pre class=\"prettyprint linenums\">slsdate DATE DEFAULT 'SYSDATE'  \npayment VARCHAR2(30) DEFAULT CASH</pre><ul><li><p><code>'SYSDATE'</code> is treated as a string literal, not the SYSDATE function</p></li><li><p><code>CASH</code> without quotes is treated as an identifier (e.g., column or variable), not a string</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">CREATE TABLE sales( \n   salesid NUMBER(4), \n   storeid NUMBER(4), \n   itemid NUMBER(4), \n   qty NUMBER DEFAULT = 1, \n   slsdate DATE DEFAULT SYSDATE, \n   payment VARCHAR2(30) DEFAULT = \"CASH\"\n);</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE sales( \n   salesid NUMBER(4), \n   storeid NUMBER(4), \n   itemid NUMBER(4), \n   qty NUMBER DEFAULT 1, \n   slsdate DATE DEFAULT 'SYSDATE', \n   payment VARCHAR2(30) DEFAULT CASH\n);</pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE sales( \n   salesid NUMBER(4), \n   storeid NUMBER(4), \n   itemid NUMBER(4), \n   qty NUMBER DEFAULT = 1, \n   slsdate DATE DEFAULT SYSDATE, \n   payment VARCHAR2(30) DEFAULT = \"CASH\"\n); </pre>",
                    "<pre class=\"prettyprint linenums\">CREATE TABLE sales( \n  salesid NUMBER(4), \n  storeid NUMBER(4), \n  itemid NUMBER(4), \n  qty NUMBER DEFAULT 1, \n  slsdate DATE DEFAULT SYSDATE, \n  payment VARCHAR2(30) DEFAULT 'CASH' \n);</pre>"
                ]
            },
            "correct_response": [
                "d"
            ],
            "section": "SQL Statements",
            "question_plain": "View and examine the following scenario.Required: Create a SALES table with these column specifications and data types: SALESID: Number STOREID: Number ITEMID: Number QTY: Number, should be set to 1 when no value is specified SLSDATE: Date, should be set to current date when no value is specified&nbsp; PAYMENT: Characters up to 30 characters, should be set to CASH when no value is specified.&nbsp; &nbsp;Identify the statement would best create the table. (Choose the best answer)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306073,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify the statements regarding group functions. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Group Operations](https://www.safaribooksonline.com/library/view/mastering-oracle-sql/0596006322/ch04.html)",
                    "[Using Group functions](https://www.tutorialspoint.com/sql_certificate/using_the_group_functions.htm)",
                    "[GROUP BY clause](https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj32654.html)"
                ],
                "feedbacks": [
                    "Group functions can be applied to columns or expressions in the SELECT statement to perform calculations on groups of rows rather than individual rows.",
                    "<p>Group functions are commonly used in conjunction with the GROUP BY clause to group the result set based on one or more columns and perform aggregate calculations on each group.</p>",
                    "<p>Group functions can be used on multiple columns in the SELECT clause, not limited to just one column. They can also be used on expressions derived from columns.</p>",
                    "<p>Group functions can be combined with single-row functions in the SELECT clause to perform calculations on individual rows as well as on groups of rows. This allows for more complex and versatile data manipulation in SQL queries.</p>"
                ],
                "explanation": "<p>Based on standard SQL rules and common usage of group (aggregate) functions, let's exam each&nbsp; of the statements:</p><ol><li><p><strong>They can be used on columns or expressions.</strong></p><ul><li><p><strong>TRUE</strong>. Group functions like <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, etc., can operate on a column (e.g., <code>SUM(salary)</code>) or on an expression involving columns (e.g., <code>AVG(price * quantity)</code>).</p></li></ul></li><li><p><strong>They can be used with a SQL statement that has a GROUP BY clause.</strong></p><ul><li><p><strong>TRUE</strong>. This is a primary use case. Group functions calculate a summary result for each group defined by the <code>GROUP BY</code> clause. If <code>GROUP BY</code> is omitted, the function treats the entire result set as a single group.</p></li></ul></li><li><p><strong>They can be used together with the single-row functions in the SELECT clause.</strong></p><ul><li><p><strong>TRUE</strong>. It's common to select grouping columns (which might be processed by single-row functions) alongside the aggregate function results. For example: <code>SELECT UPPER(department_name), COUNT(*) FROM employees GROUP BY department_name;</code>. Here, <code>UPPER</code> (single-row) is used with <code>COUNT(*)</code> (group function). Single-row functions can also be used <em>inside</em> aggregate functions: <code>SELECT MAX(LENGTH(last_name)) FROM employees;</code>.</p></li></ul></li><li><p><strong>They can be used only on one column in the SELECT clause.</strong></p><ul><li><p><strong>FALSE</strong>. You can use multiple group functions in a single <code>SELECT</code> clause (e.g., <code>SELECT COUNT(*), AVG(salary) FROM employees;</code>). The statement incorrectly claims a limitation to just one column or function.</p></li></ul><p><br></p></li></ol><p>Aggregate data using the Group functions</p><p>SQL has numerous predefined aggregate functions that can be used to write queries to produce exactly this kind of information.The <code>GROUP BY</code> clause specifies how to group rows from a data table when aggregating information, while the HAVING clause filters out rows that do not belong in specified groups.</p><p>Aggregate functions perform a variety of actions such as counting all the rows in a table, averaging a column's data, and summing numeric data. Aggregates can also search a table to find the highest <code>MAX</code> or lowest <code>MIN</code> values in a column. As with other types of queries, you can restrict, or filter out the rows these functions act on with the <code>WHERE</code> clause. For example, if a manager needs to know how many employees work in an organization, the aggregate function named <code>COUNT(*)</code> can be used to produce this information.The <code>COUNT(*)</code> function shown in the below <code>SELECT</code> statement counts all rows in a table.</p><p>The result table for the <code>COUNT(*)</code> function is a single column from a single row known as a scalar result or value. Notice that the result table has a column heading that corresponds to the name of the aggregate function specified in the <code>SELECT</code> clause.</p><p><em>√&nbsp; Group functions can be used together with the single-row functions in the SELECT clause.</em></p><p><br></p><p>The <code>ALL</code> and <code>DISTINCT</code> keywords are optional, and perform as they do with the <code>SELECT</code> clauses that you have learned to write.The <code>ALL</code> keyword is the default where the option is allowed.The expression listed in the syntax can be a constant,a function, or any combination of column names, constants, and functions connected by arithmetic operators.However, aggregate functions are most often used with a column name. Except <code>COUNT </code>function,all the aggregate functions do not consider <code>NULL</code> values.</p><p><strong>There are two rules that you must understand and follow when using aggregates:</strong></p><p>Aggregate functions can be used in both the <code>SELECT</code> and <code>HAVING</code> clauses.</p><p>Aggregate functions cannot be used in a <code>WHERE</code> clause. Its violation will produce the Oracle ORA-00934 group function is not allowed here error message.</p><p><a href=\"https://www.tutorialspoint.com/sql_certificate/using_the_group_functions.htm\">https://www.tutorialspoint.com/sql_certificate/using_the_group_functions.htm</a></p><p><br></p><p>An <em>aggregate function</em> summarizes the results of an expression over a number of rows, returning a single value. The general syntax for most of the aggregate functions is as follows:</p><p><br></p><pre class=\"prettyprint linenums\">aggregate_function([DISTINCT | ALL] expression)</pre><p><br></p><p>The syntax elements are:</p><p><code><em>aggregate_function</em></code> - Gives the name of the function—e.g., <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code></p><p><code>DISTINCT</code> - Specifies that the aggregate function should consider only distinct values of the argument expression.</p><p><code>ALL</code> - Specifies that the aggregate function should consider all values, including all duplicate values, of the argument expression. The default is ALL.</p><p><code><em>expression</em></code> - Specifies a column, or any other expression, on which you want to perform the aggregation.</p><p><br></p><p><strong>NULLs and Aggregate Functions</strong></p><p>The clause&nbsp; <code>COUNT(sale_price)</code> ignores NULLs, whereas <code>COUNT(*)</code> doesn’t. The reason <code>COUNT(*)</code> doesn’t ignore NULLs is because it counts rows, not column values. The concept of NULL doesn’t apply to a row as a whole. Other than <code>COUNT(*)</code>, there is only one other aggregate function that doesn’t ignore NULLs, and that is <code>GROUPING</code>. All other aggregate functions ignore NULLs.</p><p><a href=\"https://www.safaribooksonline.com/library/view/mastering-oracle-sql/0596006322/ch04.html\">https://www.safaribooksonline.com/library/view/mastering-oracle-sql/0596006322/ch04.html</a></p><p><br></p><p><strong>GROUP BY</strong></p><p>The <code>GROUP BY</code> clause is used in a <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a> statement to group rows into a set of summary rows by values of columns or expressions. </p><p><em>√&nbsp; Group functions can be used on columns or expressions.</em></p><p><br></p><p>The <code>GROUP BY</code> clause returns one row per group.</p><p>The <code>GROUP BY</code> clause is often used with <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/\">aggregate functions</a> such as <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-avg/\"><code>AVG()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-count/\"><code>COUNT()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-max/\"><code>MAX()</code></a>, <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-min/\"><code>MIN()</code></a> and <a href=\"https://www.oracletutorial.com/oracle-aggregate-functions/oracle-sum/\"><code>SUM()</code></a>. In this case, the aggregate function returns the summary information per group. For example, given groups of products in several categories, the <code>AVG()</code> function returns the average price of products in each category.</p><p><a href=\"https://www.oracletutorial.com/oracle-basics/oracle-group-by/\">https://www.oracletutorial.com/oracle-basics/oracle-group-by/</a></p><p><br></p><p>Aggregate functions are normally used in conjunction with a <code>GROUP BY</code> clause. The <code>GROUP BY</code> clause enables you to use aggregate functions to answer more complex managerial questions such as:</p><p>What is the average salary of employees in each department?</p><p>How many employees work in each department?</p><p>How many employees are working on a particular project?</p><p><code>GROUP BY</code> function establishes data groups based on columns and aggregates the information within a group only. The grouping criterion is defined by the columns specified in <code>GROUP BY</code> clause. Following this hierarchy, data is first organized in the groups and then <code>WHERE</code> clause restricts the rows in each group.</p><p><br></p><p><strong>Guidelines of using GROUP BY clause</strong></p><p>(1) All the dependent columns or columns used in <code>GROUP BY</code> function must form the basis of grouping, hence must be included in <code>GROUP BY</code> clause.</p><p>(2) <code>GROUP BY</code> clause does not support the use of column alias, but the actual names.</p><p>(3) <code>GROUP BY</code> clause is typically used with aggregate functions like <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, <code>MAX</code>, and <code>MIN</code></p><p>(4) <code>GROUP BY</code> clause must contain only aggregates or grouping columns.</p><p><br></p><p><strong>Use of DISTINCT, ALL keywords with Aggregate functions</strong></p><p>By specifying <code>DISTINCT</code> keyword with the input parameter, group by function considers only the unique value of the column for aggregation. By specifying <code>ALL</code> keyword with the input parameter, group by function considers all the values of the column for aggregation, including nulls and duplicates. <code>ALL</code> is the default specification.</p><p><br></p><p><strong>The HAVING clause</strong></p><p>The <code>HAVING</code> clause is used for aggregate functions in the same way that a <code>WHERE</code> clause is used for column names and expressions. Essentially, the <code>HAVING</code> and <code>WHERE</code> clauses do the same thing, that is filter rows from inclusion in a result table based on a condition. While it may appear that a <code>HAVING</code> clause filters out groups, it does not. Rather, a <code>HAVING</code> clause filters rows.</p><p>When all rows for a group are eliminated so is the group. To summarize, the important differences between the <code>WHERE</code> and <code>HAVING</code> clauses are:</p><p>A <code>WHERE</code> clause is used to filter rows BEFORE the <code>GROUPING</code> action (i.e., before the calculation of the aggregate functions).</p><p>A <code>HAVING</code> clause filters rows AFTER the <code>GROUPING</code> action (i.e., after the calculation of the aggregate functions).</p><p>The <code>HAVING</code> clause is a conditional option that is directly related to the <code>GROUP BY</code> clause option because a <code>HAVING</code> clause eliminates rows from a result table based on the result of a <code>GROUP BY</code> clause.</p><p>The <code>HAVING</code> clause is closely associated with the <code>GROUP BY</code> clause. The <code>HAVING</code> clause is used to put a filter on the groups created by the <code>GROUP BY</code> clause. If a query has a <code>HAVING</code> clause along with a <code>GROUP BY</code> clause, the result set will include only the groups that satisfy the condition specified in the <code>HAVING</code> clause.</p><p>Even though Oracle doesn’t care whether the <code>HAVING</code> clause comes before the <code>GROUP BY</code> clause or after, the <code>HAVING</code> clause is applied to the groups created by the <code>GROUP BY</code> clause, so it is a good programming practice to always put the <code>HAVING</code> clause after the <code>GROUP BY</code>clause. Another reason for placing <code>HAVING</code> after <code>GROUP BY</code> is that SQL Standard requires that particular order. Thus, putting <code>HAVING</code> after <code>GROUP BY</code> makes your code more portable.</p><p>You can use a <code>WHERE</code> clause and a <code>HAVING</code> clause together in a query. When you do, it is important to understand the impact of the two clauses. The <code>WHERE</code> clause is executed first, and the rows that don’t satisfy the <code>WHERE</code> condition are not passed to the <code>GROUP BY</code> clause. The <code>GROUP BY</code> clause summarizes the filtered data into groups, and then the <code>HAVING</code> clause is applied to the groups to eliminate the groups that don’t satisfy the <code>HAVING</code> condition.</p>",
                "answers": [
                    "<p>They can be used on columns or expressions.</p>",
                    "<p>They can be used with a SQL statement that has a GROUP BY clause.</p>",
                    "<p>They can be used only on one column in the SELECT clause.</p>",
                    "<p>They can be used together with the single-row functions in the SELECT clause.</p>"
                ]
            },
            "correct_response": [
                "a",
                "e",
                "b",
                "d"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify the statements regarding group functions. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306075,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the following available responses.</p><p>Identify Oracle Mathematical Functions which can be performed on a column by using a SQL function that is built into Oracle database. (Choose three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: SUM Function](https://www.techonthenet.com/oracle/functions/sum.php)",
                    "[Oracle / PLSQL: MIN Function](https://www.techonthenet.com/oracle/functions/min.php)",
                    "[Oracle / PLSQL: POWER Function](https://www.techonthenet.com/oracle/functions/power.php)"
                ],
                "feedbacks": [
                    "Finding the lowest value is a mathematical operation that can be performed on a column using the MIN() function in Oracle database. This function returns the minimum value in a set of values.",
                    "Finding the quotient is a mathematical operation that can be performed on a column using the DIV() function in Oracle database. This function returns the integer quotient of a division operation.",
                    "Raising to a power is a mathematical operation that can be performed on a column using the POWER() function in Oracle database. This function raises a number to a specified power.",
                    "Subtraction is not a mathematical function that is built into Oracle database as a SQL function. It is a basic arithmetic operation that can be performed using the \"-\" operator in SQL queries.",
                    "Addition is not a mathematical function that is built into Oracle database as a SQL function. It is a basic arithmetic operation that can be performed using the \"+\" operator in SQL queries."
                ],
                "explanation": "<p>To identify which <strong>Oracle Mathematical Functions</strong> are <strong>built-in SQL functions</strong> (i.e., invoked as <strong>functions</strong>, not just operators), let’s review each option carefully.</p><p>Oracle built-in mathematical functions (used as <strong>functions</strong>, not just operators):</p><ol><li><p><strong>Raising to a power</strong><br><strong>Correct</strong> — Oracle provides the <code>POWER(n, m)</code> function, which raises <code>n</code> to the power of <code>m</code>.</p></li><li><p><strong>Finding the quotient</strong><br><strong>Correct</strong> — You can use <code>FLOOR(n/m)</code> or <code>MOD()</code> in combination. More directly, the <code>TRUNC(n / m)</code> or <code>FLOOR(n / m)</code> are used to return quotient parts. These are built-in functions used for integer division-like behaviour.</p></li><li><p><strong>Addition</strong><br><strong>Incorrect</strong> — Addition is done using the <code>+</code> operator, <strong>not</strong> a built-in <strong>function</strong>.</p></li><li><p><strong>Subtraction</strong><br><strong>Incorrect</strong> — Like addition, subtraction uses the <code>-</code> operator, <strong>not</strong> a built-in function.</p></li><li><p><strong>Finding the lowest value</strong><br><code><strong>LEAST()</strong></code> is used to find the smallest value <strong>among multiple expressions</strong>.</p><p><code><strong>MIN()</strong></code> is an <strong>aggregate function</strong> used to find the lowest value in a <strong>column</strong> of a table.</p><p><strong>Correct </strong>- However, here's the key distinction:</p><p>While <code><strong>LEAST()</strong></code> is a <strong>scalar function</strong> (and built-in),</p><p><code><strong>MIN()</strong></code> is a <strong>group (aggregate) function</strong>, not a mathematical function in the traditional Oracle mathematical function category.</p><p>So, even though both can \"find the lowest value,\" <strong>Oracle classifies only certain functions</strong> (like <code>POWER</code>, <code>MOD</code>, <code>FLOOR</code>, <code>CEIL</code>, <code>ROUND</code>, <code>TRUNC</code>, etc.) under <strong>mathematical functions</strong>.</p></li></ol><p><br></p><p><strong><em>Finding the lowest value:</em></strong><em> </em><code>MIN</code> function returns the minimum value of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>MIN</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT MIN(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>MIN</code> function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       MIN(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n Expressions that are not encapsulated within the MIN function and must be included in the GROUP BY clause at the end of the SQL statement. aggregate_expression This is the column or expression from which the minimum value will be returned. tables The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. WHERE conditions Optional. These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>MIN</code> function returns the minimum value.</p><p><br></p><p><strong><em>Raising to a power:</em></strong><em> </em><code>POWER</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">POWER( m, n )</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p><code>m</code> -The base used in the calculation. </p><p><code>n</code> - The exponent used in the calculation</p><p><strong>Returns</strong></p><p>The <code>POWER</code> function returns a numeric value.</p><p><br></p><p><strong><em>Addition:</em> </strong><code>SUM</code> function returns the summed value of an expression.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>SUM</code> function in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT SUM(aggregate_expression)\nFROM tables\n[WHERE conditions];</pre><p><br></p><p>OR the syntax for the <code>SUM</code> function when grouping the results by one or more columns is:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT expression1, expression2, ... expression_n,\n       SUM(aggregate_expression)\nFROM tables\n[WHERE conditions]\nGROUP BY expression1, expression2, ... expression_n;</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression1, expression2, ... expression_n Expressions that are not encapsulated within the SUM function and must be included in the GROUP BY clause at the end of the SQL statement. aggregate_expression This is the column or expression that will be summed. tables The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. WHERE conditions Optional. These are conditions that must be met for the records to be selected.</p><p><strong>Returns</strong></p><p>The <code>SUM</code> function returns a numeric value.</p><p><br></p><p><br></p><p><strong>Oracle Mathematical Functions</strong></p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_abs\"><code>ABS()</code></a> Return the absolute value</p><p> <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_acos\"><code>ACOS()</code></a> Return the arc cosine </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_asin\"><code>ASIN()</code></a> Return the arc sine </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_atan\"><code>ATAN()</code></a> Return the arc tangent </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_atan2\"><code>ATAN2()</code>, <code>ATAN()</code></a> Return the arc tangent of the two arguments </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_ceil\"><code>CEIL()</code></a> Return the smallest integer value not less than the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_ceiling\"><code>CEILING()</code></a> Return the smallest integer value not less than the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_conv\"><code>CONV()</code></a> Convert numbers between different number bases </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_cos\"><code>COS()</code></a> Return the cosine </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_cot\"><code>COT()</code></a> Return the cotangent </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_crc32\"><code>CRC32()</code></a> Compute a cyclic redundancy check value </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_degrees\"><code>DEGREES()</code></a> Convert radians to degrees </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_exp\"><code>EXP()</code></a> Raise to the power of </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_floor\"><code>FLOOR()</code></a> Return the largest integer value not greater than the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_ln\"><code>LN()</code></a> Return the natural logarithm of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_log\"><code>LOG()</code></a> Return the natural logarithm of the first argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_log10\"><code>LOG10()</code></a> Return the base-10 logarithm of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_log2\"><code>LOG2()</code></a> Return the base-2 logarithm of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_mod\"><code>MOD()</code></a> Return the remainder</p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_pi\"><code>PI()</code></a> Return the value of pi </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_pow\"><code>POW()</code></a> , <a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_power\"><code>POWER()</code></a> Return the argument raised to the specified power </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_radians\"><code>RADIANS()</code></a> Return argument converted to radians </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_rand\"><code>RAND()</code></a> Return a random floating-point value </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_round\"><code>ROUND()</code></a> Round the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_sign\"><code>SIGN()</code></a> Return the sign of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_sin\"><code>SIN()</code></a> Return the sine of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_sqrt\"><code>SQRT()</code></a> Return the square root of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_tan\"><code>TAN()</code></a> Return the tangent of the argument </p><p><a href=\"https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/mathematical-functions.html#function_truncate\"><code>TRUNCATE()</code></a> Truncate to specified number of decimal places</p>",
                "answers": [
                    "<p>Finding the lowest value</p>",
                    "<p>Finding the quotient</p>",
                    "<p>Raising to a power</p>",
                    "<p>Subtraction</p>",
                    "<p>Addition</p>"
                ]
            },
            "correct_response": [
                "c",
                "b",
                "a"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the following available responses.Identify Oracle Mathematical Functions which can be performed on a column by using a SQL function that is built into Oracle database. (Choose three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130305947,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>View and examine the structure of the TRANSACTIONS table.</p><p><strong>Table: TRANSACTIONS </strong></p><pre class=\"prettyprint linenums\">Name                   Null??              Type\nTRANS_ID               NOT NULL            NUMBER(6)\nCUST_NAME              NOT NULL            CARCHAR(20)\nCUST_STATUS            NOT NULL            CHAR\nTRANS_DATE             NOT NULL            DATE\nTRANS_VALIDITY                             VARCHAR2\nCUST_CREDIT_LIMIT                          NUMBER</pre><p><br></p><p>Identify two true statements regarding the storage of data in the above table structure. (Choose two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle NUMBER Data Type](https://www.oracletutorial.com/oracle-basics/oracle-number-data-type/)",
                    "[Overview of DATE Datatype](https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT413)",
                    "[Oracle Built-in Data Types](http://docs.oracle.com/database/121/SQLRF/sql_elements001.htm#SQLRF30020)"
                ],
                "feedbacks": [
                    "The CUST_CREDIT_LIMIT column is likely defined as a numeric data type, such as INTEGER or NUMBER, which allows for the storage of both positive and negative integers. This makes it suitable for storing credit limits, which can be positive or negative values.",
                    "The TRANS_DATE column is likely defined as a DATE data type, which allows for the storage of a point in time including days, hours, minutes, and seconds. This makes it suitable for storing timestamps or dates and times related to transactions.",
                    "The TRANS_VALIDITY column is likely defined as a VARCHAR2 data type, which allows for the storage of variable-length character strings up to a maximum size of 4,000 characters. This makes it suitable for storing textual information related to transaction validity, but it does not necessarily have a specific limit of 4,000 characters.",
                    "The TRANS_DATE column, if defined as a DATE data type, would allow storage of dates in a standard date format, not limited to the dd-mon-yyyy format. The DATE data type in Oracle allows for the storage of dates in various formats and does not restrict the format to a specific style like dd-mon-yyyy."
                ],
                "explanation": "<p>Based on the structure of the <code>TRANSACTIONS</code> table provided, here is the correct evaluation of the statements:</p><p><strong>True Statements:</strong></p><ol><li><p><strong>The CUST_CREDIT_LIMIT column would allow storage of positive and negative integers.</strong></p><ul><li><p><strong>Explanation:</strong> <code>CUST_CREDIT_LIMIT</code> is of type <code>NUMBER</code>, which can store both positive and negative numbers, including integers and decimals (unless explicitly restricted by precision/scale, which it isn't here).</p></li></ul></li><li><p><strong>The TRANS_DATE column would allow storage of a point in time (days, hours, minutes, and seconds).</strong></p><ul><li><p><strong>Explanation:</strong> In Oracle, the <code>DATE</code> datatype stores <strong>date and time</strong> down to seconds (i.e., includes day, hour, minute, and second).</p></li></ul></li></ol><p><strong>False Statements:</strong></p><ul><li><p><strong>The TRANS_VALIDITY column would allow storage of data up to the maximum VARCHAR2 size of 4,000 characters.</strong></p><ul><li><p><strong>Explanation:</strong> Since the column definition does not specify a length (e.g., <code>VARCHAR2(4000)</code>), it will <strong>not</strong> default to 4000. In fact, this would cause an error during table creation. You must <strong>explicitly</strong> define the size for a <code>VARCHAR2</code> column.</p></li></ul></li><li><p><strong>The TRANS_DATE column would allow storage of dates only in the dd-mon-yyyy format.</strong></p><ul><li><p><strong>Explanation:</strong> The internal storage of a <code>DATE</code> column is format-independent. The display format like <code>dd-mon-yyyy</code> is determined by <strong>NLS settings</strong>, not the data type itself.</p></li></ul></li></ul><p><br></p><p><br></p><p>The Oracle <code>NUMBER</code> data type is used to store numeric values that can be negative or positive. The following illustrates the syntax of the <code>NUMBER</code> data type:</p><p><br></p><pre class=\"prettyprint linenums\">NUMBER[(precision [, scale])]</pre><p><br></p><p>The Oracle <code>NUMBER</code> data type has precision and scale.</p><p>The precision is the number of digits in a number. It ranges from 1 to 38.</p><p>The scale is the number of digits to the right of the decimal point in a number. It ranges from -84 to 127.</p><p>For example, the number 1234.56 has a precision of 6 and a scale of 2. So to store this number, you need <code>NUMBER(6,2)</code>.</p><p>Both precision and scale are in decimal digits and optional. If you skip the precision and scale, Oracle uses the maximum range and precision for the number.</p><p><br></p><p><br></p><p>The <code>DATE</code> datatype stores point-in-time values (dates and times) in a table. The <code>DATE</code> datatype stores the year (including the century), the month, the day, the hours, the minutes, and the seconds (after midnight).</p><p><br></p><p><br></p><p><em>X The TRANS_VALIDITY column would allow storage of data up to the maximum VARCHAR2 size of 4,000 characters.</em></p><p>In Oracle Databast 12c maybe up to 32767 bytes or characters.</p><p><code>VARCHAR2</code>(<code>size</code> [<code>BYTE</code> | <code>CHAR</code>])</p><p>Variable-length character string having maximum length <code>size</code> bytes or characters. You must specify <code>size</code> for <code>VARCHAR2</code>. Minimum <code>size</code> is 1 byte or 1 character. Maximum size is:</p><ul><li><p>32767 bytes or characters if <code>MAX_STRING_SIZE</code> <code>=</code> <code>EXTENDED</code></p></li><li><p>4000 bytes or characters if <code>MAX_STRING_SIZE</code> <code>=</code> <code>STANDARD</code></p></li></ul><p>Refer to <a href=\"https://docs.oracle.com/database/121/SQLRF/sql_elements001.htm#BABCIGGA\">\"Extended Data Types\"</a> for more information on the <code>MAX_STRING_SIZE</code> initialization parameter.</p><p><code>BYTE</code> indicates that the column will have byte length semantics. <code>CHAR</code> indicates that the column will have character semantics.</p>",
                "answers": [
                    "<p>The CUST_CREDIT_LIMIT column would allow storage of positive and negative integers.</p>",
                    "<p>The TRANS_DATE column would allow storage of a point in time (days, hours, minutes, and seconds).</p>",
                    "<p>The TRANS_VALIDITY column would allow storage of data up to the maximum VARCHAR2 size of 4,000 characters.</p>",
                    "<p>The TRANS_DATE column would allow storage of dates only in the dd-mon-yyyy format.</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the structure of the TRANSACTIONS table.Table: TRANSACTIONS Name                   Null??              Type\nTRANS_ID               NOT NULL            NUMBER(6)\nCUST_NAME              NOT NULL            CARCHAR(20)\nCUST_STATUS            NOT NULL            CHAR\nTRANS_DATE             NOT NULL            DATE\nTRANS_VALIDITY                             VARCHAR2\nCUST_CREDIT_LIMIT                          NUMBERIdentify two true statements regarding the storage of data in the above table structure. (Choose two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306089,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and review the following available responses.</p><p>Identify the SQL statement that would display the value 1889.22 as&nbsp; 1.889,22€.</p>",
                "relatedLectureIds": [],
                "links": [],
                "feedbacks": [
                    "This SQL statement uses the TRANSLATE function to replace the comma and period in the number format with a period and comma, respectively. It then concatenates the Euro sign ('€') to the formatted number, resulting in the desired output format of 1.889,22€.",
                    "This SQL statement uses the TO_CHAR function with a specific format model ('€99G999D00') to format the number 1889.22 as Euro currency. However, the format model does not match the desired output format of 1.889,22€.",
                    "This SQL statement uses the TRANSLATE function within the TO_CHAR function to attempt to format the number 1889.22 as Euro currency. However, the placement of the Euro sign ('€') within the format model is incorrect, resulting in an incorrect output format.",
                    "This SQL statement attempts to format the number 1889.22 as Euro currency using the TO_CHAR function with a format model ('99G999D99'€). However, the format model is not valid and does not match the desired output format of 1.889,22€.",
                    "<p>Correct statement is:</p><pre class=\"prettyprint linenums\">SELECT translate (TO_CHAR (1889.22, '99,999.00'),&nbsp; ',.' , '.,')&nbsp; || '€' \nFROM DUAL;</pre>"
                ],
                "explanation": "<p>To correctly display the value <code>1889.22</code> as <code><strong>1.889,22€</strong></code>, we need to:</p><ul><li><p>Use a <strong>period (.)</strong> as the <strong>thousands separator</strong>.</p></li><li><p>Use a <strong>comma (,)</strong> as the <strong>decimal separator</strong>.</p></li><li><p>Append <strong>€</strong> at the end.</p></li><li><p>Ensure <strong>locale formatting</strong> is applied properly, since Oracle uses <code>G</code> for group separator and <code>D</code> for decimal separator.</p></li></ul><pre class=\"prettyprint linenums\">SELECT translate (TO_CHAR (1889.22, '99,999.00'), ',', '.') , '.', ',') || '€' \nFROM DUAL;</pre><p>This is trying to <strong>swap comma and period</strong>, but:</p><ul><li><p><code>'99,999.00'</code> uses <strong>comma for grouping</strong> and <strong>period for decimal</strong>.</p></li><li><p>Then, it <strong>translates</strong> <code>,</code> to <code>.</code> and <code>.</code> to <code>,</code>.</p></li><li><p>So: <code>1,889.22</code> → <code>1.889,22</code></p></li><li><p><strong>Correct transformation</strong>, and <code>€</code> is appended.</p></li><li><p><strong>This works.</strong></p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT TO_CHAR (1889.22, '€99G999D00')\nFROM DUAL;</pre><ul><li><p><code>G</code> and <code>D</code> are locale-dependent for group and decimal separators.</p></li><li><p>The format <code>'€99G999D00'</code> <strong>puts € at the beginning</strong>, but we want it at the end.</p></li><li><p><strong>Incorrect placement of €</strong>.</p></li><li><p>Also, might not yield desired output unless NLS settings are set appropriately.</p></li></ul><p><br></p><pre class=\"prettyprint linenums\">SELECT translate(TO_CHAR (1889.22, '99G999D00€'))\nFROM DUAL;</pre><ul><li><p>Missing second and third parameters for <code>TRANSLATE</code>.</p></li><li><p><strong>Syntax error</strong> — <code>TRANSLATE</code> needs all 3 parameters.</p></li><li><p>Invalid SQL.</p></li></ul><pre class=\"prettyprint linenums\">SELECT TO_CHAR (1889.22, '99G999D99'€)\nFROM DUAL;</pre><ul><li><p><strong>Invalid SQL syntax</strong> — misplaced <code>€</code> outside the format string.</p></li></ul>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">SELECT translate (TO_CHAR (1889.22, '99,999.00'), ',', '.') , '.', ',') || '€' \nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1889.22, '€99G999D00')\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT translate(TO_CHAR (1889.22, '99G999D00€'))\nFROM DUAL;</pre>",
                    "<pre class=\"prettyprint linenums\">SELECT TO_CHAR (1889.22, '99G999D99'€)\nFROM DUAL;</pre>",
                    "<p>None of the listed options are correct</p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "View and review the following available responses.Identify the SQL statement that would display the value 1889.22 as&nbsp; 1.889,22€.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306091,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p>View and examine the description of the CUSTOMERS table.</p><p><strong>Table: CUSTOMERS </strong></p><pre class=\"prettyprint linenums\">Name                   Null??              Type\nCUST_ID                NOT NULL            VARCHAR2(2)\nCUST_LAST_NAME                             VARCHAR2(30)\nCITY                                       VARCHAR2(10)\nCUST_CREDIT_LIMIT                          NUMBER(6,2)            </pre><p><br></p><p><strong>Required: </strong>Display last names and credit limits of all customers whose last name starts with A or B in lower or upper case, and whose credit limit is below 1000.&nbsp; </p><p>Examine this partial query.</p><p><strong>Exhibit 1:</strong></p><pre class=\"prettyprint linenums\">SELECT cust_last_name, cust_credit_limit\nFrom customers;</pre><p><br></p><p>Identify the most efficient WHERE condition that would render a valid result.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle / PLSQL: LIKE Condition](https://www.techonthenet.com/oracle/like.php)"
                ],
                "feedbacks": [
                    "<p>This choice correctly uses the INITCAP function to ensure that the last names are compared in both lower and upper case. It correctly filters the last names that start with 'A' or 'B' and have a credit limit below 1000.</p>",
                    "<p>This choice incorrectly uses the BETWEEN operator, which is not suitable for pattern matching like 'A%' or 'B%'. It also incorrectly uses the ROUND function on the credit limit, which is unnecessary for this comparison.</p>",
                    "<p>This choice incorrectly uses the IN operator, which is not suitable for pattern matching like 'A%' or 'B%'. It also incorrectly uses the UPPER function on the last name without considering both lower and upper case variations.</p>",
                    "<p>This choice incorrectly uses the INITCAP function on 'B%' and the ROUND function on the credit limit, which are unnecessary for this comparison. It also incorrectly combines the LIKE and IN operators, leading to an invalid query.</p>",
                    "<p>This choice correctly uses the UPPER function to ensure that the last names are compared in both lower and upper case. However, it incorrectly uses the ROUND function on the credit limit, which is unnecessary for this comparison.</p>"
                ],
                "explanation": "<p>To solve this, we want to:</p><ul><li><p>Retrieve rows where <code>cust_last_name</code> starts with <strong>A or B</strong>, <strong>regardless of case</strong>.</p></li><li><p>Ensure <code>cust_credit_limit &lt; 1000</code>.</p></li><li><p>Use the most <strong>efficient and correct</strong> <code>WHERE</code> condition.</p></li></ul><p>Let’s evaluate the options:</p><p><strong>Correct and Most Efficient Option:</strong></p><pre class=\"prettyprint linenums\">WHERE ((UPPER(cust_last_name) LIKE 'A%') \n    OR (UPPER(cust_last_name) LIKE 'B%')) \nAND cust_credit_limit &lt; 1000;</pre><p><br></p><ul><li><p><strong>UPPER</strong> handles case insensitivity.</p></li><li><p><code>'A%'</code> and <code>'B%'</code> match names starting with A or B.</p></li><li><p>Credit limit is directly compared without unnecessary rounding.</p></li><li><p>Efficient and valid SQL.</p></li></ul><p>Other Options Breakdown:</p><ol><li><p><code><strong>INITCAP(cust_last_name) LIKE 'A%'</strong></code><strong>...</strong></p><ul><li><p><code>INITCAP</code> capitalizes only the first letter and lowercases the rest.</p></li><li><p>Fails for names already in all uppercase/lowercase/mixed.</p></li><li><p>Not as reliable or efficient.</p></li></ul></li><li><p><code><strong>BETWEEN ('A%', 'B%')</strong></code></p><ul><li><p>Syntax error: <code>BETWEEN</code> doesn’t work with wildcard patterns like <code>%</code>.</p></li></ul></li><li><p><code><strong>IN ('A%', 'B%')</strong></code></p><ul><li><p><code>IN</code> doesn’t support wildcard matching — only exact matches.</p></li></ul></li><li><p><strong>Mix of </strong><code><strong>UPPER</strong></code><strong> and </strong><code><strong>INITCAP</strong></code><strong>, and </strong><code><strong>ROUND(cust_credit_limit)</strong></code></p><ul><li><p>Overcomplicated, mixing functions unnecessarily.</p></li><li><p>Less efficient than a simple comparison.</p></li></ul></li></ol><p><br></p><p><strong>The Oracle LIKE condition</strong> allows wildcards to be used in the<a href=\"https://www.techonthenet.com/oracle/where.php\"> WHERE clause</a> of a <a href=\"https://www.techonthenet.com/oracle/select.php\">SELECT</a>, <a href=\"https://www.techonthenet.com/oracle/insert.php\">INSERT</a>, <a href=\"https://www.techonthenet.com/oracle/update.php\">UPDATE</a>, or <a href=\"https://www.techonthenet.com/oracle/delete.php\">DELETE</a> statement. This allows you to perform pattern matching.</p><p><strong>Syntax</strong></p><p>The syntax for the <code>LIKE</code> condition in Oracle/PLSQL is:</p><p><br></p><pre class=\"prettyprint linenums\">expression LIKE pattern [ ESCAPE 'escape_character' ]</pre><p><br></p><p><strong>Parameters or Arguments</strong></p><p>expression - A character expression such as a column or field. </p><p>pattern - A character expression that contains pattern matching. The patterns that you can choose from are:</p><p><strong>Wildcard with Explanation </strong></p><p>%&nbsp; - Allows you to match any string of any length (including zero length) </p><p>_&nbsp; - Allows you to match on a single character</p><p>escape_character Optional.&nbsp; - It allows you to test for literal instances of a wildcard character such as % or _.</p><p><br></p><p><img src=\"https://img-c.udemycdn.com/redactor/raw/test_question_description/2021-01-13_15-38-57-6af490720a4c275298c42632ff2dbd82.png\"></p><p><br></p><p>In the above query, it does execute under most circumstances but since CUST_CREDIT_LIMIT has datatype NUMBER(6, 2), if there is a value 999.99 and it is rounded to 1000. In this case the rounded figure would be equal to 1000 but won't be included in the query result. </p>",
                "answers": [
                    "<pre class=\"prettyprint linenums\">WHERE((INITCAP(cust_last_name) LIKE 'A%')\nOR (INITCAP(cust_last_name) LIKE 'B%'))\nAND cust_credit_limit &lt; 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE UPPER(customer_last_name) BETWEEN ('A%', 'B%') \nAND ROUND(cust_credit_limit) &lt; 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE UPPER(customer_last_name) IN ('A%', 'B%') \nAND cust_credit_limit &lt; 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE(UPPER(customer_last_name) LIKE 'A%' \nOR UPPER(cust_last_name) LIKE INITCAP('B%')) \nAND ROUND (cust_credit_limit) &lt; ROUND 1000;</pre>",
                    "<pre class=\"prettyprint linenums\">WHERE((UPPER(cust_last_name) LIKE 'A%')\nOR (UPPER(cust_last_name) LIKE 'B%'))\nAND ROUND (cust_credit_limit) &lt; ROUND (1000);</pre>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "Database SQL Reference",
            "question_plain": "View and examine the description of the CUSTOMERS table.Table: CUSTOMERS Name                   Null??              Type\nCUST_ID                NOT NULL            VARCHAR2(2)\nCUST_LAST_NAME                             VARCHAR2(30)\nCITY                                       VARCHAR2(10)\nCUST_CREDIT_LIMIT                          NUMBER(6,2)            Required: Display last names and credit limits of all customers whose last name starts with A or B in lower or upper case, and whose credit limit is below 1000.&nbsp; Examine this partial query.Exhibit 1:SELECT cust_last_name, cust_credit_limit\nFrom customers;Identify the most efficient WHERE condition that would render a valid result.",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306093,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Which of the following are true statements about the Oracle Indexes? (Select three)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Unique vs. non unique index](https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:7641143144618)",
                    "[Managing Indexes ](https://docs.oracle.com/en/database/oracle//oracle-database/18/admin/managing-indexes.html#GUID-2CE1BB91-3EFA-450D-BD31-0C961549F0C2)",
                    "[Why index other users table?](https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:963584700346413565)"
                ],
                "feedbacks": [
                    "<p>A UNIQUE index can be converted to a non-UNIQUE index by altering the index definition. This change allows duplicate values to be stored in the indexed column, making it a non-UNIQUE index.</p>",
                    "An update operation on a table can update any or all the indexes associated with that table. Depending on the columns being updated and the index definitions, the update operation may affect one or multiple indexes.",
                    "An update operation on a table can lead to no update on indexes if the columns being updated are not part of any indexed columns. In such cases, the indexes remain unchanged as they are not affected by the update operation.",
                    "Users can create indexes in another schema by specifying the schema name when creating the index. This allows users to create indexes on tables in different schemas, provided they have the necessary privileges.",
                    "Bitmap indexes are compact data structures that work best for columns with a small set of distinct values. They are efficient for columns with low cardinality, where the values are repeated frequently, making them suitable for certain types of queries.",
                    "B-tree indexes are the default and most common type of index in Oracle databases. They are well-suited for a wide range of queries and provide efficient access to data by organizing the index keys in a balanced tree structure."
                ],
                "explanation": "<p>Here is an analysis of each statement about Oracle indexes:</p><p><strong>True Statements:</strong></p><ol><li><p><strong>Bitmap indexes are compact; work best for columns with a small set of values</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Bitmap indexes are ideal for low-cardinality columns (few distinct values, e.g., gender, status).</p></li><li><p>They are space-efficient and support complex queries involving AND/OR.</p></li></ul></li><li><p><strong>B-tree indexes are the default and the most common type of index</strong></p><ul><li><p><strong>True</strong></p></li><li><p>B-tree (balanced tree) indexes are the <strong>default index type</strong> in Oracle.</p></li><li><p>They are best for high-cardinality columns (many distinct values).</p></li></ul></li><li><p><strong>An update operation on table can update any or all the INDEXES</strong></p><ul><li><p><strong>True</strong></p></li><li><p>When a table row is updated and the updated column is part of one or more indexes, <strong>those indexes are also updated</strong> automatically.</p></li></ul></li></ol><p><strong>False Statements:</strong></p><ol><li><p><strong>UNIQUE index can be converted to non UNIQUE index</strong></p><ul><li><p><strong>False</strong></p></li><li><p>You cannot directly \"convert\" a unique index to a non-unique one. You would need to <strong>drop and recreate</strong> it.</p></li></ul></li><li><p><strong>Update operation on table can lead to no update on INDEXES</strong></p><ul><li><p><strong>False</strong></p></li><li><p>If the update affects <strong>no indexed columns</strong>, <strong>no index updates</strong> are triggered — but the statement implies this happens generally, which is misleading. So this is <strong>conditionally true</strong>, but <strong>generally misleading</strong>, hence considered <strong>false</strong> in exam contexts.</p></li></ul></li><li><p><strong>Users cannot create indexes in another schema</strong></p><ul><li><p><strong>False</strong></p></li><li><p>Users <strong>can create indexes in another schema</strong> if they have the required privileges (e.g., <code>CREATE ANY INDEX</code>).</p></li></ul></li></ol><p><br></p><p><strong>About Indexes</strong></p><p>Indexes are optional structures associated with tables and clusters that allow SQL queries to execute more quickly against a table.</p><p>Just as the index in this manual helps you locate information faster than if there were no index, an Oracle Database index provides a faster access path to table data. You can use indexes without rewriting any queries. Your results are the same, but you see them more quickly.</p><p>Oracle Database provides several indexing schemes that provide complementary performance functionality. These are:</p><ul><li><p>B-tree indexes: the default and the most common</p></li><li><p>B-tree cluster indexes: defined specifically for cluster</p></li><li><p>Hash cluster indexes: defined specifically for a hash cluster</p></li><li><p>Global and local indexes: relate to partitioned tables and indexes</p></li><li><p>Reverse key indexes: most useful for Oracle Real Application Clusters applications</p></li><li><p>Bitmap indexes: compact; work best for columns with a small set of values</p></li><li><p>Function-based indexes: contain the precomputed value of a function/expression</p></li><li><p>Domain indexes: specific to an application or cartridge.</p></li></ul><p>Indexes are logically and physically independent of the data in the associated table. Being independent structures, they require storage space. You can create or drop an index without affecting the base tables, database applications, or other indexes. The database automatically maintains indexes when you insert, update, and delete rows of the associated table. If you drop an index, all applications continue to work. However, access to previously indexed data might be slower.</p><p><strong>Unique and non-unique index structure</strong></p><p>The structural difference between a unique and non-unique index in Oracle is Nothing. Bit for bit, byte for byte, they would be the same.</p><p>It is just that in a unique index, the rowid is not considered \"part of the key\" and in a non-unique index \"the rowid is considered part of the key\".</p><p><br></p><p><strong>UNIQUE index can be converted to non UNIQUE index</strong></p><p>You <strong>cannot directly change a UNIQUE index to a non-UNIQUE index</strong> by altering its definition. In most database systems, once an index is created as UNIQUE, its uniqueness constraint cannot be modified.</p><p>Alternative Approaches:</p><p>If you need to convert a <strong>UNIQUE index</strong> into a <strong>non-UNIQUE index</strong>, you must <strong>drop and recreate</strong> the index:</p><p>1. <strong>Drop the UNIQUE Index</strong></p><pre class=\"prettyprint linenums\">sql\nDROP INDEX unique_index_name;</pre><p>2. <strong>Recreate it as a Non-UNIQUE Index</strong></p><pre class=\"prettyprint linenums\">sql\nCREATE INDEX non_unique_index_name ON table_name(column_name);</pre><p><br></p><p>Key Points:</p><ul><li><p><strong>UNIQUE Index</strong> enforces uniqueness at the database level.</p></li><li><p><strong>Non-UNIQUE Index</strong> does not enforce uniqueness but improves query performance.</p></li><li><p><strong>Altering an index definition to change uniqueness is not supported</strong> in most databases (e.g., Oracle, MySQL, PostgreSQL, SQL Server).</p></li><li><p>You may also need to check for <strong>unique constraints</strong> (<code>UNIQUE</code> or <code>PRIMARY KEY</code>) tied to the index before dropping it.</p></li></ul>",
                "answers": [
                    "<p>UNIQUE index can be converted to non UNIQUE index</p>",
                    "<p>An update operation on table can update any or all the INDEXES</p>",
                    "<p>Update operation on table can lead to no update on INDEXES</p>",
                    "<p>Users cannot create indexes in another schema</p>",
                    "<p>Bitmap indexes are compact; work best for columns with a small set of values</p>",
                    "<p>B-tree indexes are the default and the most common type of index</p>"
                ]
            },
            "correct_response": [
                "e",
                "f",
                "b"
            ],
            "section": "Database SQL Reference",
            "question_plain": "Which of the following are true statements about the Oracle Indexes? (Select three)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306095,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p>Which of the following are true statements about Oracle Global Temporary Tables? (Select four)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Do DMLs on temporary tables generate redo?](https://asktom.oracle.com/ords/asktom.search?tag=do-dmls-on-temporary-tables-generate-redo)",
                    "[Global Temporary Tables](https://oracle-base.com/articles/misc/temporary-tables)"
                ],
                "feedbacks": [
                    "This statement is correct because when the TRUNCATE statement is used on a global temporary table, it only removes the data that is specific to the session, leaving data from other sessions intact.",
                    "This statement is incorrect because DML operations on global temporary tables do generate redo. Redo logs are generated to ensure data consistency and recovery in case of failures.",
                    "This statement is true as data in global temporary tables is automatically deleted at the end of the session, regardless of whether the session ends normally or abnormally. This ensures data isolation and prevents data from persisting across sessions.",
                    "This statement is accurate as views can indeed be created against global temporary tables, and they can also be combined with permanent tables in queries. This allows for flexible data manipulation and reporting capabilities.",
                    "This statement is incorrect because temporary tables can have triggers associated with them. Triggers can be defined on global temporary tables to enforce data integrity rules or perform specific actions when data is modified.",
                    "This statement is correct because while there is redo generated on the blocks of global temporary tables, the undo generated will also have redo associated with it. This ensures that changes made to the temporary table data can be rolled back or recovered if needed."
                ],
                "explanation": "<p>Let’s evaluate each statement about <strong>Oracle Global Temporary Tables (GTTs)</strong>:</p><p><strong>True Statements:</strong></p><ol><li><p><strong>If the TRUNCATE statement is issued against a temporary table, only the session-specific data is truncated.</strong></p><ul><li><p><strong>True</strong></p></li><li><p>In a GTT, each session has its own data. <code>TRUNCATE</code> affects <strong>only the current session’s data</strong>, not data from other sessions.</p></li></ul></li><li><p><strong>Data in temporary tables is automatically deleted at the end of the database session, even if it ends abnormally.</strong></p><ul><li><p><strong>True</strong></p></li><li><p>If the GTT is created with <code>ON COMMIT PRESERVE ROWS</code>, data is kept until the session ends — even if it ends abnormally, Oracle will clean up.</p></li></ul></li><li><p><strong>Views can be created against temporary tables and combinations of temporary and permanent tables.</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Views can reference GTTs, just like they can reference permanent tables or combinations of both.</p></li></ul></li><li><p><strong>There is a redo generated on the temporary table blocks; the undo that is generated will have redo generated.</strong></p><ul><li><p><strong>True</strong></p></li><li><p><strong>Minimal redo</strong> is generated for temporary tables (mainly for undo and rollback segments, not for data changes). But <strong>undo</strong> itself generates redo. So yes, redo is generated, though not to the extent of permanent tables.</p></li></ul></li></ol><p><strong>False Statements:</strong></p><ol><li><p><strong>DML offers no REDO on GTT</strong></p><ul><li><p><strong>False</strong></p></li><li><p>This is misleading. While data changes to temporary tables generate <strong>minimal redo</strong>, <strong>undo</strong> for those changes <strong>does generate redo</strong>. So saying there's \"no redo\" is incorrect.</p></li></ul></li><li><p><strong>Temporary tables cannot have triggers associated with them</strong></p><ul><li><p><strong>False</strong></p></li><li><p>You <strong>can</strong> define <strong>triggers</strong> on global temporary tables.</p></li></ul></li></ol><p><br></p><p>Applications often use some form of temporary data store for processes that are to complicated to complete in a single pass. Often, these temporary stores are defined as database tables or PL/SQL tables. From Oracle 8i onward, the maintenance and management of temporary tables can be delegated to the server by using Global Temporary Tables.</p><p><strong>Temporary Tables</strong></p><p>Oracle support two types of temporary tables.</p><ul><li><p>Global Temporary Tables : Available since Oracle 8i and subject of this article.</p></li><li><p>Private Temporary Tables : Available since Oracle 18c.</p></li></ul><p><br></p><p><strong>Creation of Global Temporary Tables</strong></p><p>The data in a global temporary table is private, such that data inserted by a session can only be accessed by that session. The session-specific rows in a global temporary table can be preserved for the whole session, or just for the current transaction.</p><p>The <code>ON COMMIT DELETE ROWS</code> clause indicates the data should be deleted at the end of the transaction, or the end of the session.</p><p><br></p><pre class=\"prettyprint linenums\">CREATE GLOBAL TEMPORARY TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n)\nON COMMIT DELETE ROWS;\n\n-- Insert, but don't commit, then check contents of GTT.\nINSERT INTO my_temp_table VALUES (1, 'ONE');\n\nSELECT COUNT(*) FROM my_temp_table;\n\n  COUNT(*)\n----------\n         1\n\nSQL&gt;\n\n-- Commit and check contents.\nCOMMIT;\n\nSELECT COUNT(*) FROM my_temp_table;\n\n  COUNT(*)\n----------\n         0\n\nSQL&gt;</pre><p><br></p><p>In contrast, the <code>ON COMMIT PRESERVE ROWS</code> clause indicates that rows should persist beyond the end of the transaction. They will only be removed at the end of the session.</p><p><br></p><pre class=\"prettyprint linenums\">CREATE GLOBAL TEMPORARY TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n)\nON COMMIT PRESERVE ROWS;\n\n-- Insert and commit, then check contents of GTT.\nINSERT INTO my_temp_table VALUES (1, 'ONE');\nCOMMIT;\n\nSELECT COUNT(*) FROM my_temp_table;\n\n  COUNT(*)\n----------\n         1\n\nSQL&gt;\n\n-- Reconnect and check contents of GTT.\nCONN test/test\n\nSELECT COUNT(*) FROM my_temp_table;\n\n  COUNT(*)\n----------\n         0\n\nSQL&gt;</pre><p><br></p><p><strong>Global Temporary Tables and Undo</strong></p><p>Although the data in a GTT is written to the temporary tablespace, the associated undo is still written to the normal undo tablespace, which is itself protected by redo, so using a GTT does not reduce undo and the redo associated with protecting the undo tablespace.</p><p>The following code creates a conventional table, populates it and checks the amount of undo used by the transaction.</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE my_temp_table PURGE;\n\n-- Create conventional table.\nCREATE TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n);\n\n-- Populate table.\nINSERT INTO my_temp_table\nWITH data AS (\n  SELECT 1 AS id\n  FROM   dual\n  CONNECT BY level &lt; 10000\n)\nSELECT rownum, TO_CHAR(rownum)\nFROM   data a, data b\nWHERE  rownum &lt;= 1000000;\n\n-- Check undo used by transaction.\nSELECT t.used_ublk,\n       t.used_urec\nFROM   v$transaction t,\n       v$session s\nWHERE  s.saddr = t.ses_addr\nAND    s.audsid = SYS_CONTEXT('USERENV', 'SESSIONID');\n\n USED_UBLK  USED_UREC\n---------- ----------\n       302       6237\n\nSQL&gt;</pre><p><br></p><p>We now repeat the previous test, but this time using a GTT.</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE my_temp_table PURGE;\n\n-- Create GTT.\nCREATE GLOBAL TEMPORARY TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n)\nON COMMIT PRESERVE ROWS;\n\n-- Populate GTT.\nINSERT INTO my_temp_table\nWITH data AS (\n  SELECT 1 AS id\n  FROM   dual\n  CONNECT BY level &lt; 10000\n)\nSELECT rownum, TO_CHAR(rownum)\nFROM   data a, data b\nWHERE  rownum &lt;= 1000000;\n\n-- Check undo used by transaction.\nSELECT t.used_ublk,\n       t.used_urec\nFROM   v$transaction t,\n       v$session s\nWHERE  s.saddr = t.ses_addr\nAND    s.audsid = SYS_CONTEXT('USERENV', 'SESSIONID');\n\n USED_UBLK  USED_UREC\n---------- ----------\n       303       6238\n\nSQL&gt;\n\nTRUNCATE TABLE my_temp_table;</pre><p><br></p><p>We can see, there is no significant difference in the undo used.</p><p>Oracle 12c introduced the concept of <a href=\"https://oracle-base.com/articles/12c/temporary-undo-12cr1\">Temporary Undo</a>, allowing the undo for a GTT to be written to the temporary tablespace, thereby reducing undo and redo.</p><p><br></p><p><strong>Global Temporary Tables and Redo</strong></p><p>If you've read the previous section, you will already know the relationship between global temporary tables and redo. The data in a GTT is written to the temporary tablespace, which is not directly protected by redo, so using a GTT improves performance by reducing redo generation. Unfortunately, prior to Oracle 12c, all undo associated with DML against a GTT is written to the normal undo tablespace, which is itself protected by redo. As a result, using a GTT reduces the amount of redo generation, but does not eliminate it. Another why of describing this is, using a GTT removes direct redo generation, but not indirect redo generation cause by undo.</p><p>The following code creates a conventional table, populates it and checks the amount of redo generated by the transaction.</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE my_temp_table PURGE;\n\n-- Create conventional table.\nCREATE TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n);\n\nSET AUTOTRACE ON STATISTICS;\n\n-- Populate table.\nINSERT INTO my_temp_table\nWITH data AS (\n  SELECT 1 AS id\n  FROM   dual\n  CONNECT BY level &lt; 10000\n)\nSELECT rownum, TO_CHAR(rownum)\nFROM   data a, data b\nWHERE  rownum &lt;= 1000000;\n\n1000000 rows created.\n\nStatistics\n----------------------------------------------------------\n        106  recursive calls\n      20119  db block gets\n       2603  consistent gets\n         16  physical reads\n   23039396  redo size\n        853  bytes sent via SQL*Net to client\n        987  bytes received via SQL*Net from client\n          3  SQL*Net roundtrips to/from client\n          6  sorts (memory)\n          0  sorts (disk)\n    1000000  rows processed\n\nSQL&gt;</pre><p><br></p><p>We now repeat the previous test, but this time using a GTT.</p><p><br></p><pre class=\"prettyprint linenums\">DROP TABLE my_temp_table PURGE;\n\n-- Create GTT.\nCREATE GLOBAL TEMPORARY TABLE my_temp_table (\n  id           NUMBER,\n  description  VARCHAR2(20)\n)\nON COMMIT PRESERVE ROWS;\n\nSET AUTOTRACE ON STATISTICS;\n\n-- Populate GTT.\nINSERT INTO my_temp_table\nWITH data AS (\n  SELECT 1 AS id\n  FROM   dual\n  CONNECT BY level &lt; 10000\n)\nSELECT rownum, TO_CHAR(rownum)\nFROM   data a, data b\nWHERE  rownum &lt;= 1000000;\n\n1000000 rows created.\n\nStatistics\n----------------------------------------------------------\n         45  recursive calls\n      15333  db block gets\n       2381  consistent gets\n         16  physical reads\n    2944180  redo size\n        862  bytes sent via SQL*Net to client\n        987  bytes received via SQL*Net from client\n          3  SQL*Net roundtrips to/from client\n          5  sorts (memory)\n          0  sorts (disk)\n    1000000  rows processed\n\nSQL&gt;\n\nTRUNCATE TABLE my_temp_table;</pre><p><br></p><p>We can see we have created an order of magnitude less redo when using the GTT, but we have not eliminated it.</p><p><br></p><p><strong>Miscellaneous Features</strong></p><ul><li><p>If the TRUNCATE statement is issued against a temporary table, only the session specific data is truncated. There is no affect on the data of other sessions.</p></li><li><p>Data in temporary tables is stored in temp segments in the temp tablespace.</p></li><li><p>Data in temporary tables is automatically deleted at the end of the database session, even if it ends abnormally.</p></li><li><p>Indexes can be created on temporary tables. The content of the index and the scope of the index is the same as the database session.</p></li><li><p>Views can be created against temporary tables and combinations of temporary and permanent tables.</p></li><li><p>Temporary tables can have triggers associated with them.</p></li><li><p>Export and Import utilities can be used to transfer the table definitions, but no data rows are processed.</p></li><li><p>Statistics on temporary tables are common to all sessions. Oracle 12c allows session specific statistics.</p></li><li><p>There are a number of restrictions related to temporary tables but these are version specific.</p></li></ul>",
                "answers": [
                    "<p>If the TRUNCATE statement is issued against a temporary table, only the session specific data is truncated. </p>",
                    "<p>DML offers no REDO on GTT</p>",
                    "<p>Data in temporary tables is automatically deleted at the end of the database session, even if it ends abnormally</p>",
                    "<p>Views can be created against temporary tables and combinations of temporary and permanent tables</p>",
                    "<p>Temporary tables cannot have triggers associated with them</p>",
                    "<p>There is a redo generated on the temporary table blocks, the undo that is generated will have redo generated</p>"
                ]
            },
            "correct_response": [
                "a",
                "c",
                "d",
                "f"
            ],
            "section": "Database SQL Reference",
            "question_plain": "Which of the following are true statements about Oracle Global Temporary Tables? (Select four)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306097,
            "assessment_type": "multi-select",
            "prompt": {
                "question": "<p><strong>View and examine the following scenario.</strong></p><p>You are working with a&nbsp; table which has the following columns which have data in each column:</p><ul><li><p><code>salary</code></p></li><li><p><code>first name</code></p></li><li><p><code>last name</code></p><p><br></p></li></ul><p>Below is a query that you plan to run:</p><pre class=\"prettyprint linenums\">SELECT * \nFROM table_name \nORDER BY \n    CASE \n        WHEN salary = (SELECT MAX(salary) FROM sales) THEN 1 \n        ELSE 2 \n    END,\n    name;</pre><p><br></p><p>Which of the following are correct statements based on the scenario? (Select two)</p>",
                "relatedLectureIds": [],
                "links": [
                    "[Oracle CASE expression](https://www.oracletutorial.com/oracle-basics/oracle-case/)"
                ],
                "feedbacks": [
                    "The query uses a CASE statement to sort the names of employees with the maximum salary in ascending order by assigning them a value of 'A'. This means that the names of employees with the max salary will be sorted in ascending order.",
                    "<p>For the remaining employees who do not have the maximum salary, their names are sorted in ascending order based on the last_name column in descending order.</p>",
                    "The query does not provide any specific sorting instruction for the names of employees with the maximum salary, so their sorting order is unspecified.",
                    "<p>The query does not specify sorting the names of employees with the maximum salary in descending order. Instead, it assigns them a value of 'A' in the CASE statement, indicating ascending order sorting.</p>",
                    "The query specifies sorting the names of the remaining employees in ascending order based on the last_name column in descending order, not in descending order.",
                    "The query does not provide any specific sorting instruction for the names of the remaining employees, so their sorting order is unspecified."
                ],
                "explanation": "<p>Let’s analyze the query:</p><pre class=\"prettyprint linenums\">SELECT * \nFROM table_name \nORDER BY \n    CASE \n        WHEN salary = (SELECT MAX(salary) FROM sales) THEN 1 \n        ELSE 2 \n    END,\n    name;</pre><p><br></p><p>How this query works:</p><p>The <code>ORDER BY</code> clause has <strong>two levels</strong> of sorting:</p><ul><li><p><strong>Primary sort</strong>: based on whether <code>salary</code> equals the maximum salary in the <code>sales</code> table.</p><p>Those <strong>with max salary</strong> get value <code>1</code>, others get <code>2</code>.</p><p>So <strong>employees with the highest salary</strong> appear <strong>first</strong>.</p></li><li><p><strong>Secondary sort</strong>: by <code>name</code>.</p><p>The column <code>name</code> is assumed to refer to a combination (possibly a derived column or alias for <code>first_name || ' ' || last_name</code> — though this is unclear from the question).</p></li></ul><p><strong>Correct Interpretations:</strong></p><ol><li><p><strong>For employees having max salary, their names are sorted in ascending order</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Within the group where <code>CASE = 1</code> (i.e., those with max salary), sorting continues by <code>name</code> in ascending order (default).</p></li></ul></li><li><p><strong>For remaining employees their names are sorted in ascending order</strong></p><ul><li><p><strong>True</strong></p></li><li><p>Those with <code>CASE = 2</code> (not max salary) also follow the same secondary sort by <code>name</code> — again, in ascending order.</p></li></ul></li></ol><p><strong>Incorrect Statements:</strong></p><ul><li><p><strong>\"Sorted in unspecified order\"</strong> → False<br>→ Because <code>ORDER BY name</code> is clearly defined.</p></li><li><p><strong>\"Sorted in descending order\"</strong> → False<br>→ No <code>DESC</code> is used, so default is ascending.</p></li></ul><p><br></p><p>The query sorts the highest salary first and then sorts by <code>name</code>. The <code>MAX(salary)</code> function applies to the whole dataset, <code>CASE</code> operates row by row.</p><p><br></p><p><strong>Oracle CASE expression</strong></p><p>Oracle <code>CASE</code> expression allows you to add <a href=\"https://www.oracletutorial.com/plsql-tutorial/plsql-if/\">if-else</a> logic to SQL statements without having to call a <a href=\"https://www.oracletutorial.com/plsql-tutorial/plsql-procedure/\">procedure</a>. The <code>CASE</code> expression evaluates a list of conditions and returns one of the multiple possible results.</p><p>You can use a <code>CASE</code> expression in any statement or clause that accepts a valid expression. For example, you can use the <code>CASE</code> expression in statements such as <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-select/\"><code>SELECT</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-update/\"><code>UPDATE</code></a>, or <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-delete/\"><code>DELETE</code></a>, and in clauses like <code>SELECT</code>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-where/\"><code>WHERE</code></a>, <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-having/\"><code>HAVING</code></a>, and <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code>ORDDER BY</code></a>.</p><p>Oracle <code>CASE</code> expression has two formats: the simple <code>CASE</code> expression and the searched <code>CASE</code> expression. Both formats support an optional <code>ELSE</code> clause.</p><p><br></p><p><strong>Simple CASE expression</strong></p><p>The simple <code>CASE</code> expression matches an expression to a list of simple expressions to determine the result.</p><p>The following illustrates the syntax of the simple <code>CASE</code> expression:</p><p><br></p><pre class=\"prettyprint linenums\">CASE e\n    WHEN e1 THEN\n          r1\n    WHEN e2 THEN\n          r2\n    WHEN en THEN\n          rn \n    [ ELSE r_else ]\nEND</pre><p><br></p><p>In this syntax, Oracle compares the input expression (e) to each comparison expression e1, e2, …, en.</p><p>If the input expression equals any comparison expression, the <code>CASE</code> expression returns the corresponding result expression (r).</p><p>If the input expression e does not match any comparison expression, the <code>CASE</code> expression returns the expression in the <code>ELSE</code> clause if the <code>ELSE</code> clause exists, otherwise, it returns a null value.</p><p>Oracle uses short-circuit evaluation for the simple <code>CASE</code> expression. It means that Oracle evaluates each comparison expression (e1, e2, .. en) only before comparing one of them with the input expression (e). Oracle does not evaluate all comparison expressions before comparing any of them with the expression (e). As a result, Oracle never evaluates a comparison expression if a previous one equals the input expression (e).</p><p><br></p><p><strong>Simple CASE expression example</strong></p><p>We will use the <code>products</code> table in the <a href=\"https://www.oracletutorial.com/getting-started/oracle-sample-database/\">sample database</a> for the demonstration.</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/07/products-table.png\"></p><p><br></p><p>The following query uses the <code>CASE</code> expression to calculate the discount for each product category i.e., CPU 5%, video card 10%, and other product categories 8%</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n  product_name,\n  list_price,\n  CASE category_id\n    WHEN 1\n    THEN ROUND(list_price * 0.05,2) -- CPU\n    WHEN 2\n    THEN ROUND(List_price * 0.1,2)  -- Video Card\n    ELSE ROUND(list_price * 0.08,2) -- other categories\n  END discount\nFROM\n  products\nORDER BY\n  product_name;</pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/12/Oracle-CASE-SELECT-example.png\"></p><p>Note that we used the <code>ROUND</code>() function to round the discount to two decimal places.</p><p><br></p><p><strong>Searched CASE expression</strong></p><p>The Oracle searched <code>CASE</code> expression evaluates a list of Boolean expressions to determine the result.</p><p>The searched <code>CASE</code> statement has the following syntax:</p><p><br></p><pre class=\"prettyprint linenums\">CASE \n    WHEN e1 THEN r1\n    [ WHEN e2 THEN r2]\n    ...\n    [ELSE\n        r_else]\nEND</pre><p><br></p><p>The searched <code>CASE</code> expression evaluates the Boolean expression (e1, e2, …) in each <code>WHEN</code> clause in the order that the Boolean expressions appear. It returns the result expression (r) of the first Boolean expression (e) that evaluates to true.</p><p>If no Boolean expression is true, then the <code>CASE</code> expression returns the result expression in the <code>ELSE</code> clause if an <code>ELSE</code> clause exists; otherwise, it returns a null value.</p><p>Like the simple <code>CASE</code> expression, Oracle also uses short-circuit evaluation for the searched <code>CASE</code> expression. In other words, Oracle evaluates each Boolean condition to determine whether it is true, and never evaluates the next condition if the previous one is true.</p><p><br></p><p><strong>Searched CASE expression example</strong></p><p>When you use the searched <code>CASE</code> expression within a <code>SELECT</code> statement, you can replace values in the result based on comparison values.</p><p>The following example uses the searched <code>CASE</code> expression to classify the products based on their list prices:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n  product_name,\n  list_price,\n  CASE\n    WHEN list_price &gt; 0 AND list_price  &lt; 600\n        THEN 'Mass'\n    WHEN list_price &gt;= 600 AND list_price &lt; 1000\n        THEN 'Economy'\n    WHEN list_price &gt;= 1000 AND list_price &lt; 2000\n        THEN 'Luxury'\n    ELSE \n        'Grand Luxury'\n  END product_group\nFROM\n  products\nWHERE\n  category_id = 1\nORDER BY\n  product_name;</pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/12/Oracle-Searched-CASE-example.png\"></p><p><br></p><p><strong>Oracle CASE expression examples</strong></p><p>Let’s take a few more examples of using the Oracle <code>CASE</code> expression to understand how it works.</p><p>A) Using CASE expression in an ORDER BY clause</p><p>See the following <code>locations</code> table:</p><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/08/locations-table.png\"></p><p><br></p><p>The following query uses the <code>CASE</code> expression in an <a href=\"https://www.oracletutorial.com/oracle-basics/oracle-order-by/\"><code>ORDER BY</code></a> clause to determine the sort order of rows based on column value:</p><p><br></p><pre class=\"prettyprint linenums\">SELECT\n  *\nFROM\n  locations\nWHERE country_id in ('US','CA','UK')\nORDER BY\n   country_id,\n  CASE country_id\n    WHEN 'US'\n    THEN state\n    ELSE city\n  END;</pre><p><br></p><p><img src=\"https://www.oracletutorial.com/wp-content/uploads/2017/12/Oracle-CASE-ORDER-BY-example.png\"></p><p><br></p><p>In this example, the result set is sorted by the column state when the country is the <code>US</code> and by the column city for all other countries.</p>",
                "answers": [
                    "<p>For employees having max salary, their names are sorted in ascending ORDER</p>",
                    "<p>For remaining employees their names are sorted in ascending ORDER</p>",
                    "<p>For employees having max salary, their names are sorted in unspecified ORDER</p>",
                    "<p>For employees having max salary, their names are sorted in descending ORDER</p>",
                    "<p>For remaining employees their names are sorted in descending ORDER</p>",
                    "<p>For remaining employees their names are sorted in unspecified ORDER</p>"
                ]
            },
            "correct_response": [
                "a",
                "b"
            ],
            "section": "",
            "question_plain": "View and examine the following scenario.You are working with a&nbsp; table which has the following columns which have data in each column:salaryfirst namelast nameBelow is a query that you plan to run:SELECT * \nFROM table_name \nORDER BY \n    CASE \n        WHEN salary = (SELECT MAX(salary) FROM sales) THEN 1 \n        ELSE 2 \n    END,\n    name;Which of the following are correct statements based on the scenario? (Select two)",
            "related_lectures": []
        },
        {
            "_class": "assessment",
            "id": 130306099,
            "assessment_type": "multiple-choice",
            "prompt": {
                "question": "<p><strong>Table: PRODUCTS </strong></p><pre class=\"prettyprint linenums\">Name                   Null??                 Type\nPROD_ID                NOT NULL               VARCHAR2(6)\nQUANTITY                                      NUMBER(8, 2)\nPRICE                                         NUMBER(10, 2)\nEXPIRY_DATE                                   DATE</pre><p><br></p><p><strong>Given:</strong></p><ul><li><p>Rows exist in this table with data in all the columns. </p></li><li><p>The PRODUCTS table in read-only mode.&nbsp; </p></li></ul><p>Identify the command which execute successfully on PRODUCTS.</p>",
                "relatedLectureIds": [],
                "links": [
                    "[CREATE INDEX ](https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5010.htm)",
                    "[DROP TABLE ](https://docs.oracle.com/en/database//oracle/oracle-database/19/sqlrf/DROP-TABLE.html)"
                ],
                "feedbacks": [
                    "<p><strong>Succeeds</strong>: Creating an index does not modify the table's data or structure, so this command is allowed.</p>",
                    "<p><strong>Fails</strong>: This modifies the table structure by dropping unused columns, which is not allowed in read-only mode.</p>",
                    "<p><strong>Fails</strong>: Marking a column as unused alters the table structure, which is not allowed in read-only mode.</p>",
                    "<p><strong>Fails</strong>: Dropping a column modifies the table structure, which is prohibited in read-only mode.</p>",
                    "<p><strong>Fails</strong>: Truncating a table removes all rows, which changes the data, and this is not allowed in read-only mode.</p>"
                ],
                "explanation": "<p>The table in read-only is different from DB in read-only.</p><p>Since the <code>PRODUCTS</code> table is in <strong>read-only mode</strong>, you cannot perform any <strong>DML (Data Manipulation Language)</strong> or <strong>DDL (Data Definition Language)</strong> operations that modify the table's structure or data.</p><p><strong>Analyzing the given commands:</strong></p><ol><li><p><code><strong>CREATE INDEX price_idx ON products (price);</strong></code><br><strong>This will execute successfully.</strong></p><ul><li><p>Creating an index does not modify table data, so it is allowed in read-only mode.</p></li></ul></li><li><p><code><strong>ALTER TABLE products DROP UNUSED COLUMNS;</strong></code><br><strong>This will fail.</strong></p><ul><li><p>Dropping unused columns modifies the table structure, which is not allowed in read-only mode.</p></li></ul></li><li><p><code><strong>ALTER TABLE products SET UNUSED (expiry_date);</strong></code><br><strong>This will fail.</strong></p><ul><li><p>Marking a column as unused modifies the table structure.</p></li></ul></li><li><p><code><strong>ALTER TABLE products DROP COLUMN expiry_date;</strong></code><br><strong>This will fail.</strong></p><ul><li><p>Dropping a column changes the schema, which is not allowed.</p></li></ul></li><li><p><code><strong>TRUNCATE TABLE products;</strong></code><br><strong>This will fail.</strong></p><ul><li><p><code>TRUNCATE</code> removes all rows, which modifies the data.</p></li></ul></li></ol><p>When a table is in read-only mode, operations that attempt to modify table data are disallowed. The following operations are not permitted on a read-only table:</p><p>All DML operations on the table or any of its partitions</p><pre class=\"prettyprint linenums\">TRUNCATE TABLE\nSELECT FOR UPDATE\nALTER TABLE ADD/MODIFY/RENAME/DROP COLUMN\nALTER TABLE SET COLUMN UNUSED\nALTER TABLE DROP/TRUNCATE/EXCHANGE (SUB)PARTITION\nALTER TABLE UPGRADE INCLUDING DATA or ALTER TYPE CASCADE INCLUDING TABLE DATA for a type with read-only table dependants\nOnline redefinition\nFLASHBACK TABLE\nThe following operations are permitted on a read-only table:\nSELECT\nCREATE/ALTER/DROP INDEX\nALTER TABLE ADD/MODIFY/DROP/ENABLE/DISABLE CONSTRAINT\nALTER TABLE for physical property changes\nALTER TABLE DROP UNUSED COLUMNS\nALTER TABLE ADD/COALESCE/MERGE/MODIFY/MOVE/RENAME/SPLIT (SUB)PARTITION\nALTER TABLE MOVE\nALTER TABLE ENABLE ROW MOVEMENT and ALTER TABLE SHRINK\nRENAME TABLE and ALTER TABLE RENAME TO\nDROP TABLE\nALTER TABLE DEALLOCATE UNUSED\nALTER TABLE ADD/DROP SUPPLEMENTAL LOG</pre>",
                "answers": [
                    "<p><code><strong>CREATE INDEX price_idx ON products (price);</strong></code></p>",
                    "<p><code><strong>ALTER TABLE products DROP UNUSED COLUMNS;</strong></code></p>",
                    "<p><code><strong>ALTER TABLE products SET UNUSED (expiry_date);</strong></code></p>",
                    "<p><code><strong>ALTER TABLE products DROP COLUMN expiry_date;</strong></code></p>",
                    "<p><code><strong>TRUNCATE TABLE products;</strong></code></p>"
                ]
            },
            "correct_response": [
                "a"
            ],
            "section": "SQL Statements",
            "question_plain": "Table: PRODUCTS Name                   Null??                 Type\nPROD_ID                NOT NULL               VARCHAR2(6)\nQUANTITY                                      NUMBER(8, 2)\nPRICE                                         NUMBER(10, 2)\nEXPIRY_DATE                                   DATEGiven:Rows exist in this table with data in all the columns. The PRODUCTS table in read-only mode.&nbsp; Identify the command which execute successfully on PRODUCTS.",
            "related_lectures": []
        }
    ]
}